/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@here/harp-datasource-protocol/index-decoder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/index-decoder.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/StyleSetEvaluator */ \"./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js\"));\n__export(__webpack_require__(/*! ./lib/Extruder */ \"./node_modules/@here/harp-datasource-protocol/lib/Extruder.js\"));\n__export(__webpack_require__(/*! ./lib/Outliner */ \"./node_modules/@here/harp-datasource-protocol/lib/Outliner.js\"));\n__export(__webpack_require__(/*! ./lib/Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\"));\n__export(__webpack_require__(/*! ./lib/ThreeBufferUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/index-decoder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\"));\n__export(__webpack_require__(/*! ./lib/Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\"));\n__export(__webpack_require__(/*! ./lib/Techniques */ \"./node_modules/@here/harp-datasource-protocol/lib/Techniques.js\"));\n__export(__webpack_require__(/*! ./lib/TechniqueParams */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js\"));\n__export(__webpack_require__(/*! ./lib/Theme */ \"./node_modules/@here/harp-datasource-protocol/lib/Theme.js\"));\n__export(__webpack_require__(/*! ./lib/InterpolatedProperty */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js\"));\n__export(__webpack_require__(/*! ./lib/InterpolatedPropertyDefs */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js\"));\n__export(__webpack_require__(/*! ./lib/WorkerServiceProtocol */ \"./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js\"));\n__export(__webpack_require__(/*! ./lib/WorkerTilerProtocol */ \"./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js\"));\n__export(__webpack_require__(/*! ./lib/WorkerDecoderProtocol */ \"./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js\"));\n__export(__webpack_require__(/*! ./lib/DecodedTile */ \"./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js\"));\n__export(__webpack_require__(/*! ./lib/TileInfo */ \"./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js\"));\n__export(__webpack_require__(/*! ./lib/ThemeVisitor */ \"./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js\"));\n__export(__webpack_require__(/*! ./lib/StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst SHIFT_TRANSPARENCY = 24;\nconst SHIFT_RED = 16;\nconst SHIFT_GREEN = 8;\nconst SHIFT_BLUE = 0;\n// tslint:disable: no-bitwise\n//    Allow bitwise operations for colors decoding\n// tslint:disable-next-line: no-bitwise\nconst HEX_FULL_CHANNEL = 0xff;\nconst HEX_RGB_MASK = 0xffffff;\nconst HEX_TRGB_MASK = 0xffffffff;\nconst tmpColor = new THREE.Color();\n/**\n * Utilities to convert RGBA colors encoded in custom number (hex) format to THREE.Color objects.\n *\n * The functions provided allows for conversion from and to our custom number based color format,\n * which contains transparency, red, green and blue color channels in a way that each channel\n * occupies 8 bits of resulting number (color format 0xTTRRGGBB).\n * In order to preserve compatibility with THREE.Color class and its hexadecimal color\n * representation, we do not store __alpha__ channel in encoded color's number, but replace it\n * with __transparency__ channel, which is simply opposite to alpha:\n * ```transparency = 0xFF - alpha```\n * Such channel value is stored on the oldest bits (octet) in the integral color (numeric) value,\n * so it is fully compatible with THREE.Color numerical representation (@see [[THREE.Color.getHex]],\n * [[THREE.Color.setHex]]).\n * See also [[getHexFromRgba]] and [[getRgbaFromHex]] for more info about conversion.\n */\nvar ColorUtils;\n(function (ColorUtils) {\n    /**\n     * Encodes RGBA channels in custom number coded format (represented in hex as 0xTTRRGGBB).\n     *\n     * We do not use direct alpha channel mapping to hex in order to preserve compatibility\n     * with THREE.js color format (0xRRGGBB). This is done by encoding transparency\n     * (255 - alpha) instead of alpha on the oldest bits, shifted by [[SHIFT_TRANSPARENCY]].\n     * This way simple 0xRRGGBB color is equal to 0x00RRGGBB without transparency and\n     * color defining transparency (alpha < 255) is always recognizable by the oldest\n     * bit set:\n     * ```typescript\n     * (color >> SHIFT_TRANSPARENCY) !== 0.\n     * ```\n     * @note All input components are floating points in <0, 1> range (inclusively).\n     * @note Although method encodes transparency channel in single number value, it is still\n     * compatible with THREE.js number based color coding (0xRRGGBB), so you may pass this value to\n     * [[THREE.Color]] c-tor, but keep in mind that transparency will be silently ignored.\n     */\n    function getHexFromRgba(r, g, b, a) {\n        harp_utils_1.assert(a >= 0 && a <= 1);\n        const t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);\n        return ((t << SHIFT_TRANSPARENCY) ^\n            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));\n    }\n    ColorUtils.getHexFromRgba = getHexFromRgba;\n    /**\n     * Encodes RGB all color channels in single number with format 0xRRGGBB.\n     *\n     * All input channels should be in <0, 1> range (inclusively).\n     * See also [[getHexFromRgba]] for more information about [[THREE.Color]] compatibility.\n     *\n     * @note This method is fully compatible with THREE.js color encoding, so\n     * you may pass this value directly to THREE.Color c-tor.\n     */\n    function getHexFromRgb(r, g, b) {\n        harp_utils_1.assert(r >= 0 && r <= 1);\n        harp_utils_1.assert(g >= 0 && g <= 1);\n        harp_utils_1.assert(b >= 0 && b <= 1);\n        return (((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));\n    }\n    ColorUtils.getHexFromRgb = getHexFromRgb;\n    /**\n     * Encode and convert HSL value to number coded color format (0xRRGGBB).\n     *\n     * @see getHexFromRgb.\n     * @param h Hue component value between 0 and 1.\n     * @param s Saturation value between 0 and 1.\n     * @param l Lightness channel between 0 and 1.\n     */\n    function getHexFromHsl(h, s, l) {\n        harp_utils_1.assert(h >= 0 && h <= 1);\n        harp_utils_1.assert(s >= 0 && s <= 1);\n        harp_utils_1.assert(l >= 0 && l <= 1);\n        return tmpColor.setHSL(h, s, l).getHex();\n    }\n    ColorUtils.getHexFromHsl = getHexFromHsl;\n    /**\n     * Retrieve RGBA channels separately from number encoded custom color format.\n     *\n     * Provides an easy way for channels extraction (r, g, b, a) from custom number coded color\n     * format.\n     *\n     * @see getHexFromRgba.\n     * @param hex The number encoded color value (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns r, g, b, a channels in simple object, where each channel value is saved as floating\n     * point from 0 to 1 inclusively.\n     */\n    function getRgbaFromHex(hex) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format: #\" + hex.toString(16));\n        return {\n            r: ((hex >> SHIFT_RED) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL,\n            g: ((hex >> SHIFT_GREEN) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL,\n            b: ((hex >> SHIFT_BLUE) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL,\n            a: (HEX_FULL_CHANNEL - ((hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL)) /\n                HEX_FULL_CHANNEL\n        };\n    }\n    ColorUtils.getRgbaFromHex = getRgbaFromHex;\n    /**\n     * Determines if number encoded color contains alpha (opacity) defined and different then 255.\n     *\n     * @param hex The number encoded color (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns True if color has transparency defined.\n     */\n    function hasAlphaInHex(hex) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format: #\" + hex.toString(16));\n        return hex >> SHIFT_TRANSPARENCY !== 0;\n    }\n    ColorUtils.hasAlphaInHex = hasAlphaInHex;\n    /**\n     * Retrieves alpha color channel from hex encoded color value.\n     *\n     * @see getHexFromRgba.\n     * @param hex The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns The floating point alpha component in <0, 1> range.\n     */\n    function getAlphaFromHex(hex) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format: #\" + hex.toString(16));\n        return (((HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY)) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL);\n    }\n    ColorUtils.getAlphaFromHex = getAlphaFromHex;\n    /**\n     * Remove transparency info from the number coded color, makes it compatible with external libs.\n     *\n     * @see getAlphaFromHex.\n     * @param hex The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns number coded color value representable as 0xRRGGBB in hex.\n     */\n    function removeAlphaFromHex(hex) {\n        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format: #\" + hex.toString(16));\n        return hex & HEX_RGB_MASK;\n    }\n    ColorUtils.removeAlphaFromHex = removeAlphaFromHex;\n})(ColorUtils = exports.ColorUtils || (exports.ColorUtils = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\n/**\n * Returns an array with the data type specified as parameter.\n *\n * @param attr specifies which type of data is being stored in the array\n */\nfunction getArrayConstructor(attr) {\n    switch (attr) {\n        case \"float\":\n            return Float32Array;\n        case \"uint8\":\n            return Uint8Array;\n        case \"uint16\":\n            return Uint16Array;\n        case \"uint32\":\n            return Uint32Array;\n        case \"int8\":\n            return Int8Array;\n        case \"int16\":\n            return Int16Array;\n        case \"int32\":\n            return Int32Array;\n    }\n}\nexports.getArrayConstructor = getArrayConstructor;\n/**\n * Geometry types supported by [[Geometry]] objects.\n */\nvar GeometryType;\n(function (GeometryType) {\n    GeometryType[GeometryType[\"Unspecified\"] = 0] = \"Unspecified\";\n    GeometryType[GeometryType[\"Point\"] = 1] = \"Point\";\n    GeometryType[GeometryType[\"Line\"] = 2] = \"Line\";\n    GeometryType[GeometryType[\"SolidLine\"] = 3] = \"SolidLine\";\n    GeometryType[GeometryType[\"Text\"] = 4] = \"Text\";\n    GeometryType[GeometryType[\"TextPath\"] = 5] = \"TextPath\";\n    GeometryType[GeometryType[\"ExtrudedLine\"] = 6] = \"ExtrudedLine\";\n    GeometryType[GeometryType[\"Polygon\"] = 7] = \"Polygon\";\n    GeometryType[GeometryType[\"ExtrudedPolygon\"] = 8] = \"ExtrudedPolygon\";\n    GeometryType[GeometryType[\"Object3D\"] = 9] = \"Object3D\";\n    GeometryType[GeometryType[\"Other\"] = 1000] = \"Other\";\n})(GeometryType = exports.GeometryType || (exports.GeometryType = {}));\n/**\n * Returns the projection object specified in the parameter.\n *\n * @param projectionName string describing projection to be used\n */\nfunction getProjection(projectionName) {\n    switch (projectionName) {\n        case \"mercator\":\n            return harp_geoutils_1.mercatorProjection;\n        case \"webMercator\":\n            return harp_geoutils_1.webMercatorProjection;\n        case \"sphere\":\n            return harp_geoutils_1.sphereProjection;\n        case \"normalizedEquirectangular\":\n            return harp_geoutils_1.normalizedEquirectangularProjection;\n        case \"equirectangular\":\n            return harp_geoutils_1.equirectangularProjection;\n        default:\n            throw new Error(`Unknown projection ${projectionName}`);\n    } // switch\n}\nexports.getProjection = getProjection;\n/**\n * String with the projection's name.\n *\n * @param projection `Projection` object containing the name of the projection to retrieve\n */\nfunction getProjectionName(projection) {\n    if (projection === harp_geoutils_1.mercatorProjection) {\n        return \"mercator\";\n    }\n    else if (projection === harp_geoutils_1.webMercatorProjection) {\n        return \"webMercator\";\n    }\n    else if (projection === harp_geoutils_1.sphereProjection) {\n        return \"sphere\";\n    }\n    else if (projection === harp_geoutils_1.normalizedEquirectangularProjection) {\n        return \"normalizedEquirectangular\";\n    }\n    else if (projection === harp_geoutils_1.equirectangularProjection) {\n        return \"equirectangular\";\n    }\n    throw new Error(\"Unknown projection\");\n}\nexports.getProjectionName = getProjectionName;\n/**\n * @returns Feature id from the provided attribute map.\n */\nfunction getFeatureId(attributeMap) {\n    if (attributeMap === undefined) {\n        return 0;\n    }\n    if (typeof attributeMap === \"number\") {\n        return attributeMap;\n    }\n    if (attributeMap.hasOwnProperty(\"$id\")) {\n        return attributeMap.$id;\n    }\n    return 0;\n}\nexports.getFeatureId = getFeatureId;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Env.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Env.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @hidden\n */\nclass Env {\n    /**\n     * Returns property in [[Env]] by name.\n     *\n     * @param name Name of property.\n     */\n    lookup(_name) {\n        return undefined;\n    }\n    /**\n     * Return an object containing all properties of this environment. (Here: empty object).\n     */\n    unmap() {\n        return {};\n    }\n}\nexports.Env = Env;\n/**\n * Adds access to map specific environment properties.\n */\nclass MapEnv extends Env {\n    constructor(entries, parent) {\n        super();\n        this.entries = entries;\n        this.parent = parent;\n    }\n    /**\n     * Returns property in [[Env]] by name.\n     *\n     * @param name Name of property.\n     * @override\n     */\n    lookup(name) {\n        if (this.entries.hasOwnProperty(name)) {\n            const value = this.entries[name];\n            if (value !== undefined) {\n                return value;\n            }\n        }\n        return this.parent ? this.parent.lookup(name) : undefined;\n    }\n    /**\n     * Return an object containing all properties of this environment, takes care of the parent\n     * object.\n     * @override\n     */\n    unmap() {\n        const obj = this.parent ? this.parent.unmap() : {};\n        for (const key in this.entries) {\n            if (this.entries.hasOwnProperty(key)) {\n                obj[key] = this.entries[key];\n            }\n        }\n        return obj;\n    }\n}\nexports.MapEnv = MapEnv;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Env.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExponentialInterpolant.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExponentialInterpolant.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nclass ExponentialInterpolant extends three_1.Interpolant {\n    constructor() {\n        super(...arguments);\n        /**\n         * Exponent value. Defaults to `2.0`.\n         */\n        this.exponent = 2.0;\n    }\n    // Note: We need to disable linting here as tslint thinks this function is never used, though it\n    // indeed is called by ``Interpolant.evaluate(level)``.\n    // tslint:disable-next-line\n    interpolate_(i1, t0, t, t1) {\n        const result = this.resultBuffer;\n        // TODO: Remove when Interpolant types are fixed.\n        const values = this.sampleValues;\n        const stride = this.valueSize;\n        const offset1 = i1 * stride;\n        const offset0 = offset1 - stride;\n        const weight1 = Math.pow((t - t0) / (t1 - t0), this.exponent);\n        const weight0 = 1 - weight1;\n        for (let i = 0; i !== stride; ++i) {\n            result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;\n        }\n        return result;\n    }\n}\nexports.ExponentialInterpolant = ExponentialInterpolant;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExponentialInterpolant.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Expr.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Expr.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ExprEvaluator_1 = __webpack_require__(/*! ./ExprEvaluator */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js\");\nconst ExprInstantiator_1 = __webpack_require__(/*! ./ExprInstantiator */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js\");\nconst ExprParser_1 = __webpack_require__(/*! ./ExprParser */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js\");\nconst InterpolatedProperty_1 = __webpack_require__(/*! ./InterpolatedProperty */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js\");\nconst InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js\");\nconst Theme_1 = __webpack_require__(/*! ./Theme */ \"./node_modules/@here/harp-datasource-protocol/lib/Theme.js\");\n__export(__webpack_require__(/*! ./Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\"));\nconst exprEvaluator = new ExprEvaluator_1.ExprEvaluator();\nconst exprInstantiator = new ExprInstantiator_1.ExprInstantiator();\n/**\n * The dependencies of an [[Expr]].\n */\nclass ExprDependencies {\n    constructor() {\n        /**\n         * The properties needed to evaluate the [[Expr]].\n         */\n        this.properties = new Set();\n    }\n}\nexports.ExprDependencies = ExprDependencies;\nclass ComputeExprDependencies {\n    /**\n     * Gets the dependencies of an [[Expr]].\n     *\n     * @param expr The [[Expr]] to process.\n     * @param scope The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param dependencies The output [[Set]] of dependency names.\n     */\n    static of(expr) {\n        const dependencies = new ExprDependencies();\n        expr.accept(this.instance, dependencies);\n        return dependencies;\n    }\n    visitNullLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitNumberLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitStringLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitObjectLiteralExpr(expr, context) {\n        // nothing to do\n    }\n    visitVarExpr(expr, context) {\n        context.properties.add(expr.name);\n    }\n    visitHasAttributeExpr(expr, context) {\n        context.properties.add(expr.name);\n    }\n    visitContainsExpr(expr, context) {\n        expr.value.accept(this, context);\n    }\n    visitCallExpr(expr, context) {\n        if (expr.op === \"zoom\" && expr.args.length === 0) {\n            context.zoom = true;\n        }\n        else {\n            expr.args.forEach(childExpr => childExpr.accept(this, context));\n        }\n    }\n    visitMatchExpr(expr, context) {\n        expr.value.accept(this, context);\n        expr.branches.forEach(([_, branch]) => branch.accept(this, context));\n        expr.fallback.accept(this, context);\n    }\n    visitCaseExpr(expr, context) {\n        expr.branches.forEach(([condition, branch]) => {\n            condition.accept(this, context);\n            branch.accept(this, context);\n        });\n        expr.fallback.accept(this, context);\n    }\n}\nComputeExprDependencies.instance = new ComputeExprDependencies();\nfunction isJsonExpr(v) {\n    return Array.isArray(v) && v.length > 0 && typeof v[0] === \"string\";\n}\nexports.isJsonExpr = isJsonExpr;\n/**\n * The evaluation scope of an [[Expr]].\n */\nvar ExprScope;\n(function (ExprScope) {\n    /**\n     * The scope of an [[Expr]] used as value of an attribute.\n     */\n    ExprScope[ExprScope[\"Value\"] = 0] = \"Value\";\n    /**\n     * The scope of an [[Expr]] used in a [[Technique]] `when` condition.\n     */\n    ExprScope[ExprScope[\"Condition\"] = 1] = \"Condition\";\n    /**\n     * The scope of an [[Expr]] used as dynamic property attribute value.\n     */\n    ExprScope[ExprScope[\"Dynamic\"] = 2] = \"Dynamic\";\n})(ExprScope = exports.ExprScope || (exports.ExprScope = {}));\n/**\n * Abstract class defining a shape of a [[Theme]]'s expression\n */\nclass Expr {\n    /**\n     * Tests of given value is an [[Expr]].\n     *\n     * @param value The object to test.\n     */\n    static isExpr(value) {\n        return value instanceof Expr;\n    }\n    /**\n     * Creates an expression from the given `code`.\n     *\n     * @param code The code to parse.\n     * @returns The parsed [[Expr]].\n     * @deprecated\n     */\n    static parse(code) {\n        const parser = new ExprParser_1.ExprParser(code);\n        const expr = parser.parse();\n        return expr;\n    }\n    /**\n     * Parse expression in JSON form.\n     *\n     * If `definitions` are defined, then references (`['ref', name]`) are resolved.\n     *\n     * Pass `definitionExprCache` to reuse `Expr` instances created from definitions across\n     * many `fromJSON` calls.\n     *\n     * @param node expression in JSON format to parse\n     * @param definitions optional set of definitions needed definition resolved by `ref` operator\n     * @param definitionExprCache optional cache of `Expr` instances derived from `definitions`\n     */\n    static fromJSON(node, definitions, definitionExprCache) {\n        const referenceResolverState = definitions !== undefined\n            ? {\n                definitions,\n                lockedNames: new Set(),\n                cache: definitionExprCache || new Map()\n            }\n            : undefined;\n        return parseNode(node, referenceResolverState);\n    }\n    /**\n     * Evaluate an expression returning a [[Value]] object.\n     *\n     * @param env The [[Env]] used to lookup symbols.\n     * @param scope The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param cache A cache of previously computed results.\n     */\n    evaluate(env, scope = ExprScope.Value, cache) {\n        return this.accept(exprEvaluator, new ExprEvaluator_1.ExprEvaluatorContext(exprEvaluator, env, scope, cache));\n    }\n    /**\n     * Instantiates this [[Expr]] by resolving references to the `get` and\n     * `has` operator using the given instantiation context.\n     *\n     * @param context The [[InstantationContext]] used to resolve names.\n     */\n    instantiate(context) {\n        return this.accept(exprInstantiator, context);\n    }\n    /**\n     * Gets the dependencies of this [[Expr]].\n     */\n    dependencies() {\n        return ComputeExprDependencies.of(this);\n    }\n    /**\n     * Create a unique object that is structurally equivalent to this [[Expr]].\n     *\n     * @param pool The [[ExprPool]] used to create a unique\n     * equivalent object of this [[Expr]].\n     */\n    intern(pool) {\n        return pool.add(this);\n    }\n    toJSON() {\n        return new ExprSerializer().serialize(this);\n    }\n    /**\n     * Returns `true` if a dynamic execution context is required to evaluate this [[Expr]].\n     */\n    isDynamic() {\n        if (this.m_isDynamic === undefined) {\n            this.m_isDynamic = this.exprIsDynamic();\n        }\n        return this.m_isDynamic;\n    }\n}\nexports.Expr = Expr;\n/**\n * Var expression.\n * @hidden\n */\nclass VarExpr extends Expr {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitVarExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.VarExpr = VarExpr;\nclass LiteralExpr extends Expr {\n    /**\n     * Create a [[LiteralExpr]] from the given value.\n     *\n     * @param value A constant value.\n     */\n    static fromValue(value) {\n        switch (typeof value) {\n            case \"boolean\":\n                return new BooleanLiteralExpr(value);\n            case \"number\":\n                return new NumberLiteralExpr(value);\n            case \"string\":\n                return new StringLiteralExpr(value);\n            case \"object\":\n                return value === null ? NullLiteralExpr.instance : new ObjectLiteralExpr(value);\n            default:\n                throw new Error(`failed to create a literal from '${value}'`);\n        } // switch\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.LiteralExpr = LiteralExpr;\n/**\n * Null literal expression.\n * @hidden\n */\nclass NullLiteralExpr extends LiteralExpr {\n    constructor() {\n        super();\n        /** @override */\n        this.value = null;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitNullLiteralExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.NullLiteralExpr = NullLiteralExpr;\nNullLiteralExpr.instance = new NullLiteralExpr();\n/**\n * Boolean literal expression.\n * @hidden\n */\nclass BooleanLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitBooleanLiteralExpr(this, context);\n    }\n}\nexports.BooleanLiteralExpr = BooleanLiteralExpr;\n/**\n * Number literal expression.\n * @hidden\n */\nclass NumberLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitNumberLiteralExpr(this, context);\n    }\n}\nexports.NumberLiteralExpr = NumberLiteralExpr;\n/**\n * String literal expression.\n * @hidden\n */\nclass StringLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitStringLiteralExpr(this, context);\n    }\n}\nexports.StringLiteralExpr = StringLiteralExpr;\n/**\n * Object literal expression.\n * @hidden\n */\nclass ObjectLiteralExpr extends LiteralExpr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get isArrayLiteral() {\n        return Array.isArray(this.value);\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitObjectLiteralExpr(this, context);\n    }\n}\nexports.ObjectLiteralExpr = ObjectLiteralExpr;\n/**\n * A has expression with an attribute, for example `has(ref)`.\n * @hidden\n */\nclass HasAttributeExpr extends Expr {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitHasAttributeExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return false;\n    }\n}\nexports.HasAttributeExpr = HasAttributeExpr;\n/**\n * A contains expression.\n * @hidden\n */\nclass ContainsExpr extends Expr {\n    constructor(value, elements) {\n        super();\n        this.value = value;\n        this.elements = elements;\n    }\n    static isValidElementsArray(elements) {\n        if (!Array.isArray(elements) || elements.length === 0) {\n            return false;\n        }\n        const elementTy = typeof elements[0];\n        if (elementTy === \"number\" || elementTy === \"string\") {\n            return elements.every(element => typeof element === elementTy);\n        }\n        return false;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitContainsExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return this.value.isDynamic();\n    }\n}\nexports.ContainsExpr = ContainsExpr;\n/**\n * @hidden\n */\nclass CallExpr extends Expr {\n    constructor(op, args) {\n        super();\n        this.op = op;\n        this.args = args;\n    }\n    /**\n     * Returns the child nodes of this [[Expr]].\n     * @deprecated\n     */\n    get children() {\n        return this.args;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitCallExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        const descriptor = this.descriptor || ExprEvaluator_1.ExprEvaluator.getOperator(this.op);\n        if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {\n            return true;\n        }\n        return this.args.some(e => e.isDynamic());\n    }\n}\nexports.CallExpr = CallExpr;\n/**\n * @hidden\n */\nclass MatchExpr extends Expr {\n    constructor(value, branches, fallback) {\n        super();\n        this.value = value;\n        this.branches = branches;\n        this.fallback = fallback;\n    }\n    /**\n     * Tests if the given JSON node is a valid label for the `\"match\"` operator.\n     *\n     * @param node A JSON value.\n     */\n    static isValidMatchLabel(node) {\n        switch (typeof node) {\n            case \"number\":\n            case \"string\":\n                return true;\n            case \"object\":\n                if (!Array.isArray(node) || node.length === 0) {\n                    return false;\n                }\n                const elementTy = typeof node[0];\n                if (elementTy === \"number\" || elementTy === \"string\") {\n                    return node.every(t => typeof t === elementTy);\n                }\n                return false;\n            default:\n                return false;\n        } // switch\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitMatchExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return (this.value.isDynamic() ||\n            this.branches.some(([_, branch]) => branch.isDynamic()) ||\n            this.fallback.isDynamic());\n    }\n}\nexports.MatchExpr = MatchExpr;\n/**\n * @hidden\n */\nclass CaseExpr extends Expr {\n    constructor(branches, fallback) {\n        super();\n        this.branches = branches;\n        this.fallback = fallback;\n    }\n    /** @override */\n    accept(visitor, context) {\n        return visitor.visitCaseExpr(this, context);\n    }\n    /** @override */\n    exprIsDynamic() {\n        return (this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) ||\n            this.fallback.isDynamic());\n    }\n}\nexports.CaseExpr = CaseExpr;\n/**\n * @hidden\n */\nclass ExprSerializer {\n    serialize(expr) {\n        return expr.accept(this, undefined);\n    }\n    visitNullLiteralExpr(expr, context) {\n        return null;\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitNumberLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitStringLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitObjectLiteralExpr(expr, context) {\n        return [\"literal\", expr.value];\n    }\n    visitVarExpr(expr, context) {\n        return [\"get\", expr.name];\n    }\n    visitHasAttributeExpr(expr, context) {\n        return [\"has\", expr.name];\n    }\n    visitContainsExpr(expr, context) {\n        return [\"in\", this.serialize(expr.value), expr.elements];\n    }\n    visitCallExpr(expr, context) {\n        return [expr.op, ...expr.args.map(childExpr => this.serialize(childExpr))];\n    }\n    visitMatchExpr(expr, context) {\n        const branches = [];\n        for (const [label, body] of expr.branches) {\n            branches.push(label, this.serialize(body));\n        }\n        return [\"match\", this.serialize(expr.value), ...branches, this.serialize(expr.fallback)];\n    }\n    visitCaseExpr(expr, context) {\n        const branches = [];\n        for (const [condition, body] of expr.branches) {\n            branches.push(this.serialize(condition), this.serialize(body));\n        }\n        return [\"case\", ...branches, this.serialize(expr.fallback)];\n    }\n}\nfunction parseNode(node, referenceResolverState) {\n    if (Array.isArray(node)) {\n        return parseCall(node, referenceResolverState);\n    }\n    else if (node === null) {\n        return NullLiteralExpr.instance;\n    }\n    else if (typeof node === \"boolean\") {\n        return new BooleanLiteralExpr(node);\n    }\n    else if (typeof node === \"number\") {\n        return new NumberLiteralExpr(node);\n    }\n    else if (typeof node === \"string\") {\n        return new StringLiteralExpr(node);\n    }\n    throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);\n}\nfunction parseCall(node, referenceResolverState) {\n    const op = node[0];\n    if (typeof op !== \"string\") {\n        throw new Error(\"expected a builtin function name\");\n    }\n    switch (op) {\n        case \"!has\":\n        case \"!in\":\n            return new CallExpr(\"!\", [parseCall([op.slice(1), ...node.slice(1)])]);\n        case \"ref\":\n            return resolveReference(node, referenceResolverState);\n        case \"get\":\n            return parseGetExpr(node, referenceResolverState);\n        case \"has\":\n            return parseHasExpr(node, referenceResolverState);\n        case \"in\":\n            return parseInExpr(node, referenceResolverState);\n        case \"literal\":\n            return parseLiteralExpr(node);\n        case \"match\":\n            return parseMatchExpr(node, referenceResolverState);\n        case \"case\":\n            return parseCaseExpr(node, referenceResolverState);\n        default:\n            return makeCallExpr(op, node, referenceResolverState);\n    } // switch\n}\nfunction parseGetExpr(node, referenceResolverState) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"get\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new VarExpr(name);\n}\nfunction parseHasExpr(node, referenceResolverState) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"has\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new HasAttributeExpr(name);\n}\nfunction parseInExpr(node, referenceResolverState) {\n    const elements = node[2];\n    if (!ContainsExpr.isValidElementsArray(elements)) {\n        // tslint:disable-next-line: max-line-length\n        throw new Error(`'in' expects an array of number or string literals`);\n    }\n    return new ContainsExpr(parseNode(node[1], referenceResolverState), elements);\n}\nfunction parseLiteralExpr(node) {\n    const obj = node[1];\n    if (obj === null || typeof obj !== \"object\") {\n        throw new Error(\"expected an object or array literal\");\n    }\n    return new ObjectLiteralExpr(obj);\n}\nfunction parseMatchExpr(node, referenceResolverState) {\n    if (node.length < 4) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (!(node.length % 2)) {\n        throw new Error(\"fallback is missing in 'match' expression\");\n    }\n    const value = parseNode(node[1], referenceResolverState);\n    const conditions = [];\n    for (let i = 2; i < node.length - 1; i += 2) {\n        const label = node[i];\n        if (!MatchExpr.isValidMatchLabel(label)) {\n            throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);\n        }\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        conditions.push([label, expr]);\n    }\n    const fallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new MatchExpr(value, conditions, fallback);\n}\nfunction parseCaseExpr(node, referenceResolverState) {\n    if (node.length < 3) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (node.length % 2) {\n        throw new Error(\"fallback is missing in 'case' expression\");\n    }\n    const branches = [];\n    for (let i = 1; i < node.length - 1; i += 2) {\n        const condition = parseNode(node[i], referenceResolverState);\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        branches.push([condition, expr]);\n    }\n    const caseFallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new CaseExpr(branches, caseFallback);\n}\nfunction makeCallExpr(op, node, referenceResolverState) {\n    return new CallExpr(op, node.slice(1).map(childExpr => parseNode(childExpr, referenceResolverState)));\n}\nfunction resolveReference(node, referenceResolverState) {\n    if (typeof node[1] !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    if (referenceResolverState === undefined) {\n        throw new Error(`ref used with no definitions`);\n    }\n    const name = node[1];\n    if (referenceResolverState.lockedNames.has(name)) {\n        throw new Error(`circular referene to '${name}'`);\n    }\n    if (!(name in referenceResolverState.definitions)) {\n        throw new Error(`definition '${name}' not found`);\n    }\n    const cachedEntry = referenceResolverState.cache.get(name);\n    if (cachedEntry !== undefined) {\n        return cachedEntry;\n    }\n    let definitionEntry = referenceResolverState.definitions[name];\n    let result;\n    if (Theme_1.isLiteralDefinition(definitionEntry)) {\n        return Expr.fromJSON(definitionEntry);\n    }\n    else if (Theme_1.isBoxedDefinition(definitionEntry)) {\n        if (InterpolatedProperty_1.isInterpolatedPropertyDefinition(definitionEntry.value)) {\n            // found a reference to an interpolation using\n            // the deprecated object-like syntax.\n            return Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(definitionEntry.value));\n        }\n        else if (isJsonExpr(definitionEntry.value)) {\n            definitionEntry = definitionEntry.value;\n        }\n        else {\n            return Expr.fromJSON(definitionEntry.value);\n        }\n    }\n    if (isJsonExpr(definitionEntry)) {\n        referenceResolverState.lockedNames.add(name);\n        try {\n            result = parseNode(definitionEntry, referenceResolverState);\n        }\n        finally {\n            referenceResolverState.lockedNames.delete(name);\n        }\n    }\n    else {\n        throw new Error(`unsupported definition ${name}`);\n    }\n    referenceResolverState.cache.set(name, result);\n    return result;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Expr.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst ArrayOperators_1 = __webpack_require__(/*! ./operators/ArrayOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js\");\nconst CastOperators_1 = __webpack_require__(/*! ./operators/CastOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js\");\nconst ColorOperators_1 = __webpack_require__(/*! ./operators/ColorOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js\");\nconst ComparisonOperators_1 = __webpack_require__(/*! ./operators/ComparisonOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js\");\nconst FeatureOperators_1 = __webpack_require__(/*! ./operators/FeatureOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js\");\nconst FlowOperators_1 = __webpack_require__(/*! ./operators/FlowOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js\");\nconst InterpolationOperators_1 = __webpack_require__(/*! ./operators/InterpolationOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/InterpolationOperators.js\");\nconst MapOperators_1 = __webpack_require__(/*! ./operators/MapOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js\");\nconst MathOperators_1 = __webpack_require__(/*! ./operators/MathOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js\");\nconst MiscOperators_1 = __webpack_require__(/*! ./operators/MiscOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js\");\nconst ObjectOperators_1 = __webpack_require__(/*! ./operators/ObjectOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js\");\nconst StringOperators_1 = __webpack_require__(/*! ./operators/StringOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js\");\nconst TypeOperators_1 = __webpack_require__(/*! ./operators/TypeOperators */ \"./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js\");\nconst operatorDescriptors = new Map();\n/*\n * @hidden\n */\nclass ExprEvaluatorContext {\n    constructor(evaluator, env, scope, cache) {\n        this.evaluator = evaluator;\n        this.env = env;\n        this.scope = scope;\n        this.cache = cache;\n        this.m_partialEvaluation = false;\n    }\n    /**\n     * `true` if the this context is used to partially evaluate expressions.\n     */\n    get partialEvaluation() {\n        return this.m_partialEvaluation;\n    }\n    /**\n     * Evaluate the given expression.\n     *\n     * @param expr The [[Expr]] to evaluate.\n     */\n    evaluate(expr) {\n        if (expr !== undefined) {\n            return expr.accept(this.evaluator, this);\n        }\n        throw new Error(\"Failed to evaluate expression\");\n    }\n    /**\n     * Partially evaluate the given expression.\n     *\n     * @param expr The [[Expr]] to evaluate.\n     */\n    partiallyEvaluate(expr) {\n        if (expr === undefined) {\n            throw new Error(\"Failed to evaluate expression\");\n        }\n        const previousEvaluationMode = this.m_partialEvaluation;\n        this.m_partialEvaluation = true;\n        try {\n            const value = expr.accept(this.evaluator, this);\n            this.m_partialEvaluation = previousEvaluationMode;\n            if (value instanceof Expr_1.Expr) {\n                return value;\n            }\n            return Expr_1.LiteralExpr.fromValue(value);\n        }\n        catch (error) {\n            // rethrow the exception\n            throw error;\n        }\n        finally {\n            // reset the evaluation mode.\n            this.m_partialEvaluation = previousEvaluationMode;\n        }\n    }\n}\nexports.ExprEvaluatorContext = ExprEvaluatorContext;\n/**\n * [[ExprEvaluator]] is used to evaluate [[Expr]] in a given environment.\n *\n * @hidden\n */\nclass ExprEvaluator {\n    static defineOperator(op, builtin) {\n        operatorDescriptors.set(op, builtin);\n    }\n    static defineOperators(builtins) {\n        Object.getOwnPropertyNames(builtins).forEach(p => {\n            this.defineOperator(p, builtins[p]);\n        });\n    }\n    /**\n     * Returns the [[OperatorDescriptor]] for the given operator name.\n     * @hidden\n     */\n    static getOperator(op) {\n        return operatorDescriptors.get(op);\n    }\n    visitVarExpr(expr, context) {\n        const value = context.env.lookup(expr.name);\n        return value !== undefined ? value : null;\n    }\n    visitNullLiteralExpr(expr, context) {\n        return null;\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitNumberLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitStringLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitObjectLiteralExpr(expr, context) {\n        return expr.value;\n    }\n    visitHasAttributeExpr(expr, context) {\n        return context.env.lookup(expr.name) !== undefined;\n    }\n    visitContainsExpr(expr, context) {\n        const value = expr.value.accept(this, context);\n        const result = expr.elements.includes(value);\n        if (context.cache !== undefined) {\n            context.cache.set(expr, result);\n        }\n        return result;\n    }\n    visitMatchExpr(match, context) {\n        const r = context.evaluate(match.value);\n        for (const [label, body] of match.branches) {\n            if (Array.isArray(label) && label.includes(r)) {\n                return context.evaluate(body);\n            }\n            else if (label === r) {\n                return context.evaluate(body);\n            }\n        }\n        return context.evaluate(match.fallback);\n    }\n    visitCaseExpr(match, context) {\n        for (const [condition, body] of match.branches) {\n            if (context.evaluate(condition)) {\n                return context.evaluate(body);\n            }\n        }\n        return context.evaluate(match.fallback);\n    }\n    visitCallExpr(expr, context) {\n        if (context.cache !== undefined) {\n            const v = context.cache.get(expr);\n            if (v !== undefined) {\n                return v;\n            }\n        }\n        const descriptor = expr.descriptor || operatorDescriptors.get(expr.op);\n        if (descriptor) {\n            expr.descriptor = descriptor;\n            const result = descriptor.call(context, expr);\n            if (context.cache) {\n                context.cache.set(expr, result);\n            }\n            return result;\n        }\n        throw new Error(`undefined operator '${expr.op}`);\n    }\n}\nexports.ExprEvaluator = ExprEvaluator;\nExprEvaluator.defineOperators(CastOperators_1.CastOperators);\nExprEvaluator.defineOperators(ComparisonOperators_1.ComparisonOperators);\nExprEvaluator.defineOperators(MathOperators_1.MathOperators);\nExprEvaluator.defineOperators(StringOperators_1.StringOperators);\nExprEvaluator.defineOperators(ColorOperators_1.ColorOperators);\nExprEvaluator.defineOperators(TypeOperators_1.TypeOperators);\nExprEvaluator.defineOperators(MiscOperators_1.MiscOperators);\nExprEvaluator.defineOperators(FlowOperators_1.FlowOperators);\nExprEvaluator.defineOperators(ArrayOperators_1.ArrayOperators);\nExprEvaluator.defineOperators(InterpolationOperators_1.InterpolationOperators);\nExprEvaluator.defineOperators(ObjectOperators_1.ObjectOperators);\nExprEvaluator.defineOperators(FeatureOperators_1.FeatureOperators);\nExprEvaluator.defineOperators(MapOperators_1.MapOperators);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprEvaluator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\n/**\n * @hidden\n */\nclass ExprInstantiator {\n    visitNullLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitBooleanLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitNumberLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitStringLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitObjectLiteralExpr(expr, _context) {\n        return expr;\n    }\n    visitVarExpr(expr, context) {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name);\n        return Expr_1.LiteralExpr.fromValue(value !== undefined ? value : null);\n    }\n    visitHasAttributeExpr(expr, context) {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name) !== undefined;\n        return Expr_1.LiteralExpr.fromValue(value);\n    }\n    visitContainsExpr(expr, context) {\n        const value = expr.value.accept(this, context);\n        if (value instanceof Expr_1.LiteralExpr) {\n            const result = expr.elements.includes(value.value);\n            return Expr_1.LiteralExpr.fromValue(result);\n        }\n        return value === expr.value ? expr : new Expr_1.ContainsExpr(value, expr.elements);\n    }\n    visitCallExpr(expr, context) {\n        const args = expr.args.map(arg => arg.accept(this, context));\n        if (args.some((a, i) => a !== expr.args[i])) {\n            return new Expr_1.CallExpr(expr.op, args);\n        }\n        return expr;\n    }\n    visitMatchExpr(match, context) {\n        const value = match.value.accept(this, context);\n        if (value instanceof Expr_1.LiteralExpr) {\n            const r = value.value;\n            for (const [label, body] of match.branches) {\n                if (Array.isArray(label) && label.includes(r)) {\n                    return body.accept(this, context);\n                }\n                else if (label === r) {\n                    return body.accept(this, context);\n                }\n            }\n            return match.fallback.accept(this, context);\n        }\n        let changed = match.value !== value;\n        const branches = match.branches.map(([label, branch]) => {\n            const newBranch = branch.accept(this, context);\n            if (newBranch !== branch) {\n                changed = true;\n            }\n            return [label, newBranch];\n        });\n        const fallback = match.fallback.accept(this, context);\n        if (fallback !== match.fallback) {\n            changed = true;\n        }\n        return changed ? new Expr_1.MatchExpr(value, branches, fallback) : match;\n    }\n    visitCaseExpr(expr, context) {\n        const branches = [];\n        let changed = false;\n        for (const [condition, branch] of expr.branches) {\n            const newCondition = condition.accept(this, context);\n            if (newCondition instanceof Expr_1.LiteralExpr) {\n                if (newCondition.value) {\n                    return branch.accept(this, context);\n                }\n            }\n            else {\n                if (newCondition !== condition) {\n                    changed = true;\n                }\n                branches.push([newCondition, branch]);\n            }\n        }\n        if (branches.length === 0) {\n            // all the conditions of this CaseExpr evaluated\n            // to false, so the resulting of instantiating this CaseExpr\n            // is the same as instantiating its fallback expression.\n            return expr.fallback.accept(this, context);\n        }\n        if (branches.length !== expr.branches.length) {\n            // the number of branches changed, this means that\n            // some of the branches had constant expressions that\n            // evaluate to false. In this case the resulting\n            // `CaseExpr` has less branches.\n            changed = true;\n        }\n        // Instantiate the body of all the branches of this CaseExpr\n        // that have dynamic conditions.\n        branches.forEach(branch => {\n            const instantiatedBranch = branch[1].accept(this, context);\n            if (instantiatedBranch !== branch[1]) {\n                changed = true;\n            }\n            branch[1] = instantiatedBranch;\n        });\n        const fallback = expr.fallback.accept(this, context);\n        if (fallback !== expr.fallback) {\n            changed = true;\n        }\n        if (!changed) {\n            // nothing changed, return the old expression.\n            return expr;\n        }\n        return new Expr_1.CaseExpr(branches, fallback);\n    }\n}\nexports.ExprInstantiator = ExprInstantiator;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprInstantiator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\n/**\n * Character value\n */\nvar Character;\n(function (Character) {\n    Character[Character[\"Tab\"] = 9] = \"Tab\";\n    Character[Character[\"Lf\"] = 10] = \"Lf\";\n    Character[Character[\"Cr\"] = 13] = \"Cr\";\n    Character[Character[\"Space\"] = 32] = \"Space\";\n    Character[Character[\"LParen\"] = 40] = \"LParen\";\n    Character[Character[\"RParen\"] = 41] = \"RParen\";\n    Character[Character[\"Comma\"] = 44] = \"Comma\";\n    Character[Character[\"Dot\"] = 46] = \"Dot\";\n    Character[Character[\"LBracket\"] = 91] = \"LBracket\";\n    Character[Character[\"Backslash\"] = 92] = \"Backslash\";\n    Character[Character[\"RBracket\"] = 93] = \"RBracket\";\n    Character[Character[\"_0\"] = 48] = \"_0\";\n    Character[Character[\"_9\"] = 57] = \"_9\";\n    Character[Character[\"_\"] = 95] = \"_\";\n    Character[Character[\"A\"] = 64] = \"A\";\n    Character[Character[\"Z\"] = 90] = \"Z\";\n    Character[Character[\"a\"] = 97] = \"a\";\n    Character[Character[\"z\"] = 122] = \"z\";\n    Character[Character[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    Character[Character[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    Character[Character[\"Exclaim\"] = 33] = \"Exclaim\";\n    Character[Character[\"Equal\"] = 61] = \"Equal\";\n    Character[Character[\"Caret\"] = 94] = \"Caret\";\n    Character[Character[\"Tilde\"] = 126] = \"Tilde\";\n    Character[Character[\"Dollar\"] = 36] = \"Dollar\";\n    Character[Character[\"Less\"] = 60] = \"Less\";\n    Character[Character[\"Greater\"] = 62] = \"Greater\";\n    Character[Character[\"Bar\"] = 124] = \"Bar\";\n    Character[Character[\"Amp\"] = 38] = \"Amp\";\n})(Character || (Character = {}));\n/**\n * Check if a codepoint is a whitespace character.\n */\nfunction isSpace(codepoint) {\n    switch (codepoint) {\n        case Character.Tab:\n        case Character.Lf:\n        case Character.Cr:\n        case Character.Space:\n            return true;\n        default:\n            return false;\n    } // switch\n}\n/**\n * Check if codepoint is a digit character.\n */\nfunction isNumber(codepoint) {\n    return codepoint >= Character._0 && codepoint <= Character._9;\n}\n/**\n * Check if codepoint is a letter character.\n */\nfunction isLetter(codepoint) {\n    return ((codepoint >= Character.a && codepoint <= Character.z) ||\n        (codepoint >= Character.A && codepoint <= Character.Z));\n}\n/**\n * Check if codepoint is either a digit or a letter character.\n */\nfunction isLetterOrNumber(codepoint) {\n    return isLetter(codepoint) || isNumber(codepoint);\n}\n/**\n * Check if codepoint is an identification character: underscore, dollar sign, dot or bracket.\n */\nfunction isIdentChar(codepoint) {\n    return (isLetterOrNumber(codepoint) ||\n        codepoint === Character._ ||\n        codepoint === Character.Dollar ||\n        codepoint === Character.Dot ||\n        codepoint === Character.LBracket ||\n        codepoint === Character.RBracket);\n}\n/**\n * Tokens used in theme grammar.\n */\nvar Token;\n(function (Token) {\n    Token[Token[\"Eof\"] = 0] = \"Eof\";\n    Token[Token[\"Error\"] = 1] = \"Error\";\n    Token[Token[\"Identifier\"] = 2] = \"Identifier\";\n    Token[Token[\"Number\"] = 3] = \"Number\";\n    Token[Token[\"String\"] = 4] = \"String\";\n    Token[Token[\"Comma\"] = 5] = \"Comma\";\n    Token[Token[\"LParen\"] = 6] = \"LParen\";\n    Token[Token[\"RParen\"] = 7] = \"RParen\";\n    Token[Token[\"LBracket\"] = 8] = \"LBracket\";\n    Token[Token[\"RBracket\"] = 9] = \"RBracket\";\n    Token[Token[\"Exclaim\"] = 10] = \"Exclaim\";\n    Token[Token[\"TildeEqual\"] = 11] = \"TildeEqual\";\n    Token[Token[\"CaretEqual\"] = 12] = \"CaretEqual\";\n    Token[Token[\"DollarEqual\"] = 13] = \"DollarEqual\";\n    Token[Token[\"EqualEqual\"] = 14] = \"EqualEqual\";\n    Token[Token[\"ExclaimEqual\"] = 15] = \"ExclaimEqual\";\n    Token[Token[\"Less\"] = 16] = \"Less\";\n    Token[Token[\"Greater\"] = 17] = \"Greater\";\n    Token[Token[\"LessEqual\"] = 18] = \"LessEqual\";\n    Token[Token[\"GreaterEqual\"] = 19] = \"GreaterEqual\";\n    Token[Token[\"BarBar\"] = 20] = \"BarBar\";\n    Token[Token[\"AmpAmp\"] = 21] = \"AmpAmp\";\n})(Token || (Token = {}));\n/**\n * Maps a token to its string name.\n */\nfunction tokenSpell(token) {\n    switch (token) {\n        case Token.Eof:\n            return \"eof\";\n        case Token.Error:\n            return \"error\";\n        case Token.Identifier:\n            return \"identifier\";\n        case Token.Number:\n            return \"number\";\n        case Token.String:\n            return \"string\";\n        case Token.Comma:\n            return \",\";\n        case Token.LParen:\n            return \"(\";\n        case Token.RParen:\n            return \")\";\n        case Token.LBracket:\n            return \"[\";\n        case Token.RBracket:\n            return \"]\";\n        case Token.Exclaim:\n            return \"!\";\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        case Token.BarBar:\n            return \"||\";\n        case Token.AmpAmp:\n            return \"&&\";\n        default:\n            throw new Error(`invalid token ${token}`);\n    }\n}\n/**\n * Lexer class implementation.\n */\nclass Lexer {\n    constructor(code) {\n        this.code = code;\n        this.m_token = Token.Error;\n        this.m_index = 0;\n        this.m_char = Character.Lf;\n    }\n    /**\n     * Single lexer token.\n     */\n    token() {\n        return this.m_token;\n    }\n    /**\n     * Parsed text.\n     */\n    text() {\n        return this.m_text || \"\";\n    }\n    /**\n     * Go to the next token.\n     */\n    next() {\n        this.m_token = this.yylex();\n        if (this.m_token === Token.Error) {\n            throw new Error(`unexpected character ${this.m_char}`);\n        }\n        return this.m_token;\n    }\n    yyinp() {\n        this.m_char = this.code.codePointAt(this.m_index++) || 0;\n    }\n    yylex() {\n        this.m_text = undefined;\n        while (isSpace(this.m_char)) {\n            this.yyinp();\n        }\n        if (this.m_char === 0) {\n            return Token.Eof;\n        }\n        const ch = this.m_char;\n        this.yyinp();\n        switch (ch) {\n            case Character.LParen:\n                return Token.LParen;\n            case Character.RParen:\n                return Token.RParen;\n            case Character.LBracket:\n                return Token.LBracket;\n            case Character.RBracket:\n                return Token.RBracket;\n            case Character.Comma:\n                return Token.Comma;\n            case Character.SingleQuote:\n            case Character.DoubleQuote: {\n                const start = this.m_index - 1;\n                while (this.m_char && this.m_char !== ch) {\n                    // ### TODO handle escape sequences\n                    this.yyinp();\n                }\n                if (this.m_char !== ch) {\n                    throw new Error(\"Unfinished string literal\");\n                }\n                this.yyinp();\n                this.m_text = this.code.substring(start, this.m_index - 2);\n                return Token.String;\n            }\n            case Character.Exclaim:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.ExclaimEqual;\n                }\n                return Token.Exclaim;\n            case Character.Caret:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.CaretEqual;\n                }\n                return Token.Error;\n            case Character.Tilde:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.TildeEqual;\n                }\n                return Token.Error;\n            case Character.Equal:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.EqualEqual;\n                }\n                return Token.Error;\n            case Character.Less:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.LessEqual;\n                }\n                return Token.Less;\n            case Character.Greater:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.GreaterEqual;\n                }\n                return Token.Greater;\n            case Character.Bar:\n                if (this.m_char === Character.Bar) {\n                    this.yyinp();\n                    return Token.BarBar;\n                }\n                return Token.Error;\n            case Character.Amp:\n                if (this.m_char === Character.Amp) {\n                    this.yyinp();\n                    return Token.AmpAmp;\n                }\n                return Token.Error;\n            default: {\n                const start = this.m_index - 2;\n                if (isLetter(ch) ||\n                    ch === Character._ ||\n                    (ch === Character.Dollar && isIdentChar(this.m_char))) {\n                    while (isIdentChar(this.m_char)) {\n                        this.yyinp();\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Identifier;\n                }\n                else if (isNumber(ch)) {\n                    while (isNumber(this.m_char)) {\n                        this.yyinp();\n                    }\n                    if (this.m_char === Character.Dot) {\n                        this.yyinp();\n                        while (isNumber(this.m_char)) {\n                            this.yyinp();\n                        }\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Number;\n                }\n                else if (ch === Character.Dollar) {\n                    if (this.m_char === Character.Equal) {\n                        this.yyinp();\n                        return Token.DollarEqual;\n                    }\n                    return Token.Error;\n                }\n            }\n        }\n        return Token.Error;\n    }\n}\nfunction getEqualityOp(token) {\n    switch (token) {\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        default:\n            return undefined;\n    } // switch\n}\nfunction getRelationalOp(token) {\n    switch (token) {\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        default:\n            return undefined;\n    } // switch\n}\nclass ExprParser {\n    constructor(code) {\n        this.lex = new Lexer(code);\n        this.lex.next();\n    }\n    parse() {\n        return this.parseLogicalOr();\n    }\n    yyexpect(token) {\n        if (this.lex.token() !== token) {\n            throw new Error(`Syntax error: Expected token '${tokenSpell(token)}' but ` +\n                `found '${tokenSpell(this.lex.token())}'`);\n        }\n        this.lex.next();\n    }\n    parsePrimary() {\n        switch (this.lex.token()) {\n            case Token.Identifier: {\n                const text = this.lex.text();\n                switch (text) {\n                    case \"has\":\n                        this.lex.next(); // skip has keyword\n                        this.yyexpect(Token.LParen);\n                        const hasAttribute = this.lex.text();\n                        this.yyexpect(Token.Identifier);\n                        this.yyexpect(Token.RParen);\n                        return new Expr_1.HasAttributeExpr(hasAttribute);\n                    case \"length\":\n                        this.lex.next(); // skip length keyword\n                        this.yyexpect(Token.LParen);\n                        const value = this.parseLogicalOr();\n                        this.yyexpect(Token.RParen);\n                        return new Expr_1.CallExpr(\"length\", [value]);\n                    default:\n                        const expr = new Expr_1.VarExpr(text);\n                        this.lex.next();\n                        return expr;\n                }\n            }\n            case Token.LParen: {\n                this.lex.next();\n                const expr = this.parseLogicalOr();\n                this.yyexpect(Token.RParen);\n                return expr;\n            }\n            default:\n                return this.parseLiteral();\n        } // switch\n    }\n    parseLiteral() {\n        switch (this.lex.token()) {\n            case Token.Number: {\n                const expr = new Expr_1.NumberLiteralExpr(parseFloat(this.lex.text()));\n                this.lex.next();\n                return expr;\n            }\n            case Token.String: {\n                const expr = new Expr_1.StringLiteralExpr(this.lex.text());\n                this.lex.next();\n                return expr;\n            }\n            default:\n                throw new Error(\"Syntax error\");\n        } // switch\n    }\n    parseUnary() {\n        if (this.lex.token() === Token.Exclaim) {\n            this.lex.next();\n            return new Expr_1.CallExpr(\"!\", [this.parseUnary()]);\n        }\n        return this.parsePrimary();\n    }\n    parseRelational() {\n        let expr = this.parseUnary();\n        while (true) {\n            if (this.lex.token() === Token.Identifier && this.lex.text() === \"in\") {\n                this.lex.next();\n                this.yyexpect(Token.LBracket);\n                const elements = [this.parseLiteral()];\n                while (this.lex.token() === Token.Comma) {\n                    this.lex.next();\n                    elements.push(this.parseLiteral());\n                }\n                this.yyexpect(Token.RBracket);\n                expr = new Expr_1.ContainsExpr(expr, elements.map(literal => literal.value));\n            }\n            else {\n                const op = getRelationalOp(this.lex.token());\n                if (op === undefined) {\n                    break;\n                }\n                this.lex.next();\n                const right = this.parseUnary();\n                expr = new Expr_1.CallExpr(op, [expr, right]);\n            }\n        }\n        return expr;\n    }\n    parseEquality() {\n        let expr = this.parseRelational();\n        while (true) {\n            const op = getEqualityOp(this.lex.token());\n            if (op === undefined) {\n                break;\n            }\n            this.lex.next();\n            const right = this.parseRelational();\n            expr = new Expr_1.CallExpr(op, [expr, right]);\n        }\n        return expr;\n    }\n    parseLogicalAnd() {\n        const expr = this.parseEquality();\n        if (this.lex.token() !== Token.AmpAmp) {\n            return expr;\n        }\n        const expressions = [expr];\n        do {\n            this.lex.next();\n            expressions.push(this.parseEquality());\n        } while (this.lex.token() === Token.AmpAmp);\n        return new Expr_1.CallExpr(\"all\", expressions);\n    }\n    parseLogicalOr() {\n        const expr = this.parseLogicalAnd();\n        if (this.lex.token() !== Token.BarBar) {\n            return expr;\n        }\n        const expressions = [expr];\n        do {\n            this.lex.next();\n            expressions.push(this.parseLogicalAnd());\n        } while (this.lex.token() === Token.BarBar);\n        return new Expr_1.CallExpr(\"any\", expressions);\n    }\n}\nexports.ExprParser = ExprParser;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprParser.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\n/**\n * [[ExprPool]] maintains a set of unique interned [[Expr]] objects.\n *\n * @hidden\n */\nclass ExprPool {\n    constructor() {\n        this.m_booleanLiterals = new Map();\n        this.m_numberLiterals = new Map();\n        this.m_stringLiterals = new Map();\n        this.m_objectLiterals = new Map();\n        this.m_varExprs = new Map();\n        this.m_hasAttributeExprs = new Map();\n        this.m_inExprs = new Map();\n        this.m_callExprs = new Map();\n    }\n    /**\n     * Add `expr` to this [[ExprPool]] and return a unique [[Expr]]\n     * object that is structurally equivalent to `expr`.\n     *\n     * @param expr The [[Expr]] to add to this [[ExprPool]].\n     * @returns A unique [[Expr]] that is structurally equivalent to `expr`.\n     */\n    add(expr) {\n        return expr.accept(this, undefined);\n    }\n    visitNullLiteralExpr(expr, context) {\n        return Expr_1.NullLiteralExpr.instance;\n    }\n    visitBooleanLiteralExpr(expr, context) {\n        const e = this.m_booleanLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_booleanLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitNumberLiteralExpr(expr, context) {\n        const e = this.m_numberLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_numberLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitStringLiteralExpr(expr, context) {\n        const e = this.m_stringLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_stringLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitObjectLiteralExpr(expr, context) {\n        const e = this.m_objectLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_objectLiterals.set(expr.value, expr);\n        return expr;\n    }\n    visitVarExpr(expr, context) {\n        const e = this.m_varExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_varExprs.set(expr.name, expr);\n        return expr;\n    }\n    visitHasAttributeExpr(expr, context) {\n        const e = this.m_hasAttributeExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_hasAttributeExprs.set(expr.name, expr);\n        return expr;\n    }\n    visitContainsExpr(expr, context) {\n        const value = expr.value.accept(this, context);\n        if (!this.m_inExprs.has(value)) {\n            this.m_inExprs.set(value, []);\n        }\n        const inExprs = this.m_inExprs.get(value);\n        for (const inExpr of inExprs) {\n            if (inExpr.elements.length !== expr.elements.length) {\n                continue;\n            }\n            // find the index of the first element in the cached 'in' expr\n            // that is not contained in 'expr.elements'.\n            const i = inExpr.elements.findIndex(x => !expr.elements.includes(x));\n            if (i === -1) {\n                return inExpr;\n            }\n        }\n        const e = new Expr_1.ContainsExpr(value, expr.elements);\n        this.m_inExprs.set(value, [e]);\n        return e;\n    }\n    visitMatchExpr(expr, context) {\n        const value = expr.value.accept(this, context);\n        const branches = expr.branches.map(([label, body]) => [\n            label,\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n        return new Expr_1.MatchExpr(value, branches, fallback);\n    }\n    visitCaseExpr(expr, context) {\n        const branches = expr.branches.map(([condition, body]) => [\n            condition.accept(this, context),\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n        return new Expr_1.CaseExpr(branches, fallback);\n    }\n    visitCallExpr(expr, context) {\n        // rewrite the actual arguments\n        const expressions = expr.args.map(childExpr => childExpr.accept(this, context));\n        // ensure we have a valid set of interned expressions for the calls\n        if (!this.m_callExprs.has(expr.op)) {\n            this.m_callExprs.set(expr.op, []);\n        }\n        // get the calls for the given operator.\n        const calls = this.m_callExprs.get(expr.op);\n        for (const call of calls) {\n            // check the number of arguments\n            if (call.args.length !== expressions.length) {\n                continue;\n            }\n            // find the index of the first mismatch.\n            let index = 0;\n            for (; index < call.args.length; ++index) {\n                if (call.args[index] !== expressions[index]) {\n                    break;\n                }\n            }\n            if (index === call.args.length) {\n                // no mismatch found, return the 'interned' call.\n                return call;\n            }\n        }\n        const e = new Expr_1.CallExpr(expr.op, expressions);\n        calls.push(e);\n        return e;\n    }\n}\nexports.ExprPool = ExprPool;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Extruder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Extruder.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Fills an index buffer with the indices for the extruded walls for a polygon contour.\n *\n * @param indexBuffer Index buffer to be filled.\n * @param vertexOffset Starting offset of the vertices composing the contour.\n * @param vertexStride Number of elements per contour vertex.\n * @param contour Vertices that compose the contour.\n * @param contourEdges Collection of booleans indicating if contour edges should be added.\n * @param boundaryWalls If `false`, walls in tile boundaries will not be created.\n *\n */\nfunction addExtrudedWalls(indexBuffer, vertexOffset, vertexStride, contour, contourEdges, boundaryWalls) {\n    // Infer the index buffer's position of the vertices that form the extruded-polygons' walls\n    // by stepping through the contour segment by segment.\n    const nSegments = contour.length / vertexStride;\n    for (let i = 0; i < nSegments; ++i) {\n        const vFootprint0 = vertexOffset + i * 2;\n        const vRoof0 = vFootprint0 + 1;\n        const vFootprint1 = vertexOffset + ((i + 1) % nSegments) * 2;\n        const vRoof1 = vFootprint1 + 1;\n        if (boundaryWalls !== false || contourEdges === undefined) {\n            indexBuffer.push(vFootprint0, vRoof0, vRoof1, vRoof1, vFootprint1, vFootprint0);\n        }\n        else if (contourEdges[i]) {\n            indexBuffer.push(vFootprint0, vRoof0, vRoof1, vRoof1, vFootprint1, vFootprint0);\n        }\n    }\n}\nexports.addExtrudedWalls = addExtrudedWalls;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Extruder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\nconst Env_1 = __webpack_require__(/*! ./Env */ \"./node_modules/@here/harp-datasource-protocol/lib/Env.js\");\nconst ExponentialInterpolant_1 = __webpack_require__(/*! ./ExponentialInterpolant */ \"./node_modules/@here/harp-datasource-protocol/lib/ExponentialInterpolant.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js\");\nconst StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"InterpolatedProperty\");\nconst interpolants = [\n    THREE.DiscreteInterpolant,\n    THREE.LinearInterpolant,\n    THREE.CubicInterpolant,\n    ExponentialInterpolant_1.ExponentialInterpolant\n];\nconst tmpBuffer = new Array(StringEncodedNumeral_1.StringEncodedNumeralFormatMaxSize);\n/**\n * Checks if a property is interpolated.\n * @param p property to be checked\n */\nfunction isInterpolatedPropertyDefinition(p) {\n    if (p &&\n        p.interpolationMode === undefined &&\n        Array.isArray(p.values) &&\n        p.values.length > 0 &&\n        p.values[0] !== undefined &&\n        Array.isArray(p.zoomLevels) &&\n        p.zoomLevels.length > 0 &&\n        p.zoomLevels[0] !== undefined &&\n        p.values.length === p.zoomLevels.length) {\n        return true;\n    }\n    return false;\n}\nexports.isInterpolatedPropertyDefinition = isInterpolatedPropertyDefinition;\n/**\n * Type guard to check if an object is an instance of `InterpolatedProperty`.\n */\nfunction isInterpolatedProperty(p) {\n    if (p &&\n        p.interpolationMode !== undefined &&\n        p.zoomLevels instanceof Float32Array &&\n        p.values !== undefined &&\n        p.values.length > 0 &&\n        (p.zoomLevels.length === p.values.length / 4 ||\n            p.zoomLevels.length === p.values.length / 3 ||\n            p.zoomLevels.length === p.values.length)) {\n        return true;\n    }\n    return false;\n}\nexports.isInterpolatedProperty = isInterpolatedProperty;\n/**\n * A temp [[Env]] containing the arguments passed to `getPropertyValue`.\n *\n * [[dynamicPropertiesTempEnv]] is used when `getPropertyValue` is\n * invoked with explicit values for `zoom` and `pixelToMeters` instead\n * of with an [[Env]].\n *\n * @hidden\n */\nconst dynamicPropertiesTempEnv = new Env_1.MapEnv({\n    $zoom: 0,\n    $pixelToMeters: 1\n});\nfunction getPropertyValue(property, envOrLevel, pixelToMeters = 1.0) {\n    if (Expr_1.Expr.isExpr(property)) {\n        let env;\n        if (typeof envOrLevel === \"number\") {\n            dynamicPropertiesTempEnv.entries.$zoom = envOrLevel;\n            dynamicPropertiesTempEnv.entries.$pixelToMeters = pixelToMeters;\n            env = dynamicPropertiesTempEnv;\n        }\n        else {\n            env = envOrLevel;\n        }\n        return property.evaluate(env, Expr_1.ExprScope.Dynamic);\n    }\n    let level;\n    if (typeof envOrLevel === \"number\") {\n        level = envOrLevel;\n    }\n    else {\n        level = envOrLevel.lookup(\"$zoom\");\n        pixelToMeters = envOrLevel.lookup(\"$pixelToMeters\");\n    }\n    // Non-interpolated property parsing\n    if (!isInterpolatedProperty(property)) {\n        if (typeof property !== \"string\") {\n            // Property in numeric or array, etc. format\n            return property;\n        }\n        else {\n            const value = StringEncodedNumeral_1.parseStringEncodedNumeral(property, pixelToMeters);\n            return value !== undefined ? value : property;\n        }\n        // Interpolated property\n    }\n    else if (property._stringEncodedNumeralType !== undefined) {\n        switch (property._stringEncodedNumeralType) {\n            case StringEncodedNumeral_1.StringEncodedNumeralType.Meters:\n            case StringEncodedNumeral_1.StringEncodedNumeralType.Pixels:\n                return getInterpolatedMetric(property, level, pixelToMeters);\n            case StringEncodedNumeral_1.StringEncodedNumeralType.Hex:\n            case StringEncodedNumeral_1.StringEncodedNumeralType.RGB:\n            case StringEncodedNumeral_1.StringEncodedNumeralType.RGBA:\n            case StringEncodedNumeral_1.StringEncodedNumeralType.HSL:\n                return getInterpolatedColor(property, level);\n        }\n    }\n    return getInterpolatedMetric(property, level, pixelToMeters);\n}\nexports.getPropertyValue = getPropertyValue;\nfunction getInterpolatedMetric(property, level, pixelToMeters) {\n    const nChannels = property.values.length / property.zoomLevels.length;\n    const interpolant = new interpolants[property.interpolationMode](property.zoomLevels, property.values, nChannels);\n    if (property.interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Exponential &&\n        property.exponent !== undefined) {\n        interpolant.exponent = property.exponent;\n    }\n    interpolant.evaluate(level);\n    if (property._stringEncodedNumeralDynamicMask === undefined) {\n        return interpolant.resultBuffer[0];\n    }\n    else {\n        const maskInterpolant = new interpolants[property.interpolationMode](property.zoomLevels, property._stringEncodedNumeralDynamicMask, 1);\n        if (property.interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Exponential &&\n            property.exponent !== undefined) {\n            maskInterpolant.exponent = property.exponent;\n        }\n        maskInterpolant.evaluate(level);\n        return (interpolant.resultBuffer[0] *\n            (1 + maskInterpolant.resultBuffer[0] * (pixelToMeters - 1)));\n    }\n}\nfunction getInterpolatedColor(property, level) {\n    const nChannels = property.values.length / property.zoomLevels.length;\n    const interpolant = new interpolants[property.interpolationMode](property.zoomLevels, property.values, nChannels);\n    if (property.interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Exponential &&\n        property.exponent !== undefined) {\n        interpolant.exponent = property.exponent;\n    }\n    interpolant.evaluate(level);\n    harp_utils_1.assert(nChannels === 3 || nChannels === 4);\n    // ColorUtils.getHexFromRgba() does not clamp the values which may be out of\n    // color channels range (0 <= c <= 1) after interpolation.\n    if (nChannels === 4) {\n        return ColorUtils_1.ColorUtils.getHexFromRgba(THREE.Math.clamp(interpolant.resultBuffer[0], 0, 1), THREE.Math.clamp(interpolant.resultBuffer[1], 0, 1), THREE.Math.clamp(interpolant.resultBuffer[2], 0, 1), THREE.Math.clamp(interpolant.resultBuffer[3], 0, 1));\n    }\n    else {\n        return ColorUtils_1.ColorUtils.getHexFromRgb(THREE.Math.clamp(interpolant.resultBuffer[0], 0, 1), THREE.Math.clamp(interpolant.resultBuffer[1], 0, 1), THREE.Math.clamp(interpolant.resultBuffer[2], 0, 1));\n    }\n}\n/**\n * Convert JSON representation of interpolated property to internal, normalized version that\n * can be evaluated by [[getPropertyValue]].\n */\nfunction createInterpolatedProperty(prop) {\n    removeDuplicatePropertyValues(prop);\n    const interpolationMode = prop.interpolation !== undefined\n        ? InterpolatedPropertyDefs_1.InterpolationMode[prop.interpolation]\n        : InterpolatedPropertyDefs_1.InterpolationMode.Discrete;\n    const zoomLevels = new Float32Array(prop.zoomLevels);\n    const firstValue = prop.values[0];\n    switch (typeof firstValue) {\n        default:\n        case \"number\":\n        case \"boolean\":\n            return {\n                interpolationMode,\n                zoomLevels,\n                values: new Float32Array(prop.values),\n                exponent: prop.exponent\n            };\n        case \"string\":\n            // TODO: Minimize effort for pre-matching the numeral format.\n            const matchedFormat = StringEncodedNumeral_1.StringEncodedNumeralFormats.find(format => format.regExp.test(firstValue));\n            if (matchedFormat === undefined) {\n                if (interpolationMode === InterpolatedPropertyDefs_1.InterpolationMode.Discrete) {\n                    return {\n                        interpolationMode,\n                        zoomLevels,\n                        values: prop.values\n                    };\n                }\n                logger.error(`No StringEncodedNumeralFormat matched ${firstValue}.`);\n                return undefined;\n            }\n            let needsMask = false;\n            const propValues = new Float32Array(prop.values.length * matchedFormat.size);\n            const maskValues = new Float32Array(prop.values.length);\n            needsMask = procesStringEnocodedNumeralInterpolatedProperty(matchedFormat, prop, propValues, maskValues);\n            return {\n                interpolationMode,\n                zoomLevels,\n                values: propValues,\n                exponent: prop.exponent,\n                _stringEncodedNumeralType: matchedFormat.type,\n                _stringEncodedNumeralDynamicMask: needsMask ? maskValues : undefined\n            };\n    }\n}\nexports.createInterpolatedProperty = createInterpolatedProperty;\nfunction removeDuplicatePropertyValues(p) {\n    const eps = 0.001;\n    // detect cubic interpolations and remove stops\n    // closer than `eps`, this is needed to avoid\n    // possible NaN generated by the cubic interpolator.\n    const isCubic = p.interpolation === \"Cubic\";\n    for (let i = 0; i < p.values.length; ++i) {\n        const firstIdx = p.zoomLevels.findIndex(a => {\n            return isCubic ? Math.abs(a - p.zoomLevels[i]) < eps : a === p.zoomLevels[i];\n        });\n        if (firstIdx !== i) {\n            p.zoomLevels.splice(--i, 1);\n            p.values.splice(--i, 1);\n        }\n    }\n}\nfunction procesStringEnocodedNumeralInterpolatedProperty(baseFormat, prop, propValues, maskValues) {\n    let needsMask = false;\n    const allowedValueFormats = baseFormat.type === StringEncodedNumeral_1.StringEncodedNumeralType.Meters ||\n        baseFormat.type === StringEncodedNumeral_1.StringEncodedNumeralType.Pixels\n        ? StringEncodedNumeral_1.StringEncodedMetricFormats\n        : StringEncodedNumeral_1.StringEncodedColorFormats;\n    for (let valueIdx = 0; valueIdx < prop.values.length; ++valueIdx) {\n        let matched = false;\n        for (const valueFormat of allowedValueFormats) {\n            const value = prop.values[valueIdx];\n            matched = valueFormat.decoder(value, tmpBuffer);\n            if (!matched) {\n                continue;\n            }\n            if (valueFormat.mask !== undefined) {\n                maskValues[valueIdx] = valueFormat.mask;\n                needsMask = true;\n            }\n            for (let i = 0; i < valueFormat.size; ++i) {\n                propValues[valueIdx * valueFormat.size + i] = tmpBuffer[i];\n            }\n            break;\n        }\n        if (!matched) {\n            throw Error(`Not all interpolation values match the same format: ${JSON.stringify(prop)}`);\n        }\n    }\n    return needsMask;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.\n */\nvar InterpolationMode;\n(function (InterpolationMode) {\n    InterpolationMode[InterpolationMode[\"Discrete\"] = 0] = \"Discrete\";\n    InterpolationMode[InterpolationMode[\"Linear\"] = 1] = \"Linear\";\n    InterpolationMode[InterpolationMode[\"Cubic\"] = 2] = \"Cubic\";\n    InterpolationMode[InterpolationMode[\"Exponential\"] = 3] = \"Exponential\";\n})(InterpolationMode = exports.InterpolationMode || (exports.InterpolationMode = {}));\n/**\n * Converts an [[InterpolatedPropertyDefinition]] to a [[JsonExpr]].\n *\n * @param property A valid [[InterpolatedPropertyDefinition]]\n */\nfunction interpolatedPropertyDefinitionToJsonExpr(property) {\n    if (property.interpolation === undefined || property.interpolation === \"Discrete\") {\n        const step = [\"step\", [\"zoom\"], property.values[0]];\n        for (let i = 1; i < property.zoomLevels.length; ++i) {\n            step.push(property.zoomLevels[i], property.values[i]);\n        }\n        return step;\n    }\n    const interpolation = [\"interpolate\"];\n    switch (property.interpolation) {\n        case \"Linear\":\n            interpolation.push([\"linear\"]);\n            break;\n        case \"Cubic\":\n            interpolation.push([\"cubic\"]);\n            break;\n        case \"Exponential\":\n            interpolation.push([\n                \"exponential\",\n                property.exponent !== undefined ? property.exponent : 2\n            ]);\n            break;\n        default:\n            throw new Error(`interpolation mode '${property.interpolation}' is not supported`);\n    } //switch\n    interpolation.push([\"zoom\"]);\n    for (let i = 0; i < property.zoomLevels.length; ++i) {\n        interpolation.push(property.zoomLevels[i], property.values[i]);\n    }\n    return interpolation;\n}\nexports.interpolatedPropertyDefinitionToJsonExpr = interpolatedPropertyDefinitionToJsonExpr;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Outliner.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Outliner.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst currEdgeStart = new THREE.Vector2();\nconst currEdgeGoal = new THREE.Vector2();\nconst prevEdgeStart = new THREE.Vector2();\nconst prevEdgeGoal = new THREE.Vector2();\n/**\n * Fills an index buffer with the indices for the edges of a polygon contour.\n *\n * @param indexBuffer Edge index buffer to be filled.\n * @param vertexOffset Starting offset of the vertices composing the contour.\n * @param vertexStride Number of elements per contour vertex.\n * @param polygonContour Vertices that compose the contour.\n * @param polygonContourEdges Collection of booleans indicating if contour edges should be added.\n */\nfunction addPolygonEdges(indexBuffer, vertexOffset, vertexStride, polygonContour, polygonContourEdges, isExtruded, addFootprintEdges, wallEdgeSlope) {\n    for (let i = 0; i < polygonContourEdges.length; ++i) {\n        if (polygonContourEdges[i]) {\n            if (isExtruded === true) {\n                const vFootprint0 = vertexOffset + i * 2;\n                const vRoof0 = vFootprint0 + 1;\n                const vFootprint1 = vertexOffset + ((i + 1) % polygonContourEdges.length) * 2;\n                const vRoof1 = vFootprint1 + 1;\n                if (addFootprintEdges === true) {\n                    indexBuffer.push(vFootprint0, vFootprint1);\n                }\n                indexBuffer.push(vRoof0, vRoof1);\n                const prevEdgeIdx = (i === 0 ? polygonContourEdges.length : i) - 1;\n                if (polygonContourEdges[prevEdgeIdx]) {\n                    if (wallEdgeSlope !== undefined) {\n                        const v0x = polygonContour[i * vertexStride];\n                        const v0y = polygonContour[i * vertexStride + 1];\n                        const v1x = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride];\n                        const v1y = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride + 1];\n                        currEdgeStart.set(v0x, v0y);\n                        currEdgeGoal.set(v1x, v1y);\n                        prevEdgeStart.set(polygonContour[prevEdgeIdx * vertexStride], polygonContour[prevEdgeIdx * vertexStride + 1]);\n                        prevEdgeGoal.set(currEdgeStart.x, currEdgeStart.y);\n                        if (prevEdgeGoal\n                            .sub(prevEdgeStart)\n                            .normalize()\n                            .dot(currEdgeGoal.sub(currEdgeStart).normalize()) <= wallEdgeSlope) {\n                            indexBuffer.push(vFootprint0, vRoof0);\n                        }\n                    }\n                    else {\n                        indexBuffer.push(vFootprint0, vRoof0);\n                    }\n                }\n            }\n            else {\n                const vFoot0 = vertexOffset + i;\n                const vRoof0 = vertexOffset + ((i + 1) % polygonContourEdges.length);\n                indexBuffer.push(vFoot0, vRoof0);\n            }\n        }\n    }\n}\nexports.addPolygonEdges = addPolygonEdges;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Outliner.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\nconst tmpColor = new three_1.Color();\n/**\n * Enumeration of supported string encoded numerals.\n */\nvar StringEncodedNumeralType;\n(function (StringEncodedNumeralType) {\n    StringEncodedNumeralType[StringEncodedNumeralType[\"Meters\"] = 0] = \"Meters\";\n    StringEncodedNumeralType[StringEncodedNumeralType[\"Pixels\"] = 1] = \"Pixels\";\n    StringEncodedNumeralType[StringEncodedNumeralType[\"Hex\"] = 2] = \"Hex\";\n    StringEncodedNumeralType[StringEncodedNumeralType[\"RGB\"] = 3] = \"RGB\";\n    StringEncodedNumeralType[StringEncodedNumeralType[\"RGBA\"] = 4] = \"RGBA\";\n    StringEncodedNumeralType[StringEncodedNumeralType[\"HSL\"] = 5] = \"HSL\";\n})(StringEncodedNumeralType = exports.StringEncodedNumeralType || (exports.StringEncodedNumeralType = {}));\nconst StringEncodedMeters = {\n    type: StringEncodedNumeralType.Meters,\n    size: 1,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))m$/,\n    decoder: (encodedValue, target) => {\n        const match = StringEncodedMeters.regExp.exec(encodedValue);\n        return match ? (target[0] = Number(match[1])) !== undefined : false;\n    }\n};\nconst StringEncodedPixels = {\n    type: StringEncodedNumeralType.Pixels,\n    size: 1,\n    mask: 1.0,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))px$/,\n    decoder: (encodedValue, target) => {\n        const match = StringEncodedPixels.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        target[0] = Number(match[1]);\n        return true;\n    }\n};\nconst StringEncodedHex = {\n    type: StringEncodedNumeralType.Hex,\n    size: 4,\n    regExp: /^\\#((?:[0-9A-Fa-f][0-9A-Fa-f]){3,4}|[0-9A-Fa-f]{3,4})$/,\n    decoder: (encodedValue, target) => {\n        const match = StringEncodedHex.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        const hex = match[1];\n        const size = hex.length;\n        // Only few sizes are possible for given reg-exp.\n        harp_utils_1.assert(size === 3 || size === 4 || size === 6 || size === 8, `Matched incorrect hex format: ${encodedValue}`);\n        // Note that we simply ignore alpha channel value.\n        // TODO: To be resolved with HARP-7517\n        if (size === 3 || size === 4) {\n            // #RGB or #RGBA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;\n        }\n        else if (size === 6 || size === 8) {\n            // #RRGGBB or #RRGGBBAA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;\n        }\n        return true;\n    }\n};\nconst StringEncodedRGB = {\n    type: StringEncodedNumeralType.RGB,\n    size: 3,\n    // tslint:disable-next-line:max-line-length\n    regExp: /^rgb\\( ?(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5])) ?\\)$/,\n    decoder: (encodedValue, target) => {\n        const channels = StringEncodedRGB.regExp.exec(encodedValue);\n        if (channels === null) {\n            return false;\n        }\n        target[0] = parseInt(channels[1], 10) / 255;\n        target[1] = parseInt(channels[2], 10) / 255;\n        target[2] = parseInt(channels[3], 10) / 255;\n        return true;\n    }\n};\nconst StringEncodedRGBA = {\n    type: StringEncodedNumeralType.RGBA,\n    size: 4,\n    // tslint:disable-next-line:max-line-length\n    regExp: /^rgba\\( ?(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:(0(?:\\.[0-9]+)?|1(?:\\.0+)?)) ?\\)$/,\n    decoder: (encodedValue, target) => {\n        const channels = StringEncodedRGBA.regExp.exec(encodedValue);\n        if (channels === null) {\n            return false;\n        }\n        target[0] = parseInt(channels[1], 10) / 255;\n        target[1] = parseInt(channels[2], 10) / 255;\n        target[2] = parseInt(channels[3], 10) / 255;\n        target[3] = parseFloat(channels[4]);\n        return true;\n    }\n};\nconst StringEncodedHSL = {\n    type: StringEncodedNumeralType.HSL,\n    size: 3,\n    // tslint:disable-next-line:max-line-length\n    regExp: /^hsl\\( ?((?:[0-9]|[1-9][0-9]|1[0-9]{1,2}|2[0-9]{1,2}|3[0-5][0-9]|360)), ?(?:([0-9]|[1-9][0-9]|100)%), ?(?:([0-9]|[1-9][0-9]|100)%) ?\\)$/,\n    decoder: (encodedValue, target) => {\n        const channels = StringEncodedHSL.regExp.exec(encodedValue);\n        if (channels === null) {\n            return false;\n        }\n        tmpColor.setHSL(parseInt(channels[1], 10) / 360, parseInt(channels[2], 10) / 100, parseInt(channels[3], 10) / 100);\n        target[0] = tmpColor.r;\n        target[1] = tmpColor.g;\n        target[2] = tmpColor.b;\n        return true;\n    }\n};\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing sizes, lengths and distances.\n */\nexports.StringEncodedMetricFormats = [\n    StringEncodedMeters,\n    StringEncodedPixels\n];\nconst StringEncodedMetricFormatMaxSize = exports.StringEncodedMetricFormats.reduce((a, b) => Math.max(a, b.size), 0);\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing color data.\n */\nexports.StringEncodedColorFormats = [\n    StringEncodedHex,\n    StringEncodedRGB,\n    StringEncodedRGBA,\n    StringEncodedHSL\n];\nconst StringEncodedColorFormatMaxSize = exports.StringEncodedColorFormats.reduce((a, b) => Math.max(a, b.size), 0);\n/**\n * Array of supported [[StringEncodedNumeralFormat]]s (intended to be indexed with\n * [[StringEncodedNumeralType]] enum).\n */\nexports.StringEncodedNumeralFormats = [\n    ...exports.StringEncodedMetricFormats,\n    ...exports.StringEncodedColorFormats\n];\nexports.StringEncodedNumeralFormatMaxSize = Math.max(StringEncodedColorFormatMaxSize, StringEncodedMetricFormatMaxSize);\nconst tmpBuffer = new Array(exports.StringEncodedNumeralFormatMaxSize);\n/**\n * Parse string encoded numeral values using all known [[StringEncodedNumeralFormats]].\n *\n * @param numeral The string representing numeric value.\n * @param pixelToMeters The ratio used to convert from meters to pixels (default 1.0).\n * @returns Number parsed or __undefined__ if non of the numeral patterns matches the expression\n * provided in [[numeral]].\n */\nfunction parseStringEncodedNumeral(numeral, pixelToMeters = 1.0) {\n    let result;\n    const formatMatch = (format) => {\n        if (format.decoder(numeral, tmpBuffer)) {\n            switch (format.type) {\n                case StringEncodedNumeralType.Meters:\n                    result = tmpBuffer[0];\n                    break;\n                case StringEncodedNumeralType.Pixels:\n                    result = tmpBuffer[0] * pixelToMeters;\n                    break;\n                case StringEncodedNumeralType.Hex:\n                case StringEncodedNumeralType.RGBA:\n                    result = ColorUtils_1.ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);\n                    break;\n                case StringEncodedNumeralType.RGB:\n                case StringEncodedNumeralType.HSL:\n                    result = ColorUtils_1.ColorUtils.getHexFromRgb(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2]);\n                    break;\n                default:\n                    result = tmpBuffer[0];\n                    break;\n            }\n            return true;\n        }\n        return false;\n    };\n    exports.StringEncodedNumeralFormats.some(formatMatch);\n    return result;\n}\nexports.parseStringEncodedNumeral = parseStringEncodedNumeral;\n/**\n * Parse string encoded color value using all known [[StringEncodedColorFormats]].\n *\n * @param color The string encoded color expression (i.e. '#FFF', 'rgb(255, 0, 0)', etc.).\n * @returns The color parsed or __undefined__ if non of the known representations matches\n * the expression provided in [[color]].\n */\nfunction parseStringEncodedColor(color) {\n    const matchedFormat = matchFormat(exports.StringEncodedColorFormats, color, tmpBuffer);\n    if (matchedFormat === undefined) {\n        return undefined;\n    }\n    switch (matchedFormat.type) {\n        case StringEncodedNumeralType.Hex:\n        case StringEncodedNumeralType.RGBA:\n            return ColorUtils_1.ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);\n        case StringEncodedNumeralType.RGB:\n        case StringEncodedNumeralType.HSL:\n            return ColorUtils_1.ColorUtils.getHexFromRgb(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2]);\n        default:\n            return tmpBuffer[0];\n    }\n}\nexports.parseStringEncodedColor = parseStringEncodedColor;\nfunction matchFormat(formats, numeral, result) {\n    return formats.find(format => {\n        return format.decoder(numeral, result) ? true : false;\n    });\n}\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst ExprPool_1 = __webpack_require__(/*! ./ExprPool */ \"./node_modules/@here/harp-datasource-protocol/lib/ExprPool.js\");\nconst InterpolatedProperty_1 = __webpack_require__(/*! ./InterpolatedProperty */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js\");\nconst InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.js\");\nconst TechniqueDescriptor_1 = __webpack_require__(/*! ./TechniqueDescriptor */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptor.js\");\nconst Techniques_1 = __webpack_require__(/*! ./Techniques */ \"./node_modules/@here/harp-datasource-protocol/lib/Techniques.js\");\nconst Theme_1 = __webpack_require__(/*! ./Theme */ \"./node_modules/@here/harp-datasource-protocol/lib/Theme.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"StyleSetEvaluator\");\nconst emptyTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor({});\n/**\n * [[StyleConditionClassifier]] searches for usages of `$layer` in `when` conditions\n * associated with styling rules.\n *\n * @hidden\n */\nclass StyleConditionClassifier {\n    classify(style) {\n        if (style._whenExpr) {\n            const savedStyle = this.switchStyle(style);\n            style._whenExpr = style._whenExpr.accept(this, undefined);\n            this._style = savedStyle;\n        }\n    }\n    visitNullLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitBooleanLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitNumberLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitStringLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitObjectLiteralExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitVarExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitHasAttributeExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitContainsExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitMatchExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitCaseExpr(expr, enclosingExpr) {\n        return expr;\n    }\n    visitCallExpr(call, enclosingExpr) {\n        if (call.op === \"all\") {\n            // processing of an `[\"all\", e1, e2, ... eN]` expression. In this case\n            // search for expressions matching comparison of `$layer` and string literals\n            // in the sub expressions.\n            const children = call.args\n                .map(childExpr => childExpr.accept(this, call))\n                .filter(childExpr => childExpr !== undefined);\n            return new Expr_1.CallExpr(call.op, children);\n        }\n        else if (enclosingExpr) {\n            // `call` is a direct child expression of an `\"all\"` operator.\n            const matched = this.matchVarStringComparison(call);\n            if (matched) {\n                if (this._style.layer === undefined && matched.name === \"$layer\") {\n                    // found a subexpression `[\"==\", [\"get\", \"$layer\"], \"some layer name\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $layer in\n                    // [[StyleInternalParams]].\n                    this._style.layer = matched.value;\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                }\n                else if (this._style._geometryType === undefined &&\n                    matched.name === \"$geometryType\") {\n                    // found a subexpression `[\"==\", [\"get\", \"$geometryType\"], \"geometry\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $geometryType in\n                    // [[StyleInternalParams]].\n                    this._style._geometryType = matched.value;\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                }\n            }\n        }\n        return call;\n    }\n    /**\n     * Tests if the given `call` matches the structure [\"==\", [\"get\", name], value].\n     * If a match is found returns an object containing the `name` and the `value`;\n     *\n     * @param call The expression to match.\n     */\n    matchVarStringComparison(call) {\n        if (call.op === \"==\") {\n            const left = call.args[0];\n            const right = call.args[1];\n            if (left instanceof Expr_1.VarExpr && right instanceof Expr_1.StringLiteralExpr) {\n                return { name: left.name, value: right.value };\n            }\n            if (right instanceof Expr_1.VarExpr && left instanceof Expr_1.StringLiteralExpr) {\n                return { name: right.name, value: left.value };\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Sets the given `style` as current.\n     *\n     * @returns The previous `style`.\n     */\n    switchStyle(style) {\n        const saved = this._style;\n        this._style = style;\n        return saved;\n    }\n}\nclass OptimizedSubSetKey {\n    constructor(layer, geometryType) {\n        this.key = \"\";\n        this.set(layer, geometryType);\n    }\n    set(layer, geometryType, env) {\n        let keyUpdateNeeded = false;\n        if (layer === undefined) {\n            const envLayer = env !== undefined ? env.lookup(\"$layer\") : undefined;\n            layer = typeof envLayer === \"string\" ? envLayer : undefined;\n        }\n        if (this.layer !== layer) {\n            this.layer = layer;\n            keyUpdateNeeded = true;\n        }\n        if (geometryType === undefined) {\n            const envGeometryType = env !== undefined ? env.lookup(\"$geometryType\") : undefined;\n            geometryType = typeof envGeometryType === \"string\" ? envGeometryType : undefined;\n        }\n        if (this.geometryType !== geometryType) {\n            this.geometryType = geometryType;\n            keyUpdateNeeded = true;\n        }\n        if (keyUpdateNeeded) {\n            this.updateKey();\n        }\n        return this;\n    }\n    updateKey() {\n        if (this.layer !== undefined) {\n            // tslint:disable-next-line:prefer-conditional-expression\n            if (this.geometryType !== undefined) {\n                this.key = `${this.layer}:${this.geometryType}`;\n            }\n            else {\n                this.key = `${this.layer}:`;\n            }\n        }\n        else {\n            if (this.geometryType !== undefined) {\n                this.key = `:${this.geometryType}`;\n            }\n            else {\n                this.key = \"all\";\n            }\n        }\n        this.cachedStyleSet = undefined;\n    }\n}\n/**\n * Combine data from datasource and apply the rules from a specified theme to show it on the map.\n */\nclass StyleSetEvaluator {\n    constructor(styleSet, definitions) {\n        this.m_techniques = [];\n        this.m_exprPool = new ExprPool_1.ExprPool();\n        this.m_cachedResults = new Map();\n        this.m_styleConditionClassifier = new StyleConditionClassifier();\n        this.m_subStyleSetCache = new Map();\n        this.m_definitionExprCache = new Map();\n        this.m_tmpOptimizedSubSetKey = new OptimizedSubSetKey();\n        this.m_emptyEnv = new Expr_1.Env();\n        this.m_definitions = definitions;\n        this.styleSet = resolveReferences(styleSet, definitions);\n        computeDefaultRenderOrder(this.styleSet);\n        this.compileStyleSet();\n    }\n    /**\n     * Find all techniques that fit the current objects' environment.\n     * *The techniques in the resulting array may not be modified* since they are being reused for\n     * identical objects.\n     *\n     * @param env The objects environment, i.e. the attributes that are relevant for its\n     * representation.\n     * @param layer The optional layer name used to filter techniques.\n     * @param geometryType The optional geometryType used to filter techniques.\n     */\n    getMatchingTechniques(env, layer, geometryType) {\n        const result = [];\n        this.m_cachedResults.clear();\n        const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;\n        optimizedSubSetKey.set(layer, geometryType, env);\n        // get the requested $layer and $geometryType, if any.\n        this.m_layer = optimizedSubSetKey.layer;\n        this.m_geometryType = optimizedSubSetKey.geometryType;\n        this.m_zoomLevel = env.lookup(\"$zoom\");\n        const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);\n        for (const currStyle of searchedStyleSet) {\n            if (this.processStyle(env, currStyle, result)) {\n                break;\n            }\n        }\n        return result;\n    }\n    /**\n     * Check if `styleSet` contains any rule related to `layer`.\n     *\n     * @param layer name of layer\n     */\n    wantsLayer(layer) {\n        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, undefined)).length > 0);\n    }\n    /**\n     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.\n     *\n     * @param layer name of layer\n     * @param geometryType type of layer - `point`, `line` or `polygon`\n     */\n    wantsFeature(layer, geometryType) {\n        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType))\n            .length > 0);\n    }\n    /**\n     * Get the expression evaluation cache, for further feature processing.\n     *\n     * This object is valid until next `getMatchingTechniques` call.\n     */\n    get expressionEvaluatorCache() {\n        return this.m_cachedResults;\n    }\n    /**\n     * Reset array of techniques.\n     *\n     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.\n     */\n    resetTechniques() {\n        for (const techinque of this.m_techniques) {\n            techinque._index = undefined;\n        }\n        this.m_techniques.length = 0;\n    }\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get techniques() {\n        return this.m_techniques;\n    }\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get decodedTechniques() {\n        return this.m_techniques.map(makeDecodedTechnique);\n    }\n    getOptimizedStyleSet(subSetKey) {\n        if (subSetKey.cachedStyleSet !== undefined) {\n            return subSetKey.cachedStyleSet;\n        }\n        let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);\n        if (optimizedStyleSet !== undefined) {\n            subSetKey.cachedStyleSet = optimizedStyleSet;\n            return optimizedStyleSet;\n        }\n        optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);\n        this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);\n        subSetKey.cachedStyleSet = optimizedStyleSet;\n        return optimizedStyleSet;\n    }\n    createPreFilteredStyleSet(subSetKey) {\n        const { layer, geometryType } = subSetKey;\n        return this.styleSet.filter(style => {\n            if (layer !== undefined && style.layer !== undefined && style.layer !== layer) {\n                return false;\n            }\n            if (geometryType !== undefined &&\n                style._geometryType !== undefined &&\n                style._geometryType !== geometryType) {\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * Compile the `when` conditions found when traversting the styling rules.\n     */\n    compileStyleSet() {\n        this.styleSet.forEach(style => this.compileStyle(style));\n        // Create optimized styleSets for each `layer` & `geometryType` tuple.\n        this.styleSet.forEach(style => {\n            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType));\n        });\n    }\n    /**\n     * Compile the `when` conditions reachable from the given `style`.\n     *\n     * @param style The current style.\n     */\n    compileStyle(style) {\n        if (style.when !== undefined) {\n            try {\n                style._whenExpr = Array.isArray(style.when)\n                    ? Expr_1.Expr.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache)\n                    : Expr_1.Expr.parse(style.when);\n                // search for usages of '$layer' and any other\n                // special symbol that can be used to speed up the evaluation\n                // of the `when` conditions associated to this `style`.\n                this.m_styleConditionClassifier.classify(style);\n                if (style._whenExpr !== undefined) {\n                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);\n                }\n                if (Expr_1.isJsonExpr(style.minZoomLevel)) {\n                    style._minZoomLevelExpr = Expr_1.Expr.fromJSON(style.minZoomLevel).intern(this.m_exprPool);\n                }\n                if (Expr_1.isJsonExpr(style.maxZoomLevel)) {\n                    style._maxZoomLevelExpr = Expr_1.Expr.fromJSON(style.maxZoomLevel).intern(this.m_exprPool);\n                }\n            }\n            catch (err) {\n                logger.log(\"failed to evaluate expression\", JSON.stringify(style.when), \"error\", String(err));\n            }\n        }\n    }\n    /**\n     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the\n     * current objects' environment. The attributes of the styles are assembled to create a unique\n     * technique for every object.\n     *\n     * @param env The objects environment, i.e. the attributes that are relevant for its\n     *            representation.\n     * @param style Current style (could also be top of stack).\n     * @param result The array of resulting techniques. There may be more than one technique per\n     *               object, resulting in multiple graphical objects for representation.\n     * @returns `true` if style has been found and processing is finished. `false` if not found, or\n     *          more than one technique should be applied.\n     */\n    processStyle(env, style, result) {\n        if (!this.checkZoomLevel(env, style)) {\n            return false;\n        }\n        if (this.m_layer !== undefined &&\n            style.layer !== undefined &&\n            style.layer !== this.m_layer) {\n            return false;\n        }\n        if (this.m_geometryType !== undefined &&\n            style._geometryType !== undefined &&\n            style._geometryType !== this.m_geometryType) {\n            return false;\n        }\n        if (style._whenExpr) {\n            try {\n                if (!style._whenExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults)) {\n                    // Stop processing this styling rule. The `when` condition\n                    // associated with the current `style` evaluates to false so\n                    // no techinque defined by this style should be applied.\n                    return false;\n                }\n            }\n            catch (error) {\n                logger.error(`failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`);\n                return false;\n            }\n        }\n        if (style.technique === undefined) {\n            return false;\n        }\n        // we found a technique!\n        if (style.technique !== \"none\") {\n            result.push(this.getTechniqueForStyleMatch(env, style));\n        }\n        // stop processing if \"final\" is set\n        return style.final === true;\n    }\n    checkZoomLevel(env, style) {\n        if (style.minZoomLevel === undefined && style.maxZoomLevel === undefined) {\n            return true;\n        }\n        const zoomLevel = this.m_zoomLevel;\n        if (zoomLevel === undefined) {\n            return true;\n        }\n        if (style.minZoomLevel !== undefined) {\n            let minZoomLevel = style.minZoomLevel;\n            if (style._minZoomLevelExpr) {\n                // the constraint is defined as expression, evaluate it and\n                // use its value\n                try {\n                    minZoomLevel = style._minZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);\n                }\n                catch (error) {\n                    logger.error(`failed to evaluate expression '${JSON.stringify(style._minZoomLevelExpr)}': ${error}`);\n                }\n            }\n            if (typeof minZoomLevel === \"number\" && zoomLevel < minZoomLevel) {\n                return false;\n            }\n        }\n        if (style.maxZoomLevel !== undefined) {\n            let maxZoomLevel = style.maxZoomLevel;\n            if (style._maxZoomLevelExpr) {\n                try {\n                    maxZoomLevel = style._maxZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);\n                }\n                catch (error) {\n                    logger.error(`failed to evaluate expression '${JSON.stringify(style._maxZoomLevelExpr)}': ${error}`);\n                }\n            }\n            if (typeof maxZoomLevel === \"number\" && zoomLevel > maxZoomLevel) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getTechniqueForStyleMatch(env, style) {\n        this.checkStyleDynamicAttributes(style);\n        let technique;\n        if (style._dynamicTechniques !== undefined) {\n            const dynamicAttributes = this.evaluateTechniqueProperties(style, env);\n            const key = this.getDynamicTechniqueKey(style, dynamicAttributes);\n            technique = style._dynamicTechniques.get(key);\n            if (technique === undefined) {\n                technique = this.createTechnique(style, key, dynamicAttributes);\n                style._dynamicTechniques.set(key, technique);\n            }\n        }\n        else {\n            technique = style._staticTechnique;\n            if (technique === undefined) {\n                style._staticTechnique = technique = this.createTechnique(style, `${style._styleSetIndex}`, []);\n            }\n        }\n        if (technique._index === undefined) {\n            technique._index = this.m_techniques.length;\n            this.m_techniques.push(technique);\n        }\n        return technique;\n    }\n    getDynamicTechniqueKey(style, dynamicAttributes) {\n        const dynamicAttrKey = dynamicAttributes\n            .map(([_attrName, attrValue]) => {\n            if (attrValue === undefined) {\n                return \"U\";\n            }\n            else {\n                return JSON.stringify(attrValue);\n            }\n        })\n            .join(\":\");\n        return `${style._styleSetIndex}:${dynamicAttrKey}`;\n    }\n    checkStyleDynamicAttributes(style) {\n        if (style._dynamicTechniqueAttributes !== undefined || style.technique === \"none\") {\n            return;\n        }\n        style._dynamicTechniqueAttributes = [];\n        style._dynamicFeatureAttributes = [];\n        style._dynamicForwardedAttributes = [];\n        style._staticAttributes = [];\n        const dynamicFeatureAttributes = style._dynamicFeatureAttributes;\n        const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;\n        const dynamicForwardedAttributes = style._dynamicForwardedAttributes;\n        const targetStaticAttributes = style._staticAttributes;\n        const techniqueDescriptor = Techniques_1.techniqueDescriptors[style.technique] || emptyTechniqueDescriptor;\n        const processAttribute = (attrName, attrValue) => {\n            if (attrValue === undefined) {\n                return;\n            }\n            if (Expr_1.isJsonExpr(attrValue)) {\n                attrValue = Expr_1.Expr.fromJSON(attrValue, this.m_definitions, this.m_definitionExprCache).intern(this.m_exprPool);\n            }\n            else if (InterpolatedProperty_1.isInterpolatedPropertyDefinition(attrValue)) {\n                // found a property using an object-like interpolation definition.\n                attrValue = Expr_1.Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(attrValue)).intern(this.m_exprPool);\n            }\n            if (Expr_1.Expr.isExpr(attrValue)) {\n                const deps = attrValue.dependencies();\n                if (!deps.zoom && deps.properties.size === 0) {\n                    // no data-dependencies detected.\n                    attrValue = attrValue.evaluate(this.m_emptyEnv);\n                }\n            }\n            if (Expr_1.Expr.isExpr(attrValue)) {\n                let attrScope = techniqueDescriptor.attrScopes[attrName];\n                if (attrScope === undefined) {\n                    // Use [[AttrScope.TechniqueGeometry]] as default scope for the attribute.\n                    attrScope = TechniqueDescriptor_1.AttrScope.TechniqueGeometry;\n                }\n                const deps = attrValue.dependencies();\n                switch (attrScope) {\n                    case TechniqueDescriptor_1.AttrScope.FeatureGeometry:\n                        dynamicFeatureAttributes.push([attrName, attrValue]);\n                        break;\n                    case TechniqueDescriptor_1.AttrScope.TechniqueGeometry:\n                        dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        break;\n                    case TechniqueDescriptor_1.AttrScope.TechniqueRendering:\n                        if (deps.properties.size === 0) {\n                            dynamicForwardedAttributes.push([attrName, attrValue]);\n                        }\n                        else {\n                            dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        }\n                        break;\n                }\n            }\n            else if (attrValue !== undefined && attrValue !== null) {\n                targetStaticAttributes.push([attrName, attrValue]);\n            }\n        };\n        processAttribute(\"renderOrder\", style.renderOrder);\n        // TODO: What the heck is that !?\n        processAttribute(\"label\", style.labelProperty);\n        // line & solid-line secondaryRenderOrder should be generic attr\n        // TODO: maybe just warn and force move it to `attr` ?\n        processAttribute(\"secondaryRenderOrder\", style.secondaryRenderOrder);\n        if (style.attr !== undefined) {\n            for (const attrName in style.attr) {\n                if (!style.attr.hasOwnProperty(attrName)) {\n                    continue;\n                }\n                processAttribute(attrName, style.attr[attrName]);\n            }\n        }\n        if (dynamicTechniqueAttributes.length > 0) {\n            style._dynamicTechniques = new Map();\n        }\n    }\n    evaluateTechniqueProperties(style, env) {\n        if (style._dynamicTechniqueAttributes === undefined) {\n            return [];\n        }\n        const instantiationContext = { env };\n        return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {\n            try {\n                if (attrExpr.isDynamic()) {\n                    const reducedExpr = attrExpr.instantiate(instantiationContext);\n                    return [attrName, reducedExpr];\n                }\n                const evaluatedValue = attrExpr.evaluate(env, Expr_1.ExprScope.Value, this.m_cachedResults);\n                return [attrName, evaluatedValue];\n            }\n            catch (error) {\n                logger.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);\n                return [attrName, null];\n            }\n        });\n    }\n    createTechnique(style, key, dynamicAttrs) {\n        const technique = {};\n        technique.name = style.technique;\n        if (style._staticAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._staticAttributes) {\n                if (attrValue !== null) {\n                    technique[attrName] = attrValue;\n                }\n            }\n        }\n        for (const [attrName, attrValue] of dynamicAttrs) {\n            if (attrValue !== null) {\n                technique[attrName] = attrValue;\n            }\n        }\n        if (style._dynamicFeatureAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {\n                technique[attrName] = attrValue;\n            }\n        }\n        if (style._dynamicForwardedAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {\n                // tslint:disable-next-line: prefer-conditional-expression\n                if (Expr_1.Expr.isExpr(attrValue)) {\n                    technique[attrName] = attrValue.toJSON();\n                }\n                else {\n                    technique[attrName] = attrValue;\n                }\n            }\n        }\n        technique._index = this.m_techniques.length;\n        technique._styleSetIndex = style._styleSetIndex;\n        technique._key = key;\n        this.m_techniques.push(technique);\n        return technique;\n    }\n}\nexports.StyleSetEvaluator = StyleSetEvaluator;\nfunction computeDefaultRenderOrder(styleSet) {\n    let techniqueRenderOrder = 0;\n    let styleSetIndex = 0;\n    for (const style of styleSet) {\n        style._styleSetIndex = styleSetIndex++;\n        if (style.technique !== undefined && style.renderOrder === undefined) {\n            style.renderOrder = techniqueRenderOrder++;\n        }\n    }\n}\nfunction resolveReferences(styleSet, definitions) {\n    return styleSet.map(style => resolveStyleReferences(style, definitions));\n}\nfunction resolveStyleReferences(style, definitions) {\n    if (Expr_1.isJsonExpr(style)) {\n        if (!Theme_1.isJsonExprReference(style)) {\n            throw new Error(\"invalid expression in this context, only 'ref's are supported\");\n        }\n        // expand and instantiate references to style definitions.\n        const definitionName = style[1];\n        const def = definitions && definitions[definitionName];\n        if (!def) {\n            throw new Error(`invalid reference '${definitionName}' - not found`);\n        }\n        if (!Theme_1.isActualSelectorDefinition(def)) {\n            throw new Error(`invalid reference '${definitionName}' - expected style definition`);\n        }\n        // instantiate the style\n        return resolveStyleReferences(def, definitions);\n    }\n    return Object.assign({}, style);\n}\n/**\n * Create transferable representation of dynamic technique.\n *\n * As for now, we remove all `Expr` as they are not supported on other side.\n */\nfunction makeDecodedTechnique(technique) {\n    const result = {};\n    for (const attrName in technique) {\n        if (!technique.hasOwnProperty(attrName)) {\n            continue;\n        }\n        let attrValue = technique[attrName];\n        if (Expr_1.Expr.isExpr(attrValue)) {\n            attrValue = attrValue.toJSON();\n        }\n        result[attrName] = attrValue;\n    }\n    return result;\n}\nexports.makeDecodedTechnique = makeDecodedTechnique;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst InterpolatedProperty_1 = __webpack_require__(/*! ./InterpolatedProperty */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TechniqueAttr\");\nfunction evaluateTechniqueAttr(context, attrValue, defaultValue) {\n    const env = context instanceof Expr_1.Env ? context : context.env;\n    let evaluated;\n    if (Expr_1.Expr.isExpr(attrValue)) {\n        try {\n            evaluated = attrValue.evaluate(env, Expr_1.ExprScope.Dynamic, !(context instanceof Expr_1.Env) ? context.cachedExprResults : undefined);\n        }\n        catch (error) {\n            logger.error(`failed to evaluate expression '${JSON.stringify(attrValue)}': ${error}`);\n            evaluated = undefined;\n        }\n    }\n    else if (InterpolatedProperty_1.isInterpolatedProperty(attrValue)) {\n        const storageLevel = context instanceof Expr_1.Env ? context.lookup(\"$zoom\") : context.zoomLevel;\n        evaluated = InterpolatedProperty_1.getPropertyValue(attrValue, storageLevel);\n    }\n    else {\n        evaluated = attrValue;\n    }\n    if (evaluated === undefined || evaluated === null) {\n        return defaultValue;\n    }\n    else {\n        return evaluated;\n    }\n}\nexports.evaluateTechniqueAttr = evaluateTechniqueAttr;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptor.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AttrScope;\n(function (AttrScope) {\n    /**\n     * Attributes that affect generation of feature geometry and thus must be resolved at decoding\n     * time.\n     *\n     * They may have huge variancy as they are implemented as vertex attributes or embedded in\n     * generated meshes.\n     *\n     * These attributes are available only in decoding scope.\n     */\n    AttrScope[AttrScope[\"FeatureGeometry\"] = 0] = \"FeatureGeometry\";\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     * These attributes affect generated geometry and  thus must be resolved at decoding time.\n     *\n     * They shouldn't have big variancy and evaluate to at least dozens of values as each\n     * combination of these attributes consitute new technique and material.\n     *\n     * These attributes are available in decoding and rendering scope.\n     */\n    AttrScope[AttrScope[\"TechniqueGeometry\"] = 1] = \"TechniqueGeometry\";\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     * Attributes that can be changed in resulting object/material from frame to frame. They are\n     * usually implemented as uniforms.\n     *\n     * These attributes may be available only at rendering scope.\n     */\n    AttrScope[AttrScope[\"TechniqueRendering\"] = 2] = \"TechniqueRendering\";\n})(AttrScope = exports.AttrScope || (exports.AttrScope = {}));\nfunction mergeTechniqueDescriptor(...descriptors) {\n    const result = {\n        attrScopes: {}\n    };\n    for (const descriptor of descriptors) {\n        if (descriptor.attrTransparencyColor !== undefined) {\n            result.attrTransparencyColor = descriptor.attrTransparencyColor;\n        }\n        if (descriptor.attrScopes !== undefined) {\n            result.attrScopes = Object.assign(Object.assign({}, result.attrScopes), descriptor.attrScopes);\n        }\n    }\n    return result;\n}\nexports.mergeTechniqueDescriptor = mergeTechniqueDescriptor;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptor.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The kind of geometry is used to\n *\n * a) Group objects together, allowing the group to be hidden or displayed.\n *\n * b) Assigning the objects a loading phase. If a [[PhasedTileGeometryManager]] is used, techniques\n *      without a `GeometryKind` may not be processed (at the desired phase).\n *\n * Any string can be used to specify the kind of the technique in a style in the theme file. Is is\n * suggested to specify multiple kinds for specific types of data. For a highway, the following list\n * of kinds is suggested:\n *\n *    [\"line\", \"road\", \"road:highway\"]\n *\n * If it is a tunnel for a highway:\n *\n *    [\"line\", \"road\", \"road:highway\", \"tunnel\", \"road:tunnel\", \"road:highway:tunnel\"]\n *\n * If specified in this way, specific types of data (here: highway roads) can be enabled and/or\n * disabled.\n */\nvar GeometryKind;\n(function (GeometryKind) {\n    /**\n     * Used in the enabledKinds/disabledKinds filter to match any kind.\n     */\n    GeometryKind[\"All\"] = \"_all_\";\n    /**\n     * Background geometry.\n     */\n    GeometryKind[\"Background\"] = \"background\";\n    /**\n     * Terrain geometry.\n     */\n    GeometryKind[\"Terrain\"] = \"terrain\";\n    /**\n     * Default value for the FillTechnique.\n     */\n    GeometryKind[\"Area\"] = \"area\";\n    /**\n     * Default value for all line techniques.\n     */\n    GeometryKind[\"Line\"] = \"line\";\n    /**\n     * Default value for the FillTechnique.\n     */\n    GeometryKind[\"Water\"] = \"water\";\n    /**\n     * Political borders.\n     */\n    GeometryKind[\"Border\"] = \"border\";\n    /**\n     * Basis for all roads.\n     */\n    GeometryKind[\"Road\"] = \"road\";\n    /**\n     * Default value for the ExtrudedPolygonTechnique.\n     */\n    GeometryKind[\"Building\"] = \"building\";\n    /**\n     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.\n     */\n    GeometryKind[\"Label\"] = \"label\";\n    /**\n     * Anything that may show up last.\n     */\n    GeometryKind[\"Detail\"] = \"detail\";\n})(GeometryKind = exports.GeometryKind || (exports.GeometryKind = {}));\n/**\n * A set of [[GeometryKind]]s.\n */\nclass GeometryKindSet extends Set {\n    /**\n     * Return `true` if the Set is a superset of the set 'subset'.\n     */\n    isSuperset(subset) {\n        for (const elem of subset) {\n            if (!this.has(elem)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Return `true` if the Set intersects Set 'set'.\n     */\n    hasIntersection(set) {\n        for (const elem of set) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'\n     * if set is not a Set.\n     */\n    hasOrIntersects(set) {\n        if (set instanceof Set) {\n            return this.hasIntersection(set);\n        }\n        return this.has(set);\n    }\n    /**\n     * Return `true` if this set and the array of elements share at least a single element.\n     */\n    hasOrIntersectsArray(subset) {\n        for (const elem of subset) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.GeometryKindSet = GeometryKindSet;\nvar TextureCoordinateType;\n(function (TextureCoordinateType) {\n    /**\n     * Texture coordinates are in tile space.\n     * SW of the tile will have (0,0) and NE will have (1,1).\n     */\n    TextureCoordinateType[\"TileSpace\"] = \"tile-space\";\n    /**\n     * Texture coordinates are in equirectangular space.\n     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).\n     */\n    TextureCoordinateType[\"EquirectangularSpace\"] = \"equirectangular-space\";\n})(TextureCoordinateType = exports.TextureCoordinateType || (exports.TextureCoordinateType = {}));\n/**\n * Define the stacking option. Enum values for theme file are in \"kebab-case\".\n */\nvar PoiStackMode;\n(function (PoiStackMode) {\n    /**\n     * Show in a stack.\n     */\n    PoiStackMode[\"Show\"] = \"show-in-stack\";\n    /**\n     * Do not show in a stack.\n     */\n    PoiStackMode[\"Hide\"] = \"hide-in-stack\";\n    /**\n     * Show category parent in the stack.\n     */\n    PoiStackMode[\"ShowParent\"] = \"show-parent\";\n})(PoiStackMode = exports.PoiStackMode || (exports.PoiStackMode = {}));\n/**\n * Type guard to check if an object is an instance of `TextureBuffer`.\n */\nfunction isTextureBuffer(object) {\n    return object && object.buffer && typeof object.type === \"string\";\n}\nexports.isTextureBuffer = isTextureBuffer;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Techniques.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Techniques.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TechniqueParams_1 = __webpack_require__(/*! ./TechniqueParams */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueParams.js\");\nconst TechniqueDescriptor_1 = __webpack_require__(/*! ./TechniqueDescriptor */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueDescriptor.js\");\n/**\n * Names of the supported texture properties.\n */\nexports.TEXTURE_PROPERTY_KEYS = [\n    \"map\",\n    \"normalMap\",\n    \"displacementMap\",\n    \"roughnessMap\",\n    \"emissiveMap\",\n    \"alphaMap\",\n    \"metalnessMap\",\n    \"bumpMap\"\n];\n/**\n * Names of the properties controlling transparency.\n */\nexports.TRANSPARENCY_PROPERTY_KEYS = [\"opacity\", \"transparent\"];\nexports.techniqueDescriptors = {};\nexports.baseTechniqueParamsDescriptor = {\n    // TODO: Choose which techniques should support color with transparency.\n    // For now we chosen all, but it maybe not suitable for text or line marker techniques.\n    attrTransparencyColor: \"color\",\n    attrScopes: {\n        renderOrder: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        renderOrderOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        enabled: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        kind: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        transient: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        fadeFar: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        fadeNear: TechniqueDescriptor_1.AttrScope.TechniqueRendering\n    }\n};\nexports.pointTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {\n    attrScopes: {\n        texture: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        enablePicking: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        opacity: TechniqueDescriptor_1.AttrScope.TechniqueGeometry\n    }\n});\nexports.squaresTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, exports.pointTechniquePropTypes);\nexports.techniqueDescriptors.squares = exports.squaresTechniquePropTypes;\nexports.circlesTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, exports.pointTechniquePropTypes);\nexports.techniqueDescriptors.circles = exports.circlesTechniquePropTypes;\nconst lineMarkerTechniquePropTypes = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {\n    attrScopes: {\n        text: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        label: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        useAbbreviation: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        useIsoCode: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        priority: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        textMinZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        textMaxZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        iconMinZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        iconMaxZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        distanceScale: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        textMayOverlap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        iconMayOverlap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        textReserveSpace: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        iconReserveSpace: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        renderTextDuringMovements: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        alwaysOnTop: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        textIsOptional: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        showOnMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        stackMode: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        minDistance: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        iconIsOptional: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        iconFadeTime: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        textFadeTime: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        xOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        yOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        iconXOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        iconYOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        iconScale: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        screenHeight: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        screenWidth: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        poiTable: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        poiName: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        poiNameField: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        imageTexture: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        imageTextureField: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        imageTexturePrefix: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        imageTexturePostfix: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        style: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        fontName: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        fontStyle: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        fontVariant: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        rotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        tracking: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        leading: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        maxLines: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        canvasRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        lineRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        wrappingMode: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        hAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        vAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        backgroundColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        backgroundSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        backgroundOpacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        size: TechniqueDescriptor_1.AttrScope.TechniqueRendering\n    }\n});\nexports.techniqueDescriptors[\"line-marker\"] = lineMarkerTechniquePropTypes;\nexports.techniqueDescriptors[\"labeled-icon\"] = lineMarkerTechniquePropTypes;\nconst polygonalTechniqueDescriptor = {\n    attrScopes: {\n        polygonOffset: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        polygonOffsetFactor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        polygonOffsetUnits: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        lineColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        lineFadeFar: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        lineFadeNear: TechniqueDescriptor_1.AttrScope.TechniqueRendering\n    }\n};\nexports.solidLineTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {\n    attrScopes: {\n        clipping: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        secondaryRenderOrder: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        secondaryWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        secondaryColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        dashSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        gapSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering\n    }\n});\nexports.techniqueDescriptors[\"solid-line\"] = exports.solidLineTechniqueDescriptor;\n// TODO: Remove deprecated \"dashed-line\" support in future releases.\nexports.techniqueDescriptors[\"dashed-line\"] = exports.solidLineTechniqueDescriptor;\nexports.lineTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {\n    attrScopes: {\n        // TODO, check, which are really dynamic !\n        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        lineWidth: TechniqueDescriptor_1.AttrScope.FeatureGeometry\n    }\n});\nexports.techniqueDescriptors.line = exports.lineTechniqueDescriptor;\nconst fillTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {\n    attrScopes: {\n        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering\n    }\n});\nexports.techniqueDescriptors.fill = fillTechniqueDescriptor;\nconst standardTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {\n    attrScopes: {\n        color: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        vertexColors: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        wireframe: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        roughness: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        metalness: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        alphaTest: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        depthTest: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        emissive: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        emissiveIntensity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        refractionRatio: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        map: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        mapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        normalMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        normalMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        displacementMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        displacementMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        roughnessMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        roughnessMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        emissiveMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        emissiveMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        bumpMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        bumpMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        metalnessMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        metalnessMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        alphaMap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        alphaMapProperties: TechniqueDescriptor_1.AttrScope.TechniqueGeometry\n    }\n});\nexports.techniqueDescriptors.standard = standardTechniqueDescriptor;\nconst extrudedPolygonTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, standardTechniqueDescriptor, {\n    attrScopes: {\n        height: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        floorHeight: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        color: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        defaultColor: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        defaultHeight: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        constantHeight: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        boundaryWalls: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        footprint: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        maxSlope: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        enableDepthPrePass: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        animateExtrusionDuration: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        animateExtrusion: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        transparent: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        lineFadeNear: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        lineFadeFar: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        lineColorMix: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        lineColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering\n    }\n});\nexports.techniqueDescriptors[\"extruded-polygon\"] = extrudedPolygonTechniqueDescriptor;\nconst textTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {\n    attrScopes: {\n        text: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        label: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        useAbbreviation: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        useIsoCode: TechniqueDescriptor_1.AttrScope.FeatureGeometry,\n        minZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        maxZoomLevel: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        distanceScale: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        mayOverlap: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        reserveSpace: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        textFadeTime: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        xOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        yOffset: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        style: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        fontName: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        fontStyle: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        fontVariant: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        rotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        tracking: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        leading: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        maxLines: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        lineWidth: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        canvasRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        lineRotation: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        wrappingMode: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        hAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        vAlignment: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        backgroundColor: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        backgroundSize: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        backgroundOpacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        color: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        opacity: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        priority: TechniqueDescriptor_1.AttrScope.TechniqueRendering,\n        size: TechniqueDescriptor_1.AttrScope.TechniqueRendering\n    }\n});\nexports.techniqueDescriptors.text = textTechniqueDescriptor;\nconst shaderTechniqueDescriptor = TechniqueDescriptor_1.mergeTechniqueDescriptor(exports.baseTechniqueParamsDescriptor, {\n    attrScopes: {\n        primitive: TechniqueDescriptor_1.AttrScope.TechniqueGeometry,\n        params: TechniqueDescriptor_1.AttrScope.TechniqueRendering\n    }\n});\nexports.techniqueDescriptors.shader = shaderTechniqueDescriptor;\n/**\n * Type guard to check if an object is an instance of [[CirclesTechnique]].\n */\nfunction isCirclesTechnique(technique) {\n    return technique.name === \"circles\";\n}\nexports.isCirclesTechnique = isCirclesTechnique;\n/**\n * Type guard to check if an object is an instance of [[SquaresTechnique]].\n */\nfunction isSquaresTechnique(technique) {\n    return technique.name === \"squares\";\n}\nexports.isSquaresTechnique = isSquaresTechnique;\n/**\n * Type guard to check if an object is an instance of [[PoiTechnique]].\n */\nfunction isPoiTechnique(technique) {\n    return technique.name === \"labeled-icon\";\n}\nexports.isPoiTechnique = isPoiTechnique;\n/**\n * Type guard to check if an object is an instance of [[LineMarkerTechnique]].\n */\nfunction isLineMarkerTechnique(technique) {\n    return technique.name === \"line-marker\";\n}\nexports.isLineMarkerTechnique = isLineMarkerTechnique;\n/**\n * Type guard to check if an object is an instance of [[LineTechnique]].\n */\nfunction isLineTechnique(technique) {\n    return technique.name === \"line\";\n}\nexports.isLineTechnique = isLineTechnique;\n/**\n * Type guard to check if an object is an instance of [[SolidLineTechnique]].\n */\nfunction isSolidLineTechnique(technique) {\n    return technique.name === \"solid-line\" || technique.name === \"dashed-line\";\n}\nexports.isSolidLineTechnique = isSolidLineTechnique;\n/**\n * Type guard to check if an object is an instance of [[SegmentsTechnique]].\n */\nfunction isSegmentsTechnique(technique) {\n    return technique.name === \"segments\";\n}\nexports.isSegmentsTechnique = isSegmentsTechnique;\n/**\n * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]]\n * or [[StandardExtrudedLineTechnique]].\n */\nfunction isExtrudedLineTechnique(technique) {\n    return technique.name === \"extruded-line\";\n}\nexports.isExtrudedLineTechnique = isExtrudedLineTechnique;\n/**\n * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]].\n */\nfunction isBasicExtrudedLineTechnique(technique) {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"basic\";\n}\nexports.isBasicExtrudedLineTechnique = isBasicExtrudedLineTechnique;\n/**\n * Type guard to check if an object is an instance of [[StandardExtrudedLineTechnique]].\n */\nfunction isStandardExtrudedLineTechnique(technique) {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"standard\";\n}\nexports.isStandardExtrudedLineTechnique = isStandardExtrudedLineTechnique;\n/**\n * Type guard to check if an object is an instance of [[FillTechnique]].\n */\nfunction isFillTechnique(technique) {\n    return technique.name === \"fill\";\n}\nexports.isFillTechnique = isFillTechnique;\n/**\n * Type guard to check if an object is an instance of [[ExtrudedPolygonTechnique]].\n */\nfunction isExtrudedPolygonTechnique(technique) {\n    return technique.name === \"extruded-polygon\";\n}\nexports.isExtrudedPolygonTechnique = isExtrudedPolygonTechnique;\n/**\n * Type guard to check if an object is an instance of [[StandardTechnique]].\n */\nfunction isStandardTechnique(technique) {\n    return technique.name === \"standard\";\n}\nexports.isStandardTechnique = isStandardTechnique;\n/**\n * Type guard to check if an object is an instance of [[TerrainTechnique]].\n */\nfunction isTerrainTechnique(technique) {\n    return technique.name === \"terrain\";\n}\nexports.isTerrainTechnique = isTerrainTechnique;\n/**\n * Type guard to check if an object is an instance of [[TextTechnique]].\n */\nfunction isTextTechnique(technique) {\n    return technique.name === \"text\";\n}\nexports.isTextTechnique = isTextTechnique;\n/**\n * Type guard to check if an object is an instance of [[ShaderTechnique]].\n */\nfunction isShaderTechnique(technique) {\n    return technique.name === \"shader\";\n}\nexports.isShaderTechnique = isShaderTechnique;\nfunction isLabelRejectionLineTechnique(technique) {\n    return technique.name === \"label-rejection-line\";\n}\nexports.isLabelRejectionLineTechnique = isLabelRejectionLineTechnique;\n/**\n * Check if vertex normals should be generated for this technique (if no normals are in the data).\n * @param technique Technique to check.\n */\nfunction needsVertexNormals(technique) {\n    return (isFillTechnique(technique) ||\n        isStandardTechnique(technique) ||\n        isTerrainTechnique(technique) ||\n        isStandardExtrudedLineTechnique(technique));\n}\nexports.needsVertexNormals = needsVertexNormals;\n/**\n * Get the texture coordinate type if the technique supports it.\n */\nfunction textureCoordinateType(technique) {\n    if (isStandardTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else if (isExtrudedPolygonTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else if (isTerrainTechnique(technique)) {\n        return technique.textureCoordinateType;\n    }\n    else {\n        return undefined;\n    }\n}\nexports.textureCoordinateType = textureCoordinateType;\n/**\n * Add all the buffers of the technique to the transfer list.\n */\nfunction addBuffersToTransferList(technique, transferList) {\n    if (isStandardTechnique(technique) ||\n        isExtrudedPolygonTechnique(technique) ||\n        isTerrainTechnique(technique)) {\n        for (const texturePropertyKey of exports.TEXTURE_PROPERTY_KEYS) {\n            const textureProperty = technique[texturePropertyKey];\n            if (TechniqueParams_1.isTextureBuffer(textureProperty)) {\n                if (textureProperty.buffer instanceof ArrayBuffer) {\n                    transferList.push(textureProperty.buffer);\n                }\n            }\n        }\n    }\n}\nexports.addBuffersToTransferList = addBuffersToTransferList;\n/**\n * Compose full texture name for given image name with technique specified.\n * Some techniques allows to add prefix/postfix to icons names specified, this\n * function uses technique information to create fully qualified texture name.\n * @param imageName base name of the marker icon.\n * @param technique the technique describing POI or line marker.\n * @returns fully qualified texture name for loading from atlas (without extension).\n */\nfunction composeTechniqueTextureName(imageName, technique) {\n    let textureName = imageName;\n    if (typeof technique.imageTexturePrefix === \"string\") {\n        textureName = technique.imageTexturePrefix + textureName;\n    }\n    if (typeof technique.imageTexturePostfix === \"string\") {\n        textureName = textureName + technique.imageTexturePostfix;\n    }\n    return textureName;\n}\nexports.composeTechniqueTextureName = composeTechniqueTextureName;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Techniques.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/Theme.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/Theme.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst InterpolatedProperty_1 = __webpack_require__(/*! ./InterpolatedProperty */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js\");\n/**\n * Checks if the given definition implements the [[BoxedDefinition]] interface.\n */\nfunction isBoxedDefinition(def) {\n    const bdef = def;\n    return (typeof bdef === \"object\" &&\n        bdef !== null &&\n        (typeof bdef.type === \"string\" || typeof bdef.type === \"undefined\") &&\n        (typeof bdef.value === \"string\" ||\n            typeof bdef.value === \"number\" ||\n            typeof bdef.value === \"boolean\" ||\n            InterpolatedProperty_1.isInterpolatedPropertyDefinition(bdef.value) ||\n            Expr_1.isJsonExpr(bdef.value)));\n}\nexports.isBoxedDefinition = isBoxedDefinition;\nfunction isLiteralDefinition(def) {\n    return typeof def === \"string\" || typeof def === \"number\" || typeof def === \"boolean\";\n}\nexports.isLiteralDefinition = isLiteralDefinition;\n/**\n * Checks if the given value is a reference to a definition.\n *\n * @param value The value of a technique property.\n */\nfunction isJsonExprReference(value) {\n    return (Array.isArray(value) &&\n        value.length === 2 &&\n        value[0] === \"ref\" &&\n        typeof value[1] === \"string\");\n}\nexports.isJsonExprReference = isJsonExprReference;\nfunction isActualSelectorDefinition(def) {\n    const styleDef = def;\n    return (typeof styleDef === \"object\" &&\n        styleDef !== null &&\n        !Array.isArray(styleDef) &&\n        typeof styleDef.technique === \"string\");\n}\nexports.isActualSelectorDefinition = isActualSelectorDefinition;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/Theme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\n/**\n * The ThemeVisitor visits every style in the theme in a depth-first fashion.\n */\nclass ThemeVisitor {\n    constructor(theme) {\n        this.theme = theme;\n    }\n    /**\n     * Applies a function to every style in the theme.\n     *\n     * @param visitFunc Function to be called with `style` as an argument. Function should return\n     *                  `true` to cancel visitation.\n     * @returns `true` if function has finished prematurely.\n     */\n    visitStyles(visitFunc) {\n        const visit = (style) => {\n            if (Expr_1.isJsonExpr(style)) {\n                return false;\n            }\n            if (visitFunc(style)) {\n                return true;\n            }\n            return false;\n        };\n        if (this.theme.styles !== undefined) {\n            for (const styleSetName in this.theme.styles) {\n                if (this.theme.styles[styleSetName] !== undefined) {\n                    for (const style of this.theme.styles[styleSetName]) {\n                        if (visit(style)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\nexports.ThemeVisitor = ThemeVisitor;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ThemeVisitor.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DecodedTile_1 = __webpack_require__(/*! ./DecodedTile */ \"./node_modules/@here/harp-datasource-protocol/lib/DecodedTile.js\");\n/**\n * Collection of helper methods to convert\n * {@link https://threejs.org/docs/index.html#api/en/core/BufferGeometry|three.js BufferGeometry}\n * to [[Geometry]] that allows creation and transfering of THREE BufferGeometry in webworkers.\n * See also [[CustomDatasourceExample]].\n */\nvar ThreeBufferUtils;\n(function (ThreeBufferUtils) {\n    function getBufferElementType(buffer) {\n        if (buffer instanceof Int8Array) {\n            return \"int8\";\n        }\n        else if (buffer instanceof Uint8Array) {\n            return \"uint8\";\n        }\n        else if (buffer instanceof Int16Array) {\n            return \"int16\";\n        }\n        else if (buffer instanceof Uint16Array) {\n            return \"uint16\";\n        }\n        else if (buffer instanceof Int32Array) {\n            return \"int32\";\n        }\n        else if (buffer instanceof Uint32Array) {\n            return \"uint32\";\n        }\n        else if (buffer instanceof Float32Array) {\n            return \"float\";\n        }\n        throw new Error(`Unsupported buffer type ${name}`);\n    }\n    ThreeBufferUtils.getBufferElementType = getBufferElementType;\n    function fromThreeBufferAttribute(bufferAttribute) {\n        const buffer = bufferAttribute.array;\n        return {\n            name: bufferAttribute.name,\n            buffer: buffer.buffer,\n            type: getBufferElementType(buffer),\n            itemCount: bufferAttribute.itemSize,\n            normalized: bufferAttribute.normalized\n        };\n    }\n    ThreeBufferUtils.fromThreeBufferAttribute = fromThreeBufferAttribute;\n    function fromThreeInterleavedBufferAttribute(bufferAttribute) {\n        throw new Error(\"Not implemented yet\");\n    }\n    ThreeBufferUtils.fromThreeInterleavedBufferAttribute = fromThreeInterleavedBufferAttribute;\n    function fromThreeBufferGeometry(bufferGeometry, techniqueIndex) {\n        const vertexAttributes = [];\n        const attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);\n        for (const name of attributeNames) {\n            const attribute = bufferGeometry.attributes[name];\n            // FIXME: Also support InterleavedBufferAttribute\n            const vertexAttribute = fromThreeBufferAttribute(attribute);\n            vertexAttribute.name = name;\n            vertexAttributes.push(vertexAttribute);\n        }\n        const index = bufferGeometry.index !== null\n            ? fromThreeBufferAttribute(bufferGeometry.index)\n            : undefined;\n        let count = 0;\n        if (index !== undefined) {\n            count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;\n        }\n        else {\n            // If there is no index buffer, try to deduce the count from the position attribute.\n            const posAttr = bufferGeometry.attributes.position;\n            if (posAttr === undefined) {\n                throw new Error(\"Missing position attibute to deduce item count\");\n            }\n            count = posAttr.count;\n        }\n        return {\n            type: DecodedTile_1.GeometryType.Unspecified,\n            vertexAttributes,\n            index,\n            groups: [{ start: 0, count, technique: techniqueIndex }]\n        };\n    }\n    ThreeBufferUtils.fromThreeBufferGeometry = fromThreeBufferGeometry;\n})(ThreeBufferUtils = exports.ThreeBufferUtils || (exports.ThreeBufferUtils = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/ThreeBufferUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Expr_1 = __webpack_require__(/*! ./Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst StyleSetEvaluator_1 = __webpack_require__(/*! ./StyleSetEvaluator */ \"./node_modules/@here/harp-datasource-protocol/lib/StyleSetEvaluator.js\");\nconst TechniqueAttr_1 = __webpack_require__(/*! ./TechniqueAttr */ \"./node_modules/@here/harp-datasource-protocol/lib/TechniqueAttr.js\");\nconst Techniques_1 = __webpack_require__(/*! ./Techniques */ \"./node_modules/@here/harp-datasource-protocol/lib/Techniques.js\");\n/**\n * Represents a feature group type for tile info.\n */\nvar FeatureGroupType;\n(function (FeatureGroupType) {\n    FeatureGroupType[FeatureGroupType[\"Point\"] = 0] = \"Point\";\n    FeatureGroupType[FeatureGroupType[\"Line\"] = 1] = \"Line\";\n    FeatureGroupType[FeatureGroupType[\"Polygon\"] = 2] = \"Polygon\";\n})(FeatureGroupType = exports.FeatureGroupType || (exports.FeatureGroupType = {}));\n/**\n * Minimum estimated size of a JS object.\n */\nconst MINIMUM_OBJECT_SIZE_ESTIMATION = 100;\n/**\n * Structure of arrays containing data for all features of this group. No methods, since the object\n * is being passed as part of ExtendedTileInfo across \"process boundaries\" to the web worker.\n *\n * Supporting methods in namespace [[ExtendedTileInfo]].\n */\nclass FeatureGroup {\n    /**\n     * Construct featureGroup.\n     *\n     * @param storeExtendedTags Pass `true` to create fields for more OMV tags (`layer`, `class`\n     * and `type`).\n     */\n    constructor(storeExtendedTags, startSize = 5000) {\n        /** featureIds */\n        this.featureIds = new Array();\n        /** number of features */\n        this.numFeatures = 0;\n        /** number of positions of elements (2 per point) */\n        this.numPositions = 0;\n        this.featureIds = new Array(startSize);\n        this.featureIds.length = startSize;\n        this.techniqueIndex = new Array(startSize);\n        this.techniqueIndex.length = startSize;\n        this.textIndex = new Array(startSize);\n        this.textIndex.length = startSize;\n        this.positionIndex = new Array(startSize);\n        this.positionIndex.length = startSize;\n        this.positions = new Array(10 * startSize);\n        this.positions.length = 10 * startSize;\n        if (storeExtendedTags) {\n            this.layerIndex = new Array(startSize);\n            this.layerIndex.length = startSize;\n            this.classIndex = new Array(startSize);\n            this.classIndex.length = startSize;\n            this.typeIndex = new Array(startSize);\n            this.typeIndex.length = startSize;\n        }\n    }\n    /**\n     * Compute size in bytes.\n     */\n    getNumBytes() {\n        return ((this.featureIds.length +\n            this.techniqueIndex.length +\n            this.textIndex.length +\n            this.positionIndex.length +\n            this.positions.length +\n            (this.layerIndex !== undefined ? this.layerIndex.length : 0) +\n            (this.classIndex !== undefined ? this.classIndex.length : 0) +\n            (this.typeIndex !== undefined ? this.typeIndex.length : 0)) *\n            8);\n    }\n}\nexports.FeatureGroup = FeatureGroup;\n/**\n * Structure of arrays containing data for roads. No methods, since the object is being passed as\n * part of [[ExtendedTileInfo]] across \"process boundaries\" to the web worker.\n */\nclass LineFeatureGroup extends FeatureGroup {\n    constructor() {\n        super(...arguments);\n        /**\n         * An array of object defined by the user. Certain elements may be `undefined` (if this line\n         * feature is not a road, or if the object for that feature is undefined).\n         */\n        this.userData = [];\n    }\n    /** @override */\n    getNumBytes() {\n        return (super.getNumBytes() +\n            ((this.segmentIds !== undefined ? this.segmentIds.length : 0) +\n                (this.segmentStartOffsets !== undefined ? this.segmentStartOffsets.length : 0) +\n                (this.segmentEndOffsets !== undefined ? this.segmentEndOffsets.length : 0)) *\n                8);\n    }\n}\nexports.LineFeatureGroup = LineFeatureGroup;\n/**\n * Structure of arrays containing data for polygons. No methods, since the object is being passed as\n * part of ExtendedTileInfo across \"process boundaries\" to the web worker.\n *\n * Supporting methods in namespace [[ExtendedTileInfo]].\n *\n * Due to the complexity of the access, there are supporting classes to store and access data in\n * the feature groups. See [[ExtendedTileInfoWriter]] and [[ExtendedTileInfoPolygonAccessor]].\n */\nclass PolygonFeatureGroup extends FeatureGroup {\n    constructor(storeExtendedTags, startSize = 5000) {\n        super(storeExtendedTags, startSize);\n        /**\n         * Number of rings stored in all polygons in tis group. Used to keep size of the\n         * arrays.\n         */\n        this.groupNumRings = 0;\n        this.outerRingStartIndex = new Array(startSize);\n        this.outerRingStartIndex.length = startSize;\n        this.innerRingIsOuterContour = new Array(startSize);\n        this.innerRingIsOuterContour.length = startSize;\n        this.innerRingStartIndex = new Array(startSize);\n        this.innerRingStartIndex.length = startSize;\n    }\n    /** @override */\n    getNumBytes() {\n        return (super.getNumBytes() +\n            ((this.outerRingStartIndex !== undefined ? this.outerRingStartIndex.length : 0) +\n                (this.innerRingIsOuterContour !== undefined\n                    ? this.innerRingIsOuterContour.length\n                    : 0) +\n                (this.innerRingStartIndex !== undefined ? this.innerRingStartIndex.length : 0)) *\n                8);\n    }\n}\nexports.PolygonFeatureGroup = PolygonFeatureGroup;\n/**\n * Class to hold infos from [[OmvTile]]s. Optimized for fast serialization when being passed from\n * webworker to main thread. No methods, since the object is being passed across \"process\n * boundaries\" to the web worker.\n *\n * Supporting methods in namespace [[ExtendedTileInfo]].\n *\n * Due to the complexity of the access, there are supporting classes to store and access data in\n * the feature groups. See [[ExtendedTileInfoWriter]] and [[ExtendedTileInfoPolygonAccessor]].\n */\nclass ExtendedTileInfo {\n    constructor(tileKey, storeExtendedTags) {\n        this.tileKey = tileKey;\n        /**\n         * Catalog of strings. Addressed by every features stringIndex.\n         */\n        this.textCatalog = new Array();\n        /**\n         * Catalog of techniques. Addressed by every features featureIndex.\n         */\n        this.techniqueCatalog = new Array();\n        /**\n         * Used for performance diagnostics.\n         */\n        this.setupTime = 0;\n        /**\n         * Size in bytes.\n         */\n        this.numBytes = 0;\n        this.pointGroup = new FeatureGroup(storeExtendedTags);\n        this.lineGroup = new LineFeatureGroup(storeExtendedTags);\n        this.polygonGroup = new PolygonFeatureGroup(storeExtendedTags);\n        if (storeExtendedTags) {\n            this.layerCatalog = new Array();\n            this.classCatalog = new Array();\n            this.typeCatalog = new Array();\n        }\n    }\n    /**\n     * Compute the memory footprint caused by objects owned by the `ExtendedTileInfo`.\n     */\n    getNumBytes() {\n        let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;\n        for (const str of this.textCatalog) {\n            numBytes += 2 * str.length;\n        }\n        numBytes += this.techniqueCatalog.length * MINIMUM_OBJECT_SIZE_ESTIMATION;\n        numBytes += this.pointGroup.getNumBytes();\n        numBytes += this.lineGroup.getNumBytes();\n        numBytes += this.polygonGroup.getNumBytes();\n        if (this.layerCatalog !== undefined) {\n            for (const str of this.layerCatalog) {\n                numBytes += 2 * str.length;\n            }\n            for (const str of this.classCatalog) {\n                numBytes += 2 * str.length;\n            }\n            for (const str of this.typeCatalog) {\n                numBytes += 2 * str.length;\n            }\n        }\n        return numBytes;\n    }\n}\nexports.ExtendedTileInfo = ExtendedTileInfo;\n(function (ExtendedTileInfo) {\n    function finishFeatureGroup(featureGroup) {\n        featureGroup.featureIds.length = featureGroup.numFeatures;\n        featureGroup.techniqueIndex.length = featureGroup.numFeatures;\n        featureGroup.textIndex.length = featureGroup.numFeatures;\n        featureGroup.positionIndex.length = featureGroup.numFeatures;\n        featureGroup.positions.length = featureGroup.numPositions;\n        if (featureGroup.layerIndex !== undefined) {\n            featureGroup.layerIndex.length = featureGroup.numFeatures;\n        }\n        if (featureGroup.classIndex !== undefined) {\n            featureGroup.classIndex.length = featureGroup.numFeatures;\n        }\n        if (featureGroup.typeIndex !== undefined) {\n            featureGroup.typeIndex.length = featureGroup.numFeatures;\n        }\n    }\n    function finishPolygonFeatureGroup(polygonGroup) {\n        finishFeatureGroup(polygonGroup);\n        polygonGroup.outerRingStartIndex.length = polygonGroup.numFeatures;\n        polygonGroup.innerRingIsOuterContour.length = polygonGroup.groupNumRings;\n        polygonGroup.innerRingStartIndex.length = polygonGroup.groupNumRings;\n    }\n    function finishLineFeatureGroup(lineGroup) {\n        finishFeatureGroup(lineGroup);\n        if (lineGroup.segmentIds !== undefined) {\n            lineGroup.segmentIds.length = lineGroup.numFeatures;\n            lineGroup.segmentStartOffsets.length = lineGroup.numFeatures;\n            lineGroup.segmentEndOffsets.length = lineGroup.numFeatures;\n        }\n    }\n    /**\n     * Finalize the tile's features groups.\n     */\n    function finish(tileInfo) {\n        finishFeatureGroup(tileInfo.pointGroup);\n        finishLineFeatureGroup(tileInfo.lineGroup);\n        finishPolygonFeatureGroup(tileInfo.polygonGroup);\n        tileInfo.numBytes = tileInfo.getNumBytes();\n    }\n    ExtendedTileInfo.finish = finish;\n    /**\n     * Returns the number of features in this feature group.\n     */\n    function featureGroupSize(featureGroup) {\n        return featureGroup.numFeatures;\n    }\n    ExtendedTileInfo.featureGroupSize = featureGroupSize;\n    /**\n     * Check if the feature group is finalized.\n     */\n    function featureGroupFinished(featureGroup) {\n        return featureGroup.numPositions === featureGroup.positions.length;\n    }\n    ExtendedTileInfo.featureGroupFinished = featureGroupFinished;\n    /**\n     * Check if the tileInfo is finalized.\n     */\n    function tileInfoFinished(tileInfo) {\n        return (featureGroupFinished(tileInfo.pointGroup) &&\n            featureGroupFinished(tileInfo.lineGroup) &&\n            featureGroupFinished(tileInfo.polygonGroup));\n    }\n    ExtendedTileInfo.tileInfoFinished = tileInfoFinished;\n    /**\n     * Determine the name of (OMV) feature. It implements the special handling required\n     * to determine the text content of a feature from its tags, which are passed in as the `env`.\n     *\n     * @param env Environment containing the tags from the (OMV) feature.\n     * @param useAbbreviation `true` to use the abbreviation if available.\n     * @param useIsoCode `true` to use the tag \"iso_code\".\n     * @param languages List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n     *                  as the text of the string. Order reflects priority.\n     */\n    function getFeatureName(env, useAbbreviation, useIsoCode, languages) {\n        let name;\n        if (useAbbreviation) {\n            const abbreviation = env.lookup(`name:short`);\n            if (typeof abbreviation === \"string\" && abbreviation.length > 0) {\n                return abbreviation;\n            }\n        }\n        if (useIsoCode) {\n            const isoCode = env.lookup(`iso_code`);\n            if (typeof isoCode === \"string\" && isoCode.length > 0) {\n                return isoCode;\n            }\n        }\n        if (languages !== undefined) {\n            for (const lang of languages) {\n                name = env.lookup(`name:${lang}`) || env.lookup(`name_${lang}`);\n                if (typeof name === \"string\" && name.length > 0) {\n                    return name;\n                }\n            }\n        }\n        name = env.lookup(\"name\");\n        if (typeof name === \"string\") {\n            return name;\n        }\n        return undefined;\n    }\n    ExtendedTileInfo.getFeatureName = getFeatureName;\n    /**\n     * Determine the text string of the map feature. It implements the special handling required\n     * to determine the text content of a feature from its tags, which are passed in as the `env`.\n     *\n     * @param feature Feature, including properties from the (OMV) feature.\n     * @param technique technique defining how text should be created from feature\n     * @param languages List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n     *                  as the text of the string. Order reflects priority.\n     */\n    function getFeatureText(context, technique, languages) {\n        let useAbbreviation;\n        let useIsoCode;\n        const env = context instanceof Expr_1.Env ? context : context.env;\n        if (Techniques_1.isTextTechnique(technique) ||\n            Techniques_1.isPoiTechnique(technique) ||\n            Techniques_1.isLineMarkerTechnique(technique)) {\n            if (technique.text !== undefined) {\n                return TechniqueAttr_1.evaluateTechniqueAttr(context, technique.text);\n            }\n            if (technique.label !== undefined) {\n                const name = env.lookup(technique.label);\n                return typeof name === \"string\" ? name : undefined;\n            }\n            useAbbreviation = technique.useAbbreviation;\n            useIsoCode = technique.useIsoCode;\n        }\n        return getFeatureName(env, useAbbreviation, useIsoCode, languages);\n    }\n    ExtendedTileInfo.getFeatureText = getFeatureText;\n})(ExtendedTileInfo = exports.ExtendedTileInfo || (exports.ExtendedTileInfo = {}));\n/**\n * Support class for [[ExtendedTileInfo]]. Assist in filling it with data.\n */\nclass ExtendedTileInfoWriter {\n    /**\n     * Create an [[ExtendedTileInfoWriter]] for an [[ExtendedTileInfo]]. Assist in filling the\n     * [[ExtendedTileInfo]] with data.\n     *\n     * @param tileInfo [[ExtendedTileInfo]] to write data to.\n     * @param storeExtendedTags Pass `true` if feature data like `layer`, `class`or `type` should\n     *          be stored for every feature.\n     */\n    constructor(tileInfo, storeExtendedTags) {\n        this.tileInfo = tileInfo;\n        this.storeExtendedTags = storeExtendedTags;\n        /** Map to identify which techniques already have been added to the [[ExtendedTileInfo]]. */\n        this.techniqueIndexMap = new Map();\n        /** Map to identify which strings already have been added to the [[ExtendedTileInfo]]. */\n        this.stringMap = new Map();\n        /** Map to identify which `layer` names already have been added to the [[ExtendedTileInfo]]. */\n        this.layerMap = new Map();\n        /** Map to identify which `class` names already have been added to the [[ExtendedTileInfo]]. */\n        this.classMap = new Map();\n        /** Map to identify which `type` names already have been added to the [[ExtendedTileInfo]]. */\n        this.typeMap = new Map();\n    }\n    /**\n     * Adds a [[Technique]] to the catalog of techniques. Individual techniques have a `_index` file\n     * which has been created in the [[StyleSetEvaluator]]. This index is required to identify a\n     * technique. The `Map` is used to map techniques to already added techniques, or store the\n     * technique as new, and add it to the map.\n     *\n     * @param technique The [[Technique]] to add.\n     */\n    addTechnique(technique) {\n        let infoTileTechniqueIndex = this.techniqueIndexMap.get(technique._index);\n        if (infoTileTechniqueIndex !== undefined) {\n            return infoTileTechniqueIndex;\n        }\n        const decodedTechnique = StyleSetEvaluator_1.makeDecodedTechnique(technique);\n        infoTileTechniqueIndex = this.tileInfo.techniqueCatalog.length;\n        this.techniqueIndexMap.set(decodedTechnique._index, infoTileTechniqueIndex);\n        this.tileInfo.techniqueCatalog.push(decodedTechnique);\n        return infoTileTechniqueIndex;\n    }\n    /**\n     * Add a feature.\n     *\n     * @param featureGroup The feature group to add to.\n     * @param technique The technique to add.\n     * @param env The `env` which is a mix of original OMV feature tags and fields added by the\n     *      [[StyleSetEvaluator]]\n     * @param featureId The featureId, a number unique for many features (but not all).\n     * @param infoTileTechniqueIndex The previously computed index of the technique. Must have been\n     *      computed by `addTechnique(technique)`.\n     * @param isPolygonGroup `true`for polygons.\n     */\n    addFeature(featureGroup, env, featureId, featureText, infoTileTechniqueIndex, featureGroupType) {\n        // compute name/label of feature\n        let stringIndex = -1;\n        if (featureText !== undefined && featureText.length > 0) {\n            stringIndex = this.addText(featureText);\n        }\n        // add indices into the arrays.\n        featureGroup.featureIds[featureGroup.numFeatures] = featureId;\n        featureGroup.techniqueIndex[featureGroup.numFeatures] = infoTileTechniqueIndex;\n        featureGroup.textIndex[featureGroup.numFeatures] = stringIndex;\n        featureGroup.positionIndex[featureGroup.numFeatures] = featureGroup.numPositions;\n        switch (featureGroupType) {\n            case FeatureGroupType.Polygon:\n                // polygons need the extra fields for polygon rings\n                const polygonGroup = featureGroup;\n                harp_utils_1.assert(polygonGroup.outerRingStartIndex !== undefined);\n                harp_utils_1.assert(polygonGroup.innerRingStartIndex !== undefined);\n                harp_utils_1.assert(polygonGroup.innerRingIsOuterContour !== undefined);\n                polygonGroup.outerRingStartIndex[featureGroup.numFeatures] =\n                    polygonGroup.groupNumRings;\n                break;\n            case FeatureGroupType.Line:\n                featureGroup.userData[featureGroup.numFeatures] = env.entries;\n                break;\n        }\n        // store the extra feature fields\n        if (this.storeExtendedTags) {\n            featureGroup.layerIndex[featureGroup.numFeatures] = this.addLayer(env.lookup(\"$layer\"));\n            featureGroup.classIndex[featureGroup.numFeatures] = this.addClass(env.lookup(\"class\"));\n            featureGroup.typeIndex[featureGroup.numFeatures] = this.addType(env.lookup(\"type\"));\n        }\n        featureGroup.numFeatures++;\n    }\n    /**\n     * Add the X/Y coordinate of the point. Only for point feature groups.\n     *\n     * @param featureGroup The feature group to add it to.\n     * @param x X Position of point.\n     * @param y Y Position of point.\n     */\n    addFeaturePoint(featureGroup, x, y) {\n        featureGroup.positions[featureGroup.numPositions++] = x;\n        featureGroup.positions[featureGroup.numPositions++] = y;\n    }\n    /**\n     * Add the line points as X/Y coordinates to the line feature.\n     *\n     * If a line feature has more than one line (rare for HERE data), it should define multiple\n     * line features for it.\n     *\n     * @param featureGroup The feature group to add to. Must be line feature group.\n     * @param points The X/Y coordinates of the points.\n     */\n    addFeaturePoints(featureGroup, points) {\n        const n = featureGroup.numPositions;\n        const l = points.length;\n        const p = featureGroup.positions;\n        for (let i = 0; i < l; i++) {\n            p[n + i] = points[i];\n        }\n        featureGroup.numPositions += points.length;\n    }\n    /**\n     * Add the information about road segments to the line feature. Performs lazy initialization of\n     * `segmentIds`, `segmentStartOffsets`, and `segmentEndOffsets` members of a\n     * [[LineFeatureGroup]] instance.\n     *\n     * @param featureGroup The line feature group to add information to.\n     * @param segmentId Segment id of a feature.\n     * @param startOffset Start offset of a feature.\n     * @param endOffset End offset of a feature.\n     */\n    addRoadSegments(featureGroup, segmentId, startOffset, endOffset) {\n        if (featureGroup.segmentIds === undefined) {\n            featureGroup.segmentIds = new Array();\n            featureGroup.segmentStartOffsets = new Array();\n            featureGroup.segmentEndOffsets = new Array();\n        }\n        featureGroup.segmentIds[featureGroup.numFeatures - 1] = segmentId;\n        featureGroup.segmentStartOffsets[featureGroup.numFeatures - 1] = startOffset;\n        featureGroup.segmentEndOffsets[featureGroup.numFeatures - 1] = endOffset;\n    }\n    /**\n     * Add a single ring to the polygon. Can be called multiple times to add multiple rings to the\n     * polygon.\n     *\n     * @param featureGroup Polygon feature group to add polygon ring to.\n     * @param contour The X/Y coordinates of the ring.\n     * @param isOuterRing Pass `true`if it is a outer ring, otherwise `false`.\n     */\n    addRingPoints(featureGroup, contour, isOuterRing) {\n        featureGroup.innerRingStartIndex[featureGroup.groupNumRings] = featureGroup.numPositions;\n        featureGroup.innerRingIsOuterContour[featureGroup.groupNumRings] = isOuterRing ? 1 : 0;\n        featureGroup.groupNumRings++;\n        const n = featureGroup.numPositions;\n        const l = contour.length;\n        const p = featureGroup.positions;\n        for (let i = 0; i < l; i++) {\n            p[n + i] = contour[i];\n        }\n        featureGroup.numPositions += contour.length;\n    }\n    /**\n     * Finalize the tile info's feature group.\n     */\n    finish() {\n        ExtendedTileInfo.finish(this.tileInfo);\n    }\n    addText(name) {\n        return this.addStringValue(name, this.tileInfo.textCatalog, this.stringMap);\n    }\n    addLayer(name) {\n        return this.addStringValue(name, this.tileInfo.layerCatalog, this.layerMap);\n    }\n    addClass(name) {\n        return this.addStringValue(name, this.tileInfo.classCatalog, this.classMap);\n    }\n    addType(name) {\n        return this.addStringValue(name, this.tileInfo.typeCatalog, this.typeMap);\n    }\n    // Add a string to the strings catalog. Returns index into the catalog.\n    addStringValue(str, catalog, map) {\n        if (str === undefined || str === null) {\n            return -1;\n        }\n        const name = str.toString();\n        let i = map.get(name);\n        if (i !== undefined) {\n            return i;\n        }\n        i = catalog.length;\n        catalog.push(name);\n        map.set(name, i);\n        return i;\n    }\n}\nexports.ExtendedTileInfoWriter = ExtendedTileInfoWriter;\n/**\n * Implementation of [[ExtendedTileInfoPolygonAccessor]].\n */\nclass ExtendedTileInfoPolygonAccessorImpl {\n    constructor() {\n        /**\n         * Feature's index in the group.\n         */\n        this.featureIndex = 0;\n        /**\n         * Indicates where the ring starts.\n         */\n        this.ringStart = 0;\n        /**\n         * Number of rings.\n         */\n        this.numRings = 0;\n    }\n    /**\n     * Setup the accessor for extended [[TileInfo]].\n     *\n     * @param polygons polygons feature group.\n     * @param featureIndex feature's index in the group.\n     * @param ringStart where the ring starts.\n     * @param numRings number of rings.\n     */\n    setup(polygons, featureIndex, ringStart, numRings) {\n        this.polygons = polygons;\n        this.featureIndex = featureIndex;\n        this.ringStart = ringStart;\n        this.numRings = numRings;\n    }\n    /**\n     * Shut down the accessor and free all references.\n     */\n    reset() {\n        this.polygons = undefined;\n        this.featureIndex = 0;\n        this.ringStart = 0;\n        this.numRings = 0;\n    }\n    isOuterRing(ringIndex) {\n        harp_utils_1.assert(ringIndex >= 0);\n        harp_utils_1.assert(ringIndex < this.numRings);\n        harp_utils_1.assert(this.polygons !== undefined);\n        if (ringIndex < 0 || ringIndex >= this.numRings || this.polygons === undefined) {\n            throw new Error(\"ExtendedTileInfoPolygonAccessor: Invalid ring index\");\n        }\n        return this.polygons.innerRingIsOuterContour[this.ringStart + ringIndex] !== 0;\n    }\n    getPoints(ringIndex) {\n        harp_utils_1.assert(ringIndex >= 0);\n        harp_utils_1.assert(ringIndex < this.numRings);\n        harp_utils_1.assert(this.polygons !== undefined);\n        if (ringIndex < 0 || ringIndex >= this.numRings || this.polygons === undefined) {\n            throw new Error(\"ExtendedTileInfoPolygonAccessor: Invalid ring index\");\n        }\n        // compute the start/size of the points in this ring. All `points` are actually just the\n        // indices of a single X/Y coordinate.\n        const pointsStart = this.polygons.innerRingStartIndex[this.ringStart + ringIndex];\n        let numPointValues;\n        if (ringIndex < this.numRings - 1) {\n            numPointValues =\n                this.polygons.innerRingStartIndex[this.ringStart + ringIndex + 1] - pointsStart;\n        }\n        else {\n            if (this.ringStart + ringIndex < this.polygons.innerRingStartIndex.length - 1) {\n                numPointValues =\n                    this.polygons.innerRingStartIndex[this.ringStart + ringIndex + 1] - pointsStart;\n            }\n            else {\n                numPointValues = this.polygons.positions.length - pointsStart;\n            }\n        }\n        return {\n            points: this.polygons.positions,\n            pointsStart,\n            numPointValues\n        };\n    }\n}\n/**\n * Supporting class for [[ExtendedTileInfo]]. Takes an [[ExtendedTileInfoHandler]] and calls an\n * `accept` for every feature of the [[ExtendedTileInfo]], or just all features of a specified\n * `featureId`.\n */\nclass ExtendedTileInfoVisitor {\n    constructor(tileInfo) {\n        this.tileInfo = tileInfo;\n    }\n    /**\n     * Visit all feature in the [[ExtendedTileInfo]]\n     *\n     * @param handler Let the `handler` visit all features.\n     */\n    visitAll(handler) {\n        this.visitAllPointFeatures(handler);\n        this.visitAllLineFeatures(handler);\n        this.visitAllPolygonFeatures(handler);\n    }\n    /**\n     * Visit all features of a specified featureId.\n     *\n     * @param featureId The featureId to visit.\n     * @param handler The `handler` to use.\n     */\n    visitFeature(featureId, handler) {\n        let numFeaturesFound = 0;\n        const numPointFeatures = this.tileInfo.pointGroup.numFeatures;\n        const pointFeatures = this.tileInfo.pointGroup.featureIds;\n        for (let i = 0; i < numPointFeatures; i++) {\n            if (pointFeatures[i] === featureId) {\n                numFeaturesFound++;\n                this.visitPointFeature(i, handler);\n            }\n        }\n        const numLineFeatures = this.tileInfo.lineGroup.numFeatures;\n        const lineFeatures = this.tileInfo.lineGroup.featureIds;\n        for (let i = 0; i < numLineFeatures; i++) {\n            if (lineFeatures[i] === featureId) {\n                numFeaturesFound++;\n                this.visitLineFeature(i, handler);\n            }\n        }\n        const numPolygonFeatures = this.tileInfo.polygonGroup.numFeatures;\n        const polygonsFeatures = this.tileInfo.polygonGroup.featureIds;\n        for (let i = 0; i < numPolygonFeatures; i++) {\n            if (polygonsFeatures[i] === featureId) {\n                numFeaturesFound++;\n                this.visitPolygonFeature(i, handler);\n            }\n        }\n        return numFeaturesFound;\n    }\n    /**\n     * Visit all `POINT` features.\n     *\n     * @param handler The `handler` to use.\n     */\n    visitAllPointFeatures(handler) {\n        const numFeatures = this.tileInfo.pointGroup.numFeatures;\n        for (let i = 0; i < numFeatures; i++) {\n            this.visitPointFeature(i, handler);\n        }\n    }\n    /**\n     * Visit all `LINESTRING` features.\n     *\n     * @param handler The handler to use.\n     */\n    visitAllLineFeatures(handler) {\n        const numFeatures = this.tileInfo.lineGroup.numFeatures;\n        for (let i = 0; i < numFeatures; i++) {\n            this.visitLineFeature(i, handler);\n        }\n    }\n    /**\n     * Visit all `POLYGON` features.\n     *\n     * @param handler The `handler` to use.\n     */\n    visitAllPolygonFeatures(handler) {\n        const numFeatures = this.tileInfo.polygonGroup.numFeatures;\n        for (let i = 0; i < numFeatures; i++) {\n            this.visitPolygonFeature(i, handler);\n        }\n    }\n    getTag(featureIndex, index) {\n        return index !== undefined && index[featureIndex] >= 0 ? index[featureIndex] : -1;\n    }\n    /**\n     * Call the `handler` on a point feature.\n     *\n     * @param featureIndex The index of the feature into the feature table.\n     * @param handler The `handler` to use.\n     */\n    visitPointFeature(featureIndex, handler) {\n        const tileInfo = this.tileInfo;\n        const points = tileInfo.pointGroup;\n        const start = points.positionIndex[featureIndex];\n        const x = points.positions[start];\n        const y = points.positions[start + 1];\n        if (!!handler.acceptPoint) {\n            handler.acceptPoint(points.featureIds[featureIndex], points.techniqueIndex[featureIndex], x, y, points.textIndex[featureIndex], this.getTag(featureIndex, points.layerIndex), this.getTag(featureIndex, points.classIndex), this.getTag(featureIndex, points.typeIndex));\n        }\n    }\n    /**\n     * Call the `handler` on a line feature.\n     *\n     * @param featureIndex The index of the feature into the feature table.\n     * @param handler The `handler` to use.\n     */\n    visitLineFeature(featureIndex, handler) {\n        const tileInfo = this.tileInfo;\n        const lines = tileInfo.lineGroup;\n        const numFeatures = lines.numFeatures;\n        const positionsStart = lines.positionIndex[featureIndex];\n        const numPointValues = featureIndex === numFeatures - 1\n            ? lines.positions.length - positionsStart\n            : lines.positionIndex[featureIndex + 1] - positionsStart;\n        let segmentId;\n        let startOffset;\n        let endOffset;\n        if (lines.segmentIds !== undefined) {\n            segmentId = lines.segmentIds[featureIndex];\n            startOffset = lines.segmentStartOffsets[featureIndex];\n            endOffset = lines.segmentEndOffsets[featureIndex];\n        }\n        if (!!handler.acceptLine) {\n            handler.acceptLine(lines.featureIds[featureIndex], lines.techniqueIndex[featureIndex], lines.textIndex[featureIndex], this.getTag(featureIndex, lines.layerIndex), this.getTag(featureIndex, lines.classIndex), this.getTag(featureIndex, lines.typeIndex), tileInfo.lineGroup.positions, positionsStart, numPointValues, segmentId, startOffset, endOffset);\n        }\n    }\n    /**\n     * Call the `handler` on a polygon feature.\n     *\n     * @param featureIndex The index of the feature into the feature table.\n     * @param handler The `handler` to use.\n     */\n    visitPolygonFeature(featureIndex, handler) {\n        if (handler.acceptPolygon === undefined) {\n            return;\n        }\n        const tileInfo = this.tileInfo;\n        const polygons = tileInfo.polygonGroup;\n        const numFeatures = polygons.numFeatures;\n        const ringStart = polygons.outerRingStartIndex[featureIndex];\n        const numRings = featureIndex === numFeatures - 1\n            ? polygons.innerRingStartIndex.length - ringStart\n            : polygons.outerRingStartIndex[featureIndex + 1] - ringStart;\n        // Use a static instance, so we do not allocate anything here\n        ExtendedTileInfoVisitor.polygonAccessor.setup(polygons, featureIndex, ringStart, numRings);\n        handler.acceptPolygon(polygons.featureIds[featureIndex], polygons.techniqueIndex[featureIndex], polygons.textIndex[featureIndex], this.getTag(featureIndex, polygons.layerIndex), this.getTag(featureIndex, polygons.classIndex), this.getTag(featureIndex, polygons.typeIndex), ExtendedTileInfoVisitor.polygonAccessor);\n        // Free all data references.\n        ExtendedTileInfoVisitor.polygonAccessor.reset();\n    }\n}\nexports.ExtendedTileInfoVisitor = ExtendedTileInfoVisitor;\n// static instance to work without allocations.\nExtendedTileInfoVisitor.polygonAccessor = new ExtendedTileInfoPolygonAccessorImpl();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/TileInfo.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Allows to cancel and prioritize requests inside the requestQueue. Useful to optimize the order of\n * decoding tiles during animations and camera movements.\n *\n * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.\n */\nclass RequestController {\n    /**\n     * Creates an instance of `RequestController`.\n     *\n     * @param {number} priority\n     * @param {AbortController} abortController Optional [[AbortController]] used internally, since\n     *      [[AbortController]]s should not be subclassed.\n     */\n    constructor(priority = 0, abortController = new AbortController()) {\n        this.priority = priority;\n        this.abortController = abortController;\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and\n     * signal to any observers that the associated activity is to be aborted.\n     */\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.RequestController = RequestController;\n/**\n * Communication protocol with [[ITileDecoder]].\n */\nvar WorkerDecoderProtocol;\n(function (WorkerDecoderProtocol) {\n    /**\n     * Define possible names of messages exchanged with decoder services within `WebWorker`.\n     */\n    let DecoderMessageName;\n    (function (DecoderMessageName) {\n        DecoderMessageName[\"Configuration\"] = \"configuration\";\n    })(DecoderMessageName = WorkerDecoderProtocol.DecoderMessageName || (WorkerDecoderProtocol.DecoderMessageName = {}));\n    /**\n     * Type guard to check if an object is an instance of `ConfigurationMessage`.\n     */\n    function isConfigurationMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === DecoderMessageName.Configuration);\n    }\n    WorkerDecoderProtocol.isConfigurationMessage = isConfigurationMessage;\n    /**\n     * Define possible names of requests called on decoder services within `WebWorker`.\n     */\n    let Requests;\n    (function (Requests) {\n        Requests[\"DecodeTileRequest\"] = \"decode-tile-request\";\n        Requests[\"TileInfoRequest\"] = \"tile-info-request\";\n    })(Requests = WorkerDecoderProtocol.Requests || (WorkerDecoderProtocol.Requests = {}));\n    /**\n     * Type guard to check if an object is a decoded tile object sent to a worker.\n     */\n    function isDecodeTileRequest(message) {\n        return (message &&\n            typeof message.type === \"string\" &&\n            message.type === Requests.DecodeTileRequest);\n    }\n    WorkerDecoderProtocol.isDecodeTileRequest = isDecodeTileRequest;\n    /**\n     * Type guard to check if an object is an info tile object sent to a worker.\n     */\n    function isTileInfoRequest(message) {\n        return (message && typeof message.type === \"string\" && message.type === Requests.TileInfoRequest);\n    }\n    WorkerDecoderProtocol.isTileInfoRequest = isTileInfoRequest;\n})(WorkerDecoderProtocol = exports.WorkerDecoderProtocol || (exports.WorkerDecoderProtocol = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Common communication protocol for [[WorkerService]].\n */\nvar WorkerServiceProtocol;\n(function (WorkerServiceProtocol) {\n    /**\n     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service\n     * instances in workers.\n     */\n    WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID = \"worker-service-manager\";\n    /**\n     * Define possible names of messages exchanged with services within `WebWorker`.\n     */\n    let ServiceMessageName;\n    (function (ServiceMessageName) {\n        ServiceMessageName[\"Initialized\"] = \"initialized\";\n        ServiceMessageName[\"Request\"] = \"request\";\n        ServiceMessageName[\"Response\"] = \"response\";\n    })(ServiceMessageName = WorkerServiceProtocol.ServiceMessageName || (WorkerServiceProtocol.ServiceMessageName = {}));\n    /**\n     * Type guard to check if an object is a signal message from worker.\n     */\n    function isInitializedMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Initialized);\n    }\n    WorkerServiceProtocol.isInitializedMessage = isInitializedMessage;\n    /**\n     * Define possible names of requests called on services within `WebWorker`.\n     */\n    let Requests;\n    (function (Requests) {\n        Requests[\"CreateService\"] = \"create-service\";\n        Requests[\"DestroyService\"] = \"destroy-service\";\n    })(Requests = WorkerServiceProtocol.Requests || (WorkerServiceProtocol.Requests = {}));\n    /**\n     * Test if `error` thrown by [[CreateServiceRequest]] was caused by unknown type of service.\n     */\n    function isUnknownServiceError(error) {\n        return /unknown targetServiceType requested: /.test(error.message);\n    }\n    WorkerServiceProtocol.isUnknownServiceError = isUnknownServiceError;\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    function isRequestMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Request);\n    }\n    WorkerServiceProtocol.isRequestMessage = isRequestMessage;\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    function isResponseMessage(message) {\n        return (message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Response);\n    }\n    WorkerServiceProtocol.isResponseMessage = isResponseMessage;\n})(WorkerServiceProtocol = exports.WorkerServiceProtocol || (exports.WorkerServiceProtocol = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/WorkerServiceProtocol.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Communication protocol with [[ITiler]].\n */\nvar WorkerTilerProtocol;\n(function (WorkerTilerProtocol) {\n    /**\n     * Define possible names of requests called on tiler services within `WebWorker`.\n     */\n    let Requests;\n    (function (Requests) {\n        Requests[\"RegisterIndex\"] = \"register-index\";\n        Requests[\"UpdateIndex\"] = \"update-index\";\n        Requests[\"TileRequest\"] = \"tile-request\";\n    })(Requests = WorkerTilerProtocol.Requests || (WorkerTilerProtocol.Requests = {}));\n    /**\n     * Type guard to check if an object is an index registration request sent to a worker.\n     */\n    function isRegisterIndexRequest(message) {\n        return (message && typeof message.type === \"string\" && message.type === Requests.RegisterIndex);\n    }\n    WorkerTilerProtocol.isRegisterIndexRequest = isRegisterIndexRequest;\n    /**\n     * Type guard to check if an object is an update request for the index registration.\n     */\n    function isUpdateIndexRequest(message) {\n        return message && typeof message.type === \"string\" && message.type === Requests.UpdateIndex;\n    }\n    WorkerTilerProtocol.isUpdateIndexRequest = isUpdateIndexRequest;\n    /**\n     * Type guard to check if an object is a tile request sent to a worker.\n     */\n    function isTileRequest(message) {\n        return message && typeof message.type === \"string\" && message.type === Requests.TileRequest;\n    }\n    WorkerTilerProtocol.isTileRequest = isTileRequest;\n})(WorkerTilerProtocol = exports.WorkerTilerProtocol || (exports.WorkerTilerProtocol = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/WorkerTilerProtocol.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst operators = {\n    at: {\n        call: (context, call) => {\n            const args = call.args;\n            const index = context.evaluate(args[0]);\n            if (typeof index !== \"number\") {\n                throw new Error(`expected the index of the element to retrieve`);\n            }\n            const value = context.evaluate(args[1]);\n            if (!Array.isArray(value)) {\n                throw new Error(`expected an array`);\n            }\n            return index >= 0 && index < value.length ? value[index] : null;\n        }\n    }\n};\nexports.ArrayOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ArrayOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst operators = {\n    \"to-boolean\": {\n        call: (context, call) => {\n            return Boolean(context.evaluate(call.args[0]));\n        }\n    },\n    \"to-string\": {\n        call: (context, call) => {\n            return String(context.evaluate(call.args[0]));\n        }\n    },\n    \"to-number\": {\n        call: (context, call) => {\n            for (const arg of call.args) {\n                const value = Number(context.evaluate(arg));\n                if (!isNaN(value)) {\n                    return value;\n                }\n            }\n            throw new Error(\"cannot convert the value to a number\");\n        }\n    }\n};\nexports.CastOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/CastOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst ColorUtils_1 = __webpack_require__(/*! ../ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\nconst StringEncodedNumeral_1 = __webpack_require__(/*! ../StringEncodedNumeral */ \"./node_modules/@here/harp-datasource-protocol/lib/StringEncodedNumeral.js\");\nconst operators = {\n    alpha: {\n        call: (context, call) => {\n            let color = context.evaluate(call.args[0]);\n            if (typeof color === \"string\") {\n                color = StringEncodedNumeral_1.parseStringEncodedColor(color);\n            }\n            const alpha = typeof color === \"number\" ? ColorUtils_1.ColorUtils.getAlphaFromHex(color) : 1;\n            return alpha;\n        }\n    },\n    rgba: {\n        call: (context, call) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            const a = context.evaluate(call.args[3]);\n            if (typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                typeof a === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0 &&\n                a >= 0 &&\n                a <= 1) {\n                return rgbaToHex(r, g, b, a);\n            }\n            throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);\n        }\n    },\n    rgb: {\n        call: (context, call) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            if (typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0) {\n                return rgbToHex(r, g, b);\n            }\n            throw new Error(`unknown color 'rgb(${r},${g},${b})'`);\n        }\n    },\n    // Hsl operator contains angle modulated to <0, 360> range, percent of\n    // saturation and lightness in <0, 100> range, i.e. hsl(360, 100, 100)\n    hsl: {\n        call: (context, call) => {\n            const h = context.evaluate(call.args[0]);\n            const s = context.evaluate(call.args[1]);\n            const l = context.evaluate(call.args[2]);\n            if (typeof h === \"number\" &&\n                typeof s === \"number\" &&\n                typeof l === \"number\" &&\n                h >= 0 &&\n                s >= 0 &&\n                l >= 0) {\n                return hslToHex(h, s, l);\n            }\n            throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);\n        }\n    }\n};\nfunction rgbaToHex(r, g, b, a) {\n    // We decode rgba color channels using custom hex format with transparency.\n    return ColorUtils_1.ColorUtils.getHexFromRgba(THREE.Math.clamp(r, 0, 255) / 255, THREE.Math.clamp(g, 0, 255) / 255, THREE.Math.clamp(b, 0, 255) / 255, THREE.Math.clamp(a, 0, 1));\n}\nfunction rgbToHex(r, g, b) {\n    return ColorUtils_1.ColorUtils.getHexFromRgb(THREE.Math.clamp(r, 0, 255) / 255, THREE.Math.clamp(g, 0, 255) / 255, THREE.Math.clamp(b, 0, 255) / 255);\n}\nfunction hslToHex(h, s, l) {\n    return ColorUtils_1.ColorUtils.getHexFromHsl(THREE.Math.euclideanModulo(h, 360) / 360, THREE.Math.clamp(s, 0, 100) / 100, THREE.Math.clamp(l, 0, 100) / 100);\n}\nexports.ColorOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ColorOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction compare(context, call, strict = false) {\n    const left = context.evaluate(call.args[0]);\n    const right = context.evaluate(call.args[1]);\n    if (!((typeof left === \"number\" && typeof right === \"number\") ||\n        (typeof left === \"string\" && typeof right === \"string\"))) {\n        if (strict) {\n            throw new Error(`invalid operands '${left}' and '${right}' for operator '${call.op}'`);\n        }\n    }\n    switch (call.op) {\n        case \"<\":\n            return left < right;\n        case \">\":\n            return left > right;\n        case \"<=\":\n            return left <= right;\n        case \">=\":\n            return left >= right;\n        default:\n            throw new Error(`invalid comparison operator '${call.op}'`);\n    }\n}\nconst operators = {\n    \"!\": {\n        call: (context, call) => {\n            return !context.evaluate(call.args[0]);\n        }\n    },\n    \"==\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left === right;\n        }\n    },\n    \"!=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left !== right;\n        }\n    },\n    \"<\": { call: (context, call) => compare(context, call) },\n    \">\": { call: (context, call) => compare(context, call) },\n    \"<=\": { call: (context, call) => compare(context, call) },\n    \">=\": { call: (context, call) => compare(context, call) }\n};\nexports.ComparisonOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ComparisonOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst operators = {\n    \"geometry-type\": {\n        call: (context, call) => {\n            const geometryType = context.env.lookup(\"$geometryType\");\n            switch (geometryType) {\n                case \"point\":\n                    return \"Point\";\n                case \"line\":\n                    return \"LineString\";\n                case \"polygon\":\n                    return \"Polygon\";\n                default:\n                    return null;\n            }\n        }\n    }\n};\nexports.FeatureOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/FeatureOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction conditionalCast(context, type, args) {\n    switch (type) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n            for (const childExpr of args) {\n                const value = context.evaluate(childExpr);\n                if (typeof value === type) {\n                    return value;\n                }\n            }\n            throw new Error(`expected a '${type}'`);\n        default:\n            throw new Error(`invalid type '${type}'`);\n    } // switch\n}\nconst operators = {\n    all: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                if (!context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n    any: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n    none: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n    boolean: {\n        call: (context, call) => {\n            return conditionalCast(context, \"boolean\", call.args);\n        }\n    },\n    number: {\n        call: (context, call) => {\n            return conditionalCast(context, \"number\", call.args);\n        }\n    },\n    string: {\n        call: (context, call) => {\n            return conditionalCast(context, \"string\", call.args);\n        }\n    }\n};\nexports.FlowOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/FlowOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/InterpolationOperators.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/InterpolationOperators.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst InterpolatedProperty_1 = __webpack_require__(/*! ../InterpolatedProperty */ \"./node_modules/@here/harp-datasource-protocol/lib/InterpolatedProperty.js\");\n/**\n * Evaluates the given piecewise function.\n */\nfunction step(context, call) {\n    const { args } = call;\n    const value = context.evaluate(args[0]);\n    if (value === null) {\n        // returns the default value of step.\n        return context.evaluate(args[1]);\n    }\n    if (typeof value !== \"number\") {\n        throw new Error(`the input of a 'step' operator must have type 'number'`);\n    }\n    let first = 1;\n    let last = args.length / 2 - 1;\n    while (first < last) {\n        // tslint:disable-next-line: no-bitwise\n        const mid = (first + last) >>> 1;\n        const stop = args[mid * 2].value;\n        if (value < stop) {\n            last = mid - 1;\n        }\n        else if (value > stop) {\n            first = mid + 1;\n        }\n        else {\n            last = mid;\n        }\n    }\n    const result = args[first * 2];\n    if (!(result instanceof Expr_1.NumberLiteralExpr)) {\n        throw new Error(\"expected a numeric literal\");\n    }\n    const index = result.value <= value ? first : first - 1;\n    return context.evaluate(args[index * 2 + 1]);\n}\n/**\n * Prepare and validate the \"interpolate\" call.\n *\n * @param call An [[Expr]] representing an \"interpolate\" call.\n * @hidden\n */\nfunction prepareInterpolateCallExpr(call) {\n    if (call._interpolatedProperty || call._mode !== undefined) {\n        return;\n    }\n    const interpolatorType = call.args[0];\n    if (!(interpolatorType instanceof Expr_1.CallExpr)) {\n        throw new Error(\"expected an interpolation type\");\n    }\n    let mode;\n    let exponent;\n    if (interpolatorType.op === \"linear\") {\n        mode = \"Linear\";\n    }\n    else if (interpolatorType.op === \"discrete\") {\n        mode = \"Discrete\";\n    }\n    else if (interpolatorType.op === \"cubic\") {\n        mode = \"Cubic\";\n    }\n    else if (interpolatorType.op === \"exponential\") {\n        mode = \"Exponential\";\n        const base = interpolatorType.args[0];\n        if (!(base instanceof Expr_1.NumberLiteralExpr)) {\n            throw new Error(\"expected the base of the exponential interpolation\");\n        }\n        exponent = base.value;\n    }\n    else {\n        throw new Error(\"unrecognized interpolation type\");\n    }\n    const input = call.args[1];\n    if (!(input instanceof Expr_1.CallExpr)) {\n        throw new Error(\"expected the input of the interpolation\");\n    }\n    if (input.op !== \"zoom\") {\n        throw new Error(\"only 'zoom' is supported\");\n    }\n    if (call.args.length === 2 || call.args.length % 2) {\n        throw new Error(\"invalid number of samples\");\n    }\n    const stops = [];\n    const values = [];\n    let isConstantInterpolation = true;\n    for (let i = 2; i < call.args.length; i += 2) {\n        const stop = call.args[i];\n        if (!(stop instanceof Expr_1.NumberLiteralExpr)) {\n            throw new Error(\"expected a numeric literal\");\n        }\n        if (stops.length > 0 && stop.value === stops[stops.length - 1]) {\n            stops[stops.length - 1] = stop.value - 0.0000001;\n        }\n        stops.push(stop.value);\n        if (isConstantInterpolation) {\n            const value = call.args[i + 1];\n            if (value instanceof Expr_1.LiteralExpr) {\n                values.push(value.value);\n            }\n            else {\n                isConstantInterpolation = false;\n            }\n        }\n    }\n    if (isConstantInterpolation) {\n        const result = InterpolatedProperty_1.createInterpolatedProperty({\n            interpolation: mode,\n            exponent,\n            zoomLevels: stops,\n            values\n        });\n        if (!result) {\n            throw new Error(\"failed to create interpolation\");\n        }\n        call._interpolatedProperty = result;\n    }\n    else {\n        call._mode = mode;\n        call._exponent = exponent;\n        call._stops = stops;\n    }\n}\n/**\n * Classify the given `step` call.\n *\n * This function checks the input of the `step` and ensures that the stops\n * are literals.\n *\n * @param call A call to `[\"step\", ...]`.\n * @hidden\n */\nfunction classifyStepCallExpr(call) {\n    if (call._inputIsZoom !== undefined) {\n        // nothing to do, the `call` was already classified.\n        return;\n    }\n    if (call.args[0] === undefined) {\n        throw new Error(\"expected the input of the 'step' operator\");\n    }\n    if (call.args.length < 3 || call.args.length % 2) {\n        throw new Error(\"not enough arguments\");\n    }\n    const input = call.args[0];\n    // tslint:disable-next-line: prefer-conditional-expression\n    if (input instanceof Expr_1.CallExpr && input.op === \"zoom\") {\n        call._inputIsZoom = true;\n    }\n    else {\n        call._inputIsZoom = false;\n    }\n    // check that the stops are literals.\n    for (let i = 2; i < call.args.length; i += 2) {\n        const stop = call.args[i];\n        if (!(stop instanceof Expr_1.NumberLiteralExpr)) {\n            throw new Error(\"expected a numeric literal\");\n        }\n    }\n}\n/**\n * Prepares the given call for the dynamic exception.\n * This method collects the stops and\n *\n * @param call A call to `[\"step\", ...]`.\n * @hidden\n */\nfunction prepareStepCallExpr(call) {\n    if (call._stops || call._interpolatedProperty) {\n        // nothing to do, the `call` was already prepared for execution.\n        return;\n    }\n    // collect the stops of the step call.\n    const stops = [Number.MIN_SAFE_INTEGER];\n    for (let i = 2; i < call.args.length; i += 2) {\n        const stop = call.args[i];\n        stops.push(stop.value);\n    }\n    // collect the values of the step call.\n    const values = [];\n    let hasConstantValues = true;\n    for (let i = 1; hasConstantValues && i < call.args.length; i += 2) {\n        const literal = call.args[i];\n        if (literal instanceof Expr_1.LiteralExpr) {\n            values.push(literal.value);\n        }\n        else {\n            hasConstantValues = false;\n        }\n    }\n    if (hasConstantValues) {\n        // all the values of this zoom-based `step` are constant,\n        // create an interpolated property and store it together\n        // with the call.\n        const interpolatedProperty = InterpolatedProperty_1.createInterpolatedProperty({\n            interpolation: \"Discrete\",\n            zoomLevels: stops,\n            values\n        });\n        if (interpolatedProperty === undefined) {\n            throw new Error(\"failed to create interpolator\");\n        }\n        call._interpolatedProperty = interpolatedProperty;\n    }\n    else {\n        // the values the `[\"step\"]` call are not constants,\n        // cache the `zoomLevels` to avoid recreating input `Array`\n        // when instantiating a new [[InterpolatedProperty]].\n        call._stops = stops;\n    }\n}\nconst operators = {\n    interpolate: {\n        isDynamicOperator: (call) => {\n            return call.args[1] && call.args[1].isDynamic();\n        },\n        call: (context, call) => {\n            prepareInterpolateCallExpr(call);\n            if (context.scope !== Expr_1.ExprScope.Dynamic) {\n                return call;\n            }\n            let interpolatedProperty = call._interpolatedProperty;\n            if (!interpolatedProperty) {\n                const values = [];\n                for (let i = 2; i < call.args.length; i += 2) {\n                    const value = context.evaluate(call.args[i + 1]);\n                    values.push(value);\n                }\n                interpolatedProperty = InterpolatedProperty_1.createInterpolatedProperty({\n                    interpolation: call._mode,\n                    exponent: call._exponent,\n                    zoomLevels: call._stops,\n                    values\n                });\n                if (interpolatedProperty === undefined) {\n                    throw new Error(\"failed to create interpolator\");\n                }\n            }\n            return InterpolatedProperty_1.getPropertyValue(interpolatedProperty, context.env);\n        }\n    },\n    step: {\n        isDynamicOperator: (call) => {\n            return call.args[0] && call.args[0].isDynamic();\n        },\n        call: (context, call) => {\n            classifyStepCallExpr(call);\n            if (context.scope === Expr_1.ExprScope.Value) {\n                return call;\n            }\n            if (context.scope === Expr_1.ExprScope.Condition || call._inputIsZoom === false) {\n                return step(context, call);\n            }\n            prepareStepCallExpr(call);\n            let interpolatedProperty = call._interpolatedProperty;\n            if (!interpolatedProperty) {\n                // the values of the interpolation are not literals,\n                // evaluate the sub expressions and combine them\n                // with the constant stops computed when preparing this call.\n                const values = [];\n                for (let i = 1; i < call.args.length; i += 2) {\n                    const value = context.evaluate(call.args[i]);\n                    values.push(value);\n                }\n                interpolatedProperty = InterpolatedProperty_1.createInterpolatedProperty({\n                    interpolation: \"Discrete\",\n                    zoomLevels: call._stops,\n                    values\n                });\n                if (interpolatedProperty === undefined) {\n                    throw new Error(\"failed to create interpolator\");\n                }\n            }\n            return InterpolatedProperty_1.getPropertyValue(interpolatedProperty, context.env);\n        }\n    }\n};\nexports.InterpolationOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/InterpolationOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Expr_1 = __webpack_require__(/*! ../Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst operators = {\n    \"ppi-scale\": {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;\n            return value * scaleFactor;\n        }\n    },\n    \"world-ppi-scale\": {\n        isDynamicOperator: () => {\n            return true;\n        },\n        call: (context, call) => {\n            const pixels = context.evaluate(call.args[0]);\n            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;\n            const zoom = context.env.lookup(\"$zoom\");\n            const zoomWidth = Math.pow(2, 17) / Math.pow(2, zoom);\n            const v = pixels * zoomWidth * scaleFactor;\n            return v;\n        }\n    },\n    \"world-discrete-ppi-scale\": {\n        isDynamicOperator: () => {\n            return true;\n        },\n        call: (context, call) => {\n            const pixels = context.evaluate(call.args[0]);\n            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;\n            const zoom = context.env.lookup(\"$zoom\");\n            const zoomWidthDiscrete = Math.pow(2, 17) / Math.pow(2, Math.floor(zoom));\n            const v = pixels * zoomWidthDiscrete * scaleFactor;\n            return v;\n        }\n    },\n    ppi: {\n        call: (context) => {\n            const ppi = context.env.lookup(\"$ppi\");\n            if (typeof ppi === \"number\") {\n                return ppi;\n            }\n            return 72;\n        }\n    },\n    zoom: {\n        isDynamicOperator: () => {\n            return true;\n        },\n        call: (context) => {\n            if (context.scope === Expr_1.ExprScope.Condition) {\n                const zoom = context.env.lookup(\"$zoom\");\n                if (zoom !== undefined) {\n                    return zoom;\n                }\n                throw new Error(\"failed to get the zoom level.\");\n            }\n            // direct usages of 'zoom' outside technique filter conditions\n            // and interpolations are not allowed.\n            throw new Error(\"invalid usage of the 'zoom' operator.\");\n        }\n    }\n};\nexports.MapOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/MapOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst operators = {\n    \"^\": {\n        call: (context, call) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                // tslint:disable-next-line: max-line-length\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '^'`);\n            }\n            return Math.pow(a, b);\n        }\n    },\n    \"-\": {\n        call: (context, call) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '-'`);\n            }\n            return a - b;\n        }\n    },\n    \"/\": {\n        call: (context, call) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                // tslint:disable-next-line: max-line-length\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '/'`);\n            }\n            return a / b;\n        }\n    },\n    \"%\": {\n        call: (context, call) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                // tslint:disable-next-line: max-line-length\n                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '%'`);\n            }\n            return a % b;\n        }\n    },\n    \"+\": {\n        call: (context, call) => {\n            return call.args.reduce((a, b) => Number(a) + Number(context.evaluate(b)), 0);\n        }\n    },\n    \"*\": {\n        call: (context, call) => {\n            return call.args.reduce((a, b) => Number(a) * Number(context.evaluate(b)), 1);\n        }\n    },\n    abs: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'abs'`);\n            }\n            return Math.abs(value);\n        }\n    },\n    acos: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'acos'`);\n            }\n            return Math.acos(value);\n        }\n    },\n    asin: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'asin'`);\n            }\n            return Math.asin(value);\n        }\n    },\n    atan: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'atan'`);\n            }\n            return Math.atan(value);\n        }\n    },\n    ceil: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ceil'`);\n            }\n            return Math.ceil(value);\n        }\n    },\n    cos: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'cos'`);\n            }\n            return Math.cos(value);\n        }\n    },\n    e: {\n        call: () => {\n            return Math.E;\n        }\n    },\n    floor: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'floor'`);\n            }\n            return Math.floor(value);\n        }\n    },\n    ln: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln'`);\n            }\n            return Math.log(value);\n        }\n    },\n    ln2: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln2'`);\n            }\n            return Math.log2(value);\n        }\n    },\n    log10: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'log10'`);\n            }\n            return Math.log10(value);\n        }\n    },\n    max: {\n        call: (context, call) => {\n            return Math.max(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n    min: {\n        call: (context, call) => {\n            return Math.min(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n    /**\n     * Clamp numeric value to given range, inclusive.\n     *\n     * Synopsis:\n     * ```\n     * [\"clamp\", v: number, min: number, max: number]`\n     * ```\n     */\n    clamp: {\n        call: (context, call) => {\n            const v = context.evaluate(call.args[0]);\n            const min = context.evaluate(call.args[1]);\n            const max = context.evaluate(call.args[2]);\n            if (typeof v !== \"number\" || typeof min !== \"number\" || typeof max !== \"number\") {\n                throw new Error(`invalid operands '${v}', ${min}, ${max} for operator 'clamp'`);\n            }\n            return THREE.Math.clamp(v, min, max);\n        }\n    },\n    pi: {\n        call: () => {\n            return Math.PI;\n        }\n    },\n    round: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'round'`);\n            }\n            return Math.round(value);\n        }\n    },\n    sin: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sin'`);\n            }\n            return Math.sin(value);\n        }\n    },\n    sqrt: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sqrt'`);\n            }\n            return Math.sqrt(value);\n        }\n    },\n    tan: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'tan'`);\n            }\n            return Math.tan(value);\n        }\n    }\n};\nexports.MathOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/MathOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst operators = {\n    length: {\n        call: (context, call) => {\n            const value = context.evaluate(call.args[0]);\n            if (Array.isArray(value) || typeof value === \"string\") {\n                return value.length;\n            }\n            throw new Error(`invalid operand '${value}' for operator 'length'`);\n        }\n    },\n    coalesce: {\n        call: (context, call) => {\n            for (const childExpr of call.args) {\n                const value = context.evaluate(childExpr);\n                if (value !== null) {\n                    return value;\n                }\n            }\n            return null;\n        }\n    }\n};\nexports.MiscOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/MiscOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nvar LookupMode;\n(function (LookupMode) {\n    LookupMode[LookupMode[\"get\"] = 0] = \"get\";\n    LookupMode[LookupMode[\"has\"] = 1] = \"has\";\n})(LookupMode || (LookupMode = {}));\nfunction lookupMember(context, args, lookupMode) {\n    const memberName = context.evaluate(args[0]);\n    if (typeof memberName !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    const object = context.evaluate(args[1]);\n    if (object && typeof object === \"object\" && hasOwnProperty.call(object, memberName)) {\n        return lookupMode === LookupMode.get ? object[memberName] : true;\n    }\n    return lookupMode === LookupMode.get ? null : false;\n}\nconst operators = {\n    get: {\n        call: (context, call) => lookupMember(context, call.args, LookupMode.get)\n    },\n    has: {\n        call: (context, call) => lookupMember(context, call.args, LookupMode.has)\n    }\n};\nexports.ObjectOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/ObjectOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst operators = {\n    concat: {\n        call: (context, call) => {\n            return \"\".concat(...call.args.map(a => String(context.evaluate(a))));\n        }\n    },\n    downcase: {\n        call: (context, call) => {\n            return String(context.evaluate(call.args[0])).toLocaleLowerCase();\n        }\n    },\n    upcase: {\n        call: (context, call) => {\n            return String(context.evaluate(call.args[0])).toLocaleUpperCase();\n        }\n    },\n    \"~=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.indexOf(right) !== -1;\n            }\n            return false;\n        }\n    },\n    \"^=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.startsWith(right);\n            }\n            return false;\n        }\n    },\n    \"$=\": {\n        call: (context, call) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.endsWith(right);\n            }\n            return false;\n        }\n    }\n};\nexports.StringOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/StringOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst operators = {\n    typeof: {\n        call: (context, call) => {\n            return typeof context.evaluate(call.args[0]);\n        }\n    }\n};\nexports.TypeOperators = operators;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-datasource-protocol/lib/operators/TypeOperators.js?");

/***/ }),

/***/ "./node_modules/@here/harp-fetch/index.web.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-fetch/index.web.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-fetch/index.web.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js\");\nconst VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3(), new three_1.Vector3()];\n/**\n * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned\n * on the surface of a sphere centered at `(0, 0, 0)`.\n */\nclass SphericalGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {\n    /**\n     * Constructs a new [[SphericalGeometrySubdivisionModifier]].\n     *\n     * @param angle The maximum angle in radians between two vertices and the origin.\n     * @param projection The projection that defines the world space of this geometry.\n     */\n    constructor(angle, projection = harp_geoutils_1.sphereProjection) {\n        super();\n        this.angle = angle;\n        this.projection = projection;\n    }\n    /** @override */\n    shouldSplitTriangle(a, b, c) {\n        const aa = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);\n        const bb = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);\n        const cc = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);\n        const alpha = aa.angleTo(bb);\n        const beta = bb.angleTo(cc);\n        const gamma = cc.angleTo(aa);\n        // find the maximum angle\n        const m = Math.max(alpha, Math.max(beta, gamma));\n        // split the triangle if needed.\n        if (m < this.angle) {\n            return undefined;\n        }\n        if (m === alpha) {\n            return 0;\n        }\n        else if (m === beta) {\n            return 1;\n        }\n        else if (m === gamma) {\n            return 2;\n        }\n        throw new Error(\"failed to split triangle\");\n    }\n}\nexports.SphericalGeometrySubdivisionModifier = SphericalGeometrySubdivisionModifier;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst tmpVectorA = new three_1.Vector3();\nconst tmpVectorB = new three_1.Vector3();\nconst tmpVectorC = new three_1.Vector3();\n/**\n * The [[SubdivisionModifier]] subdivides triangle mesh geometries.\n */\nclass SubdivisionModifier {\n    /**\n     * Constructs a new [[SubdivisionModifier]].\n     */\n    constructor() {\n        // nothing to do\n    }\n    /**\n     * Subdivides the faces of the given [[THREE.BufferGeometry]].\n     *\n     * This method modifies (in-place) the vertices and the faces of the geometry.\n     * Please note that only the vertex position and their UV coordinates are subdivided.\n     * Normals, vertex colors and other attributes are left unmodified.\n     *\n     * @param geometry The [[THREE.BufferGeometry]] to subdivide.\n     */\n    modify(geometry) {\n        const positionAttr = geometry.getAttribute(\"position\");\n        const position = Array.from(positionAttr.array);\n        const uvAttr = geometry.getAttribute(\"uv\");\n        const uv = uvAttr !== undefined ? Array.from(uvAttr.array) : undefined;\n        const edgeAttr = geometry.getAttribute(\"edge\");\n        const edge = edgeAttr !== undefined ? Array.from(edgeAttr.array) : undefined;\n        const wallAttr = geometry.getAttribute(\"wall\");\n        const wall = wallAttr !== undefined ? Array.from(wallAttr.array) : undefined;\n        const indexAttr = geometry.getIndex();\n        const indices = Array.from(indexAttr.array);\n        // A cache containing the indices of the vertices added\n        // when subdiving the faces of the geometry.\n        const cache = new Map();\n        /**\n         * Returns the index of the vertex positioned in the middle of the given vertices.\n         */\n        function middleVertex(i, j) {\n            // Build a unique `key` for the pair of indices `(i, j)`.\n            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;\n            const h = cache.get(key);\n            if (h !== undefined) {\n                // Nothing to do, a vertex in the middle of (i, j) was already created.\n                return h;\n            }\n            // The position of the new vertex.\n            tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);\n            tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);\n            tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n            // The index of the new vertex.\n            const index = position.length / 3;\n            position.push(...tmpVectorC.toArray());\n            // Cache the position of the new vertex.\n            cache.set(key, index);\n            // The uvs of the new vertex.\n            if (uv !== undefined) {\n                tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);\n                tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);\n                tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n                uv.push(tmpVectorC.x, tmpVectorC.y);\n            }\n            // The edge and wall attributes of the new vertex.\n            // If a new vertex has been introduced between i and j, connect the elements\n            // accordingly.\n            if (edge !== undefined) {\n                if (edge[i] === j) {\n                    edge.push(j);\n                    edge[i] = index;\n                }\n                else if (edge[j] === i) {\n                    edge.push(i);\n                    edge[j] = index;\n                }\n                else {\n                    edge.push(-1);\n                }\n            }\n            if (wall !== undefined) {\n                if (wall[i] === j) {\n                    wall.push(j);\n                    wall[i] = index;\n                }\n                else if (wall[j] === i) {\n                    wall.push(i);\n                    wall[j] = index;\n                }\n                else {\n                    wall.push(-1);\n                }\n            }\n            return index;\n        }\n        const newIndices = [];\n        while (indices.length >= 3) {\n            const v0 = indices.shift();\n            const v1 = indices.shift();\n            const v2 = indices.shift();\n            tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);\n            tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);\n            tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);\n            const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);\n            switch (edgeToSplit) {\n                case 0: {\n                    const v3 = middleVertex(v0, v1);\n                    indices.push(v0, v3, v2, v3, v1, v2);\n                    break;\n                }\n                case 1: {\n                    const v3 = middleVertex(v1, v2);\n                    indices.push(v0, v1, v3, v0, v3, v2);\n                    break;\n                }\n                case 2: {\n                    const v3 = middleVertex(v2, v0);\n                    indices.push(v0, v1, v3, v3, v1, v2);\n                    break;\n                }\n                case undefined: {\n                    newIndices.push(v0, v1, v2);\n                    break;\n                }\n                default:\n                    throw new Error(\"failed to subdivide the given geometry\");\n            }\n        }\n        positionAttr.array = new Float32Array(position);\n        positionAttr.count = position.length / positionAttr.itemSize;\n        positionAttr.needsUpdate = true;\n        geometry.setIndex(newIndices);\n        if (uv !== undefined) {\n            uvAttr.array = new Float32Array(uv);\n            uvAttr.count = uv.length / uvAttr.itemSize;\n            uvAttr.needsUpdate = true;\n        }\n        if (edge !== undefined) {\n            edgeAttr.array = new Float32Array(edge);\n            edgeAttr.count = edge.length / edgeAttr.itemSize;\n            edgeAttr.needsUpdate = true;\n        }\n        return geometry;\n    }\n}\nexports.SubdivisionModifier = SubdivisionModifier;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geometry/lib/SubdivisionModifier.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\"));\n__export(__webpack_require__(/*! ./lib/coordinates/GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\"));\n__export(__webpack_require__(/*! ./lib/coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\"));\n__export(__webpack_require__(/*! ./lib/coordinates/GeoPointLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js\"));\n__export(__webpack_require__(/*! ./lib/coordinates/LatLngLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js\"));\n__export(__webpack_require__(/*! ./lib/projection/EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\"));\n__export(__webpack_require__(/*! ./lib/projection/EquirectangularProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js\"));\n__export(__webpack_require__(/*! ./lib/projection/IdentityProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js\"));\n__export(__webpack_require__(/*! ./lib/projection/Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\"));\n__export(__webpack_require__(/*! ./lib/projection/MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\"));\n__export(__webpack_require__(/*! ./lib/projection/TransverseMercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js\"));\n__export(__webpack_require__(/*! ./lib/projection/SphereProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/FlatTileBoundingBoxGenerator */ \"./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/HalfQuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/QuadTree */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/SubTiles */ \"./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/TileKeyUtils */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/TileTreeTraverse */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/HereTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/WebMercatorTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/MercatorTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js\"));\n__export(__webpack_require__(/*! ./lib/tiling/PolarTilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js\"));\n__export(__webpack_require__(/*! ./lib/math/Vector3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js\"));\n__export(__webpack_require__(/*! ./lib/math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\"));\n__export(__webpack_require__(/*! ./lib/math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\"));\n__export(__webpack_require__(/*! ./lib/math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\"));\n__export(__webpack_require__(/*! ./lib/math/TransformLike */ \"./node_modules/@here/harp-geoutils/lib/math/TransformLike.js\"));\n__export(__webpack_require__(/*! ./lib/math/OrientedBox3 */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * `GeoBox` is used to represent a bounding box in geo coordinates.\n */\nclass GeoBox {\n    /**\n     * Constructs a new `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest The south west position in geo coordinates.\n     * @param northEast The north east position in geo coordinates.\n     */\n    constructor(southWest, northEast) {\n        this.southWest = southWest;\n        this.northEast = northEast;\n    }\n    /**\n     * Returns a `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest The south west position in geo coordinates.\n     * @param northEast The north east position in geo coordinates.\n     */\n    static fromCoordinates(southWest, northEast) {\n        return new GeoBox(southWest, northEast);\n    }\n    /**\n     * Returns the minimum altitude or `undefined`.\n     */\n    get minAltitude() {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.min(this.southWest.altitude, this.northEast.altitude);\n    }\n    /**\n     * Returns the maximum altitude or `undefined`.\n     */\n    get maxAltitude() {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.max(this.southWest.altitude, this.northEast.altitude);\n    }\n    /**\n     * Returns the south latitude in degrees of this `GeoBox`.\n     */\n    get south() {\n        return this.southWest.latitude;\n    }\n    /**\n     * Returns the north altitude in degrees of this `GeoBox`.\n     */\n    get north() {\n        return this.northEast.latitude;\n    }\n    /**\n     * Returns the west longitude in degrees of this `GeoBox`.\n     */\n    get west() {\n        return this.southWest.longitude;\n    }\n    /**\n     * Returns the east longitude in degrees of this `GeoBox`.\n     */\n    get east() {\n        return this.northEast.longitude;\n    }\n    /**\n     * Returns the center of this `GeoBox`.\n     */\n    get center() {\n        const latitude = (this.south + this.north) * 0.5;\n        const { west, east } = this;\n        const { minAltitude, altitudeSpan } = this;\n        let altitude;\n        if (minAltitude !== undefined && altitudeSpan !== undefined) {\n            altitude = minAltitude + altitudeSpan * 0.5;\n        }\n        if (west < east) {\n            return new GeoCoordinates_1.GeoCoordinates(latitude, (west + east) * 0.5, altitude);\n        }\n        let longitude = (360 + east + west) * 0.5;\n        if (longitude > 360) {\n            longitude -= 360;\n        }\n        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, altitude);\n    }\n    /**\n     * Returns the latitude span in radians.\n     */\n    get latitudeSpanInRadians() {\n        return THREE.Math.degToRad(this.latitudeSpan);\n    }\n    /**\n     * Returns the longitude span in radians.\n     */\n    get longitudeSpanInRadians() {\n        return THREE.Math.degToRad(this.longitudeSpan);\n    }\n    /**\n     * Returns the latitude span in degrees.\n     */\n    get latitudeSpan() {\n        return this.north - this.south;\n    }\n    get altitudeSpan() {\n        if (this.maxAltitude === undefined || this.minAltitude === undefined) {\n            return undefined;\n        }\n        return this.maxAltitude - this.minAltitude;\n    }\n    /**\n     * Returns the longitude span in degrees.\n     */\n    get longitudeSpan() {\n        let width = this.northEast.longitude - this.southWest.longitude;\n        if (width < 0) {\n            width += 360;\n        }\n        return width;\n    }\n    /**\n     * Returns the latitude span in degrees.\n     * @deprecated Use [[latitudeSpan]] instead.\n     */\n    get latitudeSpanInDegrees() {\n        return this.latitudeSpan;\n    }\n    /**\n     * Returns the longitude span in degrees.\n     * @deprecated Use [[longitudeSpan]] instead.\n     */\n    get longitudeSpanInDegrees() {\n        return this.longitudeSpan;\n    }\n    /**\n     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.\n     *\n     * @param point The geo coordinates.\n     */\n    contains(point) {\n        if (point.altitude === undefined ||\n            this.minAltitude === undefined ||\n            this.maxAltitude === undefined) {\n            return this.containsHelper(point);\n        }\n        const isFlat = this.minAltitude === this.maxAltitude;\n        const isSameAltitude = this.minAltitude === point.altitude;\n        const isWithinAltitudeRange = this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;\n        // If box is flat, we should check the altitude and containment,\n        // otherwise we should check also altitude difference where we consider\n        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!\n        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {\n            return this.containsHelper(point);\n        }\n        return false;\n    }\n    /**\n     * Clones this `GeoBox` instance.\n     */\n    clone() {\n        return new GeoBox(this.southWest, this.northEast);\n    }\n    /**\n     * Update the bounding box by considering a given point.\n     *\n     * @param point The point that may expand the bounding box.\n     */\n    growToContain(point) {\n        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);\n        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);\n        this.southWest.altitude =\n            this.southWest.altitude !== undefined && point.altitude !== undefined\n                ? Math.min(this.southWest.altitude, point.altitude)\n                : this.southWest.altitude !== undefined\n                    ? this.southWest.altitude\n                    : point.altitude !== undefined\n                        ? point.altitude\n                        : undefined;\n        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);\n        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);\n        this.northEast.altitude =\n            this.northEast.altitude !== undefined && point.altitude !== undefined\n                ? Math.max(this.northEast.altitude, point.altitude)\n                : this.northEast.altitude !== undefined\n                    ? this.northEast.altitude\n                    : point.altitude !== undefined\n                        ? point.altitude\n                        : undefined;\n    }\n    containsHelper(point) {\n        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {\n            return false;\n        }\n        const { west, east } = this;\n        if (east > west) {\n            return point.longitude >= west && point.longitude < east;\n        }\n        return point.longitude > east || point.longitude <= west;\n    }\n}\nexports.GeoBox = GeoBox;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GeoCoordinatesLike_1 = __webpack_require__(/*! ./GeoCoordinatesLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js\");\nconst GeoPointLike_1 = __webpack_require__(/*! ./GeoPointLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js\");\nconst LatLngLike_1 = __webpack_require__(/*! ./LatLngLike */ \"./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * `GeoCoordinates` is used to represent geo positions.\n */\nclass GeoCoordinates {\n    /**\n     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude Latitude in degrees.\n     * @param longitude Longitude in degrees.\n     * @param altitude Altitude in meters.\n     */\n    constructor(latitude, longitude, altitude) {\n        this.latitude = latitude;\n        this.longitude = longitude;\n        this.altitude = altitude;\n    }\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude Latitude in degrees.\n     * @param longitude Longitude in degrees.\n     * @param altitude Altitude in meters.\n     */\n    static fromDegrees(latitude, longitude, altitude) {\n        return new GeoCoordinates(latitude, longitude, altitude);\n    }\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude Latitude in radians.\n     * @param longitude Longitude in radians.\n     * @param altitude Altitude in meters.\n     */\n    static fromRadians(latitude, longitude, altitude) {\n        return new GeoCoordinates(THREE.Math.radToDeg(latitude), THREE.Math.radToDeg(longitude), altitude);\n    }\n    /**\n     * Creates a [[GeoCoordinates]] from a [[LatLngLike]] literal.\n     * ```typescript\n     * const center = { lat: 53.3, lng: 13.4 };\n     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);\n     * ```\n     * @param latLng A [[LatLngLike]] object literal.\n     */\n    static fromLatLng(latLng) {\n        return new GeoCoordinates(latLng.lat, latLng.lng);\n    }\n    /**\n     * Creates a [[GeoCoordinates]] from a [[GeoPointLike]] tuple.\n     *\n     * Example:\n     * ```typescript\n     * mapView.geoCenter = GeoCoordinates.fromGeoPoint([longitude, latitude]);\n     *\n     * let geoCoords: number[] = ...;\n     *\n     * if (isGeoPointLike(geoCoords)) {\n     *     const p = GeoCoordinates.fromGeoPoint(geoCoords);\n     * }\n     * ```\n     * @param geoPoint An [[Array]] of at least two elements following the order\n     * longitude, latitude, altitude.\n     */\n    static fromGeoPoint(geoPoint) {\n        return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);\n    }\n    /**\n     * Creates a [[GeoCoordinates]] from different types of geo coordinate objects.\n     *\n     * Example:\n     * ```typescript\n     * const fromGeoPointLike = GeoCoordinates.fromObject([longitude, latitude]);\n     * const fromGeoCoordinateLike = GeoCoordinates.fromObject({ longitude, latitude });\n     * const fromGeoCoordinate = GeoCoordinates.fromObject(new GeoCoordinates(latitude, longitude));\n     * const fromLatLngLike = GeoCoordinates.fromObject({ lat: latitude , lng: longitude });\n     * ```\n     *\n     * @param geoPoint Either [[GeoPointLike]], [[GeoCoordinatesLike]]\n     * or [[LatLngLike]] object literal.\n     */\n    static fromObject(geoPoint) {\n        if (GeoPointLike_1.isGeoPointLike(geoPoint)) {\n            return GeoCoordinates.fromGeoPoint(geoPoint);\n        }\n        else if (GeoCoordinatesLike_1.isGeoCoordinatesLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(geoPoint.latitude, geoPoint.longitude, geoPoint.altitude);\n        }\n        else if (LatLngLike_1.isLatLngLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);\n        }\n        throw new Error(\"Invalid input coordinate format.\");\n    }\n    /**\n     * Returns the latitude in radians.\n     */\n    get latitudeInRadians() {\n        return THREE.Math.degToRad(this.latitude);\n    }\n    /**\n     * Returns the longitude in radians.\n     */\n    get longitudeInRadians() {\n        return THREE.Math.degToRad(this.longitude);\n    }\n    /**\n     * Returns the latitude in degrees.\n     * @deprecated Use the [[latitude]] property instead.\n     */\n    get latitudeInDegrees() {\n        return this.latitude;\n    } // compat api\n    /**\n     * Returns the longitude in degrees.\n     * @deprecated Use the [[longitude]] property instead.\n     */\n    get longitudeInDegrees() {\n        return this.longitude;\n    } // compat api\n    /**\n     * The latitude in the degrees.\n     */\n    get lat() {\n        return this.latitude;\n    }\n    /**\n     * The longitude in the degrees.\n     */\n    get lng() {\n        return this.longitude;\n    }\n    /**\n     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.\n     */\n    isValid() {\n        return !isNaN(this.latitude) && !isNaN(this.longitude);\n    }\n    /**\n     * Returns the normalized `GeoCoordinates`.\n     */\n    normalized() {\n        let { latitude, longitude } = this;\n        if (isNaN(latitude) || isNaN(longitude)) {\n            return this;\n        }\n        if (latitude > 90) {\n            let wrapped = (latitude + 90) % 360;\n            if (wrapped >= 180) {\n                longitude += 180;\n                wrapped = 360 - wrapped;\n            }\n            latitude = wrapped - 90;\n        }\n        if (latitude < -90) {\n            let wrapped = (latitude - 90) % 360;\n            if (wrapped <= -180) {\n                longitude += 180;\n                wrapped = -360 - wrapped;\n            }\n            latitude = wrapped + 90;\n        }\n        if (longitude < -180 || longitude > 180) {\n            const sign = Math.sign(longitude);\n            longitude = (((longitude % 360) + 180 * sign) % 360) - 180 * sign;\n        }\n        if (latitude === this.latitude && longitude === this.longitude) {\n            return this;\n        }\n        return new GeoCoordinates(latitude, longitude, this.altitude);\n    }\n    /**\n     * Returns `true` if this `GeoCoordinates` is equal to the other.\n     *\n     * @param other GeoCoordinatesLike to compare to.\n     */\n    equals(other) {\n        return (this.latitude === other.latitude &&\n            this.longitude === other.longitude &&\n            this.altitude === other.altitude);\n    }\n    /**\n     * Copy values from the other.\n     *\n     * @param other GeoCoordinatesLike to copy all values from.\n     */\n    copy(other) {\n        this.latitude = other.latitude;\n        this.longitude = other.longitude;\n        this.altitude = other.altitude;\n        return this;\n    }\n    /**\n     * Clones this `GeoCoordinates`.\n     * @deprecated\n     */\n    clone() {\n        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);\n    }\n    /**\n     * Returns this [[GeoCoordinates]] as [[LatLngLike]] literal.\n     */\n    toLatLng() {\n        return { lat: this.latitude, lng: this.longitude };\n    }\n    /**\n     * Converts this [[GeoCoordinates]] to a [[GeoPointLike]].\n     */\n    toGeoPoint() {\n        return this.altitude !== undefined\n            ? [this.longitude, this.latitude, this.altitude]\n            : [this.longitude, this.latitude];\n    }\n}\nexports.GeoCoordinates = GeoCoordinates;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Type guard to assert that `object` conforms to [[GeoCoordinatesLike]] data interface.\n */\nfunction isGeoCoordinatesLike(object) {\n    return (object &&\n        typeof object.latitude === \"number\" &&\n        typeof object.longitude === \"number\" &&\n        (typeof object.altitude === \"number\" || typeof object.altitude === \"undefined\"));\n}\nexports.isGeoCoordinatesLike = isGeoCoordinatesLike;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Type guard to assert that `object` conforms to [[GeoPointLike]] interface.\n */\nfunction isGeoPointLike(geoPoint) {\n    if (Array.isArray(geoPoint)) {\n        const [longitude, latitude, altitude] = geoPoint;\n        return (typeof longitude === \"number\" &&\n            typeof latitude === \"number\" &&\n            (altitude === undefined || typeof altitude === \"number\"));\n    }\n    return false;\n}\nexports.isGeoPointLike = isGeoPointLike;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/GeoPointLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Type guard to assert that `object` conforms to [[LatLngLike]] interface.\n */\nfunction isLatLngLike(object) {\n    return object && typeof object.lat === \"number\" && typeof object.lng === \"number\";\n}\nexports.isLatLngLike = isLatLngLike;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/coordinates/LatLngLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Box3Like.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Box3Like.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns true if the given object implements the [[Box3Like]] interface.\n *\n * @param object A valid object.\n */\nfunction isBox3Like(object) {\n    const box3 = object;\n    return box3.min !== undefined && box3.max !== undefined;\n}\nexports.isBox3Like = isBox3Like;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/Box3Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/MathUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/MathUtils.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nvar MathUtils;\n(function (MathUtils) {\n    /**\n     * Creates a new empty bounding box.\n     * @deprecated\n     */\n    function newEmptyBox3() {\n        return {\n            min: { x: Infinity, y: Infinity, z: Infinity },\n            max: { x: -Infinity, y: -Infinity, z: -Infinity }\n        };\n    }\n    MathUtils.newEmptyBox3 = newEmptyBox3;\n    /**\n     * Set the components of the given [Vector3Like] instance.\n     *\n     * @param x The x component.\n     * @param y The y component.\n     * @param z The z component.\n     * @param v The [Vector3Like]\n     */\n    function newVector3(x, y, z, v) {\n        if (v === undefined) {\n            return { x, y, z };\n        }\n        v.x = x;\n        v.y = y;\n        v.z = z;\n        return v;\n    }\n    MathUtils.newVector3 = newVector3;\n    /**\n     * Converts an angle measured in degrees to an equivalent value in radians.\n     *\n     * @param degrees Value in degrees.\n     * @returns Value in radians.\n     * @deprecated\n     */\n    MathUtils.degToRad = THREE.Math.degToRad;\n    /**\n     * Converts an angle measured in radians to an equivalent value in degrees.\n     *\n     * @param degrees Value in radians.\n     * @returns Value in degrees.\n     * @deprecated\n     */\n    MathUtils.radToDeg = THREE.Math.radToDeg;\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value The value to be clamped.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @returns Clamped value.\n     * @deprecated\n     */\n    MathUtils.clamp = THREE.Math.clamp;\n    /**\n     * Normalize angle in degrees to range `[0, 360)`.\n     *\n     * @param a Angle in degrees.\n     * @returns Angle in degrees in range `[0, 360)`.\n     */\n    function normalizeAngleDeg(a) {\n        a = a % 360;\n        if (a < 0) {\n            a = a + 360;\n        }\n        return a;\n    }\n    MathUtils.normalizeAngleDeg = normalizeAngleDeg;\n    /**\n     * Return the minimal delta between angles `a` and `b` given in degrees.\n     *\n     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed\n     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.\n     *\n     * Useful when interpolating between `b` and `a` in angle space.\n     *\n     * @param a Start angle in degrees.\n     * @param b End angle in degrees.\n     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.\n     */\n    function angleDistanceDeg(a, b) {\n        a = normalizeAngleDeg(a);\n        b = normalizeAngleDeg(b);\n        const d = a - b;\n        if (d > 180) {\n            return d - 360;\n        }\n        else if (d <= -180) {\n            return d + 360;\n        }\n        else {\n            return d;\n        }\n    }\n    MathUtils.angleDistanceDeg = angleDistanceDeg;\n    /**\n     * Interpolate linearly between two angles given in degrees.\n     *\n     * @param p0 Angle from in degrees\n     * @param p1 Angle to in degrees\n     * @param t Interpolation factor (alpha), in range `0-1`.\n     */\n    function interpolateAnglesDeg(p0, p1, t) {\n        // hand crafted version,\n        // see stack for maybe better versions:\n        //    https://stackoverflow.com/questions/2708476/rotation-interpolation\n        const d = angleDistanceDeg(p1, p0);\n        const r = (p0 + d * t) % 360;\n        return r;\n    }\n    MathUtils.interpolateAnglesDeg = interpolateAnglesDeg;\n})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/MathUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nclass OrientedBox3 {\n    /**\n     * Creates a new `OrientedBox3`.\n     *\n     * @hideconstructor\n     */\n    constructor(position, rotationMatrix, extents) {\n        /**\n         * The position of the center of this `OrientedBox3`.\n         */\n        this.position = new three_1.Vector3();\n        /**\n         * The x-axis of this `OrientedBox3`.\n         */\n        this.xAxis = new three_1.Vector3(1, 0, 0);\n        /**\n         * The y-axis of this `OrientedBox3`.\n         */\n        this.yAxis = new three_1.Vector3(0, 1, 0);\n        /**\n         * The z-axis of this `OrientedBox3`.\n         */\n        this.zAxis = new three_1.Vector3(0, 0, 1);\n        /**\n         * The extents of this `OrientedBox3`.\n         */\n        this.extents = new three_1.Vector3();\n        if (position !== undefined) {\n            this.position.copy(position);\n        }\n        if (rotationMatrix !== undefined) {\n            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);\n        }\n        if (extents !== undefined) {\n            this.extents.copy(extents);\n        }\n    }\n    /**\n     * Create a copy of this [[OrientedBoundingBox]].\n     */\n    clone() {\n        const newBox = new OrientedBox3();\n        newBox.copy(this);\n        return newBox;\n    }\n    /**\n     * Copies the values of `other` to this [[OrientedBox3]].\n     * @param other The other [[OrientedBox3]] to copy.\n     */\n    copy(other) {\n        this.position.copy(other.position);\n        this.xAxis.copy(other.xAxis);\n        this.yAxis.copy(other.yAxis);\n        this.zAxis.copy(other.zAxis);\n        this.extents.copy(other.extents);\n    }\n    /**\n     * Gets the center position of this [[OrientedBox3]].\n     *\n     * @param center The returned center position.\n     */\n    getCenter(center = new three_1.Vector3()) {\n        return center.copy(this.position);\n    }\n    /**\n     * Gets the size of this [[OrientedBox3]].\n     *\n     * @param size The returned size.\n     */\n    getSize(size = new three_1.Vector3()) {\n        return size.copy(this.extents).multiplyScalar(2);\n    }\n    /**\n     * Gets the orientation matrix of this `OrientedBox3`.\n     * @param matrix The output orientation matrix.\n     */\n    getRotationMatrix(matrix = new three_1.Matrix4()) {\n        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);\n    }\n    /**\n     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.\n     *\n     * @param frustumOrPlanes Frustum or array of planes.\n     */\n    intersects(frustumOrPlanes) {\n        const planes = Array.isArray(frustumOrPlanes)\n            ? frustumOrPlanes\n            : frustumOrPlanes.planes;\n        for (const plane of planes) {\n            const r = Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +\n                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +\n                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);\n            const d = plane.distanceToPoint(this.position);\n            if (d + r < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns true if this [[OrientedBox3]] contains the given point.\n     *\n     * @param point A valid point.\n     */\n    contains(point) {\n        const dx = point.x - this.position.x;\n        const dy = point.y - this.position.y;\n        const dz = point.z - this.position.z;\n        const x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);\n        const y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);\n        const z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);\n        if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns the distance from this [[OrientedBox3]] and the given `point`.\n     *\n     * @param point A point.\n     */\n    distanceToPoint(point) {\n        return Math.sqrt(this.distanceToPointSquared(point));\n    }\n    /**\n     * Returns the squared distance from this [[OrientedBox3]] and the given `point`.\n     *\n     * @param point A point.\n     */\n    distanceToPointSquared(point) {\n        const d = new three_1.Vector3();\n        d.subVectors(point, this.position);\n        const lengths = [d.dot(this.xAxis), d.dot(this.yAxis), d.dot(this.zAxis)];\n        let result = 0;\n        for (let i = 0; i < 3; ++i) {\n            const length = lengths[i];\n            const extent = this.extents.getComponent(i);\n            if (length < -extent) {\n                const dd = extent + length;\n                result += dd * dd;\n            }\n            else if (length > extent) {\n                const dd = length - extent;\n                result += dd * dd;\n            }\n        }\n        return result;\n    }\n}\nexports.OrientedBox3 = OrientedBox3;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/OrientedBox3.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns true if the given object implements the interface [[OrientedBox3Like]].\n *\n * @param object The object.\n */\nfunction isOrientedBox3Like(object) {\n    const obb = object;\n    return (obb.position !== undefined &&\n        obb.xAxis !== undefined &&\n        obb.yAxis !== undefined &&\n        obb.zAxis !== undefined &&\n        obb.extents !== undefined);\n}\nexports.isOrientedBox3Like = isOrientedBox3Like;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/TransformLike.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/TransformLike.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns true if the given object implements the interface [[TransformLike]].\n *\n * @param object The object.\n */\nfunction isTransformLike(object) {\n    const transform = object;\n    return (transform.position !== undefined &&\n        transform.xAxis !== undefined &&\n        transform.yAxis !== undefined &&\n        transform.zAxis !== undefined);\n}\nexports.isTransformLike = isTransformLike;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/TransformLike.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isVector3Like(v) {\n    return v && typeof v.x === \"number\" && typeof v.y === \"number\" && typeof v.z === \"number\";\n}\nexports.isVector3Like = isVector3Like;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/math/Vector3Like.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EarthConstants {\n}\nexports.EarthConstants = EarthConstants;\n/** The equatorial circumference in meters. */\nEarthConstants.EQUATORIAL_CIRCUMFERENCE = 40075016.6855784861531768177614;\n/** The equatorial radius in meters. */\nEarthConstants.EQUATORIAL_RADIUS = 6378137.0;\n/** The lowest point on earth (Dead Sea) in meters. */\nEarthConstants.MIN_ELEVATION = -433.0;\n/** The highest point on earth (Mt. Everest) in meters. */\nEarthConstants.MAX_ELEVATION = 8848.0;\n/** The highest artificial structure (building) on earth, Burj Khalifa tower in Dubai */\nEarthConstants.MAX_BUILDING_HEIGHT = 828;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nclass EquirectangularProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n    }\n    /** @override */\n    getScaleFactor(_worldPoint) {\n        return 1;\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = MathUtils_1.MathUtils.newEmptyBox3();\n        }\n        result.min.x = 0.0;\n        result.min.y = 0.0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale / 2;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result) {\n        if (result === undefined) {\n            /*\n             * The following tslint:disable is due to the fact that the [[WorldCoordinates]]\n             * might be a concrete class which is not available at runtime.\n             * Consider the following example:\n             *\n             *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);\n             *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);\n             *\n             * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!\n             */\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x =\n            (THREE.Math.degToRad(geoPoint.longitude) + Math.PI) *\n                EquirectangularProjection.geoToWorldScale *\n                this.unitScale;\n        result.y =\n            (THREE.Math.degToRad(geoPoint.latitude) + Math.PI * 0.5) *\n                EquirectangularProjection.geoToWorldScale *\n                this.unitScale;\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians((worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -\n            Math.PI * 0.5, (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI, worldPoint.z);\n        return geoPoint;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        const worldCenter = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0));\n        const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;\n        const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        if (!result) {\n            result = MathUtils_1.MathUtils.newEmptyBox3();\n        }\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;\n            result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;\n            result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;\n            result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            }\n            else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = sizeX * 0.5 * this.unitScale;\n            result.extents.y = sizeY * 0.5 * this.unitScale;\n            result.extents.z = Math.max(Number.EPSILON, (altitudeSpan || 0) * 0.5);\n        }\n        return result;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\nEquirectangularProjection.geoToWorldScale = 1.0 / (2.0 * Math.PI);\nEquirectangularProjection.worldToGeoScale = (2.0 * Math.PI) / 1.0;\n/**\n * Equirectangular [[Projection]] used to convert geo coordinates to unit coordinates and vice\n * versa.\n */\nexports.normalizedEquirectangularProjection = new EquirectangularProjection(1);\n/**\n * Equirectangular [[Projection]] used to convert geo coordinates to world coordinates and vice\n * versa.\n */\nexports.equirectangularProjection = new EquirectangularProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nclass IdentityProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n    }\n    /** @override */\n    getScaleFactor(_worldPoint) {\n        return 1;\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = MathUtils_1.MathUtils.newEmptyBox3();\n        }\n        result.min.x = -Math.PI;\n        result.min.y = -Math.PI * 0.5;\n        result.min.z = minAltitude;\n        result.max.x = Math.PI;\n        result.max.y = Math.PI * 0.5;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result) {\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x = THREE.Math.degToRad(geoPoint.longitude);\n        result.y = THREE.Math.degToRad(geoPoint.latitude);\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);\n        return geoPoint;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        if (!result) {\n            result = MathUtils_1.MathUtils.newEmptyBox3();\n        }\n        const min = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude));\n        const max = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude));\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = min.x;\n            result.min.y = min.y;\n            result.min.z = min.z;\n            result.max.x = max.x;\n            result.max.y = max.y;\n            result.max.z = max.z;\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (min.x + max.x) * 0.5;\n            result.position.y = (min.y + max.y) * 0.5;\n            result.position.z = (min.z + max.z) * 0.5;\n            result.extents.x = (max.x - min.x) * 0.5;\n            result.extents.y = (max.y - min.y) * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);\n        }\n        return result;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\n/**\n * Identity [[Projection]] used to convert geo coordinates to unit coordinates and vice versa.\n */\nexports.identityProjection = new IdentityProjection(1);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/IdentityProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\nclass MercatorProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n    }\n    static clamp(val, min, max) {\n        return Math.min(Math.max(min, val), max);\n    }\n    static latitudeClamp(latitude) {\n        return MercatorProjection.clamp(latitude, -MercatorConstants.MAXIMUM_LATITUDE, MercatorConstants.MAXIMUM_LATITUDE);\n    }\n    static latitudeProject(latitude) {\n        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;\n    }\n    static latitudeClampProject(latitude) {\n        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));\n    }\n    static unprojectLatitude(y) {\n        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;\n    }\n    /** @override */\n    getScaleFactor(worldPoint) {\n        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = MathUtils_1.MathUtils.newEmptyBox3();\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPointLike, result) {\n        let geoPoint;\n        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {\n            geoPoint = geoPointLike;\n        }\n        else {\n            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);\n        }\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        result.y =\n            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *\n                this.unitScale;\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0), (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI, worldPoint.z);\n        return geoPoint;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        const worldCenter = this.projectPoint(geoBox.center);\n        const worldNorth = (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +\n            0.5) *\n            this.unitScale;\n        const worldSouth = (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +\n            0.5) *\n            this.unitScale;\n        const worldYCenter = (worldNorth + worldSouth) * 0.5;\n        worldCenter.y = worldYCenter;\n        const latitudeSpan = worldNorth - worldSouth;\n        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;\n        if (!result) {\n            result = MathUtils_1.MathUtils.newEmptyBox3();\n        }\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = worldCenter.x - longitudeSpan * 0.5;\n            result.min.y = worldCenter.y - latitudeSpan * 0.5;\n            result.max.x = worldCenter.x + longitudeSpan * 0.5;\n            result.max.y = worldCenter.y + latitudeSpan * 0.5;\n            const altitudeSpan = geoBox.altitudeSpan;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            }\n            else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = longitudeSpan * 0.5;\n            result.extents.y = latitudeSpan * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, (geoBox.altitudeSpan || 0) * 0.5);\n        }\n        else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n    /** @override */\n    reprojectPoint(sourceProjection, worldPos, result) {\n        // this implementation of [[reprojectPoint]] supports both\n        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only\n        // difference betweeen these two variants of WEB Mercator\n        // is in the orientation of the Y axis, so we just flip Y coordinates\n        // when reprojecting between them.\n        if (sourceProjection !== this &&\n            (sourceProjection === exports.webMercatorProjection || sourceProjection === exports.mercatorProjection)) {\n            if (result === undefined) {\n                // tslint:disable-next-line: no-object-literal-type-assertion\n                result = {};\n            }\n            result.x = worldPos.x;\n            result.y = this.unitScale - worldPos.y;\n            result.z = worldPos.z;\n            return result;\n        }\n        return super.reprojectPoint(sourceProjection, worldPos, result);\n    }\n}\nclass WebMercatorProjection extends MercatorProjection {\n    /** @override */\n    projectPoint(geoPointLike, result) {\n        let geoPoint;\n        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {\n            geoPoint = geoPointLike;\n        }\n        else {\n            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);\n        }\n        /*\n         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]\n         * might be a concrete class which is not available at runtime.\n         * Consider the following example:\n         *\n         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);\n         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);\n         *\n         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!\n         */\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 };\n        }\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));\n        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const x = worldPoint.x / this.unitScale - 0.5;\n        const y = 0.5 - worldPoint.y / this.unitScale;\n        const longitude = 360 * x;\n        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;\n        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, worldPoint.z);\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        const r = super.projectBox(geoBox, result);\n        if (Box3Like_1.isBox3Like(r)) {\n            // Invert the y axis for web mercator, this means that max => min & min => max\n            const maxY = r.max.y;\n            r.max.y = this.unitScale - r.min.y;\n            r.min.y = this.unitScale - maxY;\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(r)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, r.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, -1, 0, r.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, -1, r.zAxis);\n            r.position.y = this.unitScale - r.position.y;\n        }\n        return r;\n    }\n    /** @override */\n    unprojectBox(worldBox) {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = new GeoBox_1.GeoBox(new GeoCoordinates_1.GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude), new GeoCoordinates_1.GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude));\n        return geoBox;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n    /** @override */\n    localTangentSpace(geoPoint, result) {\n        this.projectPoint(geoPoint, result.position);\n        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils_1.MathUtils.newVector3(0, -1, 0, result.yAxis);\n        MathUtils_1.MathUtils.newVector3(0, 0, -1, result.zAxis);\n        return result;\n    }\n}\nclass MercatorConstants {\n}\nexports.MercatorConstants = MercatorConstants;\n// Math.atan(Math.sinh(Math.PI))\nMercatorConstants.MAXIMUM_LATITUDE = 1.4844222297453323;\n/**\n * Mercator [[Projection]] used to convert geo coordinates to world coordinates and vice versa.\n */\nexports.mercatorProjection = new MercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n/**\n * Web Mercator [[Projection]] used to convert geo coordinates to world coordinates and vice versa.\n */\nexports.webMercatorProjection = new WebMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/Projection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/Projection.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\n/**\n * The type of projection.\n */\nvar ProjectionType;\n(function (ProjectionType) {\n    /**\n     * A type of [Projection] with zero curvature.\n     */\n    ProjectionType[ProjectionType[\"Planar\"] = 0] = \"Planar\";\n    /**\n     * A spherical [Projection].\n     */\n    ProjectionType[ProjectionType[\"Spherical\"] = 1] = \"Spherical\";\n})(ProjectionType = exports.ProjectionType || (exports.ProjectionType = {}));\n/**\n * `Projection` is used to convert positions from geo coordinates to world coordinates and vice\n * versa.\n */\nclass Projection {\n    /**\n     * Constructs the Projection\n     *\n     * @param unitScale How to transform the projected coordinates to world units.\n     */\n    constructor(unitScale) {\n        this.unitScale = unitScale;\n        //Prevent empty constructor error.\n    }\n    /**\n     * Gets the [[TransformLike]] of the local tangent space at the given geo coordinates.\n     *\n     * @param geoPoint The geo coordinates.\n     * @param result The [[TransformLike]].\n     */\n    localTangentSpace(geoPoint, result) {\n        this.projectPoint(geoPoint, result.position);\n        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n        MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n        return result;\n    }\n    /**\n     * Reproject a world position from the given source [[Projection]].\n     * Implementations should be aware of worldPos and result may be one object\n     *\n     * @param sourceProjection The source projection.\n     * @param worldPos A valid position in the world space defined by the source projection.\n     * @param result The resulting position reprojected using this [[Projection]].\n     * @hidden\n     */\n    reprojectPoint(sourceProjection, worldPos, result) {\n        if (sourceProjection === this) {\n            if (result === undefined) {\n                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };\n            }\n            result.x = worldPos.x;\n            result.y = worldPos.y;\n            result.z = worldPos.z;\n            return result;\n        }\n        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);\n    }\n}\nexports.Projection = Projection;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/Projection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst MercatorProjection_1 = __webpack_require__(/*! ./MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Transforms the given vector using the provided basis.\n */\nfunction apply(xAxis, yAxis, zAxis, v) {\n    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;\n    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;\n    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n/**\n * Returns the quadrants for the given longitude. The quadrant is defined as:\n *  - quadrant(+Math.PI * -1.0) = 0\n *  - quadrant(+Math.PI * -0.5) = 1\n *  - quadrant(+Math.PI *  0.0) = 2\n *  - quadrant(+Math.PI *  0.5) = 3\n *  - quadrant(+Math.PI *  1.0) = 4\n *\n * @param longitude The longitude in radians.\n */\nfunction getLongitudeQuadrant(longitude) {\n    const oneOverPI = 1 / Math.PI;\n    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));\n    return THREE.Math.clamp(quadrantIndex, 0, 4);\n}\nfunction lengthOfVector3(worldPoint) {\n    const d = Math.sqrt(worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z);\n    return d;\n}\n/**\n * Creates a Box3 enclosing the geobox.\n *\n * @param geoBox Ghe given geobox\n * @param worldBox The resulting axis aligned bounding box.\n */\nfunction makeBox3(geoBox, worldBox, unitScale) {\n    const halfEquatorialRadius = (unitScale + (geoBox.maxAltitude || 0)) * 0.5;\n    const minLongitude = THREE.Math.degToRad(geoBox.west);\n    const maxLongitude = THREE.Math.degToRad(geoBox.east);\n    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);\n    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);\n    let xMin = Math.cos(minLongitude);\n    let xMax = xMin;\n    let yMin = Math.sin(minLongitude);\n    let yMax = yMin;\n    for (let quadrantIndex = minLongitudeQuadrant + 1; quadrantIndex <= maxLongitudeQuadrant; quadrantIndex++) {\n        // tslint:disable-next-line: no-bitwise\n        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);\n        xMin = Math.min(x, xMin);\n        xMax = Math.max(x, xMax);\n        // tslint:disable-next-line: no-bitwise\n        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);\n        yMin = Math.min(y, yMin);\n        yMax = Math.max(y, yMax);\n    }\n    const cosMaxLongitude = Math.cos(maxLongitude);\n    xMin = Math.min(cosMaxLongitude, xMin);\n    xMax = Math.max(cosMaxLongitude, xMax);\n    const sinMaxLongitude = Math.sin(maxLongitude);\n    yMin = Math.min(sinMaxLongitude, yMin);\n    yMax = Math.max(sinMaxLongitude, yMax);\n    const xCenter = (xMax + xMin) * halfEquatorialRadius;\n    const xExtent = (xMax - xMin) * halfEquatorialRadius;\n    const yCenter = (yMax + yMin) * halfEquatorialRadius;\n    const yExtent = (yMax - yMin) * halfEquatorialRadius;\n    // Calculate Z boundaries.\n    const minLatitude = THREE.Math.degToRad(geoBox.south);\n    const maxLatutide = THREE.Math.degToRad(geoBox.north);\n    const zMax = Math.sin(maxLatutide);\n    const zMin = Math.sin(minLatitude);\n    const zCenter = (zMax + zMin) * halfEquatorialRadius;\n    const zExtent = (zMax - zMin) * halfEquatorialRadius;\n    worldBox.min.x = xCenter - xExtent;\n    worldBox.min.y = yCenter - yExtent;\n    worldBox.min.z = zCenter - zExtent;\n    worldBox.max.x = xCenter + xExtent;\n    worldBox.max.y = yCenter + yExtent;\n    worldBox.max.z = zCenter + zExtent;\n    return worldBox;\n}\n/**\n * Computes the spherical projection of the given geo coordinates.\n *\n * @param geoPoint The geo coordinates.\n * @param worldpoint The resulting world coordinates.\n */\nfunction project(geoPoint, worldpoint, unitScale) {\n    const radius = unitScale + (geoPoint.altitude || 0);\n    const latitude = THREE.Math.degToRad(geoPoint.latitude);\n    const longitude = THREE.Math.degToRad(geoPoint.longitude);\n    const cosLatitude = Math.cos(latitude);\n    worldpoint.x = radius * cosLatitude * Math.cos(longitude);\n    worldpoint.y = radius * cosLatitude * Math.sin(longitude);\n    worldpoint.z = radius * Math.sin(latitude);\n    return worldpoint;\n}\nclass SphereProjection extends Projection_1.Projection {\n    constructor() {\n        super(...arguments);\n        /** @override */\n        this.type = Projection_1.ProjectionType.Spherical;\n    }\n    /** @override */\n    worldExtent(_minElevation, maxElevation, result = MathUtils_1.MathUtils.newEmptyBox3()) {\n        const radius = this.unitScale + maxElevation;\n        result.min.x = -radius;\n        result.min.y = -radius;\n        result.min.z = -radius;\n        result.max.x = radius;\n        result.max.y = radius;\n        result.max.z = radius;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result = MathUtils_1.MathUtils.newVector3(0, 0, 0)) {\n        return project(geoPoint, result, this.unitScale);\n    }\n    /** @override */\n    unprojectPoint(point) {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y;\n        const parallelRadius = Math.sqrt(parallelRadiusSq);\n        const v = point.z / parallelRadius;\n        if (isNaN(v)) {\n            return GeoCoordinates_1.GeoCoordinates.fromRadians(0, 0, -this.unitScale);\n        }\n        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);\n        return GeoCoordinates_1.GeoCoordinates.fromRadians(Math.atan(v), Math.atan2(point.y, point.x), radius - this.unitScale);\n    }\n    /** @override */\n    unprojectAltitude(point) {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;\n        return Math.sqrt(parallelRadiusSq) - EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;\n    }\n    /** @override */\n    projectBox(geoBox, result = MathUtils_1.MathUtils.newEmptyBox3()) {\n        if (Box3Like_1.isBox3Like(result)) {\n            return makeBox3(geoBox, result, this.unitScale);\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            if (geoBox.longitudeSpan >= 90) {\n                const bounds = makeBox3(geoBox, MathUtils_1.MathUtils.newEmptyBox3(), this.unitScale);\n                MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n                MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n                MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;\n                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;\n                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;\n                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;\n                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;\n                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;\n                return result;\n            }\n            const { south, west, north, east, center: mid } = geoBox;\n            const midX = mid.longitude;\n            const midY = mid.latitude;\n            const cosSouth = Math.cos(THREE.Math.degToRad(south));\n            const sinSouth = Math.sin(THREE.Math.degToRad(south));\n            const cosWest = Math.cos(THREE.Math.degToRad(west));\n            const sinWest = Math.sin(THREE.Math.degToRad(west));\n            const cosNorth = Math.cos(THREE.Math.degToRad(north));\n            const sinNorth = Math.sin(THREE.Math.degToRad(north));\n            const cosEast = Math.cos(THREE.Math.degToRad(east));\n            const sinEast = Math.sin(THREE.Math.degToRad(east));\n            const cosMidX = Math.cos(THREE.Math.degToRad(midX));\n            const sinMidX = Math.sin(THREE.Math.degToRad(midX));\n            const cosMidY = Math.cos(THREE.Math.degToRad(midY));\n            const sinMidY = Math.sin(THREE.Math.degToRad(midY));\n            // Build the orientation of the OBB using the normal vector and its partial derivates.\n            // the sperical coordinates of the mid point of the geobox.\n            MathUtils_1.MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);\n            // the partial derivates of the normal vector.\n            MathUtils_1.MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);\n            let width;\n            let minY;\n            let maxY;\n            if (south >= 0) {\n                // abs(dot(southWest - southEast, xAxis))\n                width = Math.abs(cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));\n                // dot(south, yAxis)\n                minY = cosMidY * sinSouth - sinMidY * cosSouth;\n                // dot(northEast, zAxis)\n                maxY =\n                    cosMidY * sinNorth -\n                        sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);\n            }\n            else {\n                if (north <= 0) {\n                    // abs(dot(northWest - northEast, xAxis))\n                    width = Math.abs(cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));\n                    // dot(north, yAxis)\n                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;\n                }\n                else {\n                    // abs(dot(west - east, xAxis))\n                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));\n                    // dot(northEast, yAxis)\n                    maxY =\n                        cosMidY * sinNorth -\n                            sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);\n                }\n                // dot(southEast, yAxis)\n                minY =\n                    cosMidY * sinSouth -\n                        sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);\n            }\n            const rMax = (this.unitScale + (geoBox.maxAltitude || 0)) * 0.5;\n            const rMin = (this.unitScale + (geoBox.minAltitude || 0)) * 0.5;\n            // min(dot(southEast, zAxis), dot(northEast, zAxis))\n            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);\n            const minZ = Math.min(cosNorth * d + sinNorth * sinMidY, cosSouth * d + sinSouth * sinMidY);\n            MathUtils_1.MathUtils.newVector3(width * rMax, (maxY - minY) * rMax, rMax - minZ * rMin, result.extents);\n            MathUtils_1.MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);\n            apply(result.xAxis, result.yAxis, result.zAxis, result.position);\n            result.position.x = result.position.x - result.zAxis.x * result.extents.z;\n            result.position.y = result.position.y - result.zAxis.y * result.extents.z;\n            result.position.z = result.position.z - result.zAxis.z * result.extents.z;\n            return result;\n        }\n        throw new Error(\"Invalid bounding box\");\n    }\n    /** @override */\n    unprojectBox(_worldBox) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @override */\n    getScaleFactor(_worldPoint) {\n        return 1;\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return lengthOfVector3(worldPoint) - this.unitScale;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);\n        worldPoint.x *= scale;\n        worldPoint.y *= scale;\n        worldPoint.z *= scale;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 0 };\n        }\n        const scale = 1 / (lengthOfVector3(worldPoint) || 1);\n        normal.x = worldPoint.x * scale;\n        normal.y = worldPoint.y * scale;\n        normal.z = worldPoint.z * scale;\n        return normal;\n    }\n    /** @override */\n    reprojectPoint(sourceProjection, worldPos, result) {\n        if (sourceProjection === MercatorProjection_1.mercatorProjection || sourceProjection === MercatorProjection_1.webMercatorProjection) {\n            const { x, y, z } = worldPos;\n            const r = this.unitScale;\n            const mx = x / r - Math.PI;\n            const my = y / r - Math.PI;\n            const w = Math.exp(my);\n            const d = w * w;\n            const gx = (2 * w) / (d + 1);\n            const gy = (d - 1) / (d + 1);\n            const scale = r + z;\n            if (result === undefined) {\n                // tslint:disable-next-line: no-object-literal-type-assertion\n                result = {};\n            }\n            result.x = Math.cos(mx) * gx * scale;\n            result.y = Math.sin(mx) * gx * scale;\n            result.z = gy * scale;\n            if (sourceProjection === MercatorProjection_1.webMercatorProjection) {\n                result.z = -result.z;\n            }\n            return result;\n        }\n        return super.reprojectPoint(sourceProjection, worldPos, result);\n    }\n    /** @override */\n    localTangentSpace(geoPoint, result) {\n        const latitude = THREE.Math.degToRad(geoPoint.latitude);\n        const longitude = THREE.Math.degToRad(geoPoint.longitude);\n        const cosLongitude = Math.cos(longitude);\n        const sinLongitude = Math.sin(longitude);\n        const cosLatitude = Math.cos(latitude);\n        const sinLatitude = Math.sin(latitude);\n        MathUtils_1.MathUtils.newVector3(cosLongitude * cosLatitude, sinLongitude * cosLatitude, sinLatitude, result.zAxis);\n        MathUtils_1.MathUtils.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);\n        MathUtils_1.MathUtils.newVector3(-cosLongitude * sinLatitude, -sinLongitude * sinLatitude, cosLatitude, result.yAxis);\n        this.projectPoint(geoPoint, result.position);\n        return result;\n    }\n}\nexports.sphereProjection = new SphereProjection(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/SphereProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoBox.js\");\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ \"./node_modules/@here/harp-geoutils/lib/math/Box3Like.js\");\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\nconst OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ \"./node_modules/@here/harp-geoutils/lib/math/OrientedBox3Like.js\");\nconst EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst Projection_1 = __webpack_require__(/*! ./Projection */ \"./node_modules/@here/harp-geoutils/lib/projection/Projection.js\");\n/**\n *\n * https://en.wikipedia.org/wiki/Transverse_Mercator_projection\n * http://mathworld.wolfram.com/MercatorProjection.html\n *\n */\nclass TransverseMercatorProjection extends Projection_1.Projection {\n    constructor(unitScale) {\n        super(unitScale);\n        this.unitScale = unitScale;\n        /** @override */\n        this.type = Projection_1.ProjectionType.Planar;\n        this.m_phi0 = 0;\n        this.m_lambda0 = 0;\n    }\n    /**\n     * Like in regular Mercator projection, there are two points on sphere\n     * with radius about 5 degrees, that is out of projected space.\n     *\n     *\n     * in regular Mercator these points are:\n     *     (90, any), (-90, any)\n     *\n     * and in transverse Mercator:\n     *     (0, 90), (0, -90)\n     *\n     * So, in transverse we need to compute distnce to poles, and clamp if\n     * radius is exceeded\n     */\n    static clampGeoPoint(geoPoint, unitScale) {\n        const lat = geoPoint.latitude;\n        const lon = geoPoint.longitude;\n        const r = TransverseMercatorUtils.POLE_RADIUS;\n        const rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;\n        const nearestQuarter = Math.round(lon / 90);\n        const deltaLon = nearestQuarter * 90 - lon;\n        if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {\n            return geoPoint;\n        }\n        const deltaLat = lat - 0;\n        const distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;\n        if (distanceToPoleSq < rsq) {\n            const distanceToPole = Math.sqrt(distanceToPoleSq);\n            const scale = (r - distanceToPole) / distanceToPole;\n            // const quarter = ((nearestQuarter % 4) + 4) % 4;\n            // const dir = quarter === 1 ? -1 : quarter === 3 ? 1 : 0;\n            const dir = 1;\n            const offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;\n            return new GeoCoordinates_1.GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);\n        }\n        return geoPoint;\n    }\n    /** @override */\n    getScaleFactor(worldPoint) {\n        return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);\n    }\n    /** @override */\n    worldExtent(minAltitude, maxAltitude, result) {\n        if (!result) {\n            result = MathUtils_1.MathUtils.newEmptyBox3();\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n    /** @override */\n    projectPoint(geoPoint, result) {\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 };\n        }\n        const clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);\n        const normalLon = clamped.longitude / 360 + 0.5;\n        const offset = normalLon === 1 ? 0 : Math.floor(normalLon);\n        const phi = MathUtils_1.MathUtils.degToRad(clamped.latitude);\n        const lambda = MathUtils_1.MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;\n        const B = Math.cos(phi) * Math.sin(lambda);\n        // result.x = 1/2 * Math.log((1 + B) / (1 - B));\n        result.x = Math.atanh(B);\n        result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;\n        const outScale = 0.5 / Math.PI;\n        result.x = this.unitScale * (MathUtils_1.MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);\n        result.y = this.unitScale * MathUtils_1.MathUtils.clamp(result.y * outScale + 0.5, 0, 1);\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n    /** @override */\n    unprojectPoint(worldPoint) {\n        const tau = Math.PI * 2;\n        const nx = worldPoint.x / this.unitScale;\n        const ny = worldPoint.y / this.unitScale;\n        const offset = nx === 1 ? 0 : Math.floor(nx);\n        const x = tau * (nx - 0.5 - offset);\n        const y = tau * (ny - 0.5);\n        const z = worldPoint.z || 0;\n        const D = y + this.m_phi0;\n        const phi = Math.asin(Math.sin(D) / Math.cosh(x));\n        const lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;\n        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(phi, lambda, z);\n        return geoPoint;\n    }\n    /** @override */\n    projectBox(geoBox, result) {\n        const { north, south, east, west } = geoBox;\n        const pointsToCheck = [\n            geoBox.center,\n            geoBox.northEast,\n            geoBox.southWest,\n            new GeoCoordinates_1.GeoCoordinates(south, east),\n            new GeoCoordinates_1.GeoCoordinates(north, west)\n        ];\n        const E = TransverseMercatorUtils.POLE_EDGE_DEG;\n        const containsWestCut = west < -90 && east > -90;\n        const containsEastCut = west < 90 && east > 90;\n        const containsCenterX = west < 0 && east > 0;\n        const containsCenterY = west < E && east > -E && north > 0 && south < 0;\n        if (containsWestCut) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, -90));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, -90));\n        }\n        if (containsEastCut) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 90));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 90));\n        }\n        if (containsCenterX) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 0));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 0));\n        }\n        if (containsCenterY) {\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, west));\n            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, east));\n        }\n        TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);\n        const projected = pointsToCheck.map(p => this.projectPoint(p));\n        const vx = projected.map(p => p.x);\n        const vy = projected.map(p => p.y);\n        const vz = projected.map(p => p.z);\n        const minX = Math.min(...vx);\n        const minY = Math.min(...vy);\n        const minZ = Math.min(...vz);\n        const maxX = Math.max(...vx);\n        const maxY = Math.max(...vy);\n        const maxZ = Math.max(...vz);\n        if (!result) {\n            result = MathUtils_1.MathUtils.newEmptyBox3();\n        }\n        if (Box3Like_1.isBox3Like(result)) {\n            result.min.x = minX;\n            result.min.y = minY;\n            result.min.z = minZ;\n            result.max.x = maxX;\n            result.max.y = maxY;\n            result.max.z = maxZ;\n        }\n        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {\n            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (minX + maxX) / 2;\n            result.position.y = (minY + maxY) / 2;\n            result.position.z = (minZ + maxZ) / 2;\n            result.extents.x = (maxX - minX) / 2;\n            result.extents.y = (maxY - minY) / 2;\n            result.extents.z = (maxZ - minZ) / 2;\n        }\n        else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n    /**\n     * There are 8 sub-regions on entire projection space\n     * where both longitude and latitude preserve direction.\n     * If bounding box hits more than one region, it should be splitted\n     * into sub-boxes by regions, (un)projected and then united again.\n     *\n     *\n     * directions in form [latitude / longitude]:\n     *    1 ┌─────────|─────────┐\n     *      │ dr / dl | dl / ul │\n     * 0.75 ----------|----------\n     *      │ ur / dr | ul / ur │\n     * 0.5  ----------|----------\n     *      │ ul / ur | ur / dr │\n     * 0.25 ----------|----------\n     *      │ dl / ul | dr / dl │\n     *      └─────────|─────────┘\n     *     0         0.5        1\n     *     @override\n     */\n    unprojectBox(worldBox) {\n        const s = this.unitScale;\n        const min = worldBox.min;\n        const max = worldBox.max;\n        const pointsToCheck = [\n            { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2, z: 0 },\n            min,\n            max,\n            { x: min.x, y: max.y, z: 0 },\n            { x: max.x, y: min.y, z: 0 }\n        ];\n        const center = 0.5 * s;\n        const lowerQ = 0.25 * s;\n        const upperQ = 0.75 * s;\n        const containsCenterX = min.x < center && max.x > center;\n        const containsCenterY = min.y < center && max.y > center;\n        const containsLowerQY = min.y < lowerQ && max.y > lowerQ;\n        const containsUpperQY = min.y < upperQ && max.y > upperQ;\n        if (containsCenterY) {\n            pointsToCheck.push({ x: min.x, y: center, z: 0 });\n            pointsToCheck.push({ x: max.x, y: center, z: 0 });\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: center, z: 0 });\n            }\n        }\n        if (containsLowerQY) {\n            pointsToCheck.push({ x: min.x, y: lowerQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: lowerQ, z: 0 });\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: lowerQ, z: 0 });\n            }\n        }\n        if (containsUpperQY) {\n            pointsToCheck.push({ x: min.x, y: upperQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: upperQ, z: 0 });\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: upperQ, z: 0 });\n            }\n        }\n        const geoPoints = pointsToCheck.map(p => this.unprojectPoint(p));\n        TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);\n        const latitudes = geoPoints.map(g => g.latitude);\n        const longitudes = geoPoints.filter(g => Math.abs(g.latitude) < 90).map(g => g.longitude);\n        const altitudes = geoPoints.map(g => g.altitude || 0);\n        const minGeo = new GeoCoordinates_1.GeoCoordinates(Math.min(...latitudes), Math.min(...longitudes), Math.min(...altitudes));\n        const maxGeo = new GeoCoordinates_1.GeoCoordinates(Math.max(...latitudes), Math.max(...longitudes), Math.max(...altitudes));\n        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n    /** @override */\n    unprojectAltitude(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    groundDistance(worldPoint) {\n        return worldPoint.z;\n    }\n    /** @override */\n    scalePointToSurface(worldPoint) {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n    /** @override */\n    surfaceNormal(_worldPoint, normal) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        }\n        else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n}\nclass TransverseMercatorUtils {\n    /**\n     * There are two regions on projected space that have same geo coordinates,\n     * it's the entire lines   { x: [0..1], y: 0 } and { x: [0..1], y: 1 }\n     * they both have geo coordinates of   (0, [-90..+90])\n     * and should be aligned somehow to fall into first or second region\n     * to make proper bounding boxes, tile bounds, etc.\n     */\n    static alignLatitude(points, referencePoint) {\n        const EPSILON = 1e-9;\n        for (const point of points) {\n            if (point.latitude === 0) {\n                point.latitude = referencePoint.latitude * EPSILON;\n            }\n        }\n    }\n    /**\n     * There are two regions on projected plane,\n     * { x: 0.5, y: [0..0.25] }    and    { x: 0.5, y: [0.75..1] }\n     * that represent longitude edge where -180 and +180 met.\n     * Points falling in this regions should be aligned to get proper boxes etc.\n     */\n    static alignLongitude(points, referencePoint) {\n        const bad = referencePoint.longitude < 0 ? 180 : -180;\n        const good = referencePoint.longitude < 0 ? -180 : 180;\n        for (const point of points) {\n            if (point.longitude === bad) {\n                point.longitude = good;\n            }\n        }\n    }\n}\nexports.TransverseMercatorUtils = TransverseMercatorUtils;\nTransverseMercatorUtils.POLE_EDGE = 1.4844222297453323;\nTransverseMercatorUtils.POLE_EDGE_DEG = MathUtils_1.MathUtils.radToDeg(TransverseMercatorUtils.POLE_EDGE);\nTransverseMercatorUtils.POLE_RADIUS = 90 - TransverseMercatorUtils.POLE_EDGE_DEG;\nTransverseMercatorUtils.POLE_RADIUS_SQ = Math.pow(TransverseMercatorUtils.POLE_RADIUS, 2);\n/**\n * Transverse Mercator [[Projection]] used to convert geo coordinates to world coordinates\n * and vice versa.\n */\nexports.transverseMercatorProjection = new TransverseMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ \"./node_modules/@here/harp-geoutils/lib/math/MathUtils.js\");\n/**\n * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given\n * TilingScheme.\n */\nclass FlatTileBoundingBoxGenerator {\n    /**\n     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given\n     * TilingScheme.\n     *\n     * @param tilingScheme The [[TilingScheme]] used to compute bounding boxes.\n     * @param minElevation The minimum elevation in meters.\n     * @param maxElevation The maximum elevation in meters.\n     */\n    constructor(tilingScheme, minElevation = 0, maxElevation = 0) {\n        this.tilingScheme = tilingScheme;\n        this.minElevation = minElevation;\n        this.maxElevation = maxElevation;\n        this.m_tilingScheme = tilingScheme;\n        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);\n        const { min, max } = this.m_worldBox;\n        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };\n    }\n    /**\n     * Returns the [[Projection]] of the [[TilingScheme]].\n     */\n    get projection() {\n        return this.m_tilingScheme.projection;\n    }\n    /**\n     * Returns the [[SubdivisionScheme]] of the [[TilingScheme]].\n     */\n    get subdivisionScheme() {\n        return this.m_tilingScheme.subdivisionScheme;\n    }\n    /**\n     * Returns the bounding box in world coordinates of the given [[TileKey]].\n     *\n     * Example:\n     * ```typescript\n     * const worldBounds = new THREE.Box3();\n     * generator.getWorldBox(geoBox, worldBounds);\n     * console.log(worldBounds.getCenter());\n     * ```\n     *\n     * @param tileKey The TileKey.\n     * @param result The optional object used to store the resulting bounding box in world\n     * coordinates.\n     */\n    getWorldBox(tileKey, result) {\n        const level = tileKey.level;\n        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);\n        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);\n        const sizeX = this.m_worldDimensions.x / levelDimensionX;\n        const sizeY = this.m_worldDimensions.y / levelDimensionY;\n        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;\n        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;\n        if (!result) {\n            result = MathUtils_1.MathUtils.newEmptyBox3();\n        }\n        result.min.x = originX;\n        result.min.y = originY;\n        result.min.z = this.m_worldBox.min.z;\n        result.max.x = originX + sizeX;\n        result.max.y = originY + sizeY;\n        result.max.z = this.m_worldBox.max.z;\n        return result;\n    }\n    /**\n     * Returns the bounding box in geo coordinates for the given [[TileKey]].\n     *\n     * Example:\n     * ```typescript\n     * const geoBox = generator.getGeoBox(worldBounds);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tileKey The [[TileKey]].\n     */\n    getGeoBox(tileKey) {\n        const worldBox = this.getWorldBox(tileKey);\n        return this.projection.unprojectBox(worldBox);\n    }\n}\nexports.FlatTileBoundingBoxGenerator = FlatTileBoundingBoxGenerator;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass HalfQuadTreeSubdivisionScheme {\n    getSubdivisionX() {\n        return 2;\n    }\n    getSubdivisionY(level) {\n        return level === 0 ? 1 : 2;\n    }\n    getLevelDimensionX(level) {\n        // tslint:disable-next-line:no-bitwise\n        return 1 << level;\n    }\n    getLevelDimensionY(level) {\n        // tslint:disable-next-line:no-bitwise\n        return level !== 0 ? 1 << (level - 1) : 1;\n    }\n}\n/**\n * A [[SubdivisionScheme]] used to represent half quadtrees. This particular subdivision scheme is\n * used by the HERE tiling scheme.\n */\nexports.halfQuadTreeSubdivisionScheme = new HalfQuadTreeSubdivisionScheme();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EquirectangularProjection_1 = __webpack_require__(/*! ../projection/EquirectangularProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/EquirectangularProjection.js\");\nconst HalfQuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./HalfQuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * [[TilingScheme]] used by most of the data published by HERE.\n *\n * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular\n * projection.\n */\nexports.hereTilingScheme = new TilingScheme_1.TilingScheme(HalfQuadTreeSubdivisionScheme_1.halfQuadTreeSubdivisionScheme, EquirectangularProjection_1.normalizedEquirectangularProjection);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/HereTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\");\nconst QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * The [[TilingScheme]] used by the HERE web tiles.\n *\n * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.\n */\nexports.mercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.mercatorProjection);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/MercatorTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TransverseMercatorProjection_1 = __webpack_require__(/*! ../projection/TransverseMercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/TransverseMercatorProjection.js\");\nconst QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * A [[TilingScheme]] featuring quadtree subdivision scheme and\n * transverse Mercator projection.\n */\nexports.polarTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, TransverseMercatorProjection_1.transverseMercatorProjection);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/PolarTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TileKey_1 = __webpack_require__(/*! ./TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\");\n/**\n * A class used to represent a quadtree.\n */\nclass QuadTree {\n    /**\n     * Constructs a new `QuadTree` for the given [[TilingScheme]].\n     *\n     * Example:\n     * ```typescript\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * const geoBox = quadTree.getGeoBox(tileKey);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tilingScheme The TilingScheme used by this `QuadTree`.\n     */\n    constructor(tilingScheme) {\n        this.tilingScheme = tilingScheme;\n    }\n    /**\n     * Visits this `QuadTree` and invoke the given accept method with the current [[TileKey]] and\n     * its bounding box in geo coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = new GeoCoordinates(latitude, longitude);\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * quadTree.visit((tileKey, geoBox) => {\n     *     if (geoBox.contains(geoPos)) {\n     *         console.log(\"tile\", tileKey, \"contains\", geoPos);\n     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.\n     *     }\n     *     return false; // stop visiting the quadtree,\n     *                   // the tile's geoBox doesn't contain the given coordinates.\n     * });\n     * ```\n     *\n     * @param accept A function that takes a [[TileKey]] and its bounding box in geo coordinates and\n     * returns `true` if the visit of the `QuadTree` should continue; otherwise `false`.\n     */\n    visit(accept) {\n        this.visitTileKey(TileKey_1.TileKey.fromRowColumnLevel(0, 0, 0), accept);\n    }\n    /**\n     * Visits the subtree starting from the given tile.\n     *\n     * @param tileKey The root of the subtree that should be visited.\n     * @param accept A function that takes a [[TileKey]] and its bounding box in geo coordinates and\n     * returns `true` if the visit of the `QuadTree` should continue; otherwise `false`.\n     */\n    visitTileKey(tileKey, accept) {\n        const geoBox = this.tilingScheme.getGeoBox(tileKey);\n        if (!accept(tileKey, geoBox)) {\n            return;\n        }\n        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {\n            this.visitTileKey(subTileKey, accept);\n        }\n    }\n}\nexports.QuadTree = QuadTree;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/QuadTree.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass QuadTreeSubdivisionScheme {\n    getSubdivisionX() {\n        return 2;\n    }\n    getSubdivisionY() {\n        return 2;\n    }\n    getLevelDimensionX(level) {\n        // tslint:disable-next-line:no-bitwise\n        return 1 << level;\n    }\n    getLevelDimensionY(level) {\n        // tslint:disable-next-line:no-bitwise\n        return 1 << level;\n    }\n}\n/**\n * [[SubdivisionScheme]] representing a quadtree.\n */\nexports.quadTreeSubdivisionScheme = new QuadTreeSubdivisionScheme();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TileKey_1 = __webpack_require__(/*! ./TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\");\nclass SubTiles {\n    constructor(tileKey, sizeX, sizeY) {\n        this.tileKey = tileKey;\n        this.sizeX = sizeX;\n        this.sizeY = sizeY;\n    }\n    [Symbol.iterator]() {\n        return this.sizeX === 2 && this.sizeY === 2\n            ? SubTiles.ZCurveIterator(this.tileKey)\n            : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);\n    }\n}\nexports.SubTiles = SubTiles;\n(function (SubTiles) {\n    function* RowColumnIterator(parentKey, sizeX, sizeY) {\n        for (let y = 0; y < sizeY; y++) {\n            for (let x = 0; x < sizeX; x++) {\n                yield TileKey_1.TileKey.fromRowColumnLevel(parentKey.row * sizeY + y, parentKey.column * sizeX + x, parentKey.level + 1);\n            }\n        }\n    }\n    SubTiles.RowColumnIterator = RowColumnIterator;\n    function* ZCurveIterator(parentKey) {\n        // tslint:disable:no-bitwise\n        for (let i = 0; i < 4; i++) {\n            yield TileKey_1.TileKey.fromRowColumnLevel((parentKey.row << 1) | (i >> 1), (parentKey.column << 1) | (i & 1), parentKey.level + 1);\n        }\n        // tslint:enableno-bitwise\n    }\n    SubTiles.ZCurveIterator = ZCurveIterator;\n})(SubTiles = exports.SubTiles || (exports.SubTiles = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @hidden */\nconst powerOfTwo = [\n    0x1,\n    0x2,\n    0x4,\n    0x8,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x100,\n    0x200,\n    0x400,\n    0x800,\n    0x1000,\n    0x2000,\n    0x4000,\n    0x8000,\n    0x10000,\n    0x20000,\n    0x40000,\n    0x80000,\n    0x100000,\n    0x200000,\n    0x400000,\n    0x800000,\n    0x1000000,\n    0x2000000,\n    0x4000000,\n    0x8000000,\n    0x10000000,\n    0x20000000,\n    0x40000000,\n    0x80000000,\n    0x100000000,\n    0x200000000,\n    0x400000000,\n    0x800000000,\n    0x1000000000,\n    0x2000000000,\n    0x4000000000,\n    0x8000000000,\n    0x10000000000,\n    0x20000000000,\n    0x40000000000,\n    0x80000000000,\n    0x100000000000,\n    0x200000000000,\n    0x400000000000,\n    0x800000000000,\n    0x1000000000000,\n    0x2000000000000,\n    0x4000000000000,\n    0x8000000000000,\n    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.\n];\n/**\n * The `TileKey` instances are used to address a tile in a quadtree.\n *\n * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one\n * single tile. On every level, each tile is divided into four children (therefore the name\n * quadtree).\n *\n * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number\n * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only\n * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles\n * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.\n *\n * A tile key is usually created using [[fromRowColumnLevel]]() method.\n *\n * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not\n * modify the original object.\n *\n * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for\n * easy vertical navigation of the tree. The number of available rows and columns in the tile's\n * level is given with [[rowCount]]() and [[columnCount]]().\n *\n * Tile keys can be created from and converted into various alternative formats:\n *\n *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based\n *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based\n *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation\n *\n * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be\n * represented in the number representation returned by [[mortonCode]]().\n */\nclass TileKey {\n    /**\n     * Constructs a new immutable instance of a `TileKey`.\n     *\n     * For the better readability, [[TileKey.fromRowColumnLevel]] should be preferred.\n     *\n     * Note - row and column must not be greater than the maximum rows/columns for the given level.\n     *\n     * @param row Represents the row in the quadtree.\n     * @param column Represents the column in the quadtree.\n     * @param level Represents the level in the quadtree.\n     */\n    constructor(row, column, level) {\n        this.row = row;\n        this.column = column;\n        this.level = level;\n    }\n    /**\n     * Creates a tile key.\n     *\n     * @param row The requested row. Must be less than 2 to the power of level.\n     * @param column The requested column. Must be less than 2 to the power of level.\n     * @param level The requested level.\n     */\n    static fromRowColumnLevel(row, column, level) {\n        return new TileKey(row, column, level);\n    }\n    /**\n     * Creates a tile key from a quad string.\n     *\n     * The quad string can be created with [[toQuadKey]].\n     *\n     * @param quadkey The quadkey to convert.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromQuadKey(quadkey) {\n        const level = quadkey.length;\n        let row = 0;\n        let column = 0;\n        // tslint:disable:no-bitwise\n        for (let i = 0; i < quadkey.length; ++i) {\n            const mask = 1 << i;\n            const d = parseInt(quadkey.charAt(level - i - 1), 10);\n            if (d & 0x1) {\n                column |= mask;\n            }\n            if (d & 0x2) {\n                row |= mask;\n            }\n        }\n        // tslint:enable:no-bitwise\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n    /**\n     * Creates a tile key from a numeric Morton code representation.\n     *\n     * You can convert a tile key into a numeric Morton code with [[mortonCode]].\n     *\n     * @param quadKey64 The Morton code to be converted.\n     * @returns A new instance of [[TileKey]].\n     */\n    static fromMortonCode(quadKey64) {\n        let level = 0;\n        let row = 0;\n        let column = 0;\n        let quadKey = quadKey64;\n        // tslint:disable:no-bitwise\n        while (quadKey > 1) {\n            const mask = 1 << level;\n            if (quadKey & 0x1) {\n                column |= mask;\n            }\n            if (quadKey & 0x2) {\n                row |= mask;\n            }\n            level++;\n            quadKey = (quadKey - (quadKey & 0x3)) / 4;\n        }\n        // tslint:enable:no-bitwise\n        const result = TileKey.fromRowColumnLevel(row, column, level);\n        result.m_mortonCode = quadKey64;\n        return result;\n    }\n    /**\n     * Creates a tile key from a heretile code string.\n     *\n     * The string can be created with [[toHereTile]].\n     *\n     * @param quadkey64 The string representation of the HERE tile key.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromHereTile(quadkey64) {\n        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));\n        result.m_hereTile = quadkey64;\n        return result;\n    }\n    /**\n     * Returns the number of available columns at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level The level for which to return the number of columns.\n     * @returns The available columns at the given level.\n     */\n    static columnsAtLevel(level) {\n        return Math.pow(2, level);\n    }\n    /**\n     * Returns the number of available rows at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level The level for which to return the number of rows.\n     * @returns The available rows at the given level.\n     */\n    static rowsAtLevel(level) {\n        return Math.pow(2, level);\n    }\n    /**\n     * Returns the closest matching `TileKey` in a cartesian coordinate system.\n     *\n     * @param level The level for the tile key.\n     * @param coordX The X coordinate.\n     * @param coordY The Y coordinate.\n     * @param totalWidth The maximum X coordinate.\n     * @param totalHeight The maximum Y coordinate.\n     * @returns A new tile key at the given level that includes the given coordinates.\n     */\n    static atCoords(level, coordX, coordY, totalWidth, totalHeight) {\n        return TileKey.fromRowColumnLevel(Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))), Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))), level);\n    }\n    /**\n     * Computes the Morton code of the parent tile key of the given Morton code.\n     *\n     * Note: The parent key of the root key is the root key itself.\n     *\n     * @param mortonCode A Morton code, for example, obtained from [[mortonCode]].\n     * @returns The Morton code of the parent tile.\n     */\n    static parentMortonCode(mortonCode) {\n        return Math.floor(mortonCode / 4);\n    }\n    /**\n     * Returns a tile key representing the parent of the tile addressed by this tile key.\n     *\n     * Throws an exception is this tile is already the root.\n     */\n    parent() {\n        if (this.level === 0) {\n            throw new Error(\"Cannot get the parent of the root tile key\");\n        }\n        // tslint:disable-next-line:no-bitwise\n        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);\n    }\n    /**\n     * Returns a new tile key at a level that differs from this tile's level by delta.\n     *\n     * Equivalent to `changedLevelTo(level() + delta)`.\n     *\n     * Note - root key is returned if `delta` is smaller than the level of this tile key.\n     *\n     * @param delta The numeric difference between the current level and the requested level.\n     */\n    changedLevelBy(delta) {\n        const level = Math.max(0, this.level + delta);\n        let row = this.row;\n        let column = this.column;\n        // tslint:disable:no-bitwise\n        if (delta >= 0) {\n            row <<= delta;\n            column <<= delta;\n        }\n        else {\n            row >>>= -delta;\n            column >>>= -delta;\n        }\n        // tslint:enable:no-bitwise\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n    /**\n     * Returns a new tile key at the requested level.\n     *\n     * If the requested level is smaller than the tile's level, then the key of an ancestor of this\n     * tile is returned. If the requested level is larger than the tile's level, then the key of\n     * first child or grandchild of this tile is returned, for example, the child with the lowest\n     * row and column number. If the requested level equals this tile's level, then the tile key\n     * itself is returned. If the requested level is negative, the root tile key is returned.\n     *\n     * @param level The requested level.\n     */\n    changedLevelTo(level) {\n        return this.changedLevelBy(level - this.level);\n    }\n    /**\n     * Converts the tile key to a numeric code representation.\n     *\n     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].\n     *\n     * Note - only levels <= 26 are supported.\n     */\n    mortonCode() {\n        if (this.m_mortonCode === undefined) {\n            let column = this.column;\n            let row = this.row;\n            // tslint:disable:no-bitwise\n            let result = powerOfTwo[this.level << 1];\n            for (let i = 0; i < this.level; ++i) {\n                if (column & 0x1) {\n                    result += powerOfTwo[2 * i];\n                }\n                if (row & 0x1) {\n                    result += powerOfTwo[2 * i + 1];\n                }\n                column >>>= 1;\n                row >>>= 1;\n            }\n            // tslint:enable:no-bitwise\n            this.m_mortonCode = result;\n        }\n        return this.m_mortonCode;\n    }\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * The string is a quadkey Morton code representation as a string.\n     *\n     * You can convert back from a quadkey string with [[fromHereTile]].\n     */\n    toHereTile() {\n        if (this.m_hereTile === undefined) {\n            this.m_hereTile = this.mortonCode().toString();\n        }\n        return this.m_hereTile;\n    }\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the\n     * base of 4, but without the leading 1, with the following properties:\n     *  1. the number of digits equals the level.\n     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3\n     *     to a quadkey string gives the tiles's children.\n     *\n     * You can convert back from a quadkey string with [[fromQuadKey]].\n     */\n    toQuadKey() {\n        let result = \"\";\n        // tslint:disable:no-bitwise\n        for (let i = this.level; i > 0; --i) {\n            const mask = 1 << (i - 1);\n            const col = (this.column & mask) !== 0;\n            const row = (this.row & mask) !== 0;\n            if (col && row) {\n                result += \"3\";\n            }\n            else if (row) {\n                result += \"2\";\n            }\n            else if (col) {\n                result += \"1\";\n            }\n            else {\n                result += \"0\";\n            }\n        }\n        // tslint:enable:no-bitwise\n        return result;\n    }\n    /**\n     * Equality operator.\n     *\n     * @param qnr The tile key to compare to.\n     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.\n     */\n    equals(qnr) {\n        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;\n    }\n    /**\n     * Returns the absolute quadkey that is constructed from its sub quadkey.\n     *\n     * @param sub The sub key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubKey(sub) {\n        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? \"-\" : sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);\n    }\n    /**\n     * Returns the absolute quadkey that is constructed from its sub HERE tile key.\n     *\n     * @param sub The sub HERE key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubHereTile(sub) {\n        const subQuad = TileKey.fromHereTile(sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);\n    }\n    /**\n     * Returns a sub quadkey that is relative to its parent.\n     *\n     * This function can be used to generate sub keys that are relative to a parent that is delta\n     * levels up in the quadtree.\n     *\n     * This function can be used to create shortened keys for quads on lower levels if the parent is\n     * known.\n     *\n     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If\n     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.\n     *\n     * Deltas larger than 16 are not supported.\n     *\n     * @param delta The number of levels relative to its parent quadkey. Must be greater or equal to\n     * 0 and smaller than 16.\n     * @returns The quadkey relative to its parent that is `delta` levels up the tree.\n     */\n    getSubHereTile(delta) {\n        const key = this.mortonCode();\n        // tslint:disable-next-line:no-bitwise\n        const msb = 1 << (delta * 2);\n        const mask = msb - 1;\n        // tslint:disable-next-line:no-bitwise\n        const result = (key & mask) | msb;\n        return result.toString();\n    }\n    /**\n     * Returns the number of available rows in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    rowCount() {\n        return TileKey.rowsAtLevel(this.level);\n    }\n    /**\n     * Returns the number of available columns in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    columnCount() {\n        return TileKey.columnsAtLevel(this.level);\n    }\n}\nexports.TileKey = TileKey;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ \"./node_modules/@here/harp-geoutils/lib/coordinates/GeoCoordinates.js\");\nconst TileKey_1 = __webpack_require__(/*! ./TileKey */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKey.js\");\nclass TileKeyUtils {\n    static geoCoordinatesToTileKey(tilingScheme, geoPoint, level) {\n        const projection = tilingScheme.projection;\n        const worldPoint = projection.projectPoint(geoPoint);\n        return this.worldCoordinatesToTileKey(tilingScheme, worldPoint, level);\n    }\n    static worldCoordinatesToTileKey(tilingScheme, worldPoint, level) {\n        const projection = tilingScheme.projection;\n        const subdivisionScheme = tilingScheme.subdivisionScheme;\n        const cx = subdivisionScheme.getLevelDimensionX(level);\n        const cy = subdivisionScheme.getLevelDimensionY(level);\n        const { min, max } = projection.worldExtent(0, 0);\n        const worldSizeX = max.x - min.x;\n        const worldSizeY = max.y - min.y;\n        if (worldPoint.x < min.x || worldPoint.x > max.x) {\n            return null;\n        }\n        if (worldPoint.y < min.y || worldPoint.y > max.y) {\n            return null;\n        }\n        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));\n        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));\n        return TileKey_1.TileKey.fromRowColumnLevel(row, column, level);\n    }\n    static geoRectangleToTileKeys(tilingScheme, geoBox, level) {\n        const wrap = (value, lower, upper) => {\n            if (value < lower) {\n                return upper - ((lower - value) % (upper - lower));\n            }\n            return lower + ((value - lower) % (upper - lower));\n        };\n        const clamp = (x, minVal, maxVal) => {\n            return Math.min(Math.max(x, minVal), maxVal);\n        };\n        // Clamp at the poles and wrap around the international date line.\n        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);\n        const southWestLatitude = clamp(geoBox.southWest.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);\n        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);\n        const northEastLatitude = clamp(geoBox.northEast.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);\n        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude), level);\n        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude), level);\n        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);\n        if (!minTileKey || !maxTileKey) {\n            throw new Error(\"Invalid coordinates\");\n        }\n        const minColumn = minTileKey.column;\n        let maxColumn = maxTileKey.column;\n        // wrap around case\n        if (southWestLongitude > northEastLongitude) {\n            if (maxColumn !== minColumn) {\n                maxColumn += columnCount;\n            }\n            else {\n                // do not duplicate\n                maxColumn += columnCount - 1;\n            }\n        }\n        const minRow = Math.min(minTileKey.row, maxTileKey.row);\n        const maxRow = Math.max(minTileKey.row, maxTileKey.row);\n        const keys = new Array();\n        for (let row = minRow; row <= maxRow; ++row) {\n            for (let column = minColumn; column <= maxColumn; ++column) {\n                keys.push(TileKey_1.TileKey.fromRowColumnLevel(row, column % columnCount, level));\n            }\n        }\n        return keys;\n    }\n}\nexports.TileKeyUtils = TileKeyUtils;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SubTiles_1 = __webpack_require__(/*! ./SubTiles */ \"./node_modules/@here/harp-geoutils/lib/tiling/SubTiles.js\");\nclass TileTreeTraverse {\n    constructor(subdivisionScheme) {\n        this.m_subdivisionScheme = subdivisionScheme;\n    }\n    subTiles(tileKey) {\n        const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);\n        const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);\n        return new SubTiles_1.SubTiles(tileKey, divX, divY);\n    }\n}\nexports.TileTreeTraverse = TileTreeTraverse;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst FlatTileBoundingBoxGenerator_1 = __webpack_require__(/*! ./FlatTileBoundingBoxGenerator */ \"./node_modules/@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.js\");\nconst TileKeyUtils_1 = __webpack_require__(/*! ./TileKeyUtils */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileKeyUtils.js\");\nconst TileTreeTraverse_1 = __webpack_require__(/*! ./TileTreeTraverse */ \"./node_modules/@here/harp-geoutils/lib/tiling/TileTreeTraverse.js\");\n/**\n * The `TilingScheme` represents how the data is tiled.\n */\nclass TilingScheme {\n    /**\n     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.\n     *\n     * @param subdivisionScheme The subdivision scheme used by this `TilingScheme`.\n     * @param projection The projection used by this `TilingScheme`.\n     */\n    constructor(subdivisionScheme, projection) {\n        this.subdivisionScheme = subdivisionScheme;\n        this.projection = projection;\n        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator_1.FlatTileBoundingBoxGenerator(this);\n        this.tileTreeTraverse = new TileTreeTraverse_1.TileTreeTraverse(subdivisionScheme);\n    }\n    /**\n     * Returns the sub tile keys of the given tile.\n     *\n     * @param tileKey The [[TileKey]].\n     * @returns The list of the sub tile keys.\n     */\n    getSubTileKeys(tileKey) {\n        return this.tileTreeTraverse.subTiles(tileKey);\n    }\n    /**\n     * Gets the [[TileKey]] from the given geo position and level.\n     *\n     * @param geoPoint The position in geo coordinates.\n     * @param level The level of the resulting `TileKey`.\n     */\n    getTileKey(geoPoint, level) {\n        return TileKeyUtils_1.TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);\n    }\n    /**\n     * Gets the list of [[TileKey]]s contained in the given [[GeoBox]].\n     *\n     * @param geoBox The bounding box in geo coordinates.\n     * @param level The level of the resulting `TileKey`.\n     */\n    getTileKeys(geoBox, level) {\n        return TileKeyUtils_1.TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);\n    }\n    /**\n     * Returns the bounding box in geo coordinates for the given [[TileKey]].\n     *\n     * @param tileKey The `TileKey`.\n     */\n    getGeoBox(tileKey) {\n        return this.boundingBoxGenerator.getGeoBox(tileKey);\n    }\n    /**\n     * Returns the bounding box in world coordinates.\n     *\n     * @param tileKey The `TileKey`.\n     * @param result The optional object that will contain the resulting bounding box.\n     */\n    getWorldBox(tileKey, result) {\n        return this.boundingBoxGenerator.getWorldBox(tileKey, result);\n    }\n}\nexports.TilingScheme = TilingScheme;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ \"./node_modules/@here/harp-geoutils/lib/projection/MercatorProjection.js\");\nconst QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.js\");\nconst TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ \"./node_modules/@here/harp-geoutils/lib/tiling/TilingScheme.js\");\n/**\n * A [[TilingScheme]] featuring quadtree subdivision scheme and web Mercator projection.\n */\nexports.webMercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.webMercatorProjection);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/index.js":
/*!************************************************!*\
  !*** ./node_modules/@here/harp-lines/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/Lines */ \"./node_modules/@here/harp-lines/lib/Lines.js\"));\n__export(__webpack_require__(/*! ./lib/TriangulateLines */ \"./node_modules/@here/harp-lines/lib/TriangulateLines.js\"));\n__export(__webpack_require__(/*! ./lib/HighPrecisionLines */ \"./node_modules/@here/harp-lines/lib/HighPrecisionLines.js\"));\n__export(__webpack_require__(/*! ./lib/HighPrecisionUtils */ \"./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionLines.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionLines.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ \"./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js\");\n/**\n * Class used to render high-precision wireframe lines.\n */\nclass HighPrecisionWireFrameLine extends THREE.Line {\n    /**\n     * Creates a `HighPrecisionWireFrameLine` object.\n     *\n     * @param geometry [[BufferGeometry]] used to render this object.\n     * @param material [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions Array of 2D/3D positions.\n     * @param color Color of the rendered line.\n     * @param opacity Opacity of the rendered line.\n     */\n    constructor(geometry, material, positions, color, opacity) {\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n        if (material === undefined) {\n            material = new harp_materials_1.HighPrecisionLineMaterial({\n                color: color ? color : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_OPACITY\n            });\n        }\n        this.matrixWorldInverse = new THREE.Matrix4();\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n    get bufferGeometry() {\n        return this.geometry;\n    }\n    get shaderMaterial() {\n        return this.material;\n    }\n    setPositions(positions) {\n        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);\n    }\n    setupForRendering() {\n        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {\n            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n    updateMatrixWorld(force) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n        super.updateMatrixWorld(force);\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.getInverse(this.matrixWorld);\n        }\n    }\n}\nexports.HighPrecisionWireFrameLine = HighPrecisionWireFrameLine;\n/**\n * Class used to render high-precision lines.\n */\nclass HighPrecisionLine extends THREE.Mesh {\n    /**\n     * Creates a `HighPrecisionLine` object.\n     *\n     * @param geometry [[BufferGeometry]] used to render this object.\n     * @param material [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions Array of 2D/3D positions.\n     * @param color Color of the rendered line.\n     * @param opacity Opacity of the rendered line.\n     */\n    constructor(geometry, material, positions, color, opacity) {\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n        if (material === undefined) {\n            material = new harp_materials_1.HighPrecisionLineMaterial({\n                color: color ? color : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : harp_materials_1.HighPrecisionLineMaterial.DEFAULT_OPACITY\n            });\n        }\n        this.matrixWorldInverse = new THREE.Matrix4();\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n    get bufferGeometry() {\n        return this.geometry;\n    }\n    get shaderMaterial() {\n        return this.material;\n    }\n    setPositions(positions) {\n        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);\n    }\n    setupForRendering() {\n        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {\n            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n    updateMatrixWorld(force) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n        super.updateMatrixWorld(force);\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.getInverse(this.matrixWorld);\n        }\n    }\n}\nexports.HighPrecisionLine = HighPrecisionLine;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/HighPrecisionLines.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ \"./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js\");\n/**\n * Class used to render high-precision points.\n */\nclass HighPrecisionPoints extends THREE.Points {\n    /**\n     * Creates a `HighPrecisionPoints` object.\n     *\n     * @param geometry [[BufferGeometry]] used to render this object.\n     * @param material [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions Array of 2D/3D positions.\n     * @param color Color of the rendered point.\n     * @param opacity Opacity of the rendered point.\n     */\n    constructor(geometry, material, positions, color, opacity) {\n        if (material === undefined) {\n            material = new harp_materials_1.HighPrecisionPointMaterial({\n                color: color ? color : harp_materials_1.HighPrecisionPointMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : 1\n            });\n        }\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n        this.matrixWorldInverse = new THREE.Matrix4();\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n    get bufferGeometry() {\n        return this.geometry;\n    }\n    /**\n     * Clears the [[BufferGeometry]] used to render this point.\n     */\n    clearGeometry() {\n        return (this.geometry = new THREE.BufferGeometry());\n    }\n    get shaderMaterial() {\n        return this.material;\n    }\n    setPositions(positions) {\n        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);\n    }\n    setupForRendering() {\n        if (this.material.isHighPrecisionPointsMaterial &&\n            this.dimensionality !== undefined) {\n            this.material.setDimensionality(this.dimensionality);\n        }\n        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {\n            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n    updateMatrixWorld(force) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n        super.updateMatrixWorld(force);\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.getInverse(this.matrixWorld);\n        }\n    }\n}\nexports.HighPrecisionPoints = HighPrecisionPoints;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst HPL = __webpack_require__(/*! ./HighPrecisionLines */ \"./node_modules/@here/harp-lines/lib/HighPrecisionLines.js\");\nconst HPP = __webpack_require__(/*! ./HighPrecisionPoints */ \"./node_modules/@here/harp-lines/lib/HighPrecisionPoints.js\");\nconst TriangulateLines_1 = __webpack_require__(/*! ./TriangulateLines */ \"./node_modules/@here/harp-lines/lib/TriangulateLines.js\");\nvar HighPrecisionUtils;\n(function (HighPrecisionUtils) {\n    /**\n     * Extract the `float` parts of all vector members, Making this a `Vector3` of `float`.\n     * precision.\n     *\n     * @param v\n     */\n    function doubleToFloatVec(v) {\n        return new three_1.Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));\n    }\n    HighPrecisionUtils.doubleToFloatVec = doubleToFloatVec;\n    /**\n     * Convert a `Vector3` to `float` (in place!) Returns the minor float vector, which is the\n     * difference of the double elements and their float counterparts.\n     *\n     * @param v Vector3 to convert to float IN-PLACE!\n     */\n    function makeFloatVec(v) {\n        const majorX = Math.fround(v.x);\n        const majorY = Math.fround(v.y);\n        const majorZ = Math.fround(v.z);\n        const minorVec = new three_1.Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);\n        v.x = Math.fround(majorX);\n        v.y = Math.fround(majorY);\n        v.z = Math.fround(majorZ);\n        return minorVec;\n    }\n    HighPrecisionUtils.makeFloatVec = makeFloatVec;\n    /**\n     * Calculate high-precision camera position used in vertex shader of high-precision materials.\n     *\n     * @param camera Camera used to get the high-precision position.\n     * @param objectInverseWorldMatrix Inverse World Matrix of the rendered [[HighPrecisionObject]].\n     */\n    function createHighPrecisionCameraPos(camera, objectInverseWorldMatrix) {\n        const _projScreenMatrix = new three_1.Matrix4().copy(camera.projectionMatrix);\n        const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);\n        const eyePos = new three_1.Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);\n        // split the double float vector into hi and lo parts\n        const eyePosFloat = doubleToFloatVec(eyePos);\n        const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));\n        return {\n            viewProjection: mvp,\n            eyePosHi: eyePosFloat,\n            eyePosLo\n        };\n    }\n    HighPrecisionUtils.createHighPrecisionCameraPos = createHighPrecisionCameraPos;\n    /**\n     * Updates the high-precision uniform data of a material used to render a\n     * [[HighPrecisionObject]].\n     *\n     * @param object [[HighPrecisionObject]] used for rendering.\n     * @param camera Camera used to get the high-precision position.\n     * @param shaderMaterial Material which uniforms will be updated.\n     */\n    function updateHpUniforms(object, camera, shaderMaterial) {\n        const highPrecisionCameraInfo = createHighPrecisionCameraPos(camera, object.matrixWorldInverse);\n        const mvp = highPrecisionCameraInfo.viewProjection;\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_mvp &&\n                shaderMaterial.uniforms.u_eyepos &&\n                shaderMaterial.uniforms.u_eyepos_lowpart) {\n                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);\n                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(highPrecisionCameraInfo.eyePosHi.toArray());\n                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(highPrecisionCameraInfo.eyePosLo.toArray());\n            }\n            else {\n                throw Error(\"High pecision material has missing uniforms\");\n            }\n        }\n        else {\n            throw Error(\"High pecision line has no high precision material\");\n        }\n    }\n    HighPrecisionUtils.updateHpUniforms = updateHpUniforms;\n    /**\n     * Assembles the necessary attribute buffers needed to render [[HighPrecisionObject]].\n     *\n     * @param positions Array of positions.\n     */\n    function createAttributes(positions) {\n        if (positions.length > 0) {\n            const v = positions[0];\n            if (v === undefined || v === null) {\n                throw Error(\"Empty element in positions\");\n            }\n            const positionVec = new Array();\n            const positionVecLow = new Array();\n            const addHPValue = (...values) => {\n                for (const value of values) {\n                    const major = Math.fround(value);\n                    positionVecLow.push(value - major);\n                    positionVec.push(major);\n                }\n            };\n            const addHPVector = (vec) => {\n                addHPValue(vec.x, vec.y, vec.z);\n            };\n            const vAny = v;\n            if (vAny.z !== undefined) {\n                positions.forEach(vec => {\n                    addHPVector(vec);\n                });\n            }\n            else {\n                if (positionVec.length % 3 !== 0) {\n                    throw Error(\"Positions must be 3D, not 2D\");\n                }\n                positions.forEach((n) => {\n                    addHPValue(n);\n                });\n            }\n            return {\n                positionHigh: new three_1.Float32BufferAttribute(positionVec, 3),\n                positionLow: new three_1.Float32BufferAttribute(positionVecLow, 3)\n            };\n        }\n        else {\n            return {\n                positionHigh: new three_1.Float32BufferAttribute([], 3),\n                positionLow: new three_1.Float32BufferAttribute([], 3)\n            };\n        }\n    }\n    HighPrecisionUtils.createAttributes = createAttributes;\n    /**\n     * Assembles an interleaved buffer containing the position attribute data for a\n     * [[HighPrecisionObject]].\n     *\n     * @param positions Array of positions.\n     * @param stride Stride of the elements in the `positions` array.\n     * @param positionOffset Offset into the `positions` array.\n     */\n    function addInterleavedAttributes3(positions, stride, positionOffset = 0) {\n        const newPositions = new Array();\n        const end = positions.length;\n        for (let i = 0; i < end; i += stride) {\n            for (let j = 0; j < positionOffset; j++) {\n                newPositions.push(positions[i + j]);\n            }\n            const x = positions[i + positionOffset];\n            const y = positions[i + positionOffset + 1];\n            const z = positions[i + positionOffset + 2];\n            const majorX = Math.fround(x);\n            const minorX = x - majorX;\n            const majorY = Math.fround(y);\n            const minorY = y - majorY;\n            const majorZ = Math.fround(z);\n            const minorZ = z - majorZ;\n            // insert values in interleaved buffer\n            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);\n            for (let j = positionOffset + 3; j < stride; j++) {\n                newPositions.push(positions[i + j]);\n            }\n        }\n        return newPositions;\n    }\n    HighPrecisionUtils.addInterleavedAttributes3 = addInterleavedAttributes3;\n    /**\n     * Adds the high-precision position attribute data to a [[HighPrecisionObject]].\n     *\n     * @param object [[HighPrecisionObject]] which position attribute will be set.\n     * @param positions Array of positions.\n     */\n    function setPositions(object, positions) {\n        const attributes = createAttributes(positions);\n        object.bufferGeometry.setAttribute(\"position\", attributes.positionHigh);\n        object.bufferGeometry.setAttribute(\"positionLow\", attributes.positionLow);\n        return attributes.positionHigh.itemSize;\n    }\n    HighPrecisionUtils.setPositions = setPositions;\n    /**\n     * Convert positions from `Array<Vector3>` to `Array<number>`.\n     *\n     * @param positions Array of positions.\n     */\n    function convertPositions(positions) {\n        if (positions.length <= 0) {\n            return { positions: [] };\n        }\n        const v = positions[0];\n        if (v === undefined || v === null) {\n            throw Error(\"Empty element in positions\");\n        }\n        const vAny = v;\n        if (vAny.y === undefined && vAny.z === undefined) {\n            return { positions: positions };\n        }\n        const returnPositions = new Array();\n        positions.forEach(vec => {\n            returnPositions.push(vec.x, vec.y, vec.z);\n        });\n        return { positions: returnPositions };\n    }\n    HighPrecisionUtils.convertPositions = convertPositions;\n    /**\n     * Creates a [[HighPrecisionLine]] or [[HighPrecisionWireFrameLine]] object.\n     *\n     * @param linePositions Array of 2D/3D positions.\n     * @param params Parameters used to configure the created [[HighPrecisionObject]].\n     */\n    function createLine(linePositions, params) {\n        const lineWidth = params.lineWidth !== undefined ? params.lineWidth : 5;\n        const addCircles = params.addCircles !== undefined ? params.addCircles : false;\n        const wireFrame = params.wireFrame !== undefined ? params.wireFrame : false;\n        const positions = [];\n        const indices = [];\n        TriangulateLines_1.triangulateLine(linePositions, lineWidth, positions, indices, addCircles);\n        const hpLineGeometry = new three_1.BufferGeometry();\n        const hpPositions = addInterleavedAttributes3(positions, 3);\n        const buffer = new three_1.InterleavedBuffer(new Float32Array(hpPositions), 6);\n        const positionAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 0, false);\n        const positionLowAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 3, false);\n        hpLineGeometry.setAttribute(\"position\", positionAttribute);\n        hpLineGeometry.setAttribute(\"positionLow\", positionLowAttribute);\n        hpLineGeometry.setIndex(new three_1.BufferAttribute(new Uint32Array(indices), 1));\n        const hpSolidMaterial = new harp_materials_1.HighPrecisionLineMaterial(params);\n        const lineObject = wireFrame\n            ? new HPL.HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial)\n            : new HPL.HighPrecisionLine(hpLineGeometry, hpSolidMaterial);\n        lineObject.setupForRendering();\n        return lineObject;\n    }\n    HighPrecisionUtils.createLine = createLine;\n    /**\n     * Creates a group of [[HighPrecisionPoints]].\n     *\n     * @param pointPositions Array of 2D/3D positions.\n     * @param materialParameters Parameters used to configure the material used to render the\n     * created [[HighPrecisionPoints]].\n     */\n    function createPoints(pointPositions, materialParameters) {\n        const indices = [];\n        // tslint:disable-next-line:prefer-for-of - pointPositions doesn't have iterable interface\n        for (let i = 0; i < pointPositions.length; i++) {\n            indices.push(indices.length / 3);\n        }\n        const hpPointsGeometry = new three_1.BufferGeometry();\n        const hpPointsMaterial = harp_materials_1.isHighPrecisionPointMaterial(materialParameters)\n            ? materialParameters\n            : new harp_materials_1.HighPrecisionPointMaterial(materialParameters);\n        const pointsObject = new HPP.HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);\n        setPositions(pointsObject, pointPositions);\n        pointsObject.setupForRendering();\n        return pointsObject;\n    }\n    HighPrecisionUtils.createPoints = createPoints;\n})(HighPrecisionUtils = exports.HighPrecisionUtils || (exports.HighPrecisionUtils = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/HighPrecisionUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/Lines.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/Lines.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n// Preallocate temp variables used during line generation.\nconst tmpV = new THREE.Vector3();\nconst tmpNormal = new THREE.Vector3();\nconst tmpTangent0 = new THREE.Vector3();\nconst tmpTangent1 = new THREE.Vector3();\nconst tmpBitangent = new THREE.Vector3();\nconst SEGMENT_OFFSET = 0.1;\n/**\n * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].\n */\n/** Base line vertex attributes. */\nconst LINE_VERTEX_ATTRIBUTES = {\n    attributes: [\n        // The \"extrusionCoord\" is a vec4 which represents:\n        // xy: Extrusion coordinates\n        // sign(xy): Extrusion direction\n        // z: Line length\n        { name: \"extrusionCoord\", itemSize: 3, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 3 },\n        { name: \"tangent\", itemSize: 3, offset: 6 },\n        { name: \"bitangent\", itemSize: 4, offset: 9 }\n    ],\n    stride: 13\n};\n/** Optional normal and uv coordinates. */\nconst NORMAL_UV_VERTEX_ATTRIBUTES = {\n    attributes: [\n        { name: \"uv\", itemSize: 2, offset: LINE_VERTEX_ATTRIBUTES.stride },\n        { name: \"normal\", itemSize: 3, offset: LINE_VERTEX_ATTRIBUTES.stride + 2 }\n    ],\n    stride: 5\n};\n/** Base line vertex attributes plus normals and uv coordinates. */\nconst LINE_VERTEX_ATTRIBUTES_NUV = {\n    attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],\n    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n/**\n * Declares all the vertex attributes used for rendering a line using the\n * [[HighPrecisionLineMaterial]].\n */\nconst HP_LINE_VERTEX_ATTRIBUTES = {\n    attributes: [\n        { name: \"extrusionCoord\", itemSize: 2, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 2 },\n        { name: \"positionLow\", itemSize: 3, offset: 5 },\n        { name: \"tangent\", itemSize: 3, offset: 8 },\n        { name: \"bitangent\", itemSize: 4, offset: 11 }\n    ],\n    stride: 15\n};\n/** High precision line vertex attributes plus normals and uv coordinates. */\nconst HP_LINE_VERTEX_ATTRIBUTES_NUV = {\n    attributes: [\n        ...HP_LINE_VERTEX_ATTRIBUTES.attributes,\n        ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes\n    ],\n    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n/**\n * Class that holds the vertex and index attributes for a [[Lines]] object.\n */\nclass LineGeometry {\n    constructor() {\n        this.vertices = [];\n        this.vertexColors = [];\n        this.indices = [];\n    }\n}\nexports.LineGeometry = LineGeometry;\nfunction getVertexDescriptor(hasNormalsAndUvs, highPrecision) {\n    if (highPrecision) {\n        return hasNormalsAndUvs ? HP_LINE_VERTEX_ATTRIBUTES_NUV : HP_LINE_VERTEX_ATTRIBUTES;\n    }\n    else {\n        return hasNormalsAndUvs ? LINE_VERTEX_ATTRIBUTES_NUV : LINE_VERTEX_ATTRIBUTES;\n    }\n}\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param center Center of the polyline.\n * @param polyline Array of `numbers` describing a polyline.\n * @param offsets Array of `numbers` representing line segment offsets.\n * @param uvs Array of `numbers` representing texture coordinates.\n * @param colors Array of `numbers` describing a polyline's colors.\n * @param geometry [[LineGeometry]] object used to store the vertex and index attributes.\n * @param highPrecision If `true` will create high-precision vertex information.\n */\nfunction createLineGeometry(center, polyline, offsets, uvs, colors, geometry = new LineGeometry(), highPrecision = false) {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n    const stride = getVertexDescriptor(uvs !== undefined, highPrecision).stride;\n    const pointCount = polyline.length / 3;\n    const segments = new Array(pointCount);\n    const tangents = new Array(polyline.length - 3);\n    const baseVertex = geometry.vertices.length / stride;\n    const hasSegmentOffsets = offsets !== undefined && offsets.length > 0;\n    const hasTexCoords = uvs !== undefined && uvs.length > 0;\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n    harp_utils_1.assert(!hasSegmentOffsets || offsets.length === pointCount);\n    harp_utils_1.assert(!hasTexCoords || uvs.length / 2 === pointCount);\n    harp_utils_1.assert(!vertexColors || colors.length === polyline.length);\n    // Compute segments and tangents.\n    let sum = SEGMENT_OFFSET;\n    segments[0] = sum;\n    let isFlat = true;\n    for (let i = 0; i < pointCount - 1; ++i) {\n        let sqrLength = 0;\n        for (let j = 0; j < 3; ++j) {\n            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];\n            tangents[i * 3 + j] = d;\n            sqrLength += d * d;\n            isFlat = j === 2 ? isFlat && polyline[(i + 1) * 3 + j] === 0.0 : isFlat;\n        }\n        const len = Math.sqrt(sqrLength);\n        sum = sum + len;\n        segments[i + 1] = sum;\n    }\n    const lineCoverage = hasSegmentOffsets\n        ? Math.abs(offsets[offsets.length - 1] - offsets[0])\n        : 1.0;\n    const lineLength = segments[segments.length - 1] / lineCoverage;\n    // Override the segments if offsets are explicitly provided.\n    if (hasSegmentOffsets) {\n        for (let i = 0; i < pointCount; ++i) {\n            segments[i] = offsets[i] * lineLength + SEGMENT_OFFSET;\n        }\n    }\n    // Check if we're working with a closed line.\n    let isClosed = true;\n    for (let j = 0; j < 3; ++j) {\n        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];\n    }\n    const tmpVertices = [];\n    const addVertexPair = (i, T1, T2, segment, extrusionCoord) => {\n        tmpVertices.length = 0;\n        // Store the segment and extrusionCoord attributes.\n        geometry.vertices.push(segment, extrusionCoord * -1, lineLength);\n        tmpVertices.push(segment, extrusionCoord * 1, lineLength);\n        // Store the position attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            if (!highPrecision) {\n                geometry.vertices.push(polyline[i * 3 + j]);\n                tmpVertices.push(polyline[i * 3 + j]);\n            }\n            else {\n                const highComp = Math.fround(polyline[i * 3 + j]);\n                const lowComp = polyline[i * 3 + j] - highComp;\n                geometry.vertices.push(highComp, lowComp);\n                tmpVertices.push(highComp, lowComp);\n            }\n            tmpNormal.setComponent(j, polyline[i * 3 + j]);\n        }\n        // Store the bitangent attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            tmpTangent0.setComponent(j, tangents[T1 + j]);\n            tmpTangent1.setComponent(j, tangents[T2 + j]);\n        }\n        tmpTangent0.normalize();\n        geometry.vertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        tmpVertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        const angle = computeBitangent(isFlat ? tmpNormal.set(0, 0, 1) : tmpNormal.add(center).normalize(), tmpTangent0, tmpTangent1.normalize(), tmpBitangent);\n        geometry.vertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n        tmpVertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n        if (hasTexCoords) {\n            // uvs\n            geometry.vertices.push(uvs[i * 2], uvs[i * 2 + 1]);\n            tmpVertices.push(uvs[i * 2], uvs[i * 2 + 1]);\n            // normals\n            geometry.vertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n            tmpVertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n        }\n        geometry.vertices.push(...tmpVertices);\n        // Add vertex colors (if supplied).\n        if (vertexColors) {\n            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);\n            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);\n        }\n    };\n    for (let i = 0; i < pointCount; ++i) {\n        // Retrieve the per-point tangents.\n        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;\n        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);\n        // Process v0 and v1.\n        if (i > 0) {\n            addVertexPair(i, T1, T2, segments[i - 1], segments[i]);\n        }\n        // Process v2 and v3.\n        if (i + 1 < pointCount) {\n            addVertexPair(i, T1, T2, segments[Math.min(i, segments.length - 1)] * -1, segments[Math.min(i + 1, segments.length - 1)]);\n        }\n    }\n    // Store the triangle indices in the final index buffer.\n    for (let i = 0; i < pointCount - 1; ++i) {\n        const base = baseVertex + i * 4;\n        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);\n    }\n    return geometry;\n}\nexports.createLineGeometry = createLineGeometry;\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param polyline Array of `numbers` describing a polyline.\n * @param colors Array of `numbers` describing a polyline's colors.\n * @param geometry [[LineGeometry]] object used to store the vertex and index attributes.\n */\nfunction createSimpleLineGeometry(polyline, colors, geometry = new LineGeometry()) {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n    const pointCount = polyline.length / 3;\n    let index = geometry.vertices.length / 3;\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n    for (let i = 0; i < pointCount; ++i, index++) {\n        if (i > 0) {\n            geometry.indices.push(index);\n        }\n        if (i < pointCount - 1) {\n            geometry.indices.push(index);\n        }\n        for (let j = 0; j < 3; ++j) {\n            geometry.vertices.push(polyline[i * 3 + j]);\n            if (vertexColors) {\n                geometry.vertexColors.push(colors[i * 3 + j]);\n            }\n        }\n    }\n    return geometry;\n}\nexports.createSimpleLineGeometry = createSimpleLineGeometry;\n/**\n * Class used to render groups (or batches) of width-variable lines (in the same tile).\n */\nclass LineGroup {\n    constructor(hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {\n        this.hasNormalsAndUvs = hasNormalsAndUvs;\n        this.highPrecision = highPrecision;\n        this.isSimple = isSimple;\n        this.m_geometry = new LineGeometry();\n    }\n    /**\n     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.\n     *\n     * @param vertices Array of vertex attributes.\n     * @param colors Array of vertex colors.\n     * @param indices Array of vertex indices.\n     * @param geometry [[BufferGeometry]] object which will store all the `Lines` attribute data.\n     * @param hasNormalsAnUvs Whether vertices have normal and uv coordinates as attributes.\n     * @param highPrecision If `true` will create high-precision vertex information.\n     * @param isSimple `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.\n     */\n    static createGeometry(vertices, colors, indices, geometry, hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {\n        if (isSimple) {\n            geometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(vertices), 3));\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\"color\", new THREE.BufferAttribute(new Float32Array(colors), 3));\n            }\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n            return geometry;\n        }\n        else {\n            const vertexDescriptor = getVertexDescriptor(hasNormalsAndUvs, highPrecision);\n            const buffer = new THREE.InterleavedBuffer(new Float32Array(vertices), vertexDescriptor.stride);\n            vertexDescriptor.attributes.forEach(descr => {\n                const attribute = new THREE.InterleavedBufferAttribute(buffer, descr.itemSize, descr.offset, false);\n                geometry.setAttribute(descr.name, attribute);\n            });\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\"color\", new THREE.BufferAttribute(new Float32Array(colors), 3));\n            }\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n            return geometry;\n        }\n    }\n    /**\n     * Clears the list of line strips.\n     */\n    clear() {\n        this.m_geometry.vertices = [];\n        this.m_geometry.vertexColors = [];\n        this.m_geometry.indices = [];\n    }\n    /**\n     * Add the given points to this line group.\n     *\n     * @param center World center of the provided points.\n     * @param points Sequence of (x,y,z) coordinates.\n     * @param offsets Sequence of line segment offsets.\n     * @param uvs Sequence of (u,v) texture coordinates.\n     * @param colors Sequence of (r,g,b) color components.\n     */\n    add(center, points, offsets, uvs, colors) {\n        if (!this.isSimple) {\n            harp_utils_1.assert(!this.hasNormalsAndUvs || uvs !== undefined);\n            createLineGeometry(center, points, offsets, uvs, colors, this.m_geometry, this.highPrecision);\n        }\n        else {\n            createSimpleLineGeometry(points, colors, this.m_geometry);\n        }\n        return this;\n    }\n    /**\n     * Returns the list of vertices.\n     */\n    get vertices() {\n        return this.m_geometry.vertices;\n    }\n    /**\n     * Returns the list of vertex colors.\n     */\n    get vertexColors() {\n        return this.m_geometry.vertexColors;\n    }\n    /**\n     * Returns the list of indices.\n     */\n    get indices() {\n        return this.m_geometry.indices;\n    }\n    /**\n     * Returns the list of [[VertexAttributeDescriptor]]s.\n     */\n    get vertexAttributes() {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).attributes;\n    }\n    /**\n     * Returns the vertex attribute stride.\n     */\n    get stride() {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).stride;\n    }\n    /**\n     * Creates a three.js geometry.\n     */\n    createGeometry(geometry) {\n        if (geometry === undefined) {\n            geometry = new THREE.BufferGeometry();\n        }\n        return LineGroup.createGeometry(this.m_geometry.vertices, this.m_geometry.vertexColors, this.m_geometry.indices, geometry, this.hasNormalsAndUvs, this.highPrecision);\n    }\n}\nexports.LineGroup = LineGroup;\nfunction computeBitangent(n, t0, t1, bt) {\n    let angle = 0;\n    if (!t0.equals(t1)) {\n        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));\n        if (Number.isNaN(angle)) {\n            angle = 0;\n        }\n    }\n    bt.copy(t0)\n        .add(t1)\n        .normalize()\n        .cross(n)\n        .normalize();\n    return angle;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/Lines.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lines/lib/TriangulateLines.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-lines/lib/TriangulateLines.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst UNIT_Z = new THREE.Vector3(0, 0, 1);\nconst POINTS = [0, 1, 2, 1, 3, 2];\nconst BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];\nconst SECTORS_IN_CIRCLE = 8;\nconst STEP = Math.PI / SECTORS_IN_CIRCLE;\n/**\n * Adds a half-circle geometry to original line\n *\n * @param x The line end X (used as circle center X)\n * @param y The line end Y (used as circle center Y)\n * @param lineAngle The cap incline angle\n * @param radius The cap (circle) radius\n * @param vertices The input vertex buffer (cap vertices are added there)\n * @param indices The input index buffer (cap indices are is added there)\n */\nfunction addCircle(x, y, lineAngle, radius, vertices, indices) {\n    const baseVertex = vertices.length / 3;\n    // Add cap center to vertices directly (it doesn't need rotation)\n    vertices.push(x, y, 0);\n    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {\n        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg\n        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);\n        indices.push(baseVertex, baseVertex + i + 1, baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1);\n    }\n}\n/**\n * Returns the number of points in circle used for caps.\n *\n * @param lineWidth Width of line.\n */\n// tslint:disable-next-line:no-unused-variable\nfunction numCirclePoints(lineWidth) {\n    return SECTORS_IN_CIRCLE + 1;\n}\nexports.numCirclePoints = numCirclePoints;\n/**\n * Create a triangle mesh from the given polyline.\n *\n * @param points Sequence of (x,y,z) coordinates.\n * @param width The width of the extruded line.\n * @param vertices The output vertex buffer.\n * @param indices The output index buffer.\n * @param startWithCircle `true` if the line should start will a circle.\n * @param endWithCircle `true` if the line should end with a circle.\n */\nfunction triangulateLine(points, width, vertices, indices, startWithCircle = true, endWithCircle = startWithCircle) {\n    if (points.length < 3) {\n        return;\n    }\n    // This vector is used for computing cap angle\n    const angleVec = new THREE.Vector2();\n    if (startWithCircle) {\n        // Define lineAngle as (direction - origin) vector angle to X axis\n        const lineAngle = points.length !== 3\n            ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()\n            : 0;\n        addCircle(points[0], points[1], lineAngle, width, vertices, indices);\n    }\n    const baseVertex = vertices.length / 3;\n    // bt = Bitangent (i.e. extrusion vector)\n    const prevBt = new THREE.Vector3();\n    const p = new THREE.Vector3(); // current point\n    const n = new THREE.Vector3(); // next point\n    const bt = new THREE.Vector3();\n    const averageBt = new THREE.Vector3();\n    const p0 = new THREE.Vector3();\n    const p1 = new THREE.Vector3();\n    const p2 = new THREE.Vector3();\n    const p3 = new THREE.Vector3();\n    const N = points.length / 3;\n    let vertexOffset = 0;\n    for (let i = 0; i < N; ++i) {\n        let useBevel = false;\n        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);\n        if (i + 1 < N) {\n            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);\n            bt.copy(n)\n                .sub(p)\n                .normalize()\n                .cross(UNIT_Z);\n            averageBt.copy(bt);\n            if (i > 0) {\n                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));\n                useBevel = prevBt.angleTo(bt) > Math.PI / 2;\n                if (useBevel) {\n                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);\n                    p0.copy(bt)\n                        .add(prevBt)\n                        .normalize()\n                        .multiplyScalar(-inclineWidth)\n                        .add(p);\n                    p1.copy(prevBt)\n                        .multiplyScalar(width)\n                        .add(p);\n                    // p2 is used for \"miter\" connections\n                    p2.copy(bt)\n                        .add(prevBt)\n                        .normalize()\n                        .multiplyScalar(inclineWidth)\n                        .add(p);\n                    p3.copy(bt)\n                        .multiplyScalar(width)\n                        .add(p);\n                }\n            }\n            if (useBevel) {\n                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);\n            }\n            else {\n                p0.copy(averageBt)\n                    .multiplyScalar(-width)\n                    .add(p);\n                p1.copy(averageBt)\n                    .multiplyScalar(width)\n                    .add(p);\n                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n            }\n            prevBt.copy(bt);\n        }\n        else {\n            p0.copy(prevBt)\n                .multiplyScalar(-width)\n                .add(p);\n            p1.copy(prevBt)\n                .multiplyScalar(width)\n                .add(p);\n            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n        }\n        if (i !== N - 1) {\n            (useBevel ? BEVEL_POINTS : POINTS).forEach(o => indices.push(baseVertex + vertexOffset + o));\n            vertexOffset += useBevel ? 4 : 2;\n        }\n    }\n    if (endWithCircle) {\n        const lineAngle = points.length !== 2\n            ? angleVec\n                .set(points[(N - 3) * 3] - points[(N - 2) * 3], points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1])\n                .angle()\n            : Math.PI;\n        addCircle(points[(N - 2) * 3], points[(N - 2) * 3 + 1], lineAngle, width, vertices, indices);\n    }\n}\nexports.triangulateLine = triangulateLine;\n/**\n * Reconstruct the original points of a line from the vertices of the triangulated line.\n *\n * @param inBuffer Buffer with vertices.\n * @param startOffset Start index, will differ from `0` if the line has caps.\n * @returns Buffer containing the original points of the triangulated line.\n */\nfunction reconstructLine(inBuffer, startOffset) {\n    const outBuffer = new Float32Array(inBuffer.length / 2);\n    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {\n        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;\n        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;\n        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;\n    }\n    return outBuffer;\n}\nexports.reconstructLine = reconstructLine;\n/**\n * Extract the line width from a triangulated line.\n *\n * @param inBuffer Array of vertex elements of a triangulated line.\n * @param startIndex Start index, will differ from `0` if the line has caps.\n */\nfunction reconstructLineWidth(inBuffer, startIndex) {\n    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];\n    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];\n    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];\n    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;\n}\nexports.reconstructLineWidth = reconstructLineWidth;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lines/lib/TriangulateLines.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lrucache/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@here/harp-lrucache/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/LRUCache */ \"./node_modules/@here/harp-lrucache/lib/LRUCache.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lrucache/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-lrucache/lib/LRUCache.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-lrucache/lib/LRUCache.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/** @hidden */\nclass Entry {\n    constructor(key, value, size, newer, older) {\n        this.key = key;\n        this.value = value;\n        this.size = size;\n        this.newer = newer;\n        this.older = older;\n    }\n}\nexports.Entry = Entry;\n/**\n * Fixed size cache that evicts its entries in least-recently-used order when it overflows.\n * Modeled after standard JavaScript `Map` otherwise.\n */\nclass LRUCache {\n    /**\n     * Creates a new instance of `LRUCache`.\n     *\n     * The optional [[sizeFunction]] can be used to fine tune the memory consumption of all cached\n     * elements, thus [[cacheCapacity]] means then memory used (in MBs). Otherwise, if\n     * [[sizeFunction]] is not specified, the [[cacheCapacity]] accounts for the maximum\n     * number of elements stored.\n     *\n     * @param cacheCapacity Number used to configure the maximum cache size, may express\n     * number of entries or memory consumed in megabytes depending on [[sizeFunction]].\n     * @param sizeFunction A function determining the size per element.\n     */\n    constructor(cacheCapacity, sizeFunction = () => 1) {\n        this.m_size = 0;\n        /**\n         * The internal map object that keeps the key-value pairs and their order.\n         */\n        this.m_map = new Map();\n        /**\n         * The newest entry, i.e. the most recently used item.\n         */\n        this.m_newest = null;\n        /**\n         * The oldest entry, i.e. the least recently used item.\n         */\n        this.m_oldest = null;\n        this.m_capacity = cacheCapacity;\n        this.m_sizeFunction = sizeFunction;\n    }\n    /**\n     * Iterates over all items from the most recently used item to the least recently used one.\n     *\n     * **Note**: Results are undefined if the entire cache is modified during iteration. You may\n     * although modify the current element in [[callbackfn]] function.\n     *\n     * @param callbackfn The callback to call for each item.\n     * @param thisArg Optional this argument for the callback.\n     */\n    forEach(callbackfn, thisArg) {\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const older = entry.older;\n            callbackfn.call(thisArg, entry.value, entry.key, this);\n            entry = older;\n        }\n    }\n    /**\n     * The size of the cache, i.e. the sum of all the sizes of all the objects in the cache.\n     *\n     * @returns The size of the cache.\n     */\n    get size() {\n        return this.m_size;\n    }\n    /**\n     * Returns the maximum capacity of the cache, i.e. the maximum number of elements this cache\n     * can contain or the total amount of memory that may be consumed by cache if element size\n     * function was specified in cache c-tor.\n     *\n     * @returns The capacity of the cache.\n     */\n    get capacity() {\n        return this.m_capacity;\n    }\n    /**\n     * @deprecated - DO NOT USE. Will be removed in future versions.\n     *\n     * Returns the internal map object that keeps the key-value pairs and their order.\n     *\n     * @returns The internal map object.\n     */\n    get map() {\n        // ### TODO - remove me. Cache must not expose its internal object,\n        // modifications to it are fatal for the internal state machine.\n        return this.m_map;\n    }\n    /**\n     * Returns the newest entry in the cache.\n     *\n     * @returns Newest entry in the cache.\n     */\n    get newest() {\n        return this.m_newest;\n    }\n    /**\n     * Returns the oldest entry in the cache.\n     *\n     * Note: Does not promote the oldest item as most recently used item.\n     *\n     * @returns Oldest entry in the cache.\n     */\n    get oldest() {\n        return this.m_oldest;\n    }\n    /**\n     * Resets the capacity of this cache. If `newCapacity` is smaller than the current cache size,\n     * all items will be evicted until the cache shrinks to `newCapacity`.\n     *\n     * @param newCapacity The new capacity of this cache.\n     */\n    setCapacity(newCapacity) {\n        this.m_capacity = newCapacity;\n        this.evict();\n    }\n    /**\n     * Resets the cache capacity and function used to measure the element size.\n     *\n     * @param newCapacity The new capacity masured in units returned from [[sizeMeasure]] funtion.\n     * @param sizeMeasure Function that defines the size of element, if you want to measure\n     * number of elements only always return 1 from this function (default), you may also\n     * specify own function that measures entries by memory consumed, nubmer of sub-elements, etc.\n     */\n    setCapacityAndMeasure(newCapacity, sizeMeasure = () => 1) {\n        this.m_capacity = newCapacity;\n        this.m_sizeFunction = sizeMeasure;\n        this.shrinkToCapacity();\n    }\n    /**\n     * Updates the size of all elements in this cache. If their aggregated size is larger than the\n     * capacity, items will be evicted until the cache shrinks to fit the capacity.\n     */\n    shrinkToCapacity() {\n        let size = 0;\n        const sizeFunction = this.m_sizeFunction;\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const entrySize = sizeFunction(entry.value);\n            entry.size = entrySize;\n            size += entrySize;\n            entry = entry.older;\n        }\n        this.m_size = size;\n        this.evict();\n    }\n    /**\n     * Inserts or updates a key/value pair in the cache.\n     *\n     * If the key already existed in the cache, it will be updated and promoted to the most recently\n     * used item.\n     *\n     * If the key didn't exist in the cache, it will be inserted as most recently used item. An\n     * eviction of the least recently used item takes place if the cache exceeded its capacity.\n     *\n     * @param key The key for the key-value pair to insert or update.\n     * @param value The value for the key-value pair to insert or update.\n     */\n    set(key, value) {\n        const valueSize = this.m_sizeFunction(value);\n        let entry = this.m_map.get(key);\n        if (entry !== undefined) {\n            this.m_size = this.m_size - entry.size + valueSize;\n            entry.value = value;\n            entry.size = valueSize;\n            this.promoteEntry(entry);\n            this.evict();\n        }\n        else {\n            if (valueSize > this.m_capacity) {\n                return; // single item too big to cache\n            }\n            entry = new Entry(key, value, valueSize, null, null);\n            if (this.m_map.size === 0) {\n                this.m_newest = this.m_oldest = entry;\n            }\n            else {\n                harp_utils_1.assert(this.m_newest !== null);\n                const newest = this.m_newest;\n                entry.older = this.m_newest;\n                newest.newer = entry;\n                this.m_newest = entry;\n            }\n            this.m_map.set(key, entry);\n            this.m_size += valueSize;\n            this.evict();\n        }\n    }\n    /**\n     * Looks up key in the cache and returns the associated value.\n     *\n     * @param key The key to look up.\n     * @returns The associated value, or `undefined` if the key-value pair is not in the cache.\n     */\n    get(key) {\n        const entry = this.m_map.get(key);\n        if (entry === undefined) {\n            return undefined;\n        }\n        this.promoteEntry(entry);\n        return entry.value;\n    }\n    /**\n     * Test if a key/value pair is in the cache.\n     *\n     * @param key The key to look up.\n     * @returns `true` if the key-value pair is in the cache, `false` otherwise.\n     */\n    has(key) {\n        return this.m_map.has(key);\n    }\n    /**\n     * Clears the cache and removes all stored key-value pairs.\n     *\n     * Does not call the eviction callback. Use [[evictAll]] to clear the cache and call the\n     * eviction callback.\n     */\n    clear() {\n        this.m_newest = this.m_oldest = null;\n        this.m_size = 0;\n        this.m_map.clear();\n    }\n    /**\n     * Evicts all items from the cache, calling the eviction callback on each item.\n     *\n     * Use [[clear]] to remove all items without calling the eviction callback.\n     */\n    evictAll() {\n        const cb = this.evictionCallback;\n        if (cb !== undefined) {\n            this.forEach((value, key) => cb(key, value));\n        }\n        this.clear();\n    }\n    /**\n     * Evict selected elements from the cache using [[selector]] function.\n     *\n     * @param selector The function for selecting elements for eviction.\n     * @param thisArg Optional _this_ object reference.\n     */\n    evictSelected(selector, thisArg) {\n        const cb = this.evictionCallback;\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const entryOlder = entry.older;\n            if (selector.call(thisArg, entry.value, entry.key)) {\n                if (cb !== undefined) {\n                    cb(entry.key, entry.value);\n                }\n                this.deleteEntry(entry);\n                this.m_map.delete(entry.key);\n            }\n            entry = entryOlder;\n        }\n    }\n    /**\n     * Explicitly removes a key-value pair from the cache.\n     *\n     * **Note**: This is an explicit removal, thus, the eviction callback will not be called.\n     *\n     * @param key The key of the key-value pair to delete.\n     * @returns `true` if the key-value pair existed and was deleted, `false` otherwise.\n     */\n    delete(key) {\n        const entry = this.m_map.get(key);\n        if (entry === undefined) {\n            return false;\n        }\n        this.deleteEntry(entry);\n        return this.m_map.delete(key);\n    }\n    evict() {\n        while (this.m_oldest !== null && this.m_size > this.m_capacity) {\n            const evicted = this.evictOldest();\n            if (evicted === undefined) {\n                return;\n            }\n        }\n    }\n    evictOldest() {\n        harp_utils_1.assert(this.m_oldest !== null);\n        const oldest = this.m_oldest;\n        harp_utils_1.assert(oldest.older === null);\n        let itemToRemove = oldest;\n        if (this.canEvict !== undefined) {\n            while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {\n                if (itemToRemove.newer === null) {\n                    return undefined;\n                }\n                itemToRemove = itemToRemove.newer;\n            }\n        }\n        if (itemToRemove === oldest) {\n            this.m_oldest = itemToRemove.newer;\n            if (itemToRemove.newer !== null) {\n                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);\n                itemToRemove.newer.older = null;\n            }\n        }\n        else {\n            if (itemToRemove.newer !== null) {\n                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);\n                itemToRemove.newer.older = itemToRemove.older;\n                if (itemToRemove.older !== null) {\n                    itemToRemove.older.newer = itemToRemove.newer;\n                }\n            }\n            else {\n                return undefined;\n            }\n        }\n        const isOk = this.m_map.delete(itemToRemove.key);\n        harp_utils_1.assert(isOk === true);\n        if (isOk && this.evictionCallback !== undefined) {\n            this.evictionCallback(itemToRemove.key, itemToRemove.value);\n        }\n        this.m_size -= itemToRemove.size;\n        return itemToRemove;\n    }\n    deleteEntry(entry) {\n        if (entry === this.m_newest) {\n            this.m_newest = entry.older;\n        }\n        else if (entry.newer) {\n            entry.newer.older = entry.older;\n        }\n        else {\n            harp_utils_1.assert(false);\n        }\n        if (entry === this.m_oldest) {\n            this.m_oldest = entry.newer;\n        }\n        else if (entry.older) {\n            entry.older.newer = entry.newer;\n        }\n        else {\n            harp_utils_1.assert(false);\n        }\n        this.m_size -= entry.size;\n    }\n    promoteEntry(entry) {\n        if (entry === this.m_newest) {\n            return;\n        } // already newest, nothing to do\n        // re-link newer and older items\n        if (entry.newer) {\n            harp_utils_1.assert(entry.newer.older === entry);\n            entry.newer.older = entry.older;\n        }\n        if (entry.older) {\n            harp_utils_1.assert(entry.older.newer === entry);\n            entry.older.newer = entry.newer;\n        }\n        if (entry === this.m_oldest) {\n            this.m_oldest = entry.newer;\n        }\n        // re-link ourselves\n        entry.newer = null;\n        entry.older = this.m_newest;\n        // finally, set ourselves as the newest entry\n        harp_utils_1.assert(this.m_newest !== null);\n        const newest = this.m_newest;\n        harp_utils_1.assert(newest.newer === null);\n        newest.newer = entry;\n        this.m_newest = entry;\n    }\n}\nexports.LRUCache = LRUCache;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-lrucache/lib/LRUCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/MapControls */ \"./node_modules/@here/harp-map-controls/lib/MapControls.js\"));\n__export(__webpack_require__(/*! ./lib/MapControlsUI */ \"./node_modules/@here/harp-map-controls/lib/MapControlsUI.js\"));\n__export(__webpack_require__(/*! ./lib/LongPressHandler */ \"./node_modules/@here/harp-map-controls/lib/LongPressHandler.js\"));\n__export(__webpack_require__(/*! ./lib/Utils */ \"./node_modules/@here/harp-map-controls/lib/Utils.js\"));\n__export(__webpack_require__(/*! ./lib/MapAnimations */ \"./node_modules/@here/harp-map-controls/lib/MapAnimations.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-map-controls/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/LongPressHandler.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/LongPressHandler.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class that can be used to track long presses on an HTML Element. A long press is a press that\n * lasts a minimum duration (see the [[timeout]] member) while the mouse is not moved more than a\n * certain threshold (see the [[moveThreshold]] member).\n */\nclass LongPressHandler {\n    /**\n     * Default constructor.\n     *\n     * @param element The HTML element to track.\n     * @param onLongPress The callback to call when a long press occurred.\n     */\n    constructor(element, onLongPress) {\n        this.element = element;\n        this.onLongPress = onLongPress;\n        /**\n         * How long to wait (in ms) until a press is considered a long press.\n         */\n        this.timeout = 500;\n        /**\n         * If the cursor moves more than the given number of pixels, it is not a long-press, but a pan.\n         */\n        this.moveThreshold = 5;\n        /**\n         * Button id that should be handled by this event.\n         */\n        this.buttonId = 0;\n        this.m_mouseDownEvent = undefined;\n        this.m_timerId = undefined;\n        this.m_moveHandlerRegistered = false;\n        // workaround - need to bind 'this' for our dynamic mouse move handler\n        this.m_boundMouseMoveHandler = this.onMouseMove.bind(this);\n        this.m_boundMouseDownHandler = this.onMousedown.bind(this);\n        this.m_boundMouseUpHandler = this.onMouseup.bind(this);\n        this.element.addEventListener(\"mousedown\", this.m_boundMouseDownHandler);\n        this.element.addEventListener(\"mouseup\", this.m_boundMouseUpHandler);\n    }\n    /**\n     * Removes all events listeners. No more events will be sent.\n     */\n    dispose() {\n        this.cancel();\n        this.element.removeEventListener(\"mousedown\", this.m_boundMouseDownHandler);\n        this.element.removeEventListener(\"mouseup\", this.m_boundMouseUpHandler);\n    }\n    onMousedown(event) {\n        if (event.button !== this.buttonId) {\n            return;\n        }\n        this.cancelTimer();\n        this.m_mouseDownEvent = event;\n        this.m_timerId = setTimeout(() => this.onTimeout(), this.timeout);\n        this.addMouseMoveHandler();\n    }\n    onMouseup(event) {\n        if (event.button !== this.buttonId) {\n            return;\n        }\n        this.cancel();\n    }\n    onMouseMove(event) {\n        if (this.m_mouseDownEvent === undefined) {\n            return; // Must not happen\n        }\n        const manhattanLength = Math.abs(event.clientX - this.m_mouseDownEvent.clientX) +\n            Math.abs(event.clientY - this.m_mouseDownEvent.clientY);\n        if (manhattanLength >= this.moveThreshold) {\n            this.cancel();\n        }\n    }\n    cancel() {\n        this.m_mouseDownEvent = undefined;\n        this.cancelTimer();\n        this.removeMouseMoveHandler();\n    }\n    cancelTimer() {\n        if (this.m_timerId === undefined) {\n            return;\n        }\n        clearTimeout(this.m_timerId);\n        this.m_timerId = undefined;\n    }\n    addMouseMoveHandler() {\n        if (this.m_moveHandlerRegistered) {\n            return;\n        }\n        this.element.addEventListener(\"mousemove\", this.m_boundMouseMoveHandler);\n        this.m_moveHandlerRegistered = true;\n    }\n    removeMouseMoveHandler() {\n        if (!this.m_moveHandlerRegistered) {\n            return;\n        }\n        this.element.removeEventListener(\"mousemove\", this.m_boundMouseMoveHandler);\n        this.m_moveHandlerRegistered = false;\n    }\n    onTimeout() {\n        const event = this.m_mouseDownEvent;\n        this.m_timerId = undefined;\n        this.cancel();\n        if (event !== undefined) {\n            this.onLongPress(event);\n        }\n    }\n}\nexports.LongPressHandler = LongPressHandler;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-map-controls/lib/LongPressHandler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/MapAnimations.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/MapAnimations.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst MapControls_1 = __webpack_require__(/*! ./MapControls */ \"./node_modules/@here/harp-map-controls/lib/MapControls.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst TWEEN = __webpack_require__(/*! @tweenjs/tween.js */ \"./node_modules/@tweenjs/tween.js/src/Tween.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Functions used for specifying animations' speed.\n */\nvar EasingFunction;\n(function (EasingFunction) {\n    EasingFunction[EasingFunction[\"Linear\"] = 0] = \"Linear\";\n    EasingFunction[EasingFunction[\"QuadraticIn\"] = 1] = \"QuadraticIn\";\n    EasingFunction[EasingFunction[\"QuadraticOut\"] = 2] = \"QuadraticOut\";\n    EasingFunction[EasingFunction[\"QuadraticInOut\"] = 3] = \"QuadraticInOut\";\n    EasingFunction[EasingFunction[\"CubicIn\"] = 4] = \"CubicIn\";\n    EasingFunction[EasingFunction[\"CubicOut\"] = 5] = \"CubicOut\";\n    EasingFunction[EasingFunction[\"CubicInOut\"] = 6] = \"CubicInOut\";\n    EasingFunction[EasingFunction[\"QuarticIn\"] = 7] = \"QuarticIn\";\n    EasingFunction[EasingFunction[\"QuarticOut\"] = 8] = \"QuarticOut\";\n    EasingFunction[EasingFunction[\"QuarticInOut\"] = 9] = \"QuarticInOut\";\n    EasingFunction[EasingFunction[\"QuinticIn\"] = 10] = \"QuinticIn\";\n    EasingFunction[EasingFunction[\"QuinticOut\"] = 11] = \"QuinticOut\";\n    EasingFunction[EasingFunction[\"QuinticInOut\"] = 12] = \"QuinticInOut\";\n    EasingFunction[EasingFunction[\"SinusoidalIn\"] = 13] = \"SinusoidalIn\";\n    EasingFunction[EasingFunction[\"SinusoidalOut\"] = 14] = \"SinusoidalOut\";\n    EasingFunction[EasingFunction[\"SinusoidalInOut\"] = 15] = \"SinusoidalInOut\";\n    EasingFunction[EasingFunction[\"ExponentialIn\"] = 16] = \"ExponentialIn\";\n    EasingFunction[EasingFunction[\"ExponentialOut\"] = 17] = \"ExponentialOut\";\n    EasingFunction[EasingFunction[\"ExponentialInOut\"] = 18] = \"ExponentialInOut\";\n    EasingFunction[EasingFunction[\"CircularIn\"] = 19] = \"CircularIn\";\n    EasingFunction[EasingFunction[\"CircularOut\"] = 20] = \"CircularOut\";\n    EasingFunction[EasingFunction[\"CircularInOut\"] = 21] = \"CircularInOut\";\n    EasingFunction[EasingFunction[\"ElasticIn\"] = 22] = \"ElasticIn\";\n    EasingFunction[EasingFunction[\"ElasticOut\"] = 23] = \"ElasticOut\";\n    EasingFunction[EasingFunction[\"ElasticInOut\"] = 24] = \"ElasticInOut\";\n    EasingFunction[EasingFunction[\"BackIn\"] = 25] = \"BackIn\";\n    EasingFunction[EasingFunction[\"BackOut\"] = 26] = \"BackOut\";\n    EasingFunction[EasingFunction[\"BackInOut\"] = 27] = \"BackInOut\";\n    EasingFunction[EasingFunction[\"BounceIn\"] = 28] = \"BounceIn\";\n    EasingFunction[EasingFunction[\"BounceOut\"] = 29] = \"BounceOut\";\n    EasingFunction[EasingFunction[\"BounceInOut\"] = 30] = \"BounceInOut\";\n})(EasingFunction = exports.EasingFunction || (exports.EasingFunction = {}));\n/**\n * Functions used to generate intermediate animation values.\n */\nvar InterpolationFunction;\n(function (InterpolationFunction) {\n    InterpolationFunction[InterpolationFunction[\"Linear\"] = 0] = \"Linear\";\n    InterpolationFunction[InterpolationFunction[\"Bezier\"] = 1] = \"Bezier\";\n    InterpolationFunction[InterpolationFunction[\"CatmullRom\"] = 2] = \"CatmullRom\";\n})(InterpolationFunction = exports.InterpolationFunction || (exports.InterpolationFunction = {}));\n/**\n * Abstract class used as base to define camera animations.\n */\nclass CameraAnimation {\n    /**\n     * Creates a new `CameraAnimation` object.\n     *\n     * @param mapView [[MapView]] which will be affected by the animation.\n     * @param name Animation's name.\n     */\n    constructor(mapView, name) {\n        this.mapView = mapView;\n        this.name = name;\n        /**\n         * `True` if animation is being played.\n         */\n        this.running = false;\n        /**\n         * `True` if the animation has been interrupted.\n         */\n        this.stopped = false;\n        /**\n         * Duration of a whole animation in milliseconds. Defaults to `10` seconds.\n         */\n        this.duration = 10000;\n        /**\n         * Number of times the animation should be repeated. Defaults to `0`.\n         */\n        this.repeat = 0;\n        /**\n         * Easing function that control acceleration. Defaults to [[EasingFunction.Linear]].\n         */\n        this.easing = TWEEN.Easing.Linear.None;\n        checkSetupTween();\n    }\n    /**\n     * Update function is to be called before the next frame is rendered.\n     */\n    update(time) {\n        if (this.tween) {\n            return this.tween.update(time || harp_utils_1.PerformanceTimer.now());\n        }\n        return false;\n    }\n    /**\n     * Returns `true` if the animation is being played.\n     */\n    get isRunning() {\n        return this.running;\n    }\n}\nexports.CameraAnimation = CameraAnimation;\n/**\n * Create an animation around the Z-axis of the camera.\n */\nclass CameraRotationAnimation extends CameraAnimation {\n    /**\n     * Creates a new `CameraRotationAnimation` object.\n     *\n     * @param mapView [[MapView]] which will be affected by the animation.\n     * @param m_mapControls [[MapControls]] this animation will be taking control of.\n     * @param options Animation's options.\n     * @param name Animation's name.\n     */\n    constructor(mapView, m_mapControls, options, name) {\n        super(mapView, name);\n        this.m_mapControls = m_mapControls;\n        /**\n         * Initial camera rotation (in the Z-axis).\n         */\n        this.startAngle = 0;\n        /**\n         * Final camera rotation (in the Z-axis).\n         */\n        this.endAngle = 360;\n        // tslint:disable-next-line:no-unused-variable\n        this.m_axis = new THREE.Vector3(0, 0, 1);\n        this.beginInteractionListener = () => {\n            if (!this.stopped) {\n                this.stopTween();\n            }\n        };\n        this.endInteractionListener = () => {\n            if (!this.stopped) {\n                this.startTween();\n            }\n        };\n        if (options.axis !== undefined) {\n            this.m_axis = options.axis;\n        }\n        if (options.startAngle !== undefined) {\n            this.startAngle = options.startAngle;\n        }\n        if (options.endAngle !== undefined) {\n            this.endAngle = options.endAngle;\n        }\n        if (options.duration !== undefined) {\n            this.duration = options.duration;\n        }\n        if (options.repeat !== undefined) {\n            this.repeat = options.repeat;\n        }\n        if (options.easing !== undefined) {\n            this.easing =\n                typeof options.easing === \"function\"\n                    ? options.easing\n                    : easingMap.get(options.easing) || TWEEN.Easing.Linear.None;\n        }\n        this.m_lastRotationValue = this.startAngle;\n    }\n    /**\n     * Start the animation.\n     *\n     * @param time Duration of the animation in milliseconds.\n     * @param onFinished Callback that gets triggered once the animation ends.\n     * @override\n     */\n    start(time, onFinished) {\n        if (this.running) {\n            throw new Error(\"Animation already running\" + this.name !== undefined ? this.name : \"\");\n        }\n        this.running = true;\n        this.onFinished = onFinished;\n        this.stopped = false;\n        if (this.m_mapControls) {\n            this.m_mapControls.addEventListener(MapControls_1.EventNames.BeginInteraction, this.beginInteractionListener);\n            this.m_mapControls.addEventListener(MapControls_1.EventNames.EndInteraction, this.endInteractionListener);\n        }\n        this.startTween(time);\n        this.mapView.beginAnimation();\n    }\n    /**\n     * Stop the animation. Can be started again (with original values only, though).\n     * @override\n     */\n    stop() {\n        if (!this.running) {\n            throw new Error(\"Animation not running\" + this.name !== undefined ? this.name : \"\");\n        }\n        this.running = false;\n        this.stopped = true;\n        this.mapView.endAnimation();\n        if (this.tween) {\n            this.tween.stop();\n        }\n        if (this.m_mapControls) {\n            this.m_mapControls.removeEventListener(MapControls_1.EventNames.BeginInteraction, this.beginInteractionListener);\n            this.m_mapControls.removeEventListener(MapControls_1.EventNames.EndInteraction, this.endInteractionListener);\n        }\n    }\n    /**\n     * Internal start of tween. Required because the tween may be interrupted by the\n     * [[MapControls]].\n     */\n    startTween(time) {\n        const rotZ = new THREE.Quaternion();\n        this.m_userCamerRotation = new THREE.Quaternion();\n        this.mapView.camera.getWorldQuaternion(this.m_userCamerRotation);\n        // Create a tween to animate the camera rotation around the Z axis.\n        //\n        // make this a relative rotation, always starting from 0. Take into account the\n        // lastRotationValue which may be a leftover from the previous run of \"this\" tween.\n        this.tween = new TWEEN.Tween({ rotation: 0 })\n            .to({ rotation: this.endAngle - this.m_lastRotationValue }, this.duration)\n            .onComplete(() => {\n            this.stop();\n            if (this.onFinished) {\n                this.onFinished();\n            }\n        })\n            .onUpdate(({ rotation }) => {\n            this.m_lastRotationValue = rotation;\n            rotZ.setFromEuler(new THREE.Euler(0, 0, THREE.Math.degToRad(rotation)));\n            if (this.m_userCamerRotation !== undefined) {\n                rotZ.multiply(this.m_userCamerRotation);\n            }\n            this.mapView.camera.quaternion.copy(rotZ);\n        });\n        this.tween.repeat(this.repeat);\n        this.tween.easing(this.easing);\n        this.tween.start(time);\n    }\n    /**\n     * Internal stop of tween. Required because the tween may be interrupted by the [[MapControls]].\n     */\n    stopTween() {\n        if (this.tween) {\n            this.tween.stop();\n        }\n    }\n}\nexports.CameraRotationAnimation = CameraRotationAnimation;\n/**\n * Class to pan between the specified geo coordinates. Height can be specified to move the camera in\n * and out.\n */\nclass CameraPanAnimation extends CameraAnimation {\n    /**\n     * Creates a new `CameraPanAnimation` object.\n     *\n     * @param mapView [[MapView]] which will be affected by the animation.\n     * @param options Animation's options.\n     * @param name Animation's name.\n     */\n    constructor(mapView, options, name) {\n        super(mapView, name);\n        this.name = name;\n        /**\n         * Specifies interpolation. Defaults to [[InterpolationFunction.CatmullRom]]\n         */\n        this.interpolation = TWEEN.Interpolation.CatmullRom;\n        if (options.duration !== undefined) {\n            this.duration = options.duration;\n        }\n        if (options.repeat !== undefined) {\n            this.repeat = options.repeat;\n        }\n        if (options.easing !== undefined) {\n            this.easing =\n                typeof options.easing === \"function\"\n                    ? options.easing\n                    : easingMap.get(options.easing) || TWEEN.Easing.Linear.None;\n        }\n        if (options.interpolation !== undefined) {\n            this.interpolation =\n                typeof options.interpolation === \"function\"\n                    ? options.interpolation\n                    : interpolationMap.get(options.interpolation) || TWEEN.Interpolation.Linear;\n        }\n        this.m_geoCoordinates = options.geoCoordinates !== undefined ? options.geoCoordinates : [];\n    }\n    /**\n     * Add a geo coordinate that should be visited.\n     *\n     * @param geoPos Geographical coordinate to animate to.\n     */\n    addPosition(geoPos) {\n        this.m_geoCoordinates.push(geoPos);\n    }\n    /**\n     * Start the animation.\n     *\n     * @param time Duration of the animation in milliseconds.\n     * @param onFinished Callback that gets triggered once the animation ends.\n     * @override\n     */\n    start(time, onFinished) {\n        if (this.running) {\n            throw new Error(\"Animation already running\" + this.name !== undefined ? this.name : \"\");\n        }\n        this.onFinished = onFinished;\n        this.running = true;\n        const from = new harp_geoutils_1.GeoCoordinates(this.mapView.geoCenter.latitude, this.mapView.geoCenter.longitude, this.mapView.camera.position.z);\n        const to = {\n            latitude: new Array(),\n            longitude: new Array(),\n            altitude: new Array()\n        };\n        for (const pos of this.m_geoCoordinates) {\n            to.latitude.push(pos.latitude);\n            to.longitude.push(pos.longitude);\n            to.altitude.push(pos.altitude || this.mapView.camera.position.z);\n        }\n        this.tween = new TWEEN.Tween(from)\n            .to(to, this.duration)\n            .onComplete(() => {\n            this.stop();\n            if (this.onFinished) {\n                this.onFinished();\n            }\n        })\n            .onUpdate(({ latitude, longitude, altitude }) => {\n            this.mapView.geoCenter = new harp_geoutils_1.GeoCoordinates(latitude, longitude, altitude);\n            this.mapView.camera.position.z = altitude;\n        });\n        this.tween.repeat(this.repeat);\n        this.tween.easing(this.easing);\n        this.tween.interpolation(this.interpolation);\n        this.tween.start(time);\n        this.mapView.beginAnimation();\n    }\n    /**\n     * Stop the animation. Can be started again (with original values only, though).\n     * @override\n     */\n    stop() {\n        if (!this.running) {\n            throw new Error(\"Animation not running\" + this.name !== undefined ? this.name : \"\");\n        }\n        this.running = false;\n        this.mapView.endAnimation();\n        if (this.tween) {\n            this.tween.stop();\n        }\n    }\n    /**\n     * Returns `true` if the animation is being played.\n     * @override\n     */\n    get isRunning() {\n        return this.running;\n    }\n}\nexports.CameraPanAnimation = CameraPanAnimation;\n// Cannot use enum as map index in a typesave manner, otherwise I would love to make it more\n// elegant...\nlet easingMap;\nlet interpolationMap;\nfunction checkSetupTween() {\n    if (easingMap !== undefined) {\n        return;\n    }\n    easingMap = new Map();\n    interpolationMap = new Map();\n    easingMap.set(EasingFunction.Linear, TWEEN.Easing.Linear.None);\n    easingMap.set(EasingFunction.QuadraticIn, TWEEN.Easing.Quadratic.In);\n    easingMap.set(EasingFunction.QuadraticOut, TWEEN.Easing.Quadratic.Out);\n    easingMap.set(EasingFunction.QuadraticInOut, TWEEN.Easing.Quadratic.InOut);\n    easingMap.set(EasingFunction.CubicIn, TWEEN.Easing.Cubic.In);\n    easingMap.set(EasingFunction.CubicOut, TWEEN.Easing.Cubic.Out);\n    easingMap.set(EasingFunction.CubicInOut, TWEEN.Easing.Cubic.InOut);\n    easingMap.set(EasingFunction.QuarticIn, TWEEN.Easing.Quartic.In);\n    easingMap.set(EasingFunction.QuarticOut, TWEEN.Easing.Quartic.Out);\n    easingMap.set(EasingFunction.QuarticInOut, TWEEN.Easing.Quartic.InOut);\n    easingMap.set(EasingFunction.QuinticIn, TWEEN.Easing.Quintic.In);\n    easingMap.set(EasingFunction.QuinticOut, TWEEN.Easing.Quintic.Out);\n    easingMap.set(EasingFunction.QuinticInOut, TWEEN.Easing.Quintic.InOut);\n    easingMap.set(EasingFunction.SinusoidalIn, TWEEN.Easing.Sinusoidal.In);\n    easingMap.set(EasingFunction.SinusoidalOut, TWEEN.Easing.Sinusoidal.Out);\n    easingMap.set(EasingFunction.SinusoidalInOut, TWEEN.Easing.Sinusoidal.InOut);\n    easingMap.set(EasingFunction.ExponentialIn, TWEEN.Easing.Exponential.In);\n    easingMap.set(EasingFunction.ExponentialOut, TWEEN.Easing.Exponential.Out);\n    easingMap.set(EasingFunction.ExponentialInOut, TWEEN.Easing.Exponential.InOut);\n    easingMap.set(EasingFunction.CircularIn, TWEEN.Easing.Circular.In);\n    easingMap.set(EasingFunction.CircularOut, TWEEN.Easing.Circular.Out);\n    easingMap.set(EasingFunction.CircularOut, TWEEN.Easing.Circular.InOut);\n    easingMap.set(EasingFunction.ElasticIn, TWEEN.Easing.Elastic.In);\n    easingMap.set(EasingFunction.ElasticOut, TWEEN.Easing.Elastic.Out);\n    easingMap.set(EasingFunction.ElasticInOut, TWEEN.Easing.Elastic.InOut);\n    easingMap.set(EasingFunction.BackIn, TWEEN.Easing.Back.In);\n    easingMap.set(EasingFunction.BackOut, TWEEN.Easing.Back.Out);\n    easingMap.set(EasingFunction.BackInOut, TWEEN.Easing.Back.InOut);\n    easingMap.set(EasingFunction.BounceIn, TWEEN.Easing.Bounce.In);\n    easingMap.set(EasingFunction.BounceOut, TWEEN.Easing.Bounce.Out);\n    easingMap.set(EasingFunction.BounceInOut, TWEEN.Easing.Bounce.InOut);\n    interpolationMap.set(InterpolationFunction.Linear, TWEEN.Interpolation.Linear);\n    interpolationMap.set(InterpolationFunction.Bezier, TWEEN.Interpolation.Bezier);\n    interpolationMap.set(InterpolationFunction.CatmullRom, TWEEN.Interpolation.CatmullRom);\n}\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-map-controls/lib/MapAnimations.js?");

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/MapControls.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/MapControls.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst geoUtils = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst utils = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-map-controls/lib/Utils.js\");\nvar State;\n(function (State) {\n    State[State[\"NONE\"] = 0] = \"NONE\";\n    State[State[\"PAN\"] = 1] = \"PAN\";\n    State[State[\"ROTATE\"] = 2] = \"ROTATE\";\n    State[State[\"ORBIT\"] = 3] = \"ORBIT\";\n    State[State[\"TOUCH\"] = 4] = \"TOUCH\";\n})(State || (State = {}));\nvar TiltState;\n(function (TiltState) {\n    TiltState[TiltState[\"Tilted\"] = 0] = \"Tilted\";\n    TiltState[TiltState[\"Down\"] = 1] = \"Down\";\n})(TiltState = exports.TiltState || (exports.TiltState = {}));\n/**\n * Map interaction events' names.\n */\nvar EventNames;\n(function (EventNames) {\n    EventNames[\"Update\"] = \"update\";\n    EventNames[\"BeginInteraction\"] = \"begin-interaction\";\n    EventNames[\"EndInteraction\"] = \"end-interaction\";\n})(EventNames = exports.EventNames || (exports.EventNames = {}));\n// cast needed to workaround wrong three.js typings.\nconst MAPCONTROL_EVENT = { type: EventNames.Update };\nconst MAPCONTROL_EVENT_BEGIN_INTERACTION = {\n    type: EventNames.BeginInteraction\n};\nconst MAPCONTROL_EVENT_END_INTERACTION = {\n    type: EventNames.EndInteraction\n};\n/**\n * The number of user's inputs to consider for panning inertia, to reduce erratic inputs.\n */\nconst USER_INPUTS_TO_CONSIDER = 5;\n/**\n * The default maximum for the camera tilt. This value avoids seeing the horizon.\n */\nconst DEFAULT_MAX_TILT_ANGLE = Math.PI / 4;\n/**\n * Epsilon value to rule out when a number can be considered 0.\n */\nconst EPSILON = 0.01;\n/**\n * Maximum duration between start and end touch events to define a finger tap.\n */\nconst MAX_TAP_DURATION = 120;\n/**\n * This map control provides basic map-related building blocks to interact with the map. It also\n * provides a default way of handling user input. Currently we support basic mouse interaction and\n * touch input interaction.\n *\n * Mouse interaction:\n *  - Left mouse button + move = Panning the map.\n *  - Right mouse button + move = Orbits the camera around the focus point.\n *  - Middle mouse button + move = Rotating the view. Up down movement changes the pitch. Left/right\n *    movement changes the yaw.\n *  - Mouse wheel = Zooms up and down by one zoom level, zooms on target.\n *\n * Touch interaction:\n *  - One finger = Panning the map.\n *  - Two fingers = Scale, rotate and panning the map.\n *  - Three fingers = Orbiting the map. Up down movements influences the current orbit altitude.\n *    Left/right changes the azimuth.\n */\nclass MapControls extends THREE.EventDispatcher {\n    /**\n     * Constructs a new `MapControls` object.\n     *\n     * @param mapView [[MapView]] this controller modifies.Z\n     */\n    constructor(mapView) {\n        super();\n        this.mapView = mapView;\n        /**\n         * This factor will be applied to the delta of the current mouse pointer position and the last\n         * mouse pointer position: The result then will be used as an offset for the rotation then.\n         * Default value is `0.1`.\n         */\n        this.rotationMouseDeltaFactor = 0.1;\n        /**\n         * This factor will be applied to the delta of the current mouse pointer position and the last\n         * mouse pointer position: The result then will be used as an offset to orbit the camera.\n         * Default value is `0.1`.\n         */\n        this.orbitingMouseDeltaFactor = 0.1;\n        /**\n         * This factor will be applied to the delta of the current touch pointer position and the last\n         * touch pointer position: The result then will be used as an offset to orbit the camera.\n         * Default value is `0.1`.\n         */\n        this.orbitingTouchDeltaFactor = 0.1;\n        /**\n         * Set to `true` to enable input handling through this map control, `false` to disable input\n         * handling. Even when disabling input handling, you can manually use the public functions to\n         * change the view to the current map.\n         */\n        this.enabled = true;\n        /**\n         * Set to `true` to enable orbiting and tilting through these controls, `false` otherwise.\n         */\n        this.tiltEnabled = true;\n        /**\n         * Set to `true` to enable rotation through this map control, `false` to disable rotation.\n         */\n        this.rotateEnabled = true;\n        /**\n         * Set to `true` to enable an inertia dampening on zooming and panning. `false` cancels inertia.\n         */\n        this.inertiaEnabled = true;\n        /**\n         * Inertia damping duration for the zoom, in seconds.\n         */\n        this.zoomInertiaDampingDuration = 0.5;\n        /**\n         * Inertia damping duration for the panning, in seconds.\n         */\n        this.panInertiaDampingDuration = 1.0;\n        /**\n         * Duration in seconds of the camera animation when the tilt button is clicked. Independent of\n         * inertia.\n         */\n        this.tiltToggleDuration = 0.5;\n        /**\n         * Camera tilt to the target when tilting from the `toggleTilt` public method.\n         */\n        this.tiltAngle = Math.PI / 4;\n        /**\n         * Duration of the animation to reset the camera to looking north, in seconds. Independent of\n         * inertia.\n         */\n        this.northResetAnimationDuration = 1.5;\n        /**\n         * Determines the zoom level delta for single mouse wheel movement. So after each mouse wheel\n         * movement the current zoom level will be added or subtracted by this value. The default value\n         * is `0.2` - this means that every 5th mouse wheel movement you will cross a zoom level.\n         *\n         * **Note**: To reverse the zoom direction, you can provide a negative value.\n         */\n        this.zoomLevelDeltaOnMouseWheel = 0.2;\n        /**\n         * Zoom level delta when using the UI controls.\n         */\n        this.zoomLevelDeltaOnControl = 1.0;\n        /**\n         * Determines the minimum zoom level we can zoom to.\n         */\n        this.minZoomLevel = 0;\n        /**\n         * Determines the maximum zoom level we can zoom to.\n         */\n        this.maxZoomLevel = 20;\n        /**\n         * Determines the minimum camera height in meter.\n         */\n        this.minCameraHeight = 3;\n        /**\n         * Zoom level delta to apply when double clicking or double tapping. `0` disables the feature.\n         */\n        this.zoomLevelDeltaOnDoubleClick = 1.0;\n        /**\n         * Double click uses the OS delay through the double click event. Tapping is implemented locally\n         * here in `MapControls` with this duration setting the maximum delay to define a double tap.\n         * The value is in seconds. `300ms` is picked as the default value as jQuery does.\n         */\n        this.doubleTapTime = 0.3;\n        this.m_currentViewDirection = new THREE.Vector3();\n        this.m_lastMousePosition = new THREE.Vector2(0, 0);\n        this.m_mouseDelta = new THREE.Vector2(0, 0);\n        this.m_needsRenderLastFrame = true;\n        // Internal variables for animating panning (planar + spherical panning).\n        this.m_panIsAnimated = false;\n        this.m_panDistanceFrameDelta = new THREE.Vector3();\n        this.m_panAnimationTime = 0;\n        this.m_panAnimationStartTime = 0;\n        this.m_lastAveragedPanDistanceOrAngle = 0;\n        this.m_currentInertialPanningSpeed = 0;\n        this.m_lastPanVector = new THREE.Vector3();\n        this.m_rotateGlobeQuaternion = new THREE.Quaternion();\n        this.m_lastRotateGlobeAxis = new THREE.Vector3();\n        this.m_lastRotateGlobeAngle = 0;\n        this.m_lastRotateGlobeFromVector = new THREE.Vector3();\n        this.m_recentPanDistancesOrAngles = [\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        this.m_currentPanDistanceOrAngleIndex = 0;\n        // Internal variables for animating zoom.\n        this.m_zoomIsAnimated = false;\n        this.m_zoomDeltaRequested = 0;\n        this.m_zoomTargetNormalizedCoordinates = new THREE.Vector2();\n        this.m_zoomAnimationTime = 0;\n        this.m_zoomAnimationStartTime = 0;\n        this.m_startZoom = 0;\n        // Internal variables for animating tilt.\n        this.m_tiltIsAnimated = false;\n        this.m_tiltRequested = undefined;\n        this.m_tiltAnimationTime = 0;\n        this.m_tiltAnimationStartTime = 0;\n        this.m_startTilt = 0;\n        this.m_state = State.NONE;\n        this.m_tmpVector2 = new THREE.Vector2();\n        this.m_tmpVector3 = new THREE.Vector3();\n        // Internal variables for animating double tap.\n        this.m_tapStartTime = 0;\n        this.m_lastSingleTapTime = 0;\n        this.m_fingerMoved = false;\n        this.m_isDoubleTap = false;\n        // Internal variables for animating the movement resetting the north.\n        this.m_resetNorthStartTime = 0;\n        this.m_resetNorthIsAnimated = false;\n        this.m_resetNorthAnimationDuration = 0;\n        this.m_currentAzimuth = 0;\n        this.m_lastAzimuth = 0;\n        this.m_startAzimuth = 0;\n        /**\n         * Determines the maximum angle the camera can tilt to. It is defined in radians.\n         */\n        this.m_maxTiltAngle = DEFAULT_MAX_TILT_ANGLE;\n        this.m_touchState = {\n            touches: [],\n            currentRotation: 0,\n            initialRotation: 0\n        };\n        /**\n         * Destroy this `MapControls` instance.\n         *\n         * Unregisters all global event handlers used. This is method should be called when you stop\n         * using `MapControls`.\n         */\n        this.dispose = () => {\n            // replaced with real code in bindInputEvents\n        };\n        this.camera = mapView.camera;\n        this.domElement = mapView.renderer.domElement;\n        this.maxZoomLevel = mapView.maxZoomLevel;\n        this.minZoomLevel = mapView.minZoomLevel;\n        this.minCameraHeight = mapView.minCameraHeight;\n        this.bindInputEvents(this.domElement);\n        this.handleZoom = this.handleZoom.bind(this);\n        this.handlePan = this.handlePan.bind(this);\n        this.tilt = this.tilt.bind(this);\n        this.resetNorth = this.resetNorth.bind(this);\n        this.assignZoomAfterTouchZoomRender = this.assignZoomAfterTouchZoomRender.bind(this);\n    }\n    /**\n     * Creates MapControls object and attaches it specified [[MapView]].\n     *\n     * @param mapView - [[MapView]] object to which MapControls should be attached to.\n     */\n    static create(mapView) {\n        return new MapControls(mapView);\n    }\n    /**\n     * Current viewing angles yaw/pitch/roll in degrees.\n     */\n    get attitude() {\n        const attitude = harp_mapview_1.MapViewUtils.extractAttitude(this.mapView, this.camera);\n        return {\n            yaw: THREE.Math.radToDeg(attitude.yaw),\n            pitch: THREE.Math.radToDeg(attitude.pitch),\n            roll: THREE.Math.radToDeg(attitude.roll)\n        };\n    }\n    /**\n     * Moves the camera along the view direction in meters.\n     * A positive value will move the camera further away from the point where the camera looks at.\n     * A negative value will move the camera near to the point where the camera looks at.\n     *\n     * @param amount Amount to move along the view direction in meters.\n     */\n    moveAlongTheViewDirection(amount) {\n        if (amount === 0) {\n            return;\n        }\n        this.camera.getWorldDirection(this.m_currentViewDirection);\n        const maxDistance = harp_mapview_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this.mapView, this.mapView.minZoomLevel);\n        const minDistance = harp_mapview_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this.mapView, this.mapView.maxZoomLevel);\n        this.m_currentViewDirection.multiplyScalar(amount);\n        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n            this.camera.position.z += this.m_currentViewDirection.z;\n            this.camera.position.z = Math.max(minDistance, Math.min(maxDistance, this.camera.position.z));\n        }\n        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n            const zOnVertical = Math.cos(this.camera.position.angleTo(this.m_currentViewDirection)) *\n                this.m_currentViewDirection.length();\n            this.camera.position.setLength(Math.max(minDistance + geoUtils.EarthConstants.EQUATORIAL_RADIUS, Math.min(maxDistance + geoUtils.EarthConstants.EQUATORIAL_RADIUS, this.camera.position.length() + zOnVertical)));\n        }\n        // In sphere, we may have to also orbit the camera around the position located at the\n        // center of the screen, in order to limit the tilt to `maxTiltAngle`, as we change\n        // this tilt by changing the camera's height above.\n        if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical &&\n            this.m_maxTiltAngle !== undefined) {\n            const centerScreenTarget = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, 0, 0);\n            if (centerScreenTarget !== null) {\n                const tilt = harp_mapview_1.MapViewUtils.extractSphericalCoordinatesFromLocation(this.mapView, this.camera, this.mapView.projection.unprojectPoint(centerScreenTarget)).tilt;\n                const deltaTilt = tilt - this.m_maxTiltAngle;\n                if (deltaTilt > 0) {\n                    harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, 0, deltaTilt, this.m_maxTiltAngle);\n                }\n            }\n        }\n        this.updateMapView();\n        this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.assignZoomAfterTouchZoomRender);\n    }\n    /**\n     * Reset the camera to looking north, in an orbiting movement around the target point instead\n     * of changing the yaw (which would be the camera rotating on itself).\n     */\n    pointToNorth() {\n        const target = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, 0, 0);\n        if (target === null) {\n            throw new Error(\"MapView does not support a view pointing in the void.\");\n        }\n        this.m_startAzimuth =\n            Math.PI +\n                harp_mapview_1.MapViewUtils.extractSphericalCoordinatesFromLocation(this.mapView, this.camera, this.mapView.projection.unprojectPoint(target)).azimuth;\n        // Wrap between -PI and PI.\n        this.m_startAzimuth = Math.atan2(Math.sin(this.m_startAzimuth), Math.cos(this.m_startAzimuth));\n        if (this.m_startAzimuth === 0) {\n            return;\n        }\n        this.stopExistingAnimations();\n        this.m_resetNorthAnimationDuration = this.northResetAnimationDuration;\n        this.m_currentAzimuth = this.m_startAzimuth;\n        this.m_resetNorthStartTime = performance.now();\n        this.resetNorth();\n    }\n    /**\n     * Zooms and moves the map in such a way that the given target position remains at the same\n     * position after the zoom.\n     *\n     * @param targetPositionOnScreenXinNDC Target x position in NDC space.\n     * @param targetPositionOnScreenYinNDC Target y position in NDC space.\n     */\n    zoomOnTargetPosition(targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel) {\n        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel, this.m_maxTiltAngle);\n    }\n    /**\n     * Zooms to the desired location by the provided value.\n     *\n     * @param zoomLevel Zoom level.\n     * @param screenTarget Zoom target on screen.\n     */\n    setZoomLevel(zoomLevel, screenTarget = { x: 0, y: 0 }) {\n        if (this.enabled === false) {\n            return;\n        }\n        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);\n        // Register the zoom request\n        this.m_startZoom = this.currentZoom;\n        this.m_zoomDeltaRequested = zoomLevel - this.zoomLevelTargeted;\n        this.stopExistingAnimations();\n        // Assign the new animation start time.\n        this.m_zoomAnimationStartTime = performance.now();\n        this.m_zoomTargetNormalizedCoordinates.set(screenTarget.x, screenTarget.y);\n        this.handleZoom();\n        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);\n    }\n    /**\n     * Toggles the camera tilt between 0 (looking down) and the value at `this.tiltAngle`.\n     */\n    toggleTilt() {\n        this.stopExistingAnimations();\n        this.m_startTilt = this.currentTilt;\n        const aimTilt = this.m_startTilt < EPSILON;\n        this.m_tiltRequested = aimTilt ? this.tiltAngle : 0;\n        this.m_tiltState = aimTilt ? TiltState.Tilted : TiltState.Down;\n        this.m_tiltAnimationStartTime = performance.now();\n        this.tilt();\n    }\n    /**\n     * Set the camera height.\n     */\n    set cameraHeight(height) {\n        //Set the cameras height according to the given zoom level.\n        this.camera.position.setZ(height);\n        this.camera.matrixWorldNeedsUpdate = true;\n    }\n    /**\n     * Get the current camera height.\n     */\n    get cameraHeight() {\n        // ### Sync with the way geoviz is computing the zoom level.\n        return this.mapView.camera.position.z;\n    }\n    /**\n     * Set camera max tilt angle. The value is clamped between 0 and 90 degrees. In sphere\n     * projection, at runtime, the value is also clamped so that the camera does not look above the\n     * horizon.\n     *\n     * @param angle Angle in degrees.\n     */\n    set maxTiltAngle(angle) {\n        this.m_maxTiltAngle = Math.max(0, Math.min(90, THREE.Math.degToRad(angle)));\n    }\n    /**\n     * Get the camera max tilt angle in degrees.\n     */\n    get maxTiltAngle() {\n        return THREE.Math.radToDeg(this.m_maxTiltAngle);\n    }\n    /**\n     * Get the zoom level targeted by `MapControls`. Useful when inertia is on, to add incremented\n     * values to the target instead of getting the random zoomLevel value during the interpolation.\n     */\n    get zoomLevelTargeted() {\n        return this.m_targetedZoom === undefined ? this.currentZoom : this.m_targetedZoom;\n    }\n    /**\n     * Handy getter to know if the view is in the process of looking down or not.\n     */\n    get tiltState() {\n        if (this.m_tiltState === undefined) {\n            this.m_tiltState =\n                this.currentTilt < EPSILON || this.m_tiltState === TiltState.Down\n                    ? TiltState.Tilted\n                    : TiltState.Down;\n        }\n        return this.m_tiltState;\n    }\n    set currentZoom(zoom) {\n        this.m_currentZoom = zoom;\n    }\n    get currentZoom() {\n        return this.m_currentZoom !== undefined ? this.m_currentZoom : this.mapView.zoomLevel;\n    }\n    set currentTilt(tilt) {\n        this.m_currentTilt = tilt;\n    }\n    get currentTilt() {\n        const target = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, 0, 0);\n        if (target === null) {\n            throw new Error(\"MapView does not support a view pointing in the void.\");\n        }\n        return harp_mapview_1.MapViewUtils.extractSphericalCoordinatesFromLocation(this.mapView, this.camera, this.mapView.projection.unprojectPoint(target)).tilt;\n    }\n    get targetedTilt() {\n        return this.m_targetedTilt === undefined\n            ? this.m_currentTilt === undefined\n                ? this.currentTilt\n                : this.m_currentTilt\n            : this.m_targetedTilt;\n    }\n    assignZoomAfterTouchZoomRender() {\n        this.m_currentZoom = this.mapView.zoomLevel;\n        this.m_targetedZoom = this.mapView.zoomLevel;\n        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.assignZoomAfterTouchZoomRender);\n    }\n    stopExistingAnimations() {\n        this.stopResetNorth();\n        this.stopZoom();\n        this.stopPan();\n        this.stopTilt();\n    }\n    resetNorth() {\n        const currentTime = performance.now();\n        const animationTime = (currentTime - this.m_resetNorthStartTime) / 1000;\n        if (this.inertiaEnabled) {\n            if (!this.m_resetNorthIsAnimated) {\n                this.m_resetNorthIsAnimated = true;\n                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.resetNorth);\n            }\n            const resetNorthFinished = animationTime > this.m_resetNorthAnimationDuration;\n            if (resetNorthFinished) {\n                if (this.m_needsRenderLastFrame) {\n                    this.m_needsRenderLastFrame = false;\n                    this.stopResetNorth();\n                }\n            }\n            else {\n                this.m_needsRenderLastFrame = true;\n            }\n        }\n        this.m_lastAzimuth = this.m_currentAzimuth;\n        this.m_currentAzimuth = this.inertiaEnabled\n            ? this.easeOutCubic(this.m_startAzimuth, 0, Math.min(1, animationTime / this.m_resetNorthAnimationDuration))\n            : 0;\n        const deltaAzimuth = this.m_currentAzimuth - this.m_lastAzimuth;\n        harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, THREE.Math.radToDeg(deltaAzimuth), 0, this.m_maxTiltAngle);\n        this.updateMapView();\n    }\n    stopResetNorth() {\n        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.resetNorth);\n        this.m_resetNorthIsAnimated = false;\n    }\n    tilt() {\n        if (this.m_tiltRequested !== undefined) {\n            this.m_targetedTilt = Math.max(Math.min(this.m_tiltRequested, this.maxTiltAngle), 0);\n            this.m_tiltRequested = undefined;\n        }\n        if (this.inertiaEnabled) {\n            if (!this.m_tiltIsAnimated) {\n                this.m_tiltIsAnimated = true;\n                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);\n            }\n            const currentTime = performance.now();\n            this.m_tiltAnimationTime = (currentTime - this.m_tiltAnimationStartTime) / 1000;\n            const tiltFinished = this.m_tiltAnimationTime > this.tiltToggleDuration;\n            if (tiltFinished) {\n                if (this.m_needsRenderLastFrame) {\n                    this.m_needsRenderLastFrame = false;\n                    this.m_tiltAnimationTime = this.tiltToggleDuration;\n                    this.stopTilt();\n                }\n            }\n            else {\n                this.m_needsRenderLastFrame = true;\n            }\n        }\n        this.m_currentTilt = this.inertiaEnabled\n            ? this.easeOutCubic(this.m_startTilt, this.targetedTilt, Math.min(1, this.m_tiltAnimationTime / this.tiltToggleDuration))\n            : this.targetedTilt;\n        const initialTilt = this.currentTilt;\n        const deltaAngle = this.m_currentTilt - initialTilt;\n        const oldCameraDistance = this.mapView.camera.position.z / Math.cos(initialTilt);\n        const newHeight = Math.cos(this.currentTilt) * oldCameraDistance;\n        harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, newHeight - this.camera.position.z, THREE.Math.radToDeg(deltaAngle), this.m_maxTiltAngle);\n        this.updateMapView();\n    }\n    stopTilt() {\n        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);\n        this.m_tiltIsAnimated = false;\n        this.m_targetedTilt = this.m_currentTilt = undefined;\n    }\n    easeOutCubic(startValue, endValue, time) {\n        return startValue + (endValue - startValue) * (--time * time * time + 1);\n    }\n    handleZoom() {\n        if (this.m_zoomDeltaRequested !== 0) {\n            this.m_targetedZoom = Math.max(Math.min(this.zoomLevelTargeted + this.m_zoomDeltaRequested, this.maxZoomLevel), this.minZoomLevel);\n            this.m_zoomDeltaRequested = 0;\n        }\n        if (this.inertiaEnabled && this.zoomInertiaDampingDuration > 0) {\n            if (!this.m_zoomIsAnimated) {\n                this.m_zoomIsAnimated = true;\n                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);\n            }\n            const currentTime = performance.now();\n            this.m_zoomAnimationTime = (currentTime - this.m_zoomAnimationStartTime) / 1000;\n            const zoomFinished = this.m_zoomAnimationTime > this.zoomInertiaDampingDuration;\n            if (zoomFinished) {\n                if (this.m_needsRenderLastFrame) {\n                    this.m_needsRenderLastFrame = false;\n                    this.m_zoomAnimationTime = this.zoomInertiaDampingDuration;\n                    this.stopZoom();\n                }\n            }\n            else {\n                this.m_needsRenderLastFrame = true;\n            }\n        }\n        this.currentZoom =\n            !this.inertiaEnabled || Math.abs(this.zoomLevelTargeted - this.m_startZoom) < EPSILON\n                ? this.zoomLevelTargeted\n                : this.easeOutCubic(this.m_startZoom, this.zoomLevelTargeted, Math.min(1, this.m_zoomAnimationTime / this.zoomInertiaDampingDuration));\n        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, this.m_zoomTargetNormalizedCoordinates.x, this.m_zoomTargetNormalizedCoordinates.y, this.currentZoom, this.m_maxTiltAngle);\n        this.updateMapView();\n    }\n    stopZoom() {\n        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);\n        this.m_zoomIsAnimated = false;\n    }\n    /**\n     * Method to flip crêpes.\n     */\n    handlePan() {\n        if (this.m_state === State.NONE && this.m_lastAveragedPanDistanceOrAngle === 0) {\n            return;\n        }\n        if (this.inertiaEnabled && !this.m_panIsAnimated) {\n            this.m_panIsAnimated = true;\n            this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handlePan);\n        }\n        const applyInertia = this.inertiaEnabled &&\n            this.panInertiaDampingDuration > 0 &&\n            this.m_state === State.NONE &&\n            this.m_lastAveragedPanDistanceOrAngle > 0;\n        if (applyInertia) {\n            const currentTime = performance.now();\n            this.m_panAnimationTime = (currentTime - this.m_panAnimationStartTime) / 1000;\n            const panFinished = this.m_panAnimationTime > this.panInertiaDampingDuration;\n            if (panFinished) {\n                if (this.m_needsRenderLastFrame) {\n                    this.m_needsRenderLastFrame = false;\n                    this.m_panAnimationTime = this.panInertiaDampingDuration;\n                    this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handlePan);\n                    this.m_panIsAnimated = false;\n                }\n            }\n            else {\n                this.m_needsRenderLastFrame = true;\n            }\n            const animationTime = this.m_panAnimationTime / this.panInertiaDampingDuration;\n            this.m_currentInertialPanningSpeed = this.easeOutCubic(this.m_lastAveragedPanDistanceOrAngle, 0, Math.min(1, animationTime));\n            if (this.m_currentInertialPanningSpeed === 0) {\n                this.m_lastAveragedPanDistanceOrAngle = 0;\n            }\n            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n                this.m_panDistanceFrameDelta\n                    .copy(this.m_lastPanVector)\n                    .setLength(this.m_currentInertialPanningSpeed);\n            }\n            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n                this.m_rotateGlobeQuaternion\n                    .setFromAxisAngle(this.m_lastRotateGlobeAxis, this.m_currentInertialPanningSpeed)\n                    .normalize();\n            }\n        }\n        else {\n            let panDistanceOrAngle = 0;\n            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n                panDistanceOrAngle = this.m_lastPanVector\n                    .copy(this.m_panDistanceFrameDelta)\n                    .length();\n            }\n            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n                panDistanceOrAngle = this.m_lastRotateGlobeAngle;\n                this.m_rotateGlobeQuaternion.setFromAxisAngle(this.m_lastRotateGlobeAxis, this.m_lastRotateGlobeAngle);\n                this.m_rotateGlobeQuaternion.normalize();\n            }\n            this.m_currentPanDistanceOrAngleIndex =\n                (this.m_currentPanDistanceOrAngleIndex + 1) % USER_INPUTS_TO_CONSIDER;\n            this.m_recentPanDistancesOrAngles[this.m_currentPanDistanceOrAngleIndex] = panDistanceOrAngle;\n            this.m_lastAveragedPanDistanceOrAngle =\n                this.m_recentPanDistancesOrAngles.reduce((a, b) => a + b) / USER_INPUTS_TO_CONSIDER;\n        }\n        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n            harp_mapview_1.MapViewUtils.panCameraAboveFlatMap(this.mapView, this.m_panDistanceFrameDelta.x, this.m_panDistanceFrameDelta.y);\n        }\n        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n            harp_mapview_1.MapViewUtils.panCameraAroundGlobe(this.mapView, this.m_lastRotateGlobeFromVector, this.m_tmpVector3\n                .copy(this.m_lastRotateGlobeFromVector)\n                .applyQuaternion(this.m_rotateGlobeQuaternion));\n        }\n        if (!applyInertia) {\n            this.m_panDistanceFrameDelta.set(0, 0, 0);\n            this.m_lastRotateGlobeAngle = 0;\n        }\n        this.updateMapView();\n    }\n    stopPan() {\n        this.m_panDistanceFrameDelta.set(0, 0, 0);\n        this.m_lastAveragedPanDistanceOrAngle = 0;\n    }\n    bindInputEvents(domElement) {\n        const onContextMenu = this.contextMenu.bind(this);\n        const onMouseDown = this.mouseDown.bind(this);\n        const onMouseWheel = this.mouseWheel.bind(this);\n        const onTouchStart = this.touchStart.bind(this);\n        const onTouchEnd = this.touchEnd.bind(this);\n        const onTouchMove = this.touchMove.bind(this);\n        const onMouseDoubleClick = this.mouseDoubleClick.bind(this);\n        domElement.addEventListener(\"dblclick\", onMouseDoubleClick, false);\n        domElement.addEventListener(\"contextmenu\", onContextMenu, false);\n        domElement.addEventListener(\"mousedown\", onMouseDown, false);\n        domElement.addEventListener(\"wheel\", onMouseWheel, false);\n        domElement.addEventListener(\"touchstart\", onTouchStart, false);\n        domElement.addEventListener(\"touchend\", onTouchEnd, false);\n        domElement.addEventListener(\"touchmove\", onTouchMove, false);\n        this.dispose = () => {\n            domElement.removeEventListener(\"dblclick\", onMouseDoubleClick, false);\n            domElement.removeEventListener(\"contextmenu\", onContextMenu, false);\n            domElement.removeEventListener(\"mousedown\", onMouseDown, false);\n            domElement.removeEventListener(\"wheel\", onMouseWheel, false);\n            domElement.removeEventListener(\"touchstart\", onTouchStart, false);\n            domElement.removeEventListener(\"touchend\", onTouchEnd, false);\n            domElement.removeEventListener(\"touchmove\", onTouchMove, false);\n        };\n    }\n    updateMapView() {\n        this.dispatchEvent(MAPCONTROL_EVENT);\n        this.mapView.update();\n    }\n    mouseDoubleClick(e) {\n        if (this.enabled === false) {\n            return;\n        }\n        this.zoomOnDoubleClickOrTap(e.clientX, e.clientY);\n    }\n    mouseDown(event) {\n        if (this.enabled === false) {\n            return;\n        }\n        if (event.shiftKey || event.ctrlKey) {\n            return;\n        }\n        event.stopPropagation();\n        if (this.m_state !== State.NONE) {\n            return;\n        }\n        if (event.button === 0) {\n            this.m_state = State.PAN;\n        }\n        else if (event.button === 1) {\n            this.m_state = State.ROTATE;\n        }\n        else if (event.button === 2 && this.tiltEnabled) {\n            this.m_state = State.ORBIT;\n        }\n        else {\n            return;\n        }\n        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);\n        this.m_lastMousePosition.setX(event.clientX);\n        this.m_lastMousePosition.setY(event.clientY);\n        const onMouseMove = this.mouseMove.bind(this);\n        const onMouseUp = this.mouseUp.bind(this);\n        window.addEventListener(\"mousemove\", onMouseMove, false);\n        window.addEventListener(\"mouseup\", onMouseUp, false);\n        this.m_cleanupMouseEventListeners = () => {\n            window.removeEventListener(\"mousemove\", onMouseMove);\n            window.removeEventListener(\"mouseup\", onMouseUp);\n        };\n    }\n    mouseMove(event) {\n        if (this.enabled === false) {\n            return;\n        }\n        this.m_mouseDelta.set(event.clientX - this.m_lastMousePosition.x, event.clientY - this.m_lastMousePosition.y);\n        if (this.m_state === State.PAN) {\n            const vectors = this.getWorldPositionWithElevation(this.m_lastMousePosition.x, this.m_lastMousePosition.y, event.clientX, event.clientY);\n            if (vectors === undefined) {\n                return;\n            }\n            const { fromWorld, toWorld } = vectors;\n            this.panFromTo(fromWorld, toWorld);\n        }\n        else if (this.m_state === State.ROTATE) {\n            this.stopExistingAnimations();\n            harp_mapview_1.MapViewUtils.rotate(this.mapView, -this.rotationMouseDeltaFactor * this.m_mouseDelta.x, this.rotationMouseDeltaFactor * this.m_mouseDelta.y, this.m_maxTiltAngle);\n        }\n        else if (this.m_state === State.ORBIT) {\n            this.stopExistingAnimations();\n            harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, this.orbitingMouseDeltaFactor * this.m_mouseDelta.x, -this.orbitingMouseDeltaFactor * this.m_mouseDelta.y, this.m_maxTiltAngle);\n        }\n        this.m_lastMousePosition.set(event.clientX, event.clientY);\n        this.m_zoomAnimationStartTime = performance.now();\n        this.updateMapView();\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    mouseUp(event) {\n        if (this.enabled === false) {\n            return;\n        }\n        this.updateMapView();\n        event.preventDefault();\n        event.stopPropagation();\n        this.m_state = State.NONE;\n        if (this.m_cleanupMouseEventListeners) {\n            this.m_cleanupMouseEventListeners();\n        }\n        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);\n    }\n    mouseWheel(event) {\n        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);\n        const screenTarget = utils.calculateNormalizedDeviceCoordinates(event.offsetX, event.offsetY, width, height);\n        this.setZoomLevel(this.zoomLevelTargeted + this.zoomLevelDeltaOnMouseWheel * (event.deltaY > 0 ? -1 : 1), screenTarget);\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    /**\n     * Calculates the angle of the vector, which is formed by two touch points in world space\n     * against the X axis in world space on the map. The resulting angle is in radians and between\n     * `-PI` and `PI`.\n     */\n    updateCurrentRotation() {\n        if (this.m_touchState.touches.length < 2 ||\n            this.m_touchState.touches[1].currentWorldPosition.length() === 0 ||\n            this.m_touchState.touches[0].currentWorldPosition.length() === 0) {\n            return;\n        }\n        let x = 0;\n        let y = 0;\n        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n            // Planar uses world space coordinates to return the angle of the vector between the two\n            // fingers' locations from the north direction.\n            x =\n                this.m_touchState.touches[1].currentWorldPosition.x -\n                    this.m_touchState.touches[0].currentWorldPosition.x;\n            y =\n                this.m_touchState.touches[1].currentWorldPosition.y -\n                    this.m_touchState.touches[0].currentWorldPosition.y;\n        }\n        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n            // Globe uses screen space coordinates, as the 3d coordinate system cannot define a\n            // reference rotation scalar for the vector between the two fingers' locations.\n            x =\n                this.m_touchState.touches[1].currentTouchPoint.x -\n                    this.m_touchState.touches[0].currentTouchPoint.x;\n            // Below the subtraction is inverted, because the Y coordinate in screen space in HTML\n            // has its origin at the top and increases downwards.\n            y =\n                this.m_touchState.touches[0].currentTouchPoint.y -\n                    this.m_touchState.touches[1].currentTouchPoint.y;\n            this.m_touchState.initialRotation = this.m_touchState.currentRotation;\n        }\n        this.m_touchState.currentRotation = Math.atan2(y, x);\n    }\n    /**\n     * Calculates the difference of the current distance of two touch points against their initial\n     * distance in world space.\n     */\n    calculatePinchDistanceInWorldSpace() {\n        if (this.m_touchState.touches.length < 2) {\n            return 0;\n        }\n        const previousDistance = this.m_tmpVector3\n            .subVectors(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[1].initialWorldPosition)\n            .length();\n        const currentDistance = this.m_tmpVector3\n            .subVectors(this.m_touchState.touches[0].currentWorldPosition, this.m_touchState.touches[1].currentWorldPosition)\n            .length();\n        return currentDistance - previousDistance;\n    }\n    convertTouchPoint(touch, oldTouchState) {\n        const newTouchPoint = new THREE.Vector2(touch.pageX, touch.pageY);\n        if (oldTouchState !== undefined) {\n            const oldTouchPoint = oldTouchState.currentTouchPoint;\n            const vectors = this.getWorldPositionWithElevation(oldTouchPoint.x, oldTouchPoint.y, newTouchPoint.x, newTouchPoint.y);\n            const toWorld = vectors === undefined ? new THREE.Vector3() : vectors.toWorld;\n            // Unless the user is tilting, considering a finger losing the surface as a touchEnd\n            // event. Inertia will get triggered.\n            if (toWorld.length() === 0 &&\n                !(this.m_touchState.touches.length === 3 && this.tiltEnabled)) {\n                this.setTouchState([]);\n                this.m_state = State.NONE;\n                this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);\n                return;\n            }\n            if (this.m_state !== State.TOUCH) {\n                this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);\n            }\n            this.m_state = State.TOUCH;\n            return {\n                currentTouchPoint: newTouchPoint,\n                lastTouchPoint: newTouchPoint,\n                currentWorldPosition: toWorld,\n                initialWorldPosition: toWorld\n            };\n        }\n        else {\n            const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);\n            const to = utils.calculateNormalizedDeviceCoordinates(newTouchPoint.x, newTouchPoint.y, width, height);\n            const result = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);\n            const toWorld = result === null ? new THREE.Vector3() : result;\n            // Unless the user is tilting, considering a finger losing the surface as a touchEnd\n            // event. Inertia will get triggered.\n            if (toWorld.length() === 0 &&\n                !(this.m_touchState.touches.length === 3 && this.tiltEnabled)) {\n                this.setTouchState([]);\n                this.m_state = State.NONE;\n                this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);\n                return;\n            }\n            if (this.m_state !== State.TOUCH) {\n                this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);\n            }\n            this.m_state = State.TOUCH;\n            return {\n                currentTouchPoint: newTouchPoint,\n                lastTouchPoint: newTouchPoint,\n                currentWorldPosition: toWorld,\n                initialWorldPosition: toWorld\n            };\n        }\n    }\n    setTouchState(touches) {\n        this.m_touchState.touches = [];\n        // TouchList doesn't conform to iterator interface so we cannot use 'for of'\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < touches.length; ++i) {\n            const touchState = this.convertTouchPoint(touches[i]);\n            if (touchState !== undefined) {\n                this.m_touchState.touches.push(touchState);\n            }\n        }\n        if (this.m_touchState.touches.length !== 0) {\n            this.updateCurrentRotation();\n            this.m_touchState.initialRotation = this.m_touchState.currentRotation;\n        }\n    }\n    updateTouches(touches) {\n        const length = Math.min(touches.length, this.m_touchState.touches.length);\n        for (let i = 0; i < length; ++i) {\n            const oldTouchState = this.m_touchState.touches[i];\n            const newTouchState = this.convertTouchPoint(touches[i], oldTouchState);\n            if (newTouchState !== undefined && oldTouchState !== undefined) {\n                newTouchState.initialWorldPosition = oldTouchState.initialWorldPosition;\n                newTouchState.lastTouchPoint = oldTouchState.currentTouchPoint;\n                this.m_touchState.touches[i] = newTouchState;\n            }\n        }\n    }\n    zoomOnDoubleClickOrTap(x, y) {\n        if (this.zoomLevelDeltaOnDoubleClick === 0) {\n            return;\n        }\n        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);\n        const ndcCoords = utils.calculateNormalizedDeviceCoordinates(x, y, width, height);\n        this.setZoomLevel(this.currentZoom + this.zoomLevelDeltaOnDoubleClick, ndcCoords);\n    }\n    touchStart(event) {\n        if (this.enabled === false) {\n            return;\n        }\n        this.m_tapStartTime = performance.now();\n        this.m_fingerMoved = false;\n        this.m_state = State.TOUCH;\n        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);\n        this.setTouchState(event.touches);\n        this.updateTouches(event.touches);\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    touchMove(event) {\n        if (this.enabled === false) {\n            return;\n        }\n        this.m_fingerMoved = true;\n        this.updateTouches(event.touches);\n        if (this.m_touchState.touches.length <= 2 && this.m_touchState.touches[0] !== undefined) {\n            this.panFromTo(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[0].currentWorldPosition);\n        }\n        if (this.m_touchState.touches.length === 2) {\n            const pinchDistance = this.calculatePinchDistanceInWorldSpace();\n            if (Math.abs(pinchDistance) < EPSILON) {\n                return;\n            }\n            this.updateCurrentRotation();\n            const deltaRotation = this.m_touchState.currentRotation - this.m_touchState.initialRotation;\n            this.stopExistingAnimations();\n            harp_mapview_1.MapViewUtils.rotate(this.mapView, THREE.Math.radToDeg(deltaRotation));\n            this.moveAlongTheViewDirection(pinchDistance);\n        }\n        // Tilting\n        if (this.m_touchState.touches.length === 3 && this.tiltEnabled) {\n            const firstTouch = this.m_touchState.touches[0];\n            const diff = this.m_tmpVector2.subVectors(firstTouch.currentTouchPoint, firstTouch.lastTouchPoint);\n            this.stopExistingAnimations();\n            harp_mapview_1.MapViewUtils.orbitFocusPoint(this.mapView, this.orbitingTouchDeltaFactor * diff.x, -this.orbitingTouchDeltaFactor * diff.y, this.m_maxTiltAngle);\n        }\n        this.m_zoomAnimationStartTime = performance.now();\n        this.updateMapView();\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    touchEnd(event) {\n        if (this.enabled === false) {\n            return;\n        }\n        this.m_state = State.NONE;\n        this.handleDoubleTap();\n        this.setTouchState(event.touches);\n        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);\n        this.updateMapView();\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    handleDoubleTap() {\n        // Continue only if no touchmove happened.\n        if (this.m_fingerMoved) {\n            return;\n        }\n        const now = performance.now();\n        const tapDuration = now - this.m_tapStartTime;\n        // Continue only if proper tap.\n        if (tapDuration > MAX_TAP_DURATION) {\n            return;\n        }\n        // Continue only if this is the second valid tap.\n        if (!this.m_isDoubleTap) {\n            this.m_isDoubleTap = true;\n            this.m_lastSingleTapTime = now;\n            return;\n        }\n        // Continue only if the delay between the two taps is short enough.\n        if (now - this.m_lastSingleTapTime > this.doubleTapTime * 1000) {\n            // If too long, restart double tap validator too.\n            this.m_isDoubleTap = false;\n            return;\n        }\n        this.zoomOnDoubleClickOrTap(this.m_touchState.touches[0].currentTouchPoint.x, this.m_touchState.touches[0].currentTouchPoint.y);\n        // Prevent a string of X valid taps and only consider pairs.\n        this.m_isDoubleTap = false;\n    }\n    contextMenu(event) {\n        event.preventDefault();\n    }\n    getWorldPositionWithElevation(fromX, fromY, toX, toY) {\n        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);\n        const from = utils.calculateNormalizedDeviceCoordinates(fromX, fromY, width, height);\n        const to = utils.calculateNormalizedDeviceCoordinates(toX, toY, width, height);\n        let toWorld;\n        let fromWorld;\n        let elevationProviderResult;\n        if (this.mapView.elevationProvider !== undefined) {\n            elevationProviderResult = this.mapView.elevationProvider.rayCast(fromX, fromY);\n        }\n        if (elevationProviderResult === undefined) {\n            fromWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, from.x, from.y);\n            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);\n        }\n        else {\n            fromWorld = elevationProviderResult;\n            const fromGeoAltitude = this.mapView.projection.unprojectAltitude(fromWorld);\n            // We can ensure that points under the mouse stay there by projecting the to point onto\n            // a plane with the altitude based on the initial point.\n            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y, fromGeoAltitude);\n        }\n        if (fromWorld === null || toWorld === null) {\n            return;\n        }\n        return { fromWorld, toWorld };\n    }\n    panFromTo(fromWorld, toWorld) {\n        this.stopExistingAnimations();\n        // Assign the new animation start time.\n        this.m_panAnimationStartTime = performance.now();\n        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n            this.m_panDistanceFrameDelta.subVectors(fromWorld, toWorld);\n        }\n        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n            this.m_lastRotateGlobeFromVector.copy(fromWorld);\n            this.m_lastRotateGlobeAxis.crossVectors(fromWorld, toWorld).normalize();\n            this.m_lastRotateGlobeAngle = fromWorld.angleTo(toWorld);\n            // When fromWorld and toWorld are too close, there is a risk of getting an NaN\n            // value. The following ensures that the controls don't break.\n            if (isNaN(this.m_lastRotateGlobeAngle)) {\n                this.m_lastRotateGlobeAngle = 0;\n            }\n        }\n        this.handlePan();\n    }\n}\nexports.MapControls = MapControls;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-map-controls/lib/MapControls.js?");

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/MapControlsUI.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/MapControlsUI.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Base class to handle UI overlay elements.\n */\nclass MapControlsUI {\n    /**\n     * Constructor of the UI.\n     *\n     * @param controls Controls referencing a [[MapView]].\n     */\n    constructor(controls, options = {}) {\n        this.controls = controls;\n        /**\n         * The DOM node containing the UI.\n         */\n        this.domElement = document.createElement(\"div\");\n        this.m_buttonsElement = document.createElement(\"div\");\n        /**\n         * Displays zoom level if [[MapControlsUIOptions.zoomLevel]] is defined.\n         */\n        this.m_zoomLevelElement = null;\n        /**\n         * Displays zoom level if [[MapControlsUIOptions.projectionSwitch]] is defined.\n         */\n        this.m_projectionSwitchElement = null;\n        this.m_onMapViewRenderEvent = () => {\n            if (this.m_zoomLevelElement === null) {\n                return;\n            }\n            const zoom = this.controls.zoomLevelTargeted.toFixed(1);\n            if (this.m_zoomLevelElement.tagName === \"INPUT\") {\n                this.m_zoomLevelElement.value = zoom;\n            }\n            else {\n                this.m_zoomLevelElement.innerHTML = zoom;\n            }\n        };\n        this.m_onWindowClick = (event) => {\n            const input = this.m_zoomLevelElement;\n            if (!event ||\n                !event.target ||\n                !event.target.contains ||\n                event.target === input ||\n                event.target.contains(input)) {\n                return;\n            }\n            input.blur();\n        };\n        // Empty element to dynamically align the controls vertically, depending on which buttons\n        // are enabled. Avoids unreliable style computations in the script.\n        const verticalAligner = document.createElement(\"span\");\n        verticalAligner.className = \"harp-gl_v-align\";\n        this.domElement.appendChild(verticalAligner);\n        // This element will receive the controls and ensure the vertical alignment in the CSS.\n        this.m_buttonsElement = document.createElement(\"div\");\n        this.m_buttonsElement.className = \"harp-gl_v-aligned\";\n        this.domElement.appendChild(this.m_buttonsElement);\n        const zoomInButton = document.createElement(\"button\");\n        zoomInButton.innerText = \"+\";\n        zoomInButton.className = \"harp-gl_controls_button-top\";\n        zoomInButton.classList.add(\"harp-gl_controls-button\");\n        const zoomOutButton = document.createElement(\"button\");\n        zoomOutButton.innerText = \"-\";\n        zoomOutButton.className = \"harp-gl_controls_button-bottom\";\n        zoomOutButton.classList.add(\"harp-gl_controls-button\");\n        const tiltButton = document.createElement(\"button\");\n        tiltButton.innerText = \"3D\";\n        tiltButton.id = \"harp-gl_controls_tilt-button-ui\";\n        tiltButton.title = \"Toggle tilt\";\n        tiltButton.classList.add(\"harp-gl_controls-button\");\n        tiltButton.classList.add(\"harp-gl_controls_button-bottom\");\n        const compassButton = document.createElement(\"button\");\n        compassButton.id = \"harp-gl_controls-button_compass\";\n        compassButton.title = \"Reset North\";\n        compassButton.classList.add(\"harp-gl_controls-button\");\n        compassButton.classList.add(\"harp-gl_controls_button-top\");\n        const compass = document.createElement(\"span\");\n        compass.id = \"harp-gl_controls_compass\";\n        compassButton.appendChild(compass);\n        // Optional zoom level displaying\n        if (options.zoomLevel === \"show\") {\n            this.m_zoomLevelElement = document.createElement(\"div\");\n            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);\n        }\n        else if (options.zoomLevel === \"input\") {\n            const input = document.createElement(\"input\");\n            input.type = \"number\";\n            input.step = \"0.1\"; // Avoids messages in the UI on hovering, when a tenth value exists.\n            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);\n            const updateZoom = (event) => {\n                controls.setZoomLevel(parseFloat(input.value));\n                event.preventDefault();\n            };\n            input.addEventListener(\"blur\", updateZoom);\n            input.addEventListener(\"keypress\", event => {\n                if (event.key === \"Enter\") {\n                    updateZoom(event);\n                }\n            });\n            window.addEventListener(\"click\", this.m_onWindowClick);\n            this.m_zoomLevelElement = input;\n        }\n        if (options.projectionSwitch) {\n            const switcher = document.createElement(\"button\");\n            switcher.id = \"harp-gl_controls_switch_projection\";\n            switcher.classList.add(\"harp-gl_controls-button\");\n            const getTitle = () => {\n                return `Switch to ${this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical\n                    ? \"flat\"\n                    : \"globe\"} projection`;\n            };\n            switcher.title = getTitle();\n            const globeSVG = getGlobeSVG();\n            const flatMapSVG = getFlatMapSVG();\n            switcher.innerHTML =\n                this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical\n                    ? flatMapSVG\n                    : globeSVG;\n            switcher.addEventListener(\"click\", () => {\n                this.controls.mapView.projection =\n                    this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical\n                        ? harp_geoutils_1.mercatorProjection\n                        : harp_geoutils_1.sphereProjection;\n                switcher.title = getTitle();\n                switcher.innerHTML =\n                    this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical\n                        ? flatMapSVG\n                        : globeSVG;\n            });\n            this.m_projectionSwitchElement = switcher;\n        }\n        this.m_buttonsElement.appendChild(zoomInButton);\n        if (this.m_zoomLevelElement !== null) {\n            this.m_buttonsElement.appendChild(this.m_zoomLevelElement);\n        }\n        this.m_buttonsElement.appendChild(zoomOutButton);\n        this.m_buttonsElement.appendChild(compassButton);\n        this.m_buttonsElement.appendChild(tiltButton);\n        if (this.m_projectionSwitchElement !== null) {\n            this.m_buttonsElement.appendChild(this.m_projectionSwitchElement);\n        }\n        zoomInButton.addEventListener(\"click\", event => {\n            const zoomLevel = controls.zoomLevelTargeted + controls.zoomLevelDeltaOnControl;\n            controls.setZoomLevel(zoomLevel);\n        });\n        zoomOutButton.addEventListener(\"click\", event => {\n            const zoomLevel = controls.zoomLevelTargeted - controls.zoomLevelDeltaOnControl;\n            controls.setZoomLevel(zoomLevel);\n        });\n        tiltButton.addEventListener(\"click\", event => {\n            controls.toggleTilt();\n        });\n        compassButton.addEventListener(\"click\", event => {\n            controls.pointToNorth();\n        });\n        controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, () => {\n            compass.style.transform = `rotate(${THREE.Math.radToDeg(harp_mapview_1.MapViewUtils.extractAttitude(controls.mapView, controls.mapView.camera).yaw)}deg)`;\n        });\n        this.domElement.className = \"harp-gl_controls\";\n        if (this.m_zoomLevelElement !== null) {\n            this.m_zoomLevelElement.classList.add(\"harp-gl_controls_zoom-level\");\n        }\n        if (options.disableDefaultStyle !== true) {\n            this.initStyle();\n            this.domElement.style.cssText = `\n                position: absolute;\n                right: 5px;\n                top: 0;\n                height: 100%; /* Vertical alignment is done dynamically, in the rest of the CSS. */\n                pointer-events: none; /* Allows to click the map even though height is 100%. */\n            `;\n        }\n        return this;\n    }\n    /**\n     * Destroy this [[MapControlsUI]] instance. Unregisters all event handlers used. This method\n     * should be called when you stop using [[MapControlsUI]].\n     */\n    dispose() {\n        if (this.m_zoomLevelElement !== null && this.m_zoomLevelElement.tagName === \"INPUT\") {\n            window.removeEventListener(\"click\", this.m_onWindowClick);\n        }\n        this.controls.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);\n        this.domElement.remove();\n    }\n    initStyle() {\n        if (document.getElementById(\"here-harp-controls.map-controls-ui-styles\") !== null) {\n            return;\n        }\n        const style = document.createElement(\"style\");\n        style.id = \"here-harp-controls.map-controls-ui-styles\";\n        style.appendChild(document.createTextNode(getTextStyle()));\n        document.head.appendChild(style);\n    }\n}\nexports.MapControlsUI = MapControlsUI;\nfunction getTextStyle() {\n    return `\n        /* CSS trick to align another div dynamically. */\n        .harp-gl_v-align{\n            height: 100%;\n            display: inline-block;\n            vertical-align: middle;\n        }\n        /* The target element to align vertically with vertical-align. */\n        .harp-gl_v-aligned{\n            pointer-events: all;\n            vertical-align: middle;\n            display: inline-block;\n        }\n        .harp-gl_controls-button {\n            display: block;\n            background-color: #272d37;\n            width: 40px;\n            height: 40px;\n            font-size: 22px;\n            font-weight: bold;\n            outline: none;\n            margin:0;\n            border: none;\n            color: rgba(255, 255, 255, 0.8);\n            cursor: pointer;\n            border-radius: 4px;\n            box-shadow: 0px 0px 5px 0 hsl(220, 4%, 40%);\n            transition: all 0.1s;\n            padding: 0 0 1px 1px;\n            user-select: none;\n            position:relative;\n        }\n        #harp-gl_controls_tilt-button-ui {\n            font-size: 16px;\n        }\n        .harp-gl_controls-button:active {\n            background-color: #37afaa;\n            color: #eee;\n        }\n        .harp-gl_controls-button:focus {\n            outline:none;\n        }\n        .harp-gl_controls_button-top{\n            margin-bottom:0;\n            border-bottom-right-radius:0;\n            border-bottom-left-radius:0;\n        }\n        .harp-gl_controls_button-bottom{\n            margin-top:1px;\n            border-top-right-radius:0;\n            border-top-left-radius:0;\n        }\n        .harp-gl_controls_zoom-level {\n            display: block;\n            background-color: #fff;\n            width: 40px;\n            height: 20px;\n            font-size: 12px;\n            font-weight: bold;\n            outline: none;\n            border: none;\n            color: #555;\n            opacity: 0.87;\n            box-shadow: 0px 0px 4px #aaa;\n            padding: 2px 0 0;\n            text-align: center;\n            user-select: text;\n        }\n        input.harp-gl_controls_zoom-level::-webkit-outer-spin-button,\n        input.harp-gl_controls_zoom-level::-webkit-inner-spin-button {\n            /* display: none; <- Crashes Chrome on hover */\n            -webkit-appearance: none;\n            margin: 0; /* <-- Apparently some margin are still there even though it's hidden */\n        }\n        input.harp-gl_controls_zoom-level[type=number] {\n            -moz-appearance:textfield; /* Firefox */\n        }\n        #harp-gl_controls-button_compass{\n            margin: 5px 0 0 0;\n        }\n        #harp-gl_controls_compass{\n            pointer-events:none;\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            margin:0\n        }\n        #harp-gl_controls_compass::after{\n            content: \" \";\n            position:absolute;\n            left:50%;\n            margin-left:-3px;\n            top:50%;\n            margin-top: -18px;\n            border:solid 3px rgba(0,0,0,0);\n            border-bottom:solid 15px #a34f2e;\n        }\n        #harp-gl_controls_compass::before{\n            content: \" \";\n            position:absolute;\n            left:50%;\n            margin-left:-3px;\n            top:50%;\n            margin-top:0px;\n            border:solid 3px rgba(0,0,0,0);\n            border-top:solid 15px #eee;\n        }\n        #harp-gl_controls_switch_projection{\n            margin-top:5px;\n        }\n        .harp-gl_controls_switch_svg{\n            width: 25px;\n            height: 25px;\n            stroke: #d4d5d7;\n            fill: #d4d5d7;\n        }\n    `;\n}\n// tslint:disable:max-line-length\nfunction getFlatMapSVG() {\n    return `\n    <svg style=\"margin-top:5px;\" class=\"harp-gl_controls_switch_svg\" width=\"25\" height=\"25\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:svg=\"http://www.w3.org/2000/svg\">\n        <rect id=\"svg_1\" stroke-width=\"2\" height=\"13.51524\" width=\"18.35821\" y=\"5.80349\" x=\"3.21307\" fill=\"none\"/>\n        <path id=\"svg_14\" d=\"m9.52018,7.71815l1.2357,-0.0032l-0.61945,1.18258l-0.61625,-1.17938z\"/>\n        <path id=\"svg_15\" d=\"m4.11409,7.32396l3.65718,-0.0032l0.28156,2.13991l-2.59042,1.57678l0.50682,1.80203l2.25254,0.8447l-0.90101,2.0836l0.28157,2.25254l-3.26619,-3.04093l0.67576,-2.02728l-0.61945,-1.97097l-1.01364,-3.15356l0.73528,-0.50362z\"/>\n        <path id=\"svg_17\" d=\"m13.23688,7.4929l2.02409,-0.0032l0.78839,1.29521l2.47779,-1.35152l2.75936,0.78839l0,1.57678l-0.73208,0.61945l-0.28157,1.97097c0,0 -0.67256,0.8479 -0.72888,0.90422c-0.05631,0.05631 0.28157,1.06996 0.33788,1.18258c0.05631,0.11263 -1.68941,-1.35152 -1.6926,-1.35472c-0.0032,-0.0032 -0.16574,1.29841 -0.16894,1.29521c-0.0032,-0.0032 -1.57358,-1.34832 -1.57678,-1.35152c-0.0032,-0.0032 -0.72888,0.67896 -0.73208,0.67576c-0.0032,-0.0032 -0.8415,-0.67256 -0.8447,-0.67576c-0.0032,-0.0032 0.73528,2.0868 0.79159,2.0868c0.05631,0 -0.50682,3.20987 -0.51002,3.20667c-0.0032,-0.0032 -1.2357,-0.16574 -1.34832,-0.16574c-0.11263,0 -0.95733,-1.52046 -0.90102,-1.57678c0.05631,-0.05631 0,-1.80203 -0.0032,-1.80523c-0.0032,-0.0032 -1.40464,-0.33468 -1.40784,-0.33788c-0.0032,-0.0032 -0.05311,-1.74252 -0.05631,-1.74572c-0.0032,-0.0032 1.18578,-0.8415 1.18258,-0.8447c-0.0032,-0.0032 1.69261,-0.16574 1.74892,-0.16574c0.05631,0 1.2389,-1.06996 1.2357,-1.07316c-0.0032,-0.0032 -1.91146,-0.10943 -1.91466,-0.11263c-0.0032,-0.0032 -1.96777,0.17214 -1.97097,0.16894c-0.0032,-0.0032 1.52366,-3.20667 1.52366,-3.20667z\"/>\n    </svg>`;\n}\nfunction getGlobeSVG() {\n    return `\n    <svg style=\"margin-top:5px;\" stroke-width=\"2\" class=\"harp-gl_controls_switch_svg\" width=\"50\" height=\"50\" viewBox=\"0 0 25 25\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:svg=\"http://www.w3.org/2000/svg\">\n        <ellipse ry=\"9.79855\" rx=\"4.56139\" id=\"svg_6\" cy=\"11.99798\" cx=\"11.99798\" fill=\"none\"/>\n        <line id=\"svg_8\" y2=\"8.16866\" x2=\"21.12086\" y1=\"8.16866\" x1=\"3.10044\"/>\n        <line id=\"svg_9\" y2=\"16.10887\" x2=\"21.0645\" y1=\"16.10887\" x1=\"3.04409\"/>\n        <ellipse id=\"svg_11\" ry=\"9.79855\" rx=\"9.82671\" cy=\"11.94167\" cx=\"12.02614\" fill=\"none\"/>\n    </svg>`;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-map-controls/lib/MapControlsUI.js?");

/***/ }),

/***/ "./node_modules/@here/harp-map-controls/lib/Utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-map-controls/lib/Utils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst three_1 = __webpack_require__(/*! three */ \"three\");\n/**\n * Transforms the given point in screen space into NDC space by taking the given screen dimension\n * into account.\n *\n * @param screenCoordinateX X coordinate in screen space.\n * @param screenCoordinateY Y coordinate in screen space.\n * @param screenSizeX Width of the reference screen size.\n * @param screenSizeY Height of the reference screen size.\n */\nfunction calculateNormalizedDeviceCoordinates(screenCoordinateX, screenCoordinateY, screenSizeX, screenSizeY) {\n    return new three_1.Vector2((screenCoordinateX / screenSizeX) * 2 - 1, -((screenCoordinateY / screenSizeY) * 2) + 1);\n}\nexports.calculateNormalizedDeviceCoordinates = calculateNormalizedDeviceCoordinates;\n/**\n * Returns the direction vector that is described by the given azimuth and altitude.\n *\n * @param azimuth Azimuth in radians.\n * @param altitude Altitude in radians.\n */\nfunction azimuthAltitudeToDirection(azimuth, altitude) {\n    azimuth = azimuth;\n    altitude = altitude;\n    //Shamelessly copied from Jan ;)\n    const result = new three_1.Vector3();\n    const cosAltitude = Math.cos(altitude);\n    result.setX(Math.sin(azimuth) * cosAltitude);\n    result.setY(Math.cos(azimuth) * cosAltitude);\n    result.setZ(Math.sin(altitude));\n    return result;\n}\nexports.azimuthAltitudeToDirection = azimuthAltitudeToDirection;\n/**\n * Safely parses decimal value into `number`.\n *\n * Safely falls back to default value for `null`, `undefined`, `NaN`, empty strings, and strings\n * with characters other than digits.\n *\n * @param text Number as a text to be parsed.\n * @param fallback Default value, which is returned if `text` doesn't represent a valid number.\n */\nfunction safeParseDecimalInt(text, fallback) {\n    if (text === null || text === undefined || text === \"\") {\n        return fallback;\n    }\n    if (!text.match(integerRe)) {\n        return fallback;\n    }\n    const result = Number.parseInt(text, 10);\n    if (isNaN(result)) {\n        return fallback;\n    }\n    return result;\n}\nexports.safeParseDecimalInt = safeParseDecimalInt;\nconst integerRe = /^\\d+$/;\n/**\n * Extracts the CSS width and height of the given canvas if available, or width and height of the\n * canvas otherwise.\n *\n * @param canvas The canvas.\n */\nfunction getWidthAndHeightFromCanvas(canvas) {\n    return {\n        //use clientWidth and clientHeight to support HiDPI devices\n        width: safeParseDecimalInt(canvas.style.width, canvas.clientWidth),\n        height: safeParseDecimalInt(canvas.style.height, canvas.clientHeight)\n    };\n}\nexports.getWidthAndHeightFromCanvas = getWidthAndHeightFromCanvas;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-map-controls/lib/Utils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/TileDataSource */ \"./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js\"));\n__export(__webpack_require__(/*! ./lib/TileLoader */ \"./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ \"./node_modules/@here/harp-lrucache/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst TileLoader_1 = __webpack_require__(/*! ./TileLoader */ \"./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js\");\n/**\n * Templated factory class to create instances of [[Tile]].\n */\nclass TileFactory {\n    /**\n     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is\n     * created.\n     *\n     * @param m_modelConstructor Constructor of (subclass of) [[Tile]].\n     */\n    constructor(m_modelConstructor) {\n        this.m_modelConstructor = m_modelConstructor;\n    }\n    /**\n     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments\n     * to the constructor of [[Tile]].\n     *\n     * @param dataSource [[Datasource]] this class belongs to.\n     * @param tileKey Quadtree address of the [[Tile]].\n     */\n    create(dataSource, tileKey) {\n        return new this.m_modelConstructor(dataSource, tileKey);\n    }\n}\nexports.TileFactory = TileFactory;\nconst maxLevelTileLoaderCache = 3;\n/**\n * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the\n * tile content asynchronously. The decoder can be passed in as an option, or a default\n * asynchronous one is generated.\n */\nclass TileDataSource extends harp_mapview_1.DataSource {\n    /**\n     * Set up the `TileDataSource`.\n     *\n     * @param m_tileFactory Factory to create the [[Tile]] instances.\n     * @param m_options Options specifying the parameters of the [[DataSource]].\n     */\n    constructor(m_tileFactory, m_options) {\n        super(m_options.name, m_options.styleSetName, m_options.minZoomLevel, m_options.maxZoomLevel, m_options.storageLevelOffset);\n        this.m_tileFactory = m_tileFactory;\n        this.m_options = m_options;\n        this.logger = harp_utils_1.LoggerManager.instance.create(\"TileDataSource\");\n        this.m_isReady = false;\n        if (m_options.decoder) {\n            this.m_decoder = m_options.decoder;\n        }\n        else if (m_options.concurrentDecoderServiceName) {\n            this.m_decoder = harp_mapview_1.ConcurrentDecoderFacade.getTileDecoder(m_options.concurrentDecoderServiceName, m_options.concurrentDecoderScriptUrl, m_options.concurrentDecoderWorkerCount);\n        }\n        else {\n            throw new Error(`TileDataSource[${this.name}]: unable to create, missing decoder or ` +\n                `concurrentDecoderServiceName`);\n        }\n        this.useGeometryLoader = true;\n        this.cacheable = true;\n        this.m_tileLoaderCache = new harp_lrucache_1.LRUCache(this.getCacheCount());\n        this.m_tileLoaderCache.evictionCallback = (_, tileLoader) => {\n            // Cancel any pending downloads as early as possible.\n            tileLoader.cancel();\n        };\n    }\n    /** @override */\n    dispose() {\n        this.decoder.dispose();\n    }\n    /** @override */\n    ready() {\n        return this.m_isReady && this.m_options.dataProvider.ready();\n    }\n    /**\n     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with\n     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].\n     */\n    get decoder() {\n        return this.m_decoder;\n    }\n    /** @override */\n    async connect() {\n        await Promise.all([this.m_options.dataProvider.connect(), this.m_decoder.connect()]);\n        this.m_isReady = true;\n        this.m_decoder.configure(undefined, undefined, undefined, {\n            storageLevelOffset: this.m_options.storageLevelOffset\n        });\n    }\n    /** @override */\n    setStyleSet(styleSet, definitions, languages) {\n        this.m_decoder.configure(styleSet, definitions, languages);\n        this.mapView.markTilesDirty(this);\n    }\n    /**\n     * Apply the [[Theme]] to this data source.\n     *\n     * Applies new [[StyleSet]] and definitions from theme only if matching styleset (see\n     * `styleSetName` property) is found in `theme`.\n     * @override\n     */\n    setTheme(theme, languages) {\n        const styleSet = this.styleSetName !== undefined && theme.styles\n            ? theme.styles[this.styleSetName]\n            : undefined;\n        if (styleSet !== undefined) {\n            this.setStyleSet(styleSet, theme.definitions, languages);\n        }\n    }\n    /** @override */\n    clearCache() {\n        this.m_tileLoaderCache.evictAll();\n    }\n    /**\n     * Get the [[DataProvider]] that has been passed in with the options.\n     */\n    dataProvider() {\n        return this.m_options.dataProvider;\n    }\n    /** @override */\n    getTilingScheme() {\n        return this.m_options.tilingScheme;\n    }\n    /**\n     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will\n     * be empty, but the download and decoding will be scheduled immediately. [[Tile]] instance is\n     * initialized with default copyrights, concatenated with copyrights from copyright provider of\n     * this data source.\n     *\n     * @param tileKey Quadtree address of the requested tile.\n     * @override\n     */\n    getTile(tileKey) {\n        const tile = this.m_tileFactory.create(this, tileKey);\n        const mortonCode = tileKey.mortonCode();\n        const tileLoader = this.m_tileLoaderCache.get(mortonCode);\n        if (tileLoader !== undefined) {\n            tile.tileLoader = tileLoader;\n        }\n        else {\n            const newTileLoader = new TileLoader_1.TileLoader(this, tileKey, this.m_options.dataProvider, this.decoder, 0);\n            tile.tileLoader = newTileLoader;\n            tile.copyrightInfo = this.m_options.copyrightInfo;\n            if (this.m_options.copyrightProvider !== undefined) {\n                this.m_options.copyrightProvider\n                    .getCopyrights(tile.geoBox, tileKey.level)\n                    .then(copyrightInfo => {\n                    tile.copyrightInfo =\n                        tile.copyrightInfo === undefined\n                            ? copyrightInfo\n                            : [...tile.copyrightInfo, ...copyrightInfo];\n                    this.requestUpdate();\n                });\n            }\n            // We don't cache tiles with level 4 and above, at this level, there are 16 (2^4) tiles\n            // horizontally, given the assumption that the zoom level assumes the tile should be 256\n            // pixels wide (see function [[calculateZoomLevelFromDistance]]), and the current\n            // storage offset of -2 (which makes the tiles then 1024 pixels wide). this would mean a\n            // horizontal width of ~16k pixels for the entire earth, this would be quite a lot to\n            // pan, hence caching doesn't make sense above this point (as the chance that we need to\n            // share the TileLoader is small, and even if we did eventually see it, the original\n            // TileLoader would probably be evicted because it was removed by other more recent\n            // tiles).\n            if (tileKey.level <= maxLevelTileLoaderCache) {\n                this.m_tileLoaderCache.set(mortonCode, newTileLoader);\n            }\n        }\n        if (tile.tileLoader.decodedTile !== undefined) {\n            tile.decodedTile = tile.tileLoader.decodedTile;\n        }\n        else {\n            tile.load();\n        }\n        return tile;\n    }\n    /**\n     * Get [[TileInfo]] of a tile.\n     *\n     * @param tileKey Quadtree address of the requested tile.\n     * @returns A promise which will contain the [[TileInfo]] when resolved.\n     */\n    getTileInfo(tileKey) {\n        const promise = new Promise((resolve, reject) => {\n            const tileLoader = new TileLoader_1.TileInfoLoader(this, tileKey, this.m_options.dataProvider, this.decoder, 0);\n            tileLoader.loadAndDecode().then(loaderState => {\n                if (loaderState === harp_mapview_1.TileLoaderState.Ready) {\n                    resolve(tileLoader.tileInfo);\n                }\n                else {\n                    reject(new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`));\n                }\n            });\n        });\n        return promise;\n    }\n    getCacheCount() {\n        // We support up to [[maxLevelTileLoaderCache]] levels, this equates to roughly\n        // 2^maxLevelTileLoaderCache^2 tiles in total (at level maxLevelTileLoaderCache), we don't\n        // generally see that many, so we add a factor of 2 to try to get the worst case.\n        return Math.pow(2, maxLevelTileLoaderCache) * 2;\n    }\n}\nexports.TileDataSource = TileDataSource;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/TileDataSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TileLoader\");\n/**\n * The [[TileLoader]] manages the different states of loading and decoding for a [[Tile]]. Used by\n * the [[TileDataSource]].\n *\n * A TileLoader supports loading for multiple tiles, this is required for the wrap around, where\n * it is possible to see the same tile multiple times.\n */\nclass TileLoader {\n    /**\n     * Set up loading of a single [[Tile]].\n     *\n     * @param dataSource The [[DataSource]] the tile belongs to.\n     * @param tileKey The quadtree address of a [[Tile]].\n     * @param dataProvider The [[DataProvider]] that retrieves the binary tile data.\n     * @param tileDecoder The [[ITileDecoder]] that decodes the binary tile to a [[DecodeTile]].\n     * @param priority The priority given to the loading job. Highest number will be served first.\n     */\n    constructor(dataSource, tileKey, dataProvider, tileDecoder, priority) {\n        this.dataSource = dataSource;\n        this.tileKey = tileKey;\n        this.dataProvider = dataProvider;\n        this.tileDecoder = tileDecoder;\n        this.priority = priority;\n        /**\n         * Current state of `TileLoader`.\n         */\n        this.state = harp_mapview_1.TileLoaderState.Initialized;\n        /**\n         * The abort controller notifying the [[DataProvider]] to cancel loading.\n         */\n        this.loadAbortController = new AbortController();\n        /**\n         * This is a form of reference counting for the result. We keep a track of this because when\n         * cancelling, it is important to know if we can actually cancel, or if there is another Tile\n         * that needs the result.\n         */\n        this.countRequests = 0;\n    }\n    /**\n     * Start loading and/or proceed through the various states of loading of this tile.\n     *\n     * @returns A promise which resolves the [[TileLoaderState]].\n     */\n    loadAndDecode() {\n        switch (this.state) {\n            case harp_mapview_1.TileLoaderState.Loading:\n            case harp_mapview_1.TileLoaderState.Loaded:\n            case harp_mapview_1.TileLoaderState.Decoding:\n                // tile is already loading\n                this.countRequests++;\n                return this.donePromise;\n            case harp_mapview_1.TileLoaderState.Ready:\n            case harp_mapview_1.TileLoaderState.Failed:\n            case harp_mapview_1.TileLoaderState.Initialized:\n            case harp_mapview_1.TileLoaderState.Canceled:\n                // restart loading\n                this.countRequests++;\n                this.startLoading();\n                return this.donePromise;\n        }\n    }\n    /**\n     * Return the current state in form of a promise. Caller can then wait for the promise to be\n     * resolved.\n     *\n     * @returns A promise which resolves the current [[TileLoaderState]].\n     */\n    waitSettled() {\n        if (!this.donePromise) {\n            return Promise.resolve(this.state);\n        }\n        return this.donePromise;\n    }\n    /**\n     * Cancel loading of the [[Tile]] if there is only a single request remaining. Cancellation\n     * token is notified, an internal state is cleaned up.\n     *\n     * Otherwise this just reduces the count of requests by one.\n     */\n    cancel() {\n        if (--this.countRequests !== 0) {\n            return;\n        }\n        switch (this.state) {\n            case harp_mapview_1.TileLoaderState.Loading:\n                this.loadAbortController.abort();\n                this.loadAbortController = new AbortController();\n                break;\n            case harp_mapview_1.TileLoaderState.Decoding:\n                if (this.requestController) {\n                    this.requestController.abort();\n                    this.requestController = undefined;\n                }\n                break;\n        }\n        this.onDone(harp_mapview_1.TileLoaderState.Canceled);\n    }\n    /**\n     * Return `true` if [[Tile]] is still loading, `false` otherwise.\n     */\n    get isFinished() {\n        return (this.state === harp_mapview_1.TileLoaderState.Ready ||\n            this.state === harp_mapview_1.TileLoaderState.Canceled ||\n            this.state === harp_mapview_1.TileLoaderState.Failed);\n    }\n    /**\n     * Update the priority of this [[Tile]]'s priority. Is effective to sort the decoding requests\n     * in the request queue (used during heavy load).\n     */\n    updatePriority(priority) {\n        this.priority = priority;\n        if (this.requestController !== undefined) {\n            this.requestController.priority = priority;\n        }\n    }\n    /**\n     * Start loading. Only call if loading did not start yet.\n     */\n    startLoading() {\n        const myLoadCancellationToken = this.loadAbortController.signal;\n        this.dataProvider\n            .getTile(this.tileKey, myLoadCancellationToken)\n            .then(payload => {\n            if (myLoadCancellationToken.aborted) {\n                // safety belt if getTile doesn't really support cancellation tokens\n                const err = new Error(\"Aborted\");\n                err.name = \"AbortError\";\n                throw err;\n            }\n            this.onLoaded(payload);\n        })\n            .catch(error => {\n            // Handle abort messages from fetch and also our own.\n            if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                return;\n            }\n            this.onError(error);\n        });\n        if (this.donePromise === undefined) {\n            this.donePromise = new Promise((resolve, reject) => {\n                this.resolveDonePromise = resolve;\n                this.rejectedDonePromise = reject;\n            });\n        }\n        this.state = harp_mapview_1.TileLoaderState.Loading;\n    }\n    /**\n     * Called when binary data has been loaded. The loading state is now progressing to decoding.\n     *\n     * @param payload Binary data in form of [[ArrayBufferLike]], or any object.\n     */\n    onLoaded(payload) {\n        this.state = harp_mapview_1.TileLoaderState.Loaded;\n        this.payload = payload;\n        if (payload.byteLength !== undefined) {\n            if (payload.byteLength === 0) {\n                this.onDone(harp_mapview_1.TileLoaderState.Ready);\n                return;\n            }\n        }\n        // Object is empty\n        if (payload === {}) {\n            this.onDone(harp_mapview_1.TileLoaderState.Ready);\n            return;\n        }\n        // TBD: we might suspend decode if tile is not visible ... ?\n        this.startDecodeTile();\n    }\n    /**\n     * Start decoding the payload.\n     */\n    startDecodeTile() {\n        const payload = this.payload;\n        if (payload === undefined) {\n            logger.error(\"TileLoader#startDecodeTile: Cannot decode without payload\");\n            return;\n        }\n        this.state = harp_mapview_1.TileLoaderState.Decoding;\n        this.payload = undefined;\n        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode\n        // attempts\n        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);\n        this.requestController = requestController;\n        const dataSource = this.dataSource;\n        this.tileDecoder\n            .decodeTile(payload, this.tileKey, dataSource.projection, requestController)\n            .then(decodedTile => {\n            if (requestController.signal.aborted) {\n                // our flow is cancelled, silently return\n                return;\n            }\n            this.onDecoded(decodedTile);\n        })\n            .catch(error => {\n            // Handle abort messages from fetch and also our own.\n            if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                // our flow is cancelled, silently return\n                return;\n            }\n            this.onError(error);\n        });\n    }\n    /**\n     * Called when the decoding is finished, and the [[DecodedTile]] has been created.\n     *\n     * @param decodedTile The [[DecodedTile]].\n     */\n    onDecoded(decodedTile) {\n        this.decodedTile = decodedTile;\n        this.onDone(harp_mapview_1.TileLoaderState.Ready);\n    }\n    /**\n     * Cancel the decoding process.\n     */\n    cancelDecoding() {\n        if (this.requestController !== undefined) {\n            // we should cancel any decodes already in progress!\n            this.requestController.abort();\n            this.requestController = undefined;\n        }\n    }\n    /**\n     * Called when loading and decoding has finished successfully. Resolves loading promise if the\n     * state is Ready, otherwise it rejects the promise with the supplied state.\n     *\n     * @param doneState The latest state of loading.\n     */\n    onDone(doneState) {\n        if (this.resolveDonePromise && doneState === harp_mapview_1.TileLoaderState.Ready) {\n            this.resolveDonePromise(doneState);\n        }\n        else if (this.rejectedDonePromise) {\n            this.rejectedDonePromise(doneState);\n        }\n        this.resolveDonePromise = undefined;\n        this.rejectedDonePromise = undefined;\n        this.donePromise = undefined;\n        this.state = doneState;\n    }\n    /**\n     * Called when loading or decoding has finished with an error.\n     *\n     * @param error Error object describing the failing.\n     */\n    onError(error) {\n        if (this.state === harp_mapview_1.TileLoaderState.Canceled) {\n            // If we're canceled, we should simply ignore any state transitions and errors from\n            // underlying load/decode ops.\n            return;\n        }\n        const dataSource = this.dataSource;\n        logger.error(`[${dataSource.name}]: failed to load tile ${this.tileKey.mortonCode()}`, error);\n        this.error = error;\n        this.onDone(harp_mapview_1.TileLoaderState.Failed);\n    }\n}\nexports.TileLoader = TileLoader;\n/**\n * Subclass of [[TileLoader]] which is used by [[TileDataSource]] to load the [[TileInfo]] meta\n * data, not the tile data itself.\n */\nclass TileInfoLoader extends TileLoader {\n    /** @override */\n    startDecodeTile() {\n        const payload = this.payload;\n        if (payload === undefined) {\n            logger.error(\"TileInfoLoader#startDecodeTile: Cannot decode without payload\");\n            return;\n        }\n        this.state = harp_mapview_1.TileLoaderState.Decoding;\n        this.payload = undefined;\n        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode\n        // attempts\n        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);\n        this.requestController = requestController;\n        const dataSource = this.dataSource;\n        this.tileDecoder\n            .getTileInfo(payload, this.tileKey, dataSource.projection, requestController)\n            .then(tileInfo => {\n            if (requestController.signal.aborted) {\n                // our flow is cancelled, silently return\n                return;\n            }\n            this.tileInfo = tileInfo;\n            this.onDone(harp_mapview_1.TileLoaderState.Ready);\n        })\n            .catch(error => {\n            // Handle abort messages from fetch and also our own.\n            if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                // our flow is cancelled, silently return\n                return;\n            }\n            this.onError(error);\n        });\n    }\n}\nexports.TileInfoLoader = TileInfoLoader;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview-decoder/lib/TileLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@here/harp-mapview/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/AnimatedExtrusionHandler */ \"./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js\"));\n__export(__webpack_require__(/*! ./lib/CameraMovementDetector */ \"./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js\"));\n__export(__webpack_require__(/*! ./lib/ClipPlanesEvaluator */ \"./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js\"));\n__export(__webpack_require__(/*! ./lib/ColorCache */ \"./node_modules/@here/harp-mapview/lib/ColorCache.js\"));\n__export(__webpack_require__(/*! ./lib/composing */ \"./node_modules/@here/harp-mapview/lib/composing/index.js\"));\n__export(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ \"./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js\"));\n__export(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ \"./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js\"));\n__export(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ \"./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js\"));\n__export(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ \"./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js\"));\n__export(__webpack_require__(/*! ./lib/copyrights/CopyrightElementHandler */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js\"));\n__export(__webpack_require__(/*! ./lib/copyrights/CopyrightInfo */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js\"));\n__export(__webpack_require__(/*! ./lib/copyrights/CopyrightCoverageProvider */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js\"));\n__export(__webpack_require__(/*! ./lib/copyrights/UrlCopyrightProvider */ \"./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js\"));\n__export(__webpack_require__(/*! ./lib/DataSource */ \"./node_modules/@here/harp-mapview/lib/DataSource.js\"));\n__export(__webpack_require__(/*! ./lib/PolarTileDataSource */ \"./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js\"));\n__export(__webpack_require__(/*! ./lib/DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\"));\n__export(__webpack_require__(/*! ./lib/DepthPrePass */ \"./node_modules/@here/harp-mapview/lib/DepthPrePass.js\"));\n__export(__webpack_require__(/*! ./lib/ElevationRangeSource */ \"./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js\"));\n__export(__webpack_require__(/*! ./lib/image/Image */ \"./node_modules/@here/harp-mapview/lib/image/Image.js\"));\n__export(__webpack_require__(/*! ./lib/image/ImageCache */ \"./node_modules/@here/harp-mapview/lib/image/ImageCache.js\"));\n__export(__webpack_require__(/*! ./lib/image/MapViewImageCache */ \"./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js\"));\n__export(__webpack_require__(/*! ./lib/MapView */ \"./node_modules/@here/harp-mapview/lib/MapView.js\"));\n__export(__webpack_require__(/*! ./lib/MapViewFog */ \"./node_modules/@here/harp-mapview/lib/MapViewFog.js\"));\n__export(__webpack_require__(/*! ./lib/MapViewPoints */ \"./node_modules/@here/harp-mapview/lib/MapViewPoints.js\"));\n__export(__webpack_require__(/*! ./lib/PickHandler */ \"./node_modules/@here/harp-mapview/lib/PickHandler.js\"));\n__export(__webpack_require__(/*! ./lib/poi/Poi */ \"./node_modules/@here/harp-mapview/lib/poi/Poi.js\"));\n__export(__webpack_require__(/*! ./lib/poi/PoiManager */ \"./node_modules/@here/harp-mapview/lib/poi/PoiManager.js\"));\n__export(__webpack_require__(/*! ./lib/poi/PoiTableManager */ \"./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js\"));\n__export(__webpack_require__(/*! ./lib/RoadPicker */ \"./node_modules/@here/harp-mapview/lib/RoadPicker.js\"));\n__export(__webpack_require__(/*! ./lib/Statistics */ \"./node_modules/@here/harp-mapview/lib/Statistics.js\"));\n__export(__webpack_require__(/*! ./lib/text/TextElement */ \"./node_modules/@here/harp-mapview/lib/text/TextElement.js\"));\n__export(__webpack_require__(/*! ./lib/text/TextElementsRenderer */ \"./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js\"));\n__export(__webpack_require__(/*! ./lib/text/TextStyleCache */ \"./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js\"));\n__export(__webpack_require__(/*! ./lib/ThemeLoader */ \"./node_modules/@here/harp-mapview/lib/ThemeLoader.js\"));\n__export(__webpack_require__(/*! ./lib/Tile */ \"./node_modules/@here/harp-mapview/lib/Tile.js\"));\n__export(__webpack_require__(/*! ./lib/geometry/TileDataAccessor */ \"./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js\"));\n__export(__webpack_require__(/*! ./lib/geometry/TileGeometry */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js\"));\n__export(__webpack_require__(/*! ./lib/Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\"));\n__export(__webpack_require__(/*! ./lib/VisibleTileSet */ \"./node_modules/@here/harp-mapview/lib/VisibleTileSet.js\"));\n__export(__webpack_require__(/*! ./lib/WorkerBasedDecoder */ \"./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js\"));\n__export(__webpack_require__(/*! ./lib/WorkerBasedTiler */ \"./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js\"));\n__export(__webpack_require__(/*! ./lib/workers/WorkerLoader */ \"./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst MapView_1 = __webpack_require__(/*! ./MapView */ \"./node_modules/@here/harp-mapview/lib/MapView.js\");\n/**\n * Animation states for extrusion effect\n */\nvar AnimatedExtrusionState;\n(function (AnimatedExtrusionState) {\n    AnimatedExtrusionState[AnimatedExtrusionState[\"None\"] = 0] = \"None\";\n    AnimatedExtrusionState[AnimatedExtrusionState[\"Started\"] = 1] = \"Started\";\n    AnimatedExtrusionState[AnimatedExtrusionState[\"Playing\"] = 2] = \"Playing\";\n    AnimatedExtrusionState[AnimatedExtrusionState[\"Finished\"] = 3] = \"Finished\";\n})(AnimatedExtrusionState = exports.AnimatedExtrusionState || (exports.AnimatedExtrusionState = {}));\n/**\n * Handles animated extrusion effect of the buildings in [[MapView]].\n */\nclass AnimatedExtrusionHandler {\n    /**\n     * Creates an [[AnimatedExtrusionHandler]] in [[MapView]].\n     *\n     * @param m_mapView Instance of [[MapView]] that passes `zoomLevel`\n     * through the `zoom` property update\n     */\n    constructor(m_mapView) {\n        this.m_mapView = m_mapView;\n        /**\n         * Animate the extrusion of the buildings if set to `true`.\n         */\n        this.enabled = true;\n        /**\n         * Duration of the building's extrusion in milliseconds\n         */\n        this.duration = 750;\n        /**\n         * If `forceEnabled` is set to `true` then `animateExtrusion` and `animateExtrusionDuration`\n         * values from [[extrudedPolygonTechnique]] will be ignored in [[Tile]] and\n         * `AnimatedExtrusionHandler.enabled` with `AnimatedExtrusionHandler.duration` will be used\n         */\n        this.forceEnabled = false;\n        this.m_tileHandlerMap = new Map();\n        this.m_zoomDirection = 0;\n        this.m_zoomLevelPrevious = this.m_mapView.zoomLevel;\n    }\n    /**\n     * Returns direction of the last zoom event.\n     * Zoom in - positive value, zoom out - negative value\n     */\n    get zoomDirection() {\n        return this.m_zoomDirection;\n    }\n    /**\n     * [[MapView]] updates zoom level. Then [[AnimatedExtrusionTileHandler]] calculates actual\n     * extrusion ratio and trigger animation\n     */\n    set zoom(zoomLevel) {\n        // if zoomLevel has been changed since last render\n        if (this.m_zoomLevelPrevious !== zoomLevel) {\n            this.m_tileHandlerMap.forEach(tileHandler => {\n                if (this.m_mapView.getDataSourceByName(tileHandler.tile.dataSource.name) !==\n                    undefined) {\n                    this.m_zoomDirection = zoomLevel > this.m_zoomLevelPrevious ? 1 : -1;\n                    tileHandler.zoomLevelChanged(this.m_zoomDirection);\n                }\n            });\n            this.m_zoomLevelPrevious = zoomLevel;\n        }\n    }\n    /**\n     * Checks whether animated extrusion effect was forcibly turned off/on in [[MapView]]\n     */\n    get forceAnimatedExtrusion() {\n        return this.m_forceAnimatedExtrusion;\n    }\n    /**\n     * If set to `true` it will force the animation extrusion effect to run.\n     * In case it was set to `false` animation extrusion effect will be switched off.\n     */\n    set forceAnimatedExtrusion(animatedExtrusion) {\n        this.m_forceAnimatedExtrusion = animatedExtrusion;\n    }\n    /**\n     * Returns `animatedExtrusionDuration` value that was set in [[MapView]].\n     */\n    get forceAnimatedExtrusionDuration() {\n        return this.m_forceAnimatedExtrusionDuration;\n    }\n    /**\n     * If value is set, it will overlap in [[Tile]] with\n     * `animatedExtrusionDuration` property from [[ExtrudedPolygonTechnique]]\n     * and `DEFAULT_DURATION` from [[AnimatedExtrusionTileHandler]].\n     */\n    set forceAnimatedExtrusionDuration(extrusionDuration) {\n        this.m_forceAnimatedExtrusionDuration = extrusionDuration;\n    }\n    /**\n     * Adds an [[AnimatedExtrusionTileHandler]] to [[AnimatedExtrusionHandler]]\n     */\n    add(tileHandler) {\n        this.m_tileHandlerMap.set(tileHandler.tile, tileHandler);\n    }\n    /**\n     * Removes tile from the list subscribed for extrusion ratio updates\n     */\n    removeTile(tile) {\n        this.m_tileHandlerMap.delete(tile);\n    }\n    /**\n     * Returns first [[AnimatedExtrusionTileHandler]] existed from the list of [[Tile]]s\n     */\n    find(tileKeys) {\n        for (const tileHandler of this.m_tileHandlerMap) {\n            for (const tileKey of tileKeys) {\n                if (tileKey !== undefined &&\n                    tileHandler[0].tileKey.mortonCode() === tileKey.mortonCode()) {\n                    return tileHandler[1];\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Is `true` if any extrusion handlers are currently animating.\n     */\n    get isAnimating() {\n        for (const tileHandler of this.m_tileHandlerMap) {\n            if (tileHandler[1].isAnimating) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.AnimatedExtrusionHandler = AnimatedExtrusionHandler;\n/**\n * Implements animated extrusion effect for the extruded objects in the [[Tile]]\n */\nclass AnimatedExtrusionTileHandler {\n    constructor(m_tile, extrudedObjects, m_animatedExtrusionDuration) {\n        this.m_tile = m_tile;\n        this.m_animatedExtrusionDuration = m_animatedExtrusionDuration;\n        this.m_extrudedObjects = [];\n        this.m_animatedExtrusionRatio = harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n        this.m_animatedExtrusionState = AnimatedExtrusionState.None;\n        this.m_animatedExtrusionStartTime = undefined;\n        this.animateExtrusion = (event) => {\n            if (this.m_animatedExtrusionState !== AnimatedExtrusionState.Playing) {\n                if (this.m_animatedExtrusionState === AnimatedExtrusionState.Started) {\n                    this.m_animatedExtrusionState = AnimatedExtrusionState.Playing;\n                }\n                else {\n                    return;\n                }\n            }\n            const currentTime = Date.now();\n            if (this.m_animatedExtrusionStartTime === undefined ||\n                this.m_animatedExtrusionStartTime <= 0) {\n                this.m_animatedExtrusionStartTime = currentTime;\n            }\n            const timeProgress = Math.min(currentTime - this.m_animatedExtrusionStartTime, this.m_animatedExtrusionDuration);\n            this.extrusionRatio = harp_utils_1.MathUtils.easeInOutCubic(harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN, harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX, timeProgress / this.m_animatedExtrusionDuration);\n            if (timeProgress >= this.m_animatedExtrusionDuration) {\n                this.m_animatedExtrusionState = AnimatedExtrusionState.Finished;\n                this.stopExtrusionAnimation();\n            }\n            this.m_tile.dataSource.requestUpdate();\n        };\n        this.m_mapView = m_tile.mapView;\n        this.m_animatedExtrusionHandler = this.m_mapView.animatedExtrusionHandler;\n        extrudedObjects.forEach(extrudedObject => {\n            if (extrudedObject.materialFeature) {\n                harp_materials_1.ExtrusionFeature.addRenderHelper(extrudedObject.object);\n            }\n            this.m_extrudedObjects.push(extrudedObject.object);\n        });\n        this.startExtrusionAnimationIfNeeded(this.m_animatedExtrusionHandler.zoomDirection);\n    }\n    /**\n     * Set an extrusion ratio value for the materials [[MapMeshBasicMaterial]]\n     * and [[EdgeMaterial]]. Controlled by [[AnimatedExtrusionHandler]]\n     * for extrusion animation effect.\n     */\n    set extrusionRatio(value) {\n        this.m_animatedExtrusionRatio = value;\n        this.m_extrudedObjects.forEach(object => {\n            const material = object\n                .material;\n            material.extrusionRatio = this.m_animatedExtrusionRatio;\n        });\n    }\n    /**\n     * Returns the [[Tile]] related to [[AnimatedExtrusionTileHandler]]\n     */\n    get tile() {\n        return this.m_tile;\n    }\n    /**\n     * Return the current state of animated extrusion effect\n     */\n    get animationState() {\n        return this.m_animatedExtrusionState;\n    }\n    /**\n     * Is `true` if this handler is currently animating.\n     */\n    get isAnimating() {\n        return this.m_animatedExtrusionState !== AnimatedExtrusionState.Finished;\n    }\n    /**\n     * Cancel animation and remove from [[AnimatedExtrusionHandler]]\n     */\n    dispose() {\n        this.stopExtrusionAnimation();\n        this.m_animatedExtrusionHandler.removeTile(this.m_tile);\n    }\n    /**\n     * Start / Stop extrusion animation if zoom level was changed\n     */\n    zoomLevelChanged(zoomDirection) {\n        if (this.m_tile.isVisible === false &&\n            this.m_animatedExtrusionState !== AnimatedExtrusionState.None) {\n            this.m_animatedExtrusionState = AnimatedExtrusionState.None;\n            this.stopExtrusionAnimation();\n        }\n        if (this.m_tile.isVisible === true &&\n            this.m_animatedExtrusionState === AnimatedExtrusionState.None) {\n            this.startExtrusionAnimationIfNeeded(zoomDirection);\n        }\n    }\n    getChildTiles(tileKeys) {\n        const result = [];\n        tileKeys.forEach(tileKey => {\n            const childTileKeys = this.tile.dataSource.getTilingScheme().getSubTileKeys(tileKey);\n            for (const childTileKey of childTileKeys) {\n                result.push(childTileKey);\n            }\n        });\n        return result;\n    }\n    // search for the [[Tile]] with extrusion animation started\n    startExtrusionAnimationIfNeeded(zoomDirection) {\n        const { quadTreeSearchDistanceUp, quadTreeSearchDistanceDown } = this.tile.mapView.visibleTileSet.options;\n        const tile = this.m_tile;\n        let extrusionStartTime;\n        if (zoomDirection !== undefined) {\n            let tileHandler;\n            // if zoom out, go down and look for a child tile\n            if (zoomDirection < 0) {\n                let nextLevelDiff = 0;\n                let tileKeys = [tile.tileKey];\n                while (quadTreeSearchDistanceDown > nextLevelDiff &&\n                    extrusionStartTime === undefined) {\n                    const childTileKeys = this.getChildTiles(tileKeys);\n                    if (childTileKeys !== undefined) {\n                        tileHandler = this.m_animatedExtrusionHandler.find(childTileKeys);\n                        if (tileHandler !== undefined) {\n                            extrusionStartTime = tileHandler.m_animatedExtrusionStartTime;\n                            break;\n                        }\n                        tileKeys = childTileKeys;\n                    }\n                    nextLevelDiff++;\n                }\n            }\n            // if zoom in, go up and get the parent tile\n            if (zoomDirection > 0) {\n                let nextLevelDiff = 0;\n                let tileKey = tile.tileKey;\n                while (quadTreeSearchDistanceUp > nextLevelDiff &&\n                    extrusionStartTime === undefined &&\n                    tileKey.level !== 0) {\n                    const parentTileKey = tileKey.parent();\n                    tileHandler = this.m_animatedExtrusionHandler.find([parentTileKey]);\n                    if (tileHandler !== undefined) {\n                        extrusionStartTime = tileHandler.m_animatedExtrusionStartTime;\n                        break;\n                    }\n                    tileKey = parentTileKey;\n                    nextLevelDiff++;\n                }\n            }\n        }\n        this.startExtrusionAnimation(extrusionStartTime);\n    }\n    startExtrusionAnimation(startTime) {\n        this.m_animatedExtrusionState = AnimatedExtrusionState.Started;\n        this.m_animatedExtrusionStartTime = startTime;\n        this.animateExtrusion();\n        this.m_mapView.addEventListener(MapView_1.MapViewEventNames.AfterRender, this.animateExtrusion);\n    }\n    stopExtrusionAnimation() {\n        this.m_mapView.removeEventListener(MapView_1.MapViewEventNames.AfterRender, this.animateExtrusion);\n    }\n}\nexports.AnimatedExtrusionTileHandler = AnimatedExtrusionTileHandler;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst DataSource_1 = __webpack_require__(/*! ./DataSource */ \"./node_modules/@here/harp-mapview/lib/DataSource.js\");\nconst TileGeometryCreator_1 = __webpack_require__(/*! ./geometry/TileGeometryCreator */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js\");\nconst Tile_1 = __webpack_require__(/*! ./Tile */ \"./node_modules/@here/harp-mapview/lib/Tile.js\");\n/**\n * Provides background geometry for all tiles.\n */\nclass BackgroundDataSource extends DataSource_1.DataSource {\n    constructor() {\n        super(\"background\");\n        this.m_tilingScheme = BackgroundDataSource.DEFAULT_TILING_SCHEME;\n        this.cacheable = true;\n    }\n    updateStorageLevelOffset() {\n        let storageLevelOffset;\n        this.mapView.dataSources.forEach(ds => {\n            if (ds === this) {\n                return;\n            }\n            const tilingScheme = ds.getTilingScheme();\n            if (tilingScheme === this.m_tilingScheme) {\n                storageLevelOffset =\n                    storageLevelOffset === undefined\n                        ? ds.storageLevelOffset\n                        : Math.max(storageLevelOffset, ds.storageLevelOffset);\n            }\n        });\n        if (storageLevelOffset === undefined) {\n            storageLevelOffset = 0;\n        }\n        if (storageLevelOffset !== this.storageLevelOffset) {\n            this.storageLevelOffset = storageLevelOffset;\n            this.mapView.clearTileCache(this.name);\n        }\n    }\n    /** @override */\n    setTheme(theme, languages) {\n        this.mapView.clearTileCache(this.name);\n    }\n    setTilingScheme(tilingScheme) {\n        const newScheme = tilingScheme || BackgroundDataSource.DEFAULT_TILING_SCHEME;\n        if (newScheme === this.m_tilingScheme) {\n            return;\n        }\n        this.m_tilingScheme = newScheme;\n        this.updateStorageLevelOffset();\n        this.mapView.clearTileCache(this.name);\n    }\n    /** @override */\n    getTilingScheme() {\n        return this.m_tilingScheme;\n    }\n    /** @override */\n    getTile(tileKey) {\n        const tile = new Tile_1.Tile(this, tileKey);\n        tile.forceHasGeometry(true);\n        tile.removeDecodedTile(); // Skip geometry loading.\n        TileGeometryCreator_1.TileGeometryCreator.instance.addGroundPlane(tile, Number.MIN_SAFE_INTEGER);\n        return tile;\n    }\n}\nexports.BackgroundDataSource = BackgroundDataSource;\nBackgroundDataSource.DEFAULT_TILING_SCHEME = harp_geoutils_1.webMercatorTilingScheme;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\n/**\n * The default value for camera movement throttling, in milliseconds.\n */\nconst DEFAULT_THROTTLING_TIMEOUT = 300;\n/**\n * The `CameraMovementDetector` class checks for changes in camera position and orientation, to\n * detect continuous movements without the animation mode activated in [[MapView]]. If the\n * interaction is not continuous enough, you can use a throttling timer to reduce the number of\n * callbacks.\n */\nclass CameraMovementDetector {\n    /**\n     * Initializes the detector with timeout value and callbacks. [[MapView]] also provides\n     * events for client code to be notified when these cues occur.\n     *\n     * @param m_throttlingTimeout The delay, in milliseconds, between the last user interaction\n     * detected and the call to `m_movementFinishedFunc`; the default is `300`.\n     * @param m_movementStartedFunc Callback function, called when the user starts interacting.\n     * @param m_movementFinishedFunc Callback function, called when the user stops interacting.\n     */\n    constructor(m_throttlingTimeout, m_movementStartedFunc, m_movementFinishedFunc) {\n        this.m_throttlingTimeout = m_throttlingTimeout;\n        this.m_movementStartedFunc = m_movementStartedFunc;\n        this.m_movementFinishedFunc = m_movementFinishedFunc;\n        this.m_lastCameraPos = new three_1.Vector3();\n        this.m_newCameraPos = new three_1.Vector3();\n        this.m_throttlingTimerId = undefined;\n        this.m_movementDetectorDeadline = 0;\n        this.onDeadlineTimer = () => {\n            this.m_throttlingTimerId = undefined;\n            const now = performance.now();\n            if (now >= this.m_movementDetectorDeadline) {\n                this.movementFinished();\n            }\n            else {\n                this.startMovementFinishedTimer(now);\n            }\n        };\n        if (this.m_throttlingTimeout === undefined) {\n            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;\n        }\n    }\n    /**\n     * Checks if the camera has moved since the last time it was checked. The\n     * `m_movementStartedFunc` is called when a movement starts. If no movement\n     * is detected, a timer for `m_movementFinishedFunc` starts.\n     *\n     * @param mapView [[Mapview]]'s position and camera are checked for modifications.\n     */\n    checkCameraMoved(mapView, now) {\n        const newAttitude = Utils_1.MapViewUtils.extractAttitude(mapView, mapView.camera);\n        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);\n        if (this.m_lastAttitude === undefined) {\n            this.m_lastCameraPos.copy(newCameraPos);\n            this.m_lastAttitude = newAttitude;\n            return false;\n        }\n        const cameraMoved = !this.m_lastCameraPos.equals(newCameraPos) ||\n            newAttitude.yaw !== this.m_lastAttitude.yaw ||\n            newAttitude.pitch !== this.m_lastAttitude.pitch ||\n            newAttitude.roll !== this.m_lastAttitude.roll;\n        if (cameraMoved) {\n            this.m_lastCameraPos.copy(newCameraPos);\n            this.m_lastAttitude = newAttitude;\n        }\n        if (cameraMoved !== this.m_cameraMovedLastFrame) {\n            if (cameraMoved) {\n                this.movementStarted();\n            }\n            this.m_cameraMovedLastFrame = cameraMoved;\n        }\n        if (cameraMoved) {\n            // Start timer\n            this.m_movementDetectorDeadline = now + this.m_throttlingTimeout;\n            this.startMovementFinishedTimer(now);\n        }\n        return this.m_cameraMovedLastFrame;\n    }\n    /**\n     * Reset the saved camera position. Next time checkCameraMoved is called, it will return\n     * `false`.\n     */\n    clear(mapView) {\n        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);\n        this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);\n        const newAttitude = Utils_1.MapViewUtils.extractAttitude(mapView, mapView.camera);\n        this.m_lastAttitude = newAttitude;\n    }\n    /**\n     * Force change of camera position. Next time checkCameraMoved is called, it will return `true`.\n     */\n    forceMoved() {\n        this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);\n    }\n    /**\n     * Returns `true` if the camera of this [[MapView]] is currently moving. In this case the\n     * `m_movementFinishedFunc` is waiting to be called after the throttling timer runs out.\n     */\n    get cameraIsMoving() {\n        return this.m_throttlingTimerId !== undefined;\n    }\n    /**\n     * Disposes resources and kills the throttling timer.\n     */\n    dispose() {\n        this.removeMovementFinishedTimer();\n        this.m_movementStartedFunc = undefined;\n        this.m_movementFinishedFunc = undefined;\n    }\n    /**\n     * Returns `true` if the camera has moved in the last frame.\n     */\n    get cameraMovedLastFrame() {\n        return this.m_cameraMovedLastFrame === true;\n    }\n    movementStarted() {\n        if (this.m_movementStartedFunc !== undefined) {\n            this.m_movementStartedFunc();\n        }\n    }\n    movementFinished() {\n        this.removeMovementFinishedTimer();\n        if (this.m_movementFinishedFunc !== undefined) {\n            this.m_movementFinishedFunc();\n        }\n    }\n    startMovementFinishedTimer(now) {\n        if (this.m_throttlingTimerId === undefined) {\n            const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now);\n            this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime);\n        }\n    }\n    removeMovementFinishedTimer() {\n        if (this.m_throttlingTimerId !== undefined) {\n            clearTimeout(this.m_throttlingTimerId);\n            this.m_throttlingTimerId = undefined;\n        }\n    }\n}\nexports.CameraMovementDetector = CameraMovementDetector;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\nconst epsilon = 0.000001;\n/**\n * Simplest camera clip planes evaluator, interpolates near/far planes based on ground distance.\n *\n * At general ground distance to camera along the surface normal is used as reference point for\n * planes evaluation, where near plane distance is set as fraction of this distance refereed as\n * [[nearMultiplier]]. Far plane equation has its own multiplier - [[nearFarMultiplier]],\n * which is applied to near plane and offset giving finally far plane distance.\n * This evaluator supports both planar and spherical projections, although it's behavior is\n * slightly different in each case. General algorithm sets near plane between camera and\n * ground level, while far plane is just calculated using scale and bias approach with far offset\n * and multiplier.\n * @deprecated Class contains the legacy (first and original) clip planes evaluation method, which\n * is widelly used in examples thus is still kept for backward compatibility and comparisons.\n */\nclass InterpolatedClipPlanesEvaluator {\n    constructor(nearMin = 0.1, nearMultiplier = 0.1, nearFarMultiplier = 50.0, farOffset = 200.0) {\n        this.nearMin = nearMin;\n        this.nearMultiplier = nearMultiplier;\n        this.nearFarMultiplier = nearFarMultiplier;\n        this.farOffset = farOffset;\n        this.m_tmpVectors = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tmpQuaternion = new THREE.Quaternion();\n        harp_utils_1.assert(nearMin > 0);\n        harp_utils_1.assert(nearFarMultiplier >= 0);\n        harp_utils_1.assert(farOffset >= 0);\n        this.farMin = nearMin * nearFarMultiplier + farOffset;\n    }\n    // tslint:disable-next-line: no-empty\n    set minElevation(elevation) { }\n    get minElevation() {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n    // tslint:disable-next-line: no-empty\n    set maxElevation(elevation) { }\n    get maxElevation() {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n    evaluateClipPlanes(mapView) {\n        const camera = mapView.camera;\n        const projection = mapView.projection;\n        let nearPlane = this.nearMin;\n        let farPlane = this.farMin;\n        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            // near and far plane for a set up where\n            // the camera is looking at the center of the scene.\n            const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;\n            const d = camera.position.length();\n            const alpha = Math.asin(r / d);\n            // Extract X, Y, Z axes into tmp vectors array.\n            camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);\n            // Setup quaternion based on X axis.\n            this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], alpha);\n            // Acquire forward vector based on Z axis reversed (keep it in tmpVectors[2]).\n            const fwd = this.m_tmpVectors[2].negate();\n            // Apply quaternion rotation to forward vector, store it in tmpVectors[1].\n            const fwdRot = this.m_tmpVectors[1].copy(fwd).applyQuaternion(this.m_tmpQuaternion);\n            // Store camera position tmpVectors[0] and reference it with p.\n            const p = this.m_tmpVectors[0].copy(camera.position);\n            p.addScaledVector(fwdRot, Math.sqrt(d * d - r * r));\n            farPlane = p.sub(camera.position).dot(fwd);\n            nearPlane = Math.max(this.nearMin, projection.groundDistance(camera.position) * this.nearMultiplier);\n        }\n        else if (projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            const groundDistance = projection.groundDistance(camera.position);\n            nearPlane = Math.max(this.nearMin, groundDistance * this.nearMultiplier);\n            // Will be already clamped to minFar due to clamping above.\n            farPlane = nearPlane * this.nearFarMultiplier + this.farOffset;\n        }\n        else {\n            harp_utils_1.assert(false, \"Unsupported projection type\");\n        }\n        const viewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: farPlane\n        };\n        return viewRanges;\n    }\n}\nexports.InterpolatedClipPlanesEvaluator = InterpolatedClipPlanesEvaluator;\n/**\n * Abstract evaluator class that adds support for elevation constraints.\n *\n * Classes derived from this should implement algorithms that takes into account rendered\n * features height (elevations), such as ground plane is no more flat (or spherical), but\n * contains geometry that should be overlapped by frustum planes.\n */\nclass ElevationBasedClipPlanesEvaluator {\n    constructor(maxElevation, minElevation) {\n        harp_utils_1.assert(maxElevation >= minElevation);\n        this.m_minElevation = minElevation;\n        this.m_maxElevation = maxElevation;\n    }\n    /**\n     * Set maximum elevation above sea level to be rendered.\n     *\n     * @param elevation the elevation (altitude) value in world units (meters).\n     * @note If you set this exactly to the maximum rendered feature height (altitude above\n     * the sea, you may notice some flickering or even polygons disappearing related to rounding\n     * errors or depth buffer precision. In such cases increase [[nearFarMargin]] or add a little\n     * bit offset to your assumed maximum elevation.\n     * @note Reasonable values are in between (-DeadSeeDepression, MtEverestHeight>, both values\n     * are defined in [[EarthConstant]] as [[EarthConstant.MIN_ELEVATION]] and\n     * [[EarthConstant.MAX_ELEVATION]] respectively.\n     * @see minElevation for more information about precision and rounding errors.\n     */\n    set maxElevation(elevation) {\n        this.m_maxElevation = elevation;\n        // Min elevation should be at least equal or smaller to max elevation.\n        this.m_minElevation = Math.min(elevation, this.m_minElevation);\n    }\n    /**\n     * Get maximum elevation to be covered by camera frustum.\n     */\n    get maxElevation() {\n        return this.m_maxElevation;\n    }\n    /**\n     * Set minimum elevation to be rendered, values beneath the sea level are negative.\n     *\n     * @param elevation the minimum elevation (depression) in world units (meters).\n     * @note If you set this parameter to zero you may not see any features rendered if they are\n     * just below the sea level more than half of [[nearFarMargin]] assumed. Similarly if set to\n     * -100m and rendered features lays exactly in such depression, you may notice that problem.\n     * The errors usually come from projection precision loss and depth buffer nature (significant\n     * precision loss closer to far plane). Thus is such cases either increase the margin (if you\n     * are sure features are just at this elevation, or setup bigger offset for [[minElevation]].\n     * Reasonable values are between <-DeadSeaDepression, MtEverestHeight), where the first denotes\n     * lowest depression on the Earth defined as [[EarthConstants.MIN_ELEVATION]] and the second is\n     * the highest point our planet.\n     * @see https://developer.nvidia.com/content/depth-precision-visualized\n     */\n    set minElevation(elevation) {\n        this.m_minElevation = elevation;\n        // Max elevation should be at least equal or bigger than min elevation.\n        this.m_maxElevation = Math.max(elevation, this.m_maxElevation);\n    }\n    /**\n     * Get minimum elevation to be covered by camera frustum.\n     */\n    get minElevation() {\n        return this.m_minElevation;\n    }\n}\nexports.ElevationBasedClipPlanesEvaluator = ElevationBasedClipPlanesEvaluator;\n/**\n * Top view, clip planes evaluator that computes view ranges based on ground distance and elevation.\n *\n * This evaluator supports both planar and spherical projections, although it behavior is\n * slightly different in each case. General algorithm sets near plane and far plane close\n * to ground level, but taking into account maximum and minimum elevation of features on the ground.\n *\n * @note This evaluator supports only cameras which are always looking down the ground surface\n * (top-down view) along surface normal and does not preserve correct clip planes when\n * modifying camera pitch (tilt) angle. In simple words it is suitable only for top view camera\n * settings.\n */\nclass TopViewClipPlanesEvaluator extends ElevationBasedClipPlanesEvaluator {\n    /**\n     * Allows to setup near/far offsets (margins), rendered geometry elevation relative to sea\n     * level as also minimum near plane and maximum far plane distance constraints.\n     * It is strongly recommended to set some reasonable [[nearFarMargin]] (offset) between near\n     * and far planes to avoid flickering.\n     * @param maxElevation defines near plane offset from the ground in the surface normal\n     * direction, positive values allows to render elevated terrain features (mountains,\n     * buildings). Defaults to Burj Khalifa building height.\n     * @param minElevation defines far plane offset from the ground surface, negative values moves\n     * far plane below the ground level (use it to render depressions). Default zero - sea level.\n     * @param nearMin minimum allowable near plane distance from camera, must be bigger than zero.\n     * @param nearFarMarginRatio minimum distance between near and far plane, as a ratio of average\n     * near/far plane distance, it have to be significantly bigger than zero (especially if\n     * [[maxElevation]] and [[minElevation]] are equal), otherwise you may notice flickering when\n     * rendering, or even render empty scene if frustum planes are almost equal.\n     * @param farMaxRatio maximum ratio between ground and far plane distance, allows to limit\n     * viewing distance at overall. Have to be bigger than 1.0.\n     * @note Keep in mind that this evaluator does not evaluate terrain (or building) elevation\n     * automatically, to keep such features rendered (between frustum planes) use [[minElevation]],\n     * [[maxElevation]] constraints. You may change this parameters at any time, but it requires\n     * repeating [[evaluatePlanes]] step, if your camera is moving you need to evaluate planes\n     * anyway.\n     * @note You may treat [[minElevation]] and [[maxElevation]] parameters as the maximum and\n     * minimum renderable elevation respectively along the surface normal, when camera is\n     * constantly looking downwards (top-down view). If you need [[ClipPlanesEvaluator]] for\n     * cameras that support tilt or yaw please use [[TiltViewClipPlanesEvaluator]].\n     * @note [[nearFarMaxRatio]] does not limit far plane when spherical projection is in use,\n     * the algorithm used there estimates distance to point on tangent where line from camera\n     * touches the sphere horizon and there is no reason to clamp it.\n     */\n    constructor(maxElevation = harp_geoutils_1.EarthConstants.MAX_BUILDING_HEIGHT, minElevation = 0, nearMin = 1.0, nearFarMarginRatio = 0.05, farMaxRatio = 6.0) {\n        super(maxElevation, minElevation);\n        this.nearMin = nearMin;\n        this.nearFarMarginRatio = nearFarMarginRatio;\n        this.farMaxRatio = farMaxRatio;\n        /**\n         * Helper for reducing number of objects created at runtime.\n         */\n        this.m_tmpVectors = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        /**\n         * Helper object for reducing performance impact.\n         */\n        this.m_tmpQuaternion = new THREE.Quaternion();\n        harp_utils_1.assert(nearMin > 0);\n        harp_utils_1.assert(nearFarMarginRatio > epsilon);\n        harp_utils_1.assert(farMaxRatio > 1.0);\n        const nearFarMargin = nearFarMarginRatio * nearMin;\n        this.m_minimumViewRange = {\n            near: nearMin,\n            far: nearMin + nearFarMargin,\n            minimum: this.nearMin,\n            maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)\n        };\n    }\n    /** @override */\n    evaluateClipPlanes(mapView) {\n        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            return this.evaluateDistanceSphericalProj(mapView);\n        }\n        else if (mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            return this.evaluateDistancePlanarProj(mapView);\n        }\n        harp_utils_1.assert(false, \"Unsupported projection type\");\n        return Object.assign({}, this.minimumViewRange);\n    }\n    /**\n     * Get minimum view range that is possible to achieve with current evaluator settings.\n     * @note This value will not change after evaluator is constructed.\n     */\n    get minimumViewRange() {\n        return this.m_minimumViewRange;\n    }\n    /**\n     * Calculate camera altitude (closest distance) to ground level in world units.\n     * @param camera\n     * @param projection\n     */\n    getCameraAltitude(camera, projection) {\n        return projection.groundDistance(camera.position);\n    }\n    evaluateDistancePlanarProj(mapView) {\n        const { camera, projection } = mapView;\n        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);\n        let nearPlane = this.nearMin;\n        let farPlane = this.nearMin * this.farMaxRatio;\n        // Calculate distance to closest point on the ground.\n        const groundDistance = this.getCameraAltitude(camera, projection);\n        const farMax = groundDistance * this.farMaxRatio;\n        // We could at least try to keep margins along the eye vector (center of the view) in\n        // tact with pitch angle changes, but this does not solve all tilt angle problems,\n        // rather use more sophisticated evaluator.\n        nearPlane = groundDistance - this.maxElevation;\n        farPlane = groundDistance - this.minElevation;\n        // Apply the constraints.\n        nearPlane = Math.max(nearPlane, this.nearMin);\n        farPlane = Math.min(farPlane, farMax);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;\n        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);\n        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);\n        const viewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: Math.max(farMax, farPlane)\n        };\n        return viewRanges;\n    }\n    evaluateDistanceSphericalProj(mapView) {\n        const { camera, projection } = mapView;\n        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);\n        let nearPlane = this.nearMin;\n        let farPlane = this.nearMin * this.farMaxRatio;\n        // The near plane calculus is quite straight forward and works the same as for planar\n        // projections. We simply search for the closest point of the ground just above\n        // the camera, then we apply margin (elevation) to it along the sphere surface normal:\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        nearPlane = cameraAltitude - this.maxElevation;\n        // Far plane calculation requires different approaches depending from camera projection:\n        // - perspective\n        // - orthographic\n        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;\n        let d = camera.position.length();\n        d = d === 0 ? epsilon : d;\n        if (camera.type === \"PerspectiveCamera\") {\n            // This solution computes near and far plane for a set up where\n            // the camera is looking at the center of the scene.\n            // The far plane distance calculus requires finding the sphere tangent line that is\n            // co-linear with (goes thru) camera position, such tangent creates right angle\n            // with sphere diameter where it touches its surface (point T). Given that sphere is\n            // always at world origin and camera orbits around it we have (see\n            // #getTangentBasedFarPlane):\n            // angle(OTC) = 90\n            // sin(OCT) = sin(alpha) = r / d\n            // alpha = asin(r / d)\n            const alpha = Math.asin(r / d);\n            // If alpha it bigger than half fov angle, our visibility limit is set by tangent\n            // line, otherwise we need to find top (or right) plane intersection with sphere,\n            // which is definitely closer than the tangent point mentioned above.\n            const cam = camera;\n            // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:\n            const aspect = cam.aspect > 1 ? cam.aspect : 1 / cam.aspect;\n            const halfFovAngle = THREE.Math.degToRad((cam.fov * aspect) / 2);\n            const farTangent = this.getTangentBasedFarPlane(cam, d, r, alpha);\n            farPlane =\n                halfFovAngle > alpha\n                    ? farTangent\n                    : this.getFovBasedFarPlane(cam, d, r, 2 * halfFovAngle, projection);\n        }\n        // Orthographic camera projection\n        else {\n            farPlane = this.getOrthoBasedFarPlane(d, r);\n        }\n        // In extreme cases the largest depression assumed may be further than tangent\n        // based far plane distance, take it into account\n        const farMin = cameraAltitude - this.minElevation;\n        const farMax = cameraAltitude * this.farMaxRatio;\n        // Apply the constraints.\n        nearPlane = Math.max(nearPlane, this.nearMin);\n        farPlane = Math.max(farPlane, farMin);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;\n        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);\n        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);\n        const viewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: farMax\n        };\n        return viewRanges;\n    }\n    /**\n     * Calculate distance from a point to the tangent point of a sphere.\n     *\n     * Returns zero if point is below surface or only very slightly above surface of sphere.\n     * @param d Distance from point to center of sphere\n     * @param r Radius of sphere\n     */\n    getTangentDistance(d, r) {\n        // There may be situations when maximum elevation still remains below sea level\n        // (elevation < 0) or it is negligible (elevation ~ epsilon)\n        if (d - r < epsilon) {\n            return 0;\n        }\n        // The distance to tangent point may be described as:\n        // t = sqrt(d^2 - r^2)\n        return Math.sqrt(d * d - r * r);\n    }\n    /**\n     * Calculate far plane depending on furthest visible distance from camera position.\n     *\n     * Furthest visible distance is assumed to be distance from camera to horizon\n     * plus distance from elevated geometry to horizon(so that high objects behind horizon\n     * remain visible).\n     * @param camera The camera of the mapview\n     * @param d Distance from camera to origin\n     * @param r Radius of earth\n     * @param alpha Angle between camera eye vector and tangent\n     */\n    getTangentBasedFarPlane(camera, d, r, alpha) {\n        // Find tangent point intersection distance\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,        E\n        //   ,           .           ,    . ' far + elev\n        //  ,            .   r + e   , '   /\n        // ,             .     ,  '    ,  /\n        // ,             . O '         , / te\n        // ,             | .           ,/\n        //  ,            |   .  r     ,/\n        //   ,           |      .    ,\n        //     ,         |        , '_____ far\n        //       ' -_, _ | _ ,  ' / T\n        //     near      |      /\n        //               |    / t\n        //             d |  /\n        //               |/\n        //               C\n        const t = this.getTangentDistance(d, r);\n        // Because we would like to see elevated geometry that may be visible beyond\n        // the tangent point on ground surface, we need to extend viewing distance along\n        // the tangent line by te (see graph above).\n        const te = this.getTangentDistance(r + this.maxElevation, r);\n        // Next step is to project CE vector(length t + te) onto camera eye (forward) vector\n        // to get maximum camera far plane distance.\n        //\n        // Knowing that:\n        // tangentVec.dot(cameraFwdVec) = cos(alpha) * len(tangentVec) * len(cameraFwdVec).\n        // where:\n        // ||cameraFwdVec|| == 1 ^ ||tangentVec|| == t + te\n        // Formula simplifies to:\n        const far = Math.cos(alpha) * (t + te);\n        return far;\n    }\n    getFovBasedFarPlane(camera, d, r, fovAngle, projection) {\n        // Find intersection point that is closer to tangent point.\n        //\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,\n        //   ,           .           ,\n        //  ,            .     r     ,' T1\n        // ,             .     ,  '  / ,\n        // ,             . O.'  a   /  ,\n        // ,             | .  `  . /   ,\n        //  ,            |   .  r / TA,\n        //   ,           |    .  /   ,\n        //     ,         |     ./  ,'_____ far\n        //       ' -_, _ | _ , /' T0\n        //     near      |    /\n        //               |   / t\n        //             d | /\n        //               |/\n        //               C\n        //\n        // See:\n        // tslint:disable-next-line: max-line-length\n        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n        // Vector from camera to world center\n        const dVec = camera.position;\n        // Extract camera X, Y, Z orientation axes into tmp vectors array.\n        camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);\n        // Setup quaternion (X axis based) for angle between frustum plane and camera eye.\n        this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], fovAngle / 2);\n        // Acquire camera (eye) forward vector from Z axis (keep it in tmpVectors[2]).\n        const cameraFwdVec = this.m_tmpVectors[2];\n        // Apply quaternion to forward vector, creating intersection vector, which is\n        // parallel to top or right frustum plane (depending on the aspect ratio).\n        const tVec = this.m_tmpVectors[1].copy(cameraFwdVec).applyQuaternion(this.m_tmpQuaternion);\n        // Calculate camera to origin vector projection onto frustum plane (top or right).\n        // This gives us the length of CTA segment:\n        const cta = dVec.dot(tVec);\n        // If it is negative, it means that the dVec and the tVec points in\n        // opposite directions - there is no intersection - or intersection could\n        // potentially be behind the intersection ray's origin (camera position).\n        if (cta < 0) {\n            // Intersection points are behind camera, camera looks in wrong direction.\n            const groundDistance = this.getCameraAltitude(camera, projection);\n            // Setup far plane to maximum distance.\n            return groundDistance * this.farMaxRatio;\n        }\n        // Knowing the length of |CTA| we just need to subtract the length of |T0TA|\n        // segment from it to get far plane distance.\n        // In order to calculate |T0TA| we firstly need to use use Pythagorean theorem to\n        // find length of |OTA| = a. Here we use the right triangle formed by O-C-TA points:\n        // |OC|^2 = |CTA|^2 + |OTA|^2, where |OTA| = a, |OC| = d, |CTA| = cta\n        // a^2 = d^2 - cta^2\n        const a2 = dVec.dot(dVec) - cta * cta;\n        // Note that if a is greater than sphere radius the ray misses the sphere and\n        // thus there is no intersection at all.\n        const r2 = r * r;\n        harp_utils_1.assert(a2 <= r2, \"Please use this evaluator only for top view camera poses.\");\n        // Now to find the length of |T0TA| == |T1TA| we use the second right triangle\n        // formed by O-T0-TA points. Of course we know that |T0TA| segment length is\n        // equal to |T1TA|, and |OT0| segment is simply sphere radius.\n        // In order to find |T0TA| length we again use Pythagorean theorem, which says:\n        // |OT0|^2 = |OTA|^2 + |T0TA|^2, where |OTO| = r, |OTA| = a\n        // |T0TA|^2 = r^2 - a^2\n        const tota = Math.sqrt(r2 - a2);\n        // Finally our far plane (intersection point) is defined as:\n        return cta - tota;\n    }\n    getOrthoBasedFarPlane(d, r) {\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,     E\n        //   ,            .--------- ,-.'- far + elev\n        // | ,            .   r + e , `, |\n        // |,             .     , '     ,| te\n        // |,             . O '.........,|..\n        // |,             |        r    ,|  far\n        // | ,            |            , |\n        // |  ,           |           ,  | t\n        // |    ,         |        , '   |\n        // |      ' -_, _ | _ ,  '       |\n        // |    near      | \\/___________| near - elev\n        // |              |              |\n        // |            d |              |\n        // |              |              |\n        //                C\n        // The distance to tangent point may be described as:\n        const t = d;\n        // Tangent extension due to terrain elevation behind the horizon may be calculated\n        // based on the right triangle:\n        // (r+maxElev)^2 = r^2 + te^2\n        // te = sqrt((r+maxElev)^2 - r^2)\n        // although we may not calculate it if elevation is negligible:\n        const te = this.maxElevation < epsilon\n            ? 0\n            : Math.sqrt(r + this.maxElevation) * (r + this.maxElevation) - r * r;\n        // Both near and far planes distances are directly applied to frustum, because tangents'\n        // lines are parallel to camera look at vector.\n        // Now far plane distance is constituted with:\n        return t + te;\n    }\n}\nexports.TopViewClipPlanesEvaluator = TopViewClipPlanesEvaluator;\n/**\n * Evaluates camera clipping planes taking into account ground distance and camera angles.\n *\n * This evaluator provides support for camera with varying tilt (pitch) angle, the angle\n * between camera __look at__ vector and the ground surface normal.\n */\nclass TiltViewClipPlanesEvaluator extends TopViewClipPlanesEvaluator {\n    /**\n     * Calculate the camera distance to the ground in direction of look at vector.\n     * This is not equivalent to camera altitude cause value will change according to look at\n     * direction. It simply measures the distance of intersection point between ray from\n     * camera and ground level, yet without taking into account terrain elevation nor buildings.\n     * @param camera\n     * @param projection\n     * @note Use with extreme care cause due to optimizations the internal temporary vectors\n     * are used (m_tmpVectors[0], m_tmpVectors[1]). Those should not be used in outlining\n     * function scope (caller).\n     */\n    getCameraLookAtDistance(camera, projection) {\n        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);\n        // Using simple trigonometry we may approximate the distance of camera eye vector\n        // intersection with theoretical ground, knowing camera altitude and tilt angle:\n        // cos(tiltAngle) = altitude / groundDistance\n        // groundDistance = altitude / cos(tiltAngle)\n        // where:\n        // cos(tiltAngle) = dot(lookAt, eyeInverse)\n        const lookAt = this.m_tmpVectors[0];\n        camera.getWorldDirection(lookAt).normalize();\n        const normal = this.m_tmpVectors[1];\n        projection.surfaceNormal(camera.position, normal);\n        normal.negate();\n        let cosTiltAngle = lookAt.dot(normal);\n        cosTiltAngle = cosTiltAngle === 0 ? epsilon : cosTiltAngle;\n        return this.getCameraAltitude(camera, projection) / cosTiltAngle;\n    }\n    /**\n     * Calculate the lengths of frustum planes intersection with the ground plane.\n     * This evaluates distances between eye vector (or eye plane in orthographic projection) and\n     * ground intersections of top and bottom frustum planes.\n     * @note This method assumes the world surface (ground) to be flat and\n     * works only with planar projections.\n     *\n     * @param mapView The [[MapView]] instance in use.\n     */\n    getFrustumGroundIntersectionDist(mapView) {\n        harp_utils_1.assert(mapView.projection.type !== harp_geoutils_1.ProjectionType.Spherical);\n        const camera = mapView.camera;\n        const projection = mapView.projection;\n        // This algorithm computes the length of frustum planes before intersecting with a flat\n        // ground surface. Entire computation is split over two projections method and performed\n        // for top and bottom plane, with addition of terrain (ground) elevation which is taken\n        // into account.\n        // The following diagram may help explain the algorithm below.\n        //   🎥\n        //   C\n        //   |\\\n        //   |.\\ .\n        //   | . \\  . t\n        // z |  .  \\   .c2\n        //   |  c1.  \\e ___. max elev\n        //   |     .   \\      .\n        //___|a___D1.____\\E1_____.D2______ g\n        //   C1      .     \\ __. min elev\n        //            .      \\.E2\n        //          b  .    .\n        //              . .\n        //               .\n        // Where:\n        // - C gives the camera position.\n        // - z is the height of the camera above the ground.\n        // - z1 == z2 == z, for perspective camera all planes origin its the same\n        // - a is a right angle.\n        // - e is the look at vector of the camera.\n        // - t and b are the frustum planes of the camera (top and bottom respectively).\n        // - angle between c1 to c2 is the fov.\n        // - c1, c2 - vectors from camera to the ground along frustum planes.\n        // - angles between c1 and e or e and c2 splits fov on equal halves.\n        // - d1 and d2 are the intersection points of the frustum with the world/ground plane.\n        // - angle between z and e is the pitch of the camera.\n        // - angle between g and e is the tilt angle.\n        // - g is the ground/world surface\n        //\n        // The goal is to find distance for top/bottom planes intersections of frustum with ground\n        // plane.\n        // This are the distances from C->D1 and C->D2, and are described as\n        // c1 and c2. Then we may compensate/correct those distances with actual\n        // ground elevations, which is done by simply offsetting camera altitude, as it is\n        // opposite to elevating ground level.\n        const halfPiLimit = Math.PI / 2 - epsilon;\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        const target = Utils_1.MapViewUtils.rayCastWorldCoordinates(mapView, 0, 0);\n        if (target === null) {\n            throw new Error(\"MapView does not support a view pointing in the void.\");\n        }\n        const cameraTilt = Utils_1.MapViewUtils.extractSphericalCoordinatesFromLocation(mapView, camera, projection.unprojectPoint(target)).tilt;\n        // Angle between z and c2\n        let topAngleRad;\n        // Angle between z and c1\n        let bottomAngleRad;\n        // Bottom plane origin altitude\n        let z1;\n        // Top plane origin altitude\n        let z2;\n        // For perspective projection:\n        if (camera.type === \"PerspectiveCamera\") {\n            const cam = camera;\n            // Angle between z and c2, note, the fov is vertical, otherwise we would need to\n            // translate it using aspect ratio:\n            // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n            const aspect = 1;\n            // Half fov angle in radians\n            const halfFovAngle = THREE.Math.degToRad((cam.fov * aspect) / 2);\n            topAngleRad = harp_utils_1.MathUtils.clamp(cameraTilt + halfFovAngle, -halfPiLimit, halfPiLimit);\n            bottomAngleRad = harp_utils_1.MathUtils.clamp(cameraTilt - halfFovAngle, -halfPiLimit, halfPiLimit);\n            z1 = z2 = cameraAltitude;\n        }\n        // For orthographic projection:\n        else {\n            const cam = camera;\n            // For orthogonal camera projections we may simply ignore FOV and use 0 for FOV\n            // the top/bottom planes are simply parallel to the eye vector:\n            topAngleRad = bottomAngleRad = cameraTilt;\n            // Although the ray origin is not always the same (eye position) as for\n            // the perspective projections, thus we need to compensate for ortho-cube\n            // dimensions:\n            // sin(tilt) = zc2 / top\n            // sin(tilt) = zc1 / bottom\n            // zc2 = sin(tilt) * top\n            // zc1 = sin(tilt) * bottom\n            const sinBeta = Math.sin(cameraTilt);\n            z2 = cameraAltitude + sinBeta * cam.top;\n            z1 = cameraAltitude - sinBeta * cam.bottom;\n        }\n        // Distance along the top plane to the ground - c2\n        // cos(topAngle) = (z2 - minElev) / |c2|\n        // |c2| = (z2 - minElev) / cos(topAngle)\n        const topDist = (z2 - this.minElevation) / Math.cos(topAngleRad);\n        // Distance along the bottom plane to the ground - c1\n        // cos(bottomAngle) = (z - minElev) / |c1|\n        // |c1| = (z - minElev) / cos(bottomAngle)\n        const bottomDist = (z1 - this.maxElevation) / Math.cos(bottomAngleRad);\n        return {\n            top: Math.max(topDist, 0),\n            bottom: Math.max(bottomDist, 0)\n        };\n    }\n    /** @override */\n    evaluateDistancePlanarProj(mapView) {\n        harp_utils_1.assert(mapView.projection.type !== harp_geoutils_1.ProjectionType.Spherical);\n        const viewRanges = Object.assign({}, this.minimumViewRange);\n        // Generally near/far planes are set to keep top/bottom planes intersection distance.\n        // Then elevations margins are applied. Here margins (min/max elevations) are meant to\n        // be defined as distance along the ground normal vector thus during camera\n        // tilt they may affect near/far planes positions differently.\n        const planesDist = this.getFrustumGroundIntersectionDist(mapView);\n        const { camera, projection } = mapView;\n        // Project clipping plane distances for the top/bottom frustum planes (edges), but\n        // only if we deal with perspective camera type, this step is not required\n        // for orthographic projections, cause all clip planes are parallel to eye vector.\n        if (camera.type === \"PerspectiveCamera\") {\n            const cam = camera;\n            // Angle between z and c2, note, the fov is vertical, otherwise we would need to\n            // translate it using aspect ratio:\n            // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n            const aspect = 1;\n            // Half fov angle in radians\n            const halfFovAngle = THREE.Math.degToRad((cam.fov * aspect) / 2);\n            const cosHalfFov = Math.cos(halfFovAngle);\n            // cos(halfFov) = near / bottomDist\n            // near = cos(halfFov) * bottomDist\n            viewRanges.near = planesDist.bottom * cosHalfFov;\n            // cos(halfFov) = far / topDist\n            // far = cos(halfFov) * topDist\n            viewRanges.far = planesDist.top * cosHalfFov;\n        }\n        // Orthographic camera projection.\n        else {\n            viewRanges.near = planesDist.bottom;\n            viewRanges.far = planesDist.top;\n        }\n        // Clamp values to constraints.\n        const lookAtDist = this.getCameraLookAtDistance(camera, projection);\n        const farMax = lookAtDist * this.farMaxRatio;\n        viewRanges.near = Math.max(viewRanges.near, this.nearMin);\n        viewRanges.far = Math.min(viewRanges.far, farMax);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;\n        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);\n        viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);\n        viewRanges.minimum = this.nearMin;\n        viewRanges.maximum = farMax;\n        return viewRanges;\n    }\n    /** @override */\n    evaluateDistanceSphericalProj(mapView) {\n        const { camera, projection } = mapView;\n        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);\n        const viewRanges = Object.assign({}, this.minimumViewRange);\n        // Near plane calculus is pretty straightforward and does not depend on camera tilt:\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        viewRanges.near = cameraAltitude - this.maxElevation;\n        // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:\n        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n        const halfFovAngle = THREE.Math.degToRad((camera.fov * aspect) / 2);\n        if (camera instanceof THREE.PerspectiveCamera) {\n            // Now we need to account for camera tilt and frustum volume, so the longest\n            // frustum edge does not intersects with sphere, it takes the worst case\n            // scenario regardless of camera tilt, so may be improved little bit with more\n            // sophisticated algorithm.\n            viewRanges.near *= Math.cos(halfFovAngle);\n        }\n        // Far plane calculation requires different approaches depending from camera projection:\n        // - perspective\n        // - orthographic\n        const cameraToOrigin = this.m_tmpVectors[0].copy(camera.position).negate();\n        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;\n        const d = cameraToOrigin.length();\n        let farPlane;\n        if (camera instanceof THREE.PerspectiveCamera) {\n            // Step-wise calculate angle between camera eye vector and tangent\n            // Calculate angle between surface normal(below camera position) and tangent.\n            const alpha = Math.asin(r / d);\n            // Calculate angle between look at and surface normal(below camera position)\n            const cameraPitch = this.getCameraPitch(cameraToOrigin, camera);\n            // Calculate angle between camera eye vector and tangent.\n            const modifiedAlpha = Math.abs(alpha - cameraPitch);\n            // Use tangent based far plane if horizon is within field of view\n            const farTangent = this.getTangentBasedFarPlane(camera, d, r, modifiedAlpha);\n            farPlane =\n                halfFovAngle >= modifiedAlpha\n                    ? farTangent\n                    : this.getTiltedFovBasedFarPlane(d, r, halfFovAngle, cameraPitch);\n        }\n        else {\n            farPlane = this.getOrthoBasedFarPlane(d, r);\n        }\n        viewRanges.far = farPlane;\n        // Apply the constraints.\n        const farMin = cameraAltitude - this.minElevation;\n        const farMax = mapView.lookAtDistance * this.farMaxRatio;\n        viewRanges.near = Math.max(viewRanges.near, this.nearMin);\n        viewRanges.far = harp_utils_1.MathUtils.clamp(viewRanges.far, farMin, farMax);\n        // Apply margins.\n        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;\n        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);\n        viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);\n        // Set minimum and maximum view range.\n        viewRanges.minimum = this.nearMin;\n        viewRanges.maximum = farMax;\n        return viewRanges;\n    }\n    getTiltedFovBasedFarPlane(d, r, halfFovAngle, cameraPitch) {\n        // Find intersection point that is closer to tangent point.\n        //\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,\n        //   ,           .           ,\n        //  ,            .     r     ,' T1\n        // ,             .     ,  '  / ,\n        // ,             . O.'  a   /  ,\n        // ,             | .  `  . /   ,\n        //  ,            |   .  r / TA,\n        //   ,           |    .  /   ,\n        //     ,         |     ./  ,'_____ far\n        //       ' -_, _ | _ , /' T0\n        //     near      |    /\n        //               |   / t\n        //             d | /\n        //               |/\n        //               C\n        //\n        // See:\n        // tslint:disable-next-line: max-line-length\n        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n        // compute length of t (distance to fov intersection with sphere)\n        // with law of cosines:\n        // r² = d² + t² - 2dt * cos(alpha)\n        // solved for t:\n        // t0 = d * cos(alpha) - sqrt(d²*cos²(alpha) - d² + r²)  <-- first intersection\n        // t1 = d * cos(alpha) + sqrt(d²*cos²(alpha) - d² + r²)  <-- second intersection\n        // Use first intersection:\n        const cosAlpha = Math.cos(cameraPitch + halfFovAngle);\n        const dSqr = d * d;\n        const t = d * cosAlpha - Math.sqrt(dSqr * cosAlpha * cosAlpha - dSqr + r * r);\n        harp_utils_1.assert(!isNaN(t), \"Field of view does not intersect sphere. Use tangent based far plane instead.\");\n        // project t onto camera fwd vector\n        const far = Math.cos(halfFovAngle) * t;\n        return far;\n    }\n    getCameraPitch(cameraToOrigin, camera) {\n        cameraToOrigin.normalize();\n        const lookAt = camera.getWorldDirection(this.m_tmpVectors[1]).normalize();\n        const cosAlpha1 = cameraToOrigin.dot(lookAt);\n        const cameraPitch = Math.acos(harp_utils_1.MathUtils.clamp(cosAlpha1, -1.0, 1.0));\n        return cameraPitch;\n    }\n}\nexports.TiltViewClipPlanesEvaluator = TiltViewClipPlanesEvaluator;\n/**\n * Provides the most basic evaluation concept giving fixed values with some constraints.\n */\nclass FixedClipPlanesEvaluator {\n    constructor(minNear = 1, minFarOffset = 10) {\n        this.minNear = minNear;\n        this.minFarOffset = minFarOffset;\n        this.minFar = minNear + minFarOffset;\n        this.m_nearPlane = minNear;\n        this.m_farPlane = this.minFar;\n    }\n    get nearPlane() {\n        return this.m_nearPlane;\n    }\n    set nearPlane(fixedNear) {\n        this.invalidatePlanes(fixedNear, this.m_farPlane);\n    }\n    get farPlane() {\n        return this.m_farPlane;\n    }\n    set farPlane(fixedFar) {\n        this.invalidatePlanes(this.m_nearPlane, fixedFar);\n    }\n    // tslint:disable-next-line: no-empty\n    set minElevation(elevation) { }\n    get minElevation() {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n    // tslint:disable-next-line: no-empty\n    set maxElevation(elevation) { }\n    get maxElevation() {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n    evaluateClipPlanes(mapView) {\n        // We do not need to perform actual evaluation cause results are precomputed and\n        // kept stable until somebody changes the properties.\n        const viewRanges = {\n            near: this.m_nearPlane,\n            far: this.m_farPlane,\n            minimum: this.minNear,\n            maximum: this.m_farPlane\n        };\n        return viewRanges;\n    }\n    invalidatePlanes(near, far) {\n        // When clamping prefer to extend far plane at about minimum distance, giving\n        // near distance setup priority over far.\n        const nearDist = Math.max(this.minNear, near);\n        const farDist = Math.max(this.minFar, far, nearDist + this.minFarOffset);\n        this.m_nearPlane = nearDist;\n        this.m_farPlane = farDist;\n    }\n}\nexports.FixedClipPlanesEvaluator = FixedClipPlanesEvaluator;\n/**\n * Factory function that creates default [[ClipPlanesEvaluator]] that calculates near plane based\n * on ground distance and camera orientation.\n *\n * Creates [[TiltViewClipPlanesEvaluator]].\n */\nexports.createDefaultClipPlanesEvaluator = () => new TiltViewClipPlanesEvaluator();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ColorCache.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ColorCache.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Use `ColorCache` to reuse a color specified by name and save allocation as well as\n * setup time.\n *\n * Implemented as a singleton. Do not modify colors after getting them from the `ColorCache`.\n */\nclass ColorCache {\n    constructor() {\n        this.m_map = new Map();\n    }\n    /**\n     * Return instance of `ColorCache`.\n     */\n    static get instance() {\n        return this.m_instance;\n    }\n    /**\n     * Returns the color for the given `colorCode`. This function may reuse a previously generated\n     * color, so you cannot modify the contents of the color.\n     *\n     * @param colorCode ThreeJS color code or name. You must provide a valid color code or name,\n     * as this function does not do any validation.\n     */\n    getColor(colorCode) {\n        if (typeof colorCode === \"number\") {\n            colorCode = \"#\" + colorCode.toString(16).padStart(6, \"0\");\n        }\n        let color = this.m_map.get(colorCode);\n        if (color !== undefined) {\n            return color;\n        }\n        color = new THREE.Color(colorCode);\n        this.m_map.set(colorCode, color);\n        return color;\n    }\n    /**\n     * Returns the number of elements in the cache.\n     */\n    get size() {\n        return this.m_map.size;\n    }\n    /**\n     * Clears the cache. Only references to the THREE.Color are removed from the cache.\n     * Consequently, clearing the cache does not cause any negative visual impact.\n     */\n    clear() {\n        this.m_map.clear();\n    }\n}\nexports.ColorCache = ColorCache;\nColorCache.m_instance = new ColorCache();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ColorCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ \"./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js\");\nconst WorkerBasedDecoder_1 = __webpack_require__(/*! ./WorkerBasedDecoder */ \"./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js\");\n/**\n * Default concurrent decoder helper.\n *\n * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle\n * requested. Provides easy access to [[WorkerBasedDecoder]]s for data sources.\n */\nclass ConcurrentDecoderFacade {\n    /**\n     * Returns a [[WorkerBasedDecoder]] instance.\n     *\n     * @param decoderServiceType The name of the decoder service type.\n     * @param scriptUrl The optional URL with the workers' script.\n     * @param workerCount The number of web workers to use.\n     */\n    static getTileDecoder(decoderServiceType, scriptUrl, workerCount) {\n        const workerSet = this.getWorkerSet(scriptUrl, workerCount);\n        return new WorkerBasedDecoder_1.WorkerBasedDecoder(workerSet, decoderServiceType);\n    }\n    /**\n     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.\n     *\n     * @param scriptUrl The optional URL with the workers' script. If not specified,\n     * the function uses [[defaultScriptUrl]] instead.\n     * @param workerCount The number of web workers to use.\n     */\n    static getWorkerSet(scriptUrl, workerCount) {\n        if (scriptUrl === undefined) {\n            scriptUrl = this.defaultScriptUrl;\n        }\n        let workerSet = this.workerSets[scriptUrl];\n        if (workerSet === undefined) {\n            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({\n                scriptUrl,\n                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount\n            });\n            this.workerSets[scriptUrl] = workerSet;\n        }\n        return workerSet;\n    }\n    /**\n     * Destroys a [[ConcurrentWorkerSet]] instance.\n     *\n     * @param scriptUrl The worker script URL that was used to create the [[ConcurrentWorkerSet]].\n     */\n    static destroyWorkerSet(scriptUrl) {\n        const workerSet = this.workerSets[scriptUrl];\n        if (workerSet !== undefined) {\n            workerSet.destroy();\n            delete this.workerSets[scriptUrl];\n        }\n    }\n    /**\n     * Destroys all managed [[ConcurrentWorkerSet]]s.\n     */\n    static destroy() {\n        Object.keys(this.workerSets).forEach(name => {\n            this.workerSets[name].destroy();\n        });\n        this.workerSets = {};\n    }\n}\nexports.ConcurrentDecoderFacade = ConcurrentDecoderFacade;\n/**\n * The URL containing a script to fall back (default) to when looking for worker sets\n * and decoders.\n */\nConcurrentDecoderFacade.defaultScriptUrl = \"./decoder.bundle.js\";\n/**\n * The default number of workers.\n */\nConcurrentDecoderFacade.defaultWorkerCount = undefined;\n/**\n * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.\n */\nConcurrentDecoderFacade.workerSets = {};\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ \"./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js\");\nconst WorkerBasedTiler_1 = __webpack_require__(/*! ./WorkerBasedTiler */ \"./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js\");\n/**\n * Default concurrent tiler helper.\n *\n * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle\n * requested. Provides easy access to [[WorkerBasedTiler]]s for data sources.\n */\nclass ConcurrentTilerFacade {\n    /**\n     * Returns a [[WorkerBasedTiler]] instance.\n     *\n     * @param tilerServiceType The name of the tiler service type.\n     * @param scriptUrl The optional URL with the workers' script.\n     * @param workerCount The number of web workers to use.\n     */\n    static getTiler(tilerServiceType, scriptUrl, workerCount) {\n        const workerSet = this.getWorkerSet(scriptUrl, workerCount);\n        return new WorkerBasedTiler_1.WorkerBasedTiler(workerSet, tilerServiceType);\n    }\n    /**\n     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.\n     *\n     * @param scriptUrl The optional URL with the workers' script. If not specified,\n     * the function uses [[defaultScriptUrl]] instead.\n     * @param workerCount The number of web workers to use.\n     */\n    static getWorkerSet(scriptUrl, workerCount) {\n        if (scriptUrl === undefined) {\n            scriptUrl = this.defaultScriptUrl;\n        }\n        let workerSet = this.workerSets[scriptUrl];\n        if (workerSet === undefined) {\n            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({\n                scriptUrl,\n                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount\n            });\n            this.workerSets[scriptUrl] = workerSet;\n        }\n        return workerSet;\n    }\n    /**\n     * Destroys a [[ConcurrentWorkerSet]] instance.\n     *\n     * @param scriptUrl The worker script URL that was used to create the [[ConcurrentWorkerSet]].\n     */\n    static destroyWorkerSet(scriptUrl) {\n        const workerSet = this.workerSets[scriptUrl];\n        if (workerSet !== undefined) {\n            workerSet.destroy();\n            delete this.workerSets[scriptUrl];\n        }\n    }\n    /**\n     * Destroys all managed [[ConcurrentWorkerSet]]s.\n     */\n    static destroy() {\n        Object.keys(this.workerSets).forEach(name => {\n            this.workerSets[name].destroy();\n        });\n        this.workerSets = {};\n    }\n}\nexports.ConcurrentTilerFacade = ConcurrentTilerFacade;\n/**\n * The URL containing a script to fall back (default) to when looking for worker sets\n * and tilers.\n */\nConcurrentTilerFacade.defaultScriptUrl = \"./decoder.bundle.js\";\n/**\n * The default number of workers.\n */\nConcurrentTilerFacade.defaultWorkerCount = 1;\n/**\n * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.\n */\nConcurrentTilerFacade.workerSets = {};\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ConcurrentTilerFacade.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst WorkerLoader_1 = __webpack_require__(/*! ./workers/WorkerLoader */ \"./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"ConcurrentWorkerSet\");\nfunction isLoggingMessage(message) {\n    return message && typeof message.level === \"number\" && message.type === harp_utils_1.WORKERCHANNEL_MSG_TYPE;\n}\nexports.isLoggingMessage = isLoggingMessage;\n/**\n * The default number of Web Workers to use if `navigator.hardwareConcurrency` is unavailable.\n */\nconst DEFAULT_WORKER_COUNT = 2;\n/**\n * The default timeout for first message from worker.\n *\n * @see [[WorkerLoader.startWorker]]\n */\nexports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT = 10000;\n/**\n * A set of concurrent Web Workers. Acts as a Communication Peer for [[WorkerService]] instances\n * running in Web Workers.\n *\n * Starts and manages a certain number of web workers and provides a means to communicate\n * with them using various communication schemes, such as:\n *  - [[addEventListener]] : receive a unidirectional messages\n *  - [[broadcastMessage]] : send unidirectional broadcast message\n *  - [[invokeRequest]] : send a request that waits for a response, with load balancing\n *  - [[postMessage]] : send a unidirectional message, with load balancing\n *\n * The request queue holds all requests before they are stuffed into the event queue, allows for\n * easy (and early) cancelling of requests. The workers now only get a single new RequestMessage\n * when they return their previous result, or if they are idle. When they are idle, they are stored\n * in m_availableWorkers.\n */\nclass ConcurrentWorkerSet {\n    /**\n     * Creates a new `ConcurrentWorkerSet`.\n     *\n     * Creates as many Web Workers as specified in `options.workerCount`, from the script provided\n     * in `options.scriptUrl`. If `options.workerCount` is not specified, the value specified in\n     * `navigator.hardwareConcurrency` is used instead.\n     *\n     * The worker set is implicitly started when constructed.\n     */\n    constructor(m_options) {\n        this.m_options = m_options;\n        this.m_workerChannelLogger = harp_utils_1.LoggerManager.instance.create(\"WorkerChannel\");\n        this.m_eventListeners = new Map();\n        this.m_workers = new Array();\n        // List of idle workers that can be given the next job. It is using a LIFO scheme to reduce\n        // memory consumption in idle workers.\n        this.m_availableWorkers = new Array();\n        this.m_workerPromises = new Array();\n        this.m_readyPromises = new Map();\n        this.m_requests = new Map();\n        this.m_workerRequestQueue = [];\n        this.m_nextMessageId = 0;\n        this.m_stopped = true;\n        this.m_referenceCount = 0;\n        /**\n         * Handles messages received from workers. This method is protected so that the message\n         * reception can be simulated through an extended class, to avoid relying on real workers.\n         *\n         * @param workerId The workerId of the web worker.\n         * @param event The event to dispatch.\n         */\n        this.onWorkerMessage = (workerId, event) => {\n            if (harp_datasource_protocol_1.WorkerServiceProtocol.isResponseMessage(event.data)) {\n                const response = event.data;\n                if (response.messageId === null) {\n                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);\n                    return;\n                }\n                const entry = this.m_requests.get(response.messageId);\n                if (entry === undefined) {\n                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`);\n                    return;\n                }\n                if (workerId >= 0 && workerId < this.m_workers.length) {\n                    const worker = this.m_workers[workerId];\n                    this.m_availableWorkers.push(worker);\n                    // Check if any new work has been put into the queue.\n                    this.checkWorkerRequestQueue();\n                }\n                else {\n                    logger.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);\n                }\n                if (response.errorMessage !== undefined) {\n                    const error = new Error(response.errorMessage);\n                    if (response.errorStack !== undefined) {\n                        error.stack = response.errorStack;\n                    }\n                    entry.resolver(error);\n                }\n                else {\n                    entry.resolver(undefined, response.response);\n                }\n            }\n            else if (harp_datasource_protocol_1.WorkerServiceProtocol.isInitializedMessage(event.data)) {\n                const readyPromise = this.getReadyPromise(event.data.service);\n                if (++readyPromise.count === this.m_workerPromises.length) {\n                    readyPromise.resolve();\n                }\n            }\n            else if (isLoggingMessage(event.data)) {\n                switch (event.data.level) {\n                    case harp_utils_1.LogLevel.Trace:\n                        this.m_workerChannelLogger.trace(...event.data.message);\n                        break;\n                    case harp_utils_1.LogLevel.Debug:\n                        this.m_workerChannelLogger.debug(...event.data.message);\n                        break;\n                    case harp_utils_1.LogLevel.Log:\n                        this.m_workerChannelLogger.log(...event.data.message);\n                        break;\n                    case harp_utils_1.LogLevel.Info:\n                        this.m_workerChannelLogger.info(...event.data.message);\n                        break;\n                    case harp_utils_1.LogLevel.Warn:\n                        this.m_workerChannelLogger.warn(...event.data.message);\n                        break;\n                    case harp_utils_1.LogLevel.Error:\n                        this.m_workerChannelLogger.error(...event.data.message);\n                        break;\n                }\n            }\n            else {\n                this.eventHandler(event);\n            }\n        };\n        this.start();\n    }\n    /**\n     * Adds an external reference and increments the internal reference counter by one.\n     *\n     * To implement a reference-count based automatic resource cleanup, use this function with\n     * [[removeReference]].\n     */\n    addReference() {\n        this.m_referenceCount += 1;\n        if (this.m_referenceCount === 1 && this.m_stopped) {\n            this.start();\n        }\n    }\n    /**\n     * Decrements the internal reference counter by 1.\n     *\n     * When the internal reference counter reaches 0, this function calls [[dispose]] to clear the\n     * resources.\n     *\n     * Use with [[addReference]] to implement reference-count based automatic resource cleanup.\n     */\n    removeReference() {\n        this.m_referenceCount -= 1;\n        if (this.m_referenceCount === 0) {\n            this.destroy();\n        }\n    }\n    /**\n     * Starts workers.\n     *\n     * Use to start workers already stopped by [[stop]] or [[destroy]] calls.\n     *\n     * Note: The worker set is implicitly started on construction - no need to call [[start]] on\n     * fresh instance.\n     *\n     * @param options optional, new worker set options\n     */\n    start(options) {\n        if (options !== undefined) {\n            this.m_options = options;\n        }\n        if (!this.m_stopped) {\n            throw new Error(\"ConcurrentWorker set already started\");\n        }\n        this.m_workerCount = harp_utils_1.getOptionValue(this.m_options.workerCount, typeof navigator !== \"undefined\" && navigator.hardwareConcurrency !== undefined\n            ? // We need to have at least one worker\n                THREE.Math.clamp(navigator.hardwareConcurrency - 1, 1, 2)\n            : undefined, DEFAULT_WORKER_COUNT);\n        // Initialize the workers. The workers now have an ID to identify specific workers and\n        // handle their busy state.\n        const timeout = harp_utils_1.getOptionValue(this.m_options.workerConnectionTimeout, exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT);\n        for (let workerId = 0; workerId < this.m_workerCount; ++workerId) {\n            const workerPromise = WorkerLoader_1.WorkerLoader.startWorker(this.m_options.scriptUrl, timeout).then(worker => {\n                const listener = (evt) => {\n                    this.onWorkerMessage(workerId, evt);\n                };\n                worker.addEventListener(\"message\", listener);\n                this.m_workers.push(worker);\n                this.m_availableWorkers.push(worker);\n                return {\n                    worker,\n                    listener\n                };\n            });\n            this.m_workerPromises.push(workerPromise);\n        }\n        this.m_stopped = false;\n    }\n    /**\n     * The number of workers started for this worker set. The value is `undefined` until the workers\n     * have been created.\n     */\n    get workerCount() {\n        return this.m_workerCount;\n    }\n    /**\n     * Stops workers.\n     *\n     * Waits for all pending requests to be finished and stops all workers.\n     *\n     * Use [[start]] to start this worker again.\n     *\n     * @returns `Promise` that resolves when all workers are destroyed.\n     */\n    async stop() {\n        this.m_stopped = true;\n        await this.waitForAllResponses().then(() => {\n            this.terminateWorkers();\n        });\n    }\n    /**\n     * Destroys all workers immediately.\n     *\n     * Resolves all pending request promises with a `worker destroyed` error.\n     *\n     * Use [[start]] to start this worker again.\n     */\n    destroy() {\n        this.m_stopped = true;\n        // respond with all pending request\n        this.m_requests.forEach(entry => {\n            entry.resolver(new Error(\"worker destroyed\"));\n        });\n        this.m_requests.clear();\n        this.m_workerRequestQueue = [];\n        this.terminateWorkers();\n        // clean other stuff\n        this.m_eventListeners.clear();\n    }\n    /**\n     * Waits for `service` to be initialized in all workers.\n     *\n     * Each service that starts in a worker sends an [[isInitializedMessage]] to confirm that\n     * it has started successfully. This method resolves when all workers in a set have\n     * `service` initialized.\n     *\n     * Promise is rejected if any of worker fails to start.\n     *\n     * @param serviceId The service identifier.\n     */\n    async connect(serviceId) {\n        this.ensureStarted();\n        await Promise.all(this.m_workerPromises);\n        return this.getReadyPromise(serviceId).promise;\n    }\n    /**\n     * Registers an event listener for events that originated in a web worker, for a given\n     * `serviceId`. You can only set one event listener per `serviceId`.\n     *\n     * @param serviceId The service to listen to.\n     * @param callback The callback to invoke for matching events.\n     */\n    addEventListener(serviceId, callback) {\n        this.m_eventListeners.set(serviceId, callback);\n    }\n    /**\n     * Removes a previously set event listener for the given `serviceId`.\n     *\n     * @param serviceId The service from which to remove the event listeners.\n     */\n    removeEventListener(serviceId) {\n        this.m_eventListeners.delete(serviceId);\n    }\n    /**\n     * Invokes a request that expects a response from a random worker.\n     *\n     * Sends [[RequestMessage]] and resolves when a matching [[ResponseMessage]] is received from\n     * workers. Use this function when interfacing with \"RPC-like\" calls to services.\n     *\n     * @param serviceId The name of service, as registered with the [[WorkerClient]] instance.\n     * @param request The request to process.\n     * @param transferList An optional array of `ArrayBuffer`s to transfer to the worker context.\n     * @param requestController An optional [[RequestController]] to store state of cancelling.\n     *\n     * @returns A `Promise` that resolves with a response from the service.\n     */\n    invokeRequest(serviceId, request, transferList, requestController) {\n        this.ensureStarted();\n        const messageId = this.m_nextMessageId++;\n        let resolver;\n        const promise = new Promise((resolve, reject) => {\n            resolver = (error, response) => {\n                this.m_requests.delete(messageId);\n                if (error !== undefined) {\n                    reject(error);\n                }\n                else {\n                    resolve(response);\n                }\n            };\n        });\n        this.m_requests.set(messageId, {\n            promise,\n            resolver: resolver\n        });\n        const message = {\n            service: serviceId,\n            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,\n            messageId,\n            request\n        };\n        this.postRequestMessage(message, transferList, requestController);\n        return promise;\n    }\n    /**\n     * Invokes a request that expects responses from all workers.\n     *\n     * Send [[RequestMessage]]  to all workers and resolves when all workers have sent a matching\n     * [[ResponseMessage]]. Use this function to wait on request that need to happen on all workers\n     * before proceeding (like synchronous worker service creation).\n     *\n     * @param serviceId The name of service, as registered with the [[WorkerClient]] instance.\n     * @param request The request to process.\n     * @param transferList An optional array of `ArrayBuffer`s to transfer to the worker context.\n     *\n     * @returns Array of `Promise`s that resolves with a response from each worker (unspecified\n     * order).\n     */\n    broadcastRequest(serviceId, request, transferList) {\n        this.ensureStarted();\n        const promises = [];\n        for (const worker of this.m_workers) {\n            const messageId = this.m_nextMessageId++;\n            let resolver;\n            const promise = new Promise((resolve, reject) => {\n                resolver = (error, response) => {\n                    this.m_requests.delete(messageId);\n                    if (error !== undefined) {\n                        reject(error);\n                    }\n                    else {\n                        resolve(response);\n                    }\n                };\n            });\n            promises.push(promise);\n            this.m_requests.set(messageId, {\n                promise,\n                resolver: resolver\n            });\n            const message = {\n                service: serviceId,\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,\n                messageId,\n                request\n            };\n            if (transferList !== undefined) {\n                worker.postMessage(message, transferList);\n            }\n            else {\n                worker.postMessage(message);\n            }\n        }\n        return Promise.all(promises);\n    }\n    /**\n     * Posts a message to all workers.\n     *\n     * @param message The message to send.\n     * @param buffers Optional buffers to transfer to the workers.\n     */\n    broadcastMessage(message, buffers) {\n        this.ensureStarted();\n        if (buffers !== undefined) {\n            this.m_workers.forEach(worker => worker.postMessage(message, buffers));\n        }\n        else {\n            this.m_workers.forEach(worker => worker.postMessage(message));\n        }\n    }\n    /**\n     * The size of the request queue for debugging and profiling.\n     */\n    get requestQueueSize() {\n        return this.m_workerRequestQueue.length;\n    }\n    /**\n     * The number of workers for debugging and profiling.\n     */\n    get numWorkers() {\n        return this.m_workers.length;\n    }\n    /**\n     * The number of workers for debugging and profiling.\n     */\n    get numIdleWorkers() {\n        return this.m_availableWorkers.length;\n    }\n    /**\n     * Subclasses must call this function when a worker emits an event.\n     *\n     * @param event The event to dispatch.\n     */\n    eventHandler(event) {\n        if (typeof event.data.type !== \"string\") {\n            return; // not an event generated by us, ignore.\n        }\n        this.dispatchEvent(event.data.type, event);\n    }\n    /**\n     * Posts a [[WorkerServiceProtocol.RequestMessage]] to an available worker. If no worker is\n     * available, the request is put into a queue.\n     *\n     * @param message The message to send.\n     * @param buffers Optional buffers to transfer to the worker.\n     * @param requestController An optional [[RequestController]] to store state of cancelling.\n     */\n    postRequestMessage(message, buffers, requestController) {\n        this.ensureStarted();\n        if (this.m_workers.length === 0) {\n            throw new Error(\"ConcurrentWorkerSet#postMessage: no workers started\");\n        }\n        // Check if the requestController has received the abort signal, in which case the request\n        // is ignored.\n        if (requestController !== undefined && requestController.signal.aborted) {\n            const entry = this.m_requests.get(message.messageId);\n            if (entry === undefined) {\n                logger.error(`[${this.m_options.scriptUrl}]: Bad RequestMessage: invalid messageId`);\n                return;\n            }\n            const err = new Error(\"Aborted\");\n            err.name = \"AbortError\";\n            entry.resolver(err, undefined);\n            return;\n        }\n        if (this.m_availableWorkers.length > 0) {\n            const worker = this.m_availableWorkers.pop();\n            if (buffers !== undefined) {\n                worker.postMessage(message, buffers);\n            }\n            else {\n                worker.postMessage(message);\n            }\n        }\n        else {\n            // We need a priority to keep sorting stable, so we have to add a RequestController.\n            if (requestController === undefined) {\n                requestController = new harp_datasource_protocol_1.RequestController(0);\n            }\n            if (requestController.priority === 0) {\n                // If the requests do not get a priority, they should keep their sorting order.\n                requestController.priority = -this.m_nextMessageId;\n            }\n            this.m_workerRequestQueue.unshift({\n                message,\n                buffers,\n                requestController\n            });\n        }\n    }\n    ensureStarted() {\n        if (this.m_stopped) {\n            throw new Error(\"ConcurrentWorkerSet stopped\");\n        }\n    }\n    async waitForAllResponses() {\n        const promises = new Array();\n        this.m_requests.forEach(entry => {\n            promises.push(entry.promise);\n        });\n        await Promise.all(promises);\n    }\n    dispatchEvent(id, message) {\n        const callback = this.m_eventListeners.get(id);\n        if (callback === undefined) {\n            return;\n        } // unknown event, ignore.\n        callback(message);\n    }\n    terminateWorkers() {\n        // terminate all workers\n        this.m_workerPromises.forEach(workerPromise => {\n            workerPromise.then(workerEntry => {\n                if (workerEntry === undefined) {\n                    return;\n                }\n                workerEntry.worker.removeEventListener(\"message\", workerEntry.listener);\n                workerEntry.worker.terminate();\n            });\n        });\n        this.m_workers = [];\n        this.m_workerPromises = [];\n        this.m_availableWorkers = [];\n        this.m_readyPromises.clear();\n    }\n    getReadyPromise(id) {\n        const readyPromise = this.m_readyPromises.get(id);\n        if (readyPromise !== undefined) {\n            return readyPromise;\n        }\n        const newPromise = {\n            count: 0,\n            promise: undefined,\n            resolve: () => {\n                /* placeholder */\n            },\n            reject: (error) => {\n                newPromise.error = error;\n            },\n            error: undefined\n        };\n        newPromise.promise = new Promise((resolve, reject) => {\n            const that = newPromise;\n            if (that.error !== undefined) {\n                reject(that.error);\n            }\n            else if (that.count === this.m_workerPromises.length) {\n                resolve();\n            }\n            that.resolve = resolve;\n            that.reject = reject;\n        });\n        this.m_readyPromises.set(id, newPromise);\n        return newPromise;\n    }\n    /**\n     * Check the worker request queue, if there are any queued up decoding jobs and idle workers,\n     * they will be executed with postRequestMessage. The requests in the queue are sorted before\n     * the request with the highest priority is selected for processing.\n     */\n    checkWorkerRequestQueue() {\n        if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {\n            return;\n        }\n        this.m_workerRequestQueue.sort((a, b) => {\n            return a.requestController.priority - b.requestController.priority;\n        });\n        // Get the request with the highest priority and send it (again).\n        while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {\n            const request = this.m_workerRequestQueue.pop();\n            this.postRequestMessage(request.message, request.buffers, request.requestController);\n        }\n    }\n}\nexports.ConcurrentWorkerSet = ConcurrentWorkerSet;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ConcurrentWorkerSet.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DataSource.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DataSource.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst UPDATE_EVENT = { type: \"update\" };\n/**\n * Derive a class from `DataSource` to contribute data and geometries to the [[MapView]].\n */\nclass DataSource extends THREE.EventDispatcher {\n    /**\n     * Constructs a new `DataSource`.\n     *\n     * @param uniqueName A unique name that represents this `DataSource`.\n     * @param styleSetName The name of the [[StyleSet]] to refer to in a [[Theme]], to decode vector\n     * tiles.\n     * @param minZoomLevel Minimum zoom level this `DataSource` can be displayed in.\n     * @param maxZoomLevel Maximum zoom level this `DataSource` can be displayed in.\n     * @param storageLevelOffset Storage level offset applied to this `DataSource`.\n     */\n    constructor(uniqueName, styleSetName, minZoomLevel, maxZoomLevel, storageLevelOffset) {\n        super();\n        /**\n         * Set to `true` if this `DataSource` is enabled; `false` otherwise.\n         */\n        this.enabled = true;\n        /**\n         * Set to `true` if the [[MapView]] can cache tiles produced by this `DataSource`.\n         */\n        this.cacheable = false;\n        /**\n         * Set to `true` if the loader should be used to get the tile contents.\n         */\n        this.useGeometryLoader = false;\n        /**\n         * Whether the datasource should have a ground plane (this plane covers the tile entirely and\n         * has the minimum possible renderOrder), this can be required in some cases when fallback\n         * parent tiles need to be covered by the children, otherwise the content will overlap.\n         * Default is false\n         */\n        this.addGroundPlane = false;\n        /**\n         * Minimum zoom level this `DataSource` can be displayed in.\n         */\n        this.m_minZoomLevel = 1;\n        /**\n         * Maximum zoom level this `DataSource` can be displayed in.\n         */\n        this.m_maxZoomLevel = 20;\n        /**\n         * Current value of [[maxGeometryHeight]] property.\n         */\n        this.m_maxGeometryHeight = 0;\n        /**\n         * Storage level offset applied to this `DataSource`.\n         */\n        this.m_storageLevelOffset = 0;\n        if (uniqueName === undefined || uniqueName.length === 0) {\n            uniqueName = `anonymous-datasource#${++DataSource.uniqueNameCounter}`;\n        }\n        this.name = uniqueName;\n        this.styleSetName = styleSetName;\n        if (minZoomLevel !== undefined) {\n            this.m_minZoomLevel = minZoomLevel;\n        }\n        if (maxZoomLevel !== undefined) {\n            this.m_maxZoomLevel = maxZoomLevel;\n        }\n        if (storageLevelOffset !== undefined) {\n            this.m_storageLevelOffset = storageLevelOffset;\n        }\n    }\n    /**\n     * Returns the name of the [[StyleSet]] to use for the decoding.\n     */\n    get styleSetName() {\n        return this.m_styleSetName;\n    }\n    /**\n     * Sets the name of the [[StyleSet]] to use for the decoding. If this [[DataSource]] is already\n     * attached to a [[MapView]], this setter then reapplies [[StyleSet]] with this name found in\n     * [[MapView]]s theme.\n     */\n    set styleSetName(styleSetName) {\n        this.m_styleSetName = styleSetName;\n        if (this.m_mapView !== undefined && styleSetName !== undefined) {\n            this.setTheme(this.m_mapView.theme);\n        }\n    }\n    /**\n     * Destroys this `DataSource`.\n     */\n    dispose() {\n        // to be overloaded by subclasses\n    }\n    /**\n     * Purges all the caching done by this `DataSource`\n     */\n    clearCache() {\n        // to be overloaded by subclasses\n    }\n    /**\n     * Returns `true` if this `DataSource` is ready and the [[MapView]] can invoke `getTile()` to\n     * start requesting data.\n     */\n    ready() {\n        return true;\n    }\n    /**\n     * The [[MapView]] that is holding this `DataSource`.\n     */\n    get mapView() {\n        if (this.m_mapView === undefined) {\n            throw new Error(\"This DataSource was not added to MapView\");\n        }\n        return this.m_mapView;\n    }\n    /**\n     * The [[Projection]] used by the [[MapView]] that is holding this `DataSource`.\n     *\n     * An `Error` is thrown if you call this method before this `DataSource` has been added\n     * to a [[MapView]].\n     */\n    get projection() {\n        return this.mapView.projection;\n    }\n    /**\n     * This method is called when the `DataSource` is added to a [[MapView]]. Reimplement this\n     * method to provide any custom initialization, such as, to establish a network connection,\n     * or to initialize complex data structures.\n     */\n    async connect() {\n        // to be overloaded by subclasses\n    }\n    /**\n     * This method is called when this `DataSource` is added to a [[MapView]].\n     *\n     * Reimplementations of this method must invoke the definition of the super class.\n     *\n     * @param mapView The instance of the [[MapView]].\n     */\n    attach(mapView) {\n        this.m_mapView = mapView;\n    }\n    /**\n     * This method is called when this `DataSource` is removed from a [[MapView]].\n     *\n     * Reimplementations of this method must invoke the definition of the super class.\n     *\n     * @param mapView The instance of the [[MapView]].\n     */\n    detach(mapView) {\n        harp_utils_1.assert(this.m_mapView === mapView);\n        this.m_mapView = undefined;\n    }\n    /**\n     * Invoked by [[MapView]] to notify when the [[Theme]] has been changed.\n     *\n     * If `DataSource` depends on a `styleSet` or `languages`, it must update its tiles' geometry.\n     *\n     * @deprecated, Use [[setTheme]].\n     *\n     * @param styleSet The new theme that [[MapView]] uses.\n     * @param languages An optional list of languages for the `DataSource`.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    setStyleSet(styleSet, definitions, languages) {\n        // to be overwritten by subclasses\n    }\n    /**\n     * Apply the [[Theme]] to this data source.\n     *\n     * If `DataSource` depends on a `styleSet` defined by this theme or `languages`, it must update\n     * its tiles' geometry.\n     *\n     * @param languages\n     */\n    setTheme(theme, languages) {\n        // to be overwritten by subclasses\n    }\n    /**\n     * Used to configure the languages used by the `DataSource` according to priority;\n     * the first language in the array has the highest priority.\n     *\n     * @param languages An array of ISO 639-1 language codes.\n     */\n    setLanguages(languages) {\n        // to be overloaded by subclasses\n    }\n    /**\n     * This method is called by [[MapView]] before the tile needs to be updated, for example after\n     * a theme change.\n     *\n     * @param tile The [[Tile]] to update.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    updateTile(tile) {\n        // to be overloaded by subclasses\n    }\n    /**\n     * This method is called by the [[MapView]] to determine if the content of the surrounding\n     * tiles must be preloaded.\n     *\n     * @returns `true` if the [[MapView]] should try to preload tiles surrounding the visible\n     * tiles; `false` otherwise. The default is `false`.\n     */\n    shouldPreloadTiles() {\n        return false;\n    }\n    /**\n     * The minimum zoom level to use for display.\n     *\n     * @returns The minimum zoom level to use for display.\n     */\n    get minZoomLevel() {\n        return this.m_minZoomLevel;\n    }\n    set minZoomLevel(level) {\n        this.m_minZoomLevel = level;\n    }\n    /**\n     * The maximum zoom level to use for display.\n     */\n    get maxZoomLevel() {\n        return this.m_maxZoomLevel;\n    }\n    set maxZoomLevel(level) {\n        this.m_maxZoomLevel = level;\n    }\n    /**\n     * Maximum geometry height above ground level this `DataSource` can produce.\n     *\n     * Used in first stage of frustum culling before [[Tile.maxGeometryHeight]] data is available.\n     *\n     * @default 0.\n     */\n    get maxGeometryHeight() {\n        return this.m_maxGeometryHeight;\n    }\n    set maxGeometryHeight(value) {\n        this.m_maxGeometryHeight = value;\n    }\n    /**\n     * The difference between storage level and display level of tile.\n     *\n     * Storage level offset is a value applied (added) to current zoom level giving\n     * a final tile level being displayed. This way we may differentate current\n     * zoom level from the storage level that is displayed, giving fine grained\n     * control over the tiles being decoded an displayed.\n     */\n    get storageLevelOffset() {\n        return this.m_storageLevelOffset;\n    }\n    /**\n     * Setup the relative offset between storage level and display level of tile.\n     *\n     * @param levelOffset Difference between zoom level and display level.\n     */\n    set storageLevelOffset(levelOffset) {\n        this.m_storageLevelOffset = levelOffset;\n    }\n    /**\n     * Enables or disables overlay of geometry on elevation. It must be overloaded by data sources\n     * supporting this feature.\n     *\n     * @param value True to enable, false to disable.\n     */\n    setEnableElevationOverlay(enable) {\n        // to be overloaded by subclasses\n    }\n    /**\n     * Computes the zoom level to use for display.\n     *\n     * @param zoomLevel The zoom level of the [[MapView]].\n     * @returns The zoom level to use for display.\n     */\n    getDisplayZoomLevel(zoomLevel) {\n        return THREE.Math.clamp(zoomLevel + this.m_storageLevelOffset, this.m_minZoomLevel, this.m_maxZoomLevel);\n    }\n    /**\n     * Returns `true` if [[DataSource]] can load tile with given [[TileKey]] and zoom level.\n     *\n     * @param zoomLevel The zoom level of the [[MapView]].\n     * @param tileKey The unique identifier for a map tile.\n     * @returns `true` if the tile for the given [[TileKey]] can be loaded.\n     */\n    canGetTile(zoomLevel, tileKey) {\n        return tileKey.level <= zoomLevel;\n    }\n    /**\n     * Returns `true` if [[MapView]] should traverse tiles further with given [[TileKey]] and\n     * zoom level.\n     *\n     * @param zoomLevel The zoom level of the [[MapView]].\n     * @param tileKey The unique identifier for a map tile.\n     * @returns `true` if the subtiles of the given [[TileKey]] should be\n     * checked for collisions.\n     */\n    shouldSubdivide(zoomLevel, tileKey) {\n        return tileKey.level <= zoomLevel;\n    }\n    /**\n     * Returns `true` if [[MapView]] should render the text elements with the given [[TileKey]] and\n     * zoom level.\n     *\n     * This is an additional check for the tiles that are already selected for rendering so the\n     * default implementation returns `true`.\n     *\n     * @param zoomLevel The zoom level.\n     * @param tileKey The unique identifier for a map tile.\n     * @returns `true` if the text elements created for the given [[TileKey]] should be rendered.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    shouldRenderText(zoomLevel, tileKey) {\n        return true;\n    }\n    /**\n     * Sends a request to the [[MapView]] to redraw the scene.\n     */\n    requestUpdate() {\n        this.dispatchEvent(UPDATE_EVENT);\n    }\n}\nexports.DataSource = DataSource;\n/**\n * A counter to generate unique names for each `DataSource`, if no name is provided in the\n * constructor.\n */\nDataSource.uniqueNameCounter = 0;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/DataSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DebugContext.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DebugContext.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst isNode = typeof window === \"undefined\";\n/**\n * A `DebugOption` is a pair that consists of an option value and an array of change listeners.\n * Listeners are called up when setting the option's value.\n */\nclass DebugOption extends THREE.EventDispatcher {\n    /**\n     * Constructs the `DebugOption`.\n     *\n     * @param value The value of the option.\n     */\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    /**\n     * Updates the value of a given option.\n     *\n     * @param value The new value for the option.\n     * @param name The name of the option to set.\n     */\n    set(value, name) {\n        this.value = value;\n        this.dispatchEvent({ type: DebugOption.SET_EVENT_TYPE, name, value });\n    }\n}\nDebugOption.SET_EVENT_TYPE = \"set\";\n/**\n * Maintains a map of [[DebugOption]]s. You can add listeners to debug options by passing their\n * names.\n */\nclass DebugContext {\n    /**\n     * Builds a `DebugContext`.\n     */\n    constructor() {\n        this.m_optionsMap = new Map();\n        // If we have a `window` object, we store the context in it to make it available in the\n        // console.\n        if (!isNode && typeof window !== \"undefined\" && window) {\n            const debugInfo = window;\n            debugInfo.__debugContext = this;\n        }\n    }\n    /**\n     * Sets the value of an option. Calls change listeners of that option, even if the value has\n     * not been changed. The change listeners provided here are not called during this set\n     * operation.\n     *\n     * @param name Name of the option.\n     * @param value Value of the option.\n     */\n    setValue(name, value) {\n        let opt = this.m_optionsMap.get(name);\n        if (!opt) {\n            opt = new DebugOption(value);\n            this.m_optionsMap.set(name, opt);\n        }\n        else {\n            opt.set(value, name);\n        }\n    }\n    /**\n     * Gets the option value.\n     *\n     * @param name Name of option.\n     */\n    getValue(name) {\n        const opt = this.m_optionsMap.get(name);\n        return opt ? opt.value : undefined;\n    }\n    /**\n     * Determines if the option is registered.\n     *\n     * @param name Name of option.\n     */\n    hasOption(name) {\n        return this.m_optionsMap.get(name) !== undefined;\n    }\n    /**\n     * Adds a listener to a debug option.\n     *\n     * @param name Name of the option that requires a listener.\n     * @param listener The listener function to add.\n     */\n    addEventListener(name, listener) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        }\n        else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n    /**\n     * Checks for a listener in a debug option.\n     *\n     * @param name Name of the option to check for.\n     * @param listener The listener function to check for.\n     */\n    hasEventListener(name, listener) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        }\n        else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n    /**\n     * Removes a listener from a debug option.\n     *\n     * @param name Name of the option from which to remove a listener.\n     * @param listener The listener function to remove.\n     */\n    removeEventListener(name, listener) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        }\n        else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n    /**\n     * Provides access to the options map. This method is useful for creating an automatic\n     * browser GUI.\n     */\n    get options() {\n        return this.m_optionsMap;\n    }\n    /**\n     * Clears away all debug options. Currently, `THREE.EventDispatcher` does not provide an API\n     * to remove all event listeners.\n     */\n    clear() {\n        this.m_optionsMap.forEach(option => {\n            option.set(undefined, \"\");\n        });\n    }\n}\nexports.DebugContext = DebugContext;\nexports.debugContext = new DebugContext();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/DebugContext.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ \"./node_modules/@here/harp-mapview/lib/MapViewPoints.js\");\nconst ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ \"./node_modules/@here/harp-mapview/lib/ThemeHelpers.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"DecodedTileHelpers\");\nconst DEFAULT_SKIP_PROPERTIES = [\n    ...harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS,\n    \"mapProperties\",\n    \"normalMapProperties\",\n    \"displacementMapProperties\",\n    \"roughnessMapProperties\",\n    \"emissiveMapProperties\",\n    \"alphaMapProperties\",\n    \"metalnessMapProperties\",\n    \"bumpMapProperties\"\n];\n/**\n * Create a material, depending on the rendering technique provided in the options.\n *\n * @param options The material options the subsequent functions need.\n * @param materialUpdateCallback Optional callback when the material gets updated,\n *                               e.g. after texture loading.\n *\n * @returns new material instance that matches `technique.name`\n */\nfunction createMaterial(options, textureReadyCallback) {\n    const technique = options.technique;\n    const Constructor = getMaterialConstructor(technique);\n    const settings = {};\n    if (Constructor === undefined) {\n        return undefined;\n    }\n    if (Constructor.prototype instanceof THREE.RawShaderMaterial &&\n        Constructor !== harp_materials_1.HighPrecisionLineMaterial) {\n        settings.fog = options.fog;\n    }\n    const material = new Constructor(settings);\n    if (technique.id !== undefined) {\n        material.name = technique.id;\n    }\n    if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n        material.flatShading = true;\n        // We do not support mixing vertex colors (static) and material colors (may be dynamic)\n        // mixture. Vertex colors are stored in VBO and are not modifiable - some solution for\n        // this problem is proposed in the HARP-8289 and PR #1164.\n        // TODO: Remove when problem with substitute (vertex & material) colors will be solved.\n        if (technique.vertexColors === true) {\n            delete technique.color;\n        }\n    }\n    material.depthTest = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;\n    if (harp_datasource_protocol_1.isStandardTechnique(technique) ||\n        harp_datasource_protocol_1.isTerrainTechnique(technique) ||\n        harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n        harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName) => {\n            const textureProperty = technique[texturePropertyName];\n            if (textureProperty === undefined) {\n                return;\n            }\n            const onLoad = (texture) => {\n                const properties = technique[texturePropertyName + \"Properties\"];\n                if (properties !== undefined) {\n                    if (properties.wrapS !== undefined) {\n                        texture.wrapS = ThemeHelpers_1.toWrappingMode(properties.wrapS);\n                    }\n                    if (properties.wrapT !== undefined) {\n                        texture.wrapT = ThemeHelpers_1.toWrappingMode(properties.wrapT);\n                    }\n                    if (properties.magFilter !== undefined) {\n                        texture.magFilter = ThemeHelpers_1.toTextureFilter(properties.magFilter);\n                    }\n                    if (properties.minFilter !== undefined) {\n                        texture.minFilter = ThemeHelpers_1.toTextureFilter(properties.minFilter);\n                    }\n                    if (properties.flipY !== undefined) {\n                        texture.flipY = properties.flipY;\n                    }\n                    if (properties.repeatU !== undefined) {\n                        texture.repeat.x = properties.repeatU;\n                    }\n                    if (properties.repeatV !== undefined) {\n                        texture.repeat.y = properties.repeatV;\n                    }\n                }\n                material[texturePropertyName] = texture;\n                texture.needsUpdate = true;\n                material.needsUpdate = true;\n                if (textureReadyCallback) {\n                    textureReadyCallback(texture);\n                }\n            };\n            const onError = (error) => {\n                logger.error(\"#createMaterial: Failed to load texture: \", error);\n            };\n            let textureUrl;\n            if (typeof textureProperty === \"string\") {\n                textureUrl = textureProperty;\n            }\n            else if (harp_datasource_protocol_1.isTextureBuffer(textureProperty)) {\n                if (textureProperty.type === \"image/raw\") {\n                    const properties = textureProperty.dataTextureProperties;\n                    if (properties !== undefined) {\n                        const textureDataType = properties.type\n                            ? ThemeHelpers_1.toTextureDataType(properties.type)\n                            : undefined;\n                        const textureBuffer = getTextureBuffer(textureProperty.buffer, textureDataType);\n                        const texture = new THREE.DataTexture(textureBuffer, properties.width, properties.height, properties.format ? ThemeHelpers_1.toPixelFormat(properties.format) : undefined, textureDataType);\n                        onLoad(texture);\n                    }\n                    else {\n                        onError(\"no data texture properties provided.\");\n                    }\n                }\n                else {\n                    const textureBlob = new Blob([textureProperty.buffer], {\n                        type: textureProperty.type\n                    });\n                    textureUrl = URL.createObjectURL(textureBlob);\n                }\n            }\n            if (textureUrl) {\n                new THREE.TextureLoader().load(textureUrl, onLoad, undefined, // onProgress\n                onError);\n            }\n        });\n    }\n    if (harp_datasource_protocol_1.isShaderTechnique(technique)) {\n        // Special case for ShaderTechnique.\n        applyShaderTechniqueToMaterial(technique, material);\n    }\n    else {\n        // Generic technique.\n        applyTechniqueToMaterial(technique, material, options.level, options.skipExtraProps);\n    }\n    return material;\n}\nexports.createMaterial = createMaterial;\n/**\n * Returns a [[THREE.BufferAttribute]] created from a provided [[BufferAttribute]] object.\n *\n * @param attribute BufferAttribute a WebGL compliant buffer\n */\nfunction getBufferAttribute(attribute) {\n    switch (attribute.type) {\n        case \"float\":\n            return new THREE.BufferAttribute(new Float32Array(attribute.buffer), attribute.itemCount);\n        case \"uint8\":\n            return new THREE.BufferAttribute(new Uint8Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        case \"uint16\":\n            return new THREE.BufferAttribute(new Uint16Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        case \"uint32\":\n            return new THREE.BufferAttribute(new Uint32Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        case \"int8\":\n            return new THREE.BufferAttribute(new Int8Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        case \"int16\":\n            return new THREE.BufferAttribute(new Int16Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        case \"int32\":\n            return new THREE.BufferAttribute(new Int32Array(attribute.buffer), attribute.itemCount, attribute.normalized);\n        default:\n            throw new Error(`unsupported buffer of type ${attribute.type}`);\n    } // switch\n}\nexports.getBufferAttribute = getBufferAttribute;\n/**\n * Gets the default `three.js` object constructor associated with the given technique.\n *\n * @param technique The technique.\n */\nfunction getObjectConstructor(technique) {\n    if (technique.name === undefined) {\n        return undefined;\n    }\n    switch (technique.name) {\n        case \"extruded-line\":\n        case \"standard\":\n        case \"terrain\":\n        case \"extruded-polygon\":\n        case \"fill\":\n        case \"dashed-line\":\n        case \"solid-line\":\n            return THREE.Mesh;\n        case \"circles\":\n            return MapViewPoints_1.Circles;\n        case \"squares\":\n            return MapViewPoints_1.Squares;\n        case \"line\":\n            return THREE.LineSegments;\n        case \"segments\":\n            return THREE.LineSegments;\n        case \"shader\": {\n            if (!harp_datasource_protocol_1.isShaderTechnique(technique)) {\n                throw new Error(\"Invalid technique\");\n            }\n            switch (technique.primitive) {\n                case \"line\":\n                    return THREE.Line;\n                case \"segments\":\n                    return THREE.LineSegments;\n                case \"point\":\n                    return THREE.Points;\n                case \"mesh\":\n                    return THREE.Mesh;\n                default:\n                    return undefined;\n            }\n        }\n        case \"text\":\n        case \"labeled-icon\":\n        case \"line-marker\":\n        case \"label-rejection-line\":\n            return undefined;\n    }\n}\nexports.getObjectConstructor = getObjectConstructor;\n/**\n * Non material properties of [[BaseTechnique]]\n */\nexports.BASE_TECHNIQUE_NON_MATERIAL_PROPS = [\"name\", \"id\", \"renderOrder\", \"transient\"];\n/**\n * Returns a [[MaterialConstructor]] basing on provided technique object.\n *\n * @param technique [[Technique]] object which the material will be based on.\n */\nfunction getMaterialConstructor(technique) {\n    if (technique.name === undefined) {\n        return undefined;\n    }\n    switch (technique.name) {\n        case \"extruded-line\":\n            if (!harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {\n                throw new Error(\"Invalid extruded-line technique\");\n            }\n            return technique.shading === \"standard\"\n                ? harp_materials_1.MapMeshStandardMaterial\n                : harp_materials_1.MapMeshBasicMaterial;\n        case \"standard\":\n        case \"terrain\":\n        case \"extruded-polygon\":\n            return harp_materials_1.MapMeshStandardMaterial;\n        case \"dashed-line\":\n        case \"solid-line\":\n            return harp_materials_1.SolidLineMaterial;\n        case \"fill\":\n            return harp_materials_1.MapMeshBasicMaterial;\n        case \"squares\":\n            return THREE.PointsMaterial;\n        case \"circles\":\n            return harp_materials_1.CirclePointsMaterial;\n        case \"line\":\n        case \"segments\":\n            return THREE.LineBasicMaterial;\n        case \"shader\":\n            return THREE.ShaderMaterial;\n        case \"text\":\n        case \"labeled-icon\":\n        case \"line-marker\":\n        case \"label-rejection-line\":\n            return undefined;\n    }\n}\nexports.getMaterialConstructor = getMaterialConstructor;\n/**\n * Allows to easy parse/encode technique's base color property value as number coded color.\n *\n * Function takes care about property parsing, interpolation and encoding if neccessary. If\n * you wish to get default value without interpolation simply ignore @param zoom when calling.\n *\n * @see ColorUtils\n * @param technique the technique where we search for base (transparency) color value\n * @param zoomLevel zoom level used for value interpolation.\n * @returns [[number]] encoded color value (in custom #TTRRGGBB) format or [[undefined]] if\n * base color property is not defined in the technique passed.\n */\nfunction evaluateBaseColorProperty(technique, zoomLevel) {\n    const baseColorProp = getBaseColorProp(technique);\n    if (baseColorProp !== undefined) {\n        return evaluateColorProperty(baseColorProp, zoomLevel);\n    }\n    return undefined;\n}\nexports.evaluateBaseColorProperty = evaluateBaseColorProperty;\n/**\n * Apply [[ShaderTechnique]] parameters to material.\n *\n * @param technique the [[ShaderTechnique]] which requires special handling\n * @param material material to which technique will be applied\n */\nfunction applyShaderTechniqueToMaterial(technique, material) {\n    // The shader technique takes the argument from its `params' member.\n    const params = technique.params;\n    // Remove base color and transparency properties from the processed set.\n    const baseColorPropName = getBaseColorPropName(technique);\n    const hasBaseColor = baseColorPropName && baseColorPropName in technique.params;\n    const props = Object.getOwnPropertyNames(params).filter(propertyName => {\n        // Omit base color and related transparency attributes if its defined in technique\n        if (baseColorPropName === propertyName ||\n            (hasBaseColor && harp_datasource_protocol_1.TRANSPARENCY_PROPERTY_KEYS.indexOf(propertyName) !== -1)) {\n            return false;\n        }\n        const prop = propertyName;\n        if (prop === \"name\") {\n            // skip reserved property names\n            return false;\n        }\n        return true;\n    });\n    // Apply all technique properties omitting base color and transparency attributes.\n    props.forEach(propertyName => {\n        // TODO: Check if properties values should not be interpolated, possible bug in old code!\n        // This behavior is kept in the new version too, level is set to undefined.\n        applyTechniquePropertyToMaterial(material, propertyName, params[propertyName]);\n    });\n    if (hasBaseColor) {\n        const propColor = baseColorPropName;\n        // Finally apply base color and related properties to material (opacity, transparent)\n        applyBaseColorToMaterial(material, material[propColor], technique, params[propColor]);\n    }\n}\n/**\n * Apply generic technique parameters to material.\n *\n * Skips non-material [[Technique]] props:\n *  * [[BaseTechnique]] props,\n *  * `name` which is used as discriminator for technique types,\n *  * props starting with `_`\n *  * props found `skipExtraProps`\n *\n * `THREE.Color` properties are supported.\n *\n * @param technique technique from where params are copied\n * @param material target material\n * @param zoomLevel tile zoom level for zoom-level dependent props\n * @param skipExtraProps optional, skipped props.\n */\nfunction applyTechniqueToMaterial(technique, material, zoomLevel, skipExtraProps) {\n    // Remove transparent color from the firstly processed properties set.\n    const baseColorPropName = getBaseColorPropName(technique);\n    const hasBaseColor = baseColorPropName && baseColorPropName in technique;\n    const genericProps = Object.getOwnPropertyNames(technique).filter(propertyName => {\n        if (propertyName.startsWith(\"_\") ||\n            exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS.indexOf(propertyName) !== -1 ||\n            DEFAULT_SKIP_PROPERTIES.indexOf(propertyName) !== -1 ||\n            (skipExtraProps !== undefined && skipExtraProps.indexOf(propertyName) !== -1)) {\n            return false;\n        }\n        // Omit base color and related transparency attributes if its defined in technique.\n        if (baseColorPropName === propertyName ||\n            (hasBaseColor && harp_datasource_protocol_1.TRANSPARENCY_PROPERTY_KEYS.indexOf(propertyName) !== -1)) {\n            return false;\n        }\n        const prop = propertyName;\n        const m = material;\n        if (typeof m[prop] === \"undefined\") {\n            return false;\n        }\n        return true;\n    });\n    // Apply all other properties (even colors), but not transparent (base) ones.\n    genericProps.forEach(propertyName => {\n        const value = technique[propertyName];\n        if (value !== undefined) {\n            applyTechniquePropertyToMaterial(material, propertyName, value, zoomLevel);\n        }\n    });\n    // Finally apply base (possibly transparent) color itself, using blend modes to\n    // provide transparency if needed.\n    if (hasBaseColor) {\n        applyBaseColorToMaterial(material, material[baseColorPropName], technique, technique[baseColorPropName], zoomLevel);\n    }\n}\n/**\n * Apply single and generic technique property to corresponding material parameter.\n *\n * @note Special handling for material attributes of [[THREE.Color]] type is provided thus it\n * does not provide constructor that would take [[string]] or [[number]] values.\n *\n * @param material target material\n * @param propertyName material and technique parameter name (or index) that is to be transferred\n * @param techniqueAttrValue technique property value which will be applied to material attribute\n * @param zoomLevel optional tile zoom level.\n */\nfunction applyTechniquePropertyToMaterial(material, propertyName, techniqueAttrValue, zoomLevel) {\n    const m = material;\n    if (m[propertyName] instanceof THREE.Color) {\n        applySecondaryColorToMaterial(material[propertyName], techniqueAttrValue, zoomLevel);\n    }\n    else {\n        m[propertyName] = evaluateProperty(techniqueAttrValue, zoomLevel);\n    }\n}\n/**\n * Apply technique color to material taking special care with transparent (RGBA) colors.\n *\n * @note This function is intended to be used with secondary, triary etc. technique colors,\n * not the base ones that may contain transparency information. Such colors should be processed\n * with [[applyTechniqueBaseColorToMaterial]] function.\n *\n * @param technique an technique the applied color comes from\n * @param material the material to which color is applied\n * @param prop technique property (color) name\n * @param value color value\n * @param zoomLevel optional tile zoom level for zoom-level dependent properties are evaluated.\n */\nfunction applySecondaryColorToMaterial(materialColor, techniqueColor, zoomLevel) {\n    let value = evaluateColorProperty(techniqueColor, zoomLevel);\n    if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(value)) {\n        logger.warn(\"Used RGBA value for technique color without transparency support!\");\n        // Just for clarity remove transparency component, even if that would be ignored\n        // by THREE.Color.setHex() function.\n        value = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(value);\n    }\n    materialColor.setHex(value);\n}\nexports.applySecondaryColorToMaterial = applySecondaryColorToMaterial;\n/**\n * Apply technique base color (transparency support) to material with modifying material opacity.\n *\n * This method applies main (or base) technique color with transparency support to the corresponding\n * material color, with an effect on entire [[THREE.Material]] __opacity__ and __transparent__\n * attributes.\n *\n * @note Transparent colors should be processed as the very last technique attributes,\n * since their effect on material properties like [[THREE.Material.opacity]] and\n * [[THREE.Material.transparent]] could be overridden by corresponding technique params.\n *\n * @param technique an technique the applied color comes from\n * @param material the material to which color is applied\n * @param prop technique property (color) name\n * @param value color value in custom number format\n * @param zoomLevel optional, tile zoom level for zoom-level dependent properties are evaluated.\n */\nfunction applyBaseColorToMaterial(material, materialColor, technique, techniqueColor, zoomLevel) {\n    const colorValue = evaluateColorProperty(techniqueColor, zoomLevel);\n    const { r, g, b, a } = harp_datasource_protocol_1.ColorUtils.getRgbaFromHex(colorValue);\n    // Override material opacity and blending by mixing technique defined opacity\n    // with main color transparency\n    const tech = technique;\n    let opacity = a;\n    if (tech.opacity !== undefined) {\n        opacity *= evaluateProperty(tech.opacity, zoomLevel);\n    }\n    opacity = THREE.Math.clamp(opacity, 0, 1);\n    material.opacity = opacity;\n    materialColor.setRGB(r, g, b);\n    const opaque = opacity >= 1.0;\n    if (!opaque) {\n        harp_materials_1.enableBlending(material);\n    }\n    else {\n        harp_materials_1.disableBlending(material);\n    }\n}\nexports.applyBaseColorToMaterial = applyBaseColorToMaterial;\n/**\n * Calculates the value of the technique defined property.\n *\n * Function takes care about property interpolation (when @param zoom is set) as also parsing\n * string encoded numbers.\n *\n * @note Use with care, because function does not recognize property type.\n * @param value the value of color property defined in technique\n * @param zoomLevel zoom level used for interpolation.\n */\nfunction evaluateProperty(value, zoomLevel) {\n    if (zoomLevel !== undefined && (harp_datasource_protocol_1.isInterpolatedProperty(value) || harp_datasource_protocol_1.Expr.isExpr(value))) {\n        value = harp_datasource_protocol_1.getPropertyValue(value, zoomLevel);\n    }\n    return value;\n}\n/**\n * Calculates the numerical value of the technique defined color property.\n *\n * Function takes care about color interpolation (when @param zoom is set) as also parsing\n * string encoded colors.\n *\n * @note Use with care, because function does not recognize property type.\n * @param value the value of color property defined in technique\n * @param zoomLevel zoom level used for interpolation.\n */\nfunction evaluateColorProperty(value, zoomLevel) {\n    value = evaluateProperty(value, zoomLevel);\n    if (typeof value === \"number\") {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        const parsed = harp_datasource_protocol_1.parseStringEncodedColor(value);\n        if (parsed !== undefined) {\n            return parsed;\n        }\n    }\n    throw new Error(`Unsupported color format: '${value}'`);\n}\nexports.evaluateColorProperty = evaluateColorProperty;\n/**\n * Allows to access base color property value for given technique.\n *\n * The color value may be encoded in [[number]], [[string]] or even as\n * [[InterpolateProperty]].\n *\n * @param technique The techniqe where we seach for base color property.\n * @returns The value of technique color used to apply transparency.\n */\nfunction getBaseColorProp(technique) {\n    const baseColorPropName = getBaseColorPropName(technique);\n    if (baseColorPropName !== undefined) {\n        if (!harp_datasource_protocol_1.isShaderTechnique(technique)) {\n            const propColor = baseColorPropName;\n            return technique[propColor];\n        }\n        else {\n            const params = technique.params;\n            const propColor = baseColorPropName;\n            return params[propColor];\n        }\n    }\n    return undefined;\n}\nfunction getBaseColorPropName(technique) {\n    const techDescriptor = harp_datasource_protocol_1.techniqueDescriptors[technique.name];\n    return techDescriptor !== undefined ? techDescriptor.attrTransparencyColor : undefined;\n}\nfunction getTextureBuffer(buffer, textureDataType) {\n    if (textureDataType === undefined) {\n        return new Uint8Array(buffer);\n    }\n    switch (textureDataType) {\n        case THREE.UnsignedByteType:\n            return new Uint8Array(buffer);\n        case THREE.ByteType:\n            return new Int8Array(buffer);\n        case THREE.ShortType:\n            return new Int16Array(buffer);\n        case THREE.UnsignedShortType:\n            return new Uint16Array(buffer);\n        case THREE.IntType:\n            return new Int32Array(buffer);\n        case THREE.UnsignedIntType:\n            return new Uint32Array(buffer);\n        case THREE.FloatType:\n            return new Float32Array(buffer);\n        case THREE.HalfFloatType:\n            return new Uint16Array(buffer);\n    }\n    throw new Error(\"Unsupported texture data type\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/DepthPrePass.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/DepthPrePass.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst ColorUtils_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/ColorUtils */ \"./node_modules/@here/harp-datasource-protocol/lib/ColorUtils.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\");\n/**\n * Bitmask used for the depth pre-pass to prevent multiple fragments in the same screen position\n * from rendering color.\n */\nexports.DEPTH_PRE_PASS_STENCIL_MASK = 0x01;\n/**\n * Render order offset for the depth pre-pass to ensure that it's rendered first.\n */\nconst DEPTH_PRE_PASS_RENDER_ORDER_OFFSET = 1e-6;\n/**\n * Check if technique requires (and not disables) use of depth prepass.\n *\n * Depth prepass is enabled if correct opacity is specified (in range `(0,1)`) _and_ not explicitly\n * disabled by `enableDepthPrePass` option.\n *\n * @param technique [[BaseStandardTechnique]] instance to be checked\n */\nfunction isRenderDepthPrePassEnabled(technique) {\n    // Depth pass explicitly disabled\n    if (technique.enableDepthPrePass === false) {\n        return false;\n    }\n    let transparent = technique.opacity !== undefined && technique.opacity > 0.0 && technique.opacity < 1.0;\n    // If not opaque then check if transparency may be modified via alpha in base color.\n    // Otherwise we don't need to even test base color because opacity mixed with any base alpha,\n    // will always produce some transparency effect.\n    if (!transparent) {\n        // We do not support switching depth pass during alpha interpolation, ignore zoom level\n        // when calculating base color value.\n        const color = DecodedTileHelpers_1.evaluateBaseColorProperty(technique);\n        if (color !== undefined) {\n            const alpha = ColorUtils_1.ColorUtils.getAlphaFromHex(color);\n            transparent = alpha > 0.0 && alpha < 1.0;\n        }\n    }\n    return transparent;\n}\nexports.isRenderDepthPrePassEnabled = isRenderDepthPrePassEnabled;\n/**\n * Creates material for depth prepass.\n *\n * Creates material that writes only to the z-buffer. Updates the original material instance, to\n * support depth prepass.\n *\n * @param baseMaterial The base material of mesh that is updated to work with depth prepass\n *     and then used. This parameter is a template for depth prepass material that is returned.\n * @returns depth prepass material, which is a clone of `baseMaterial` with the adapted settings.\n */\nfunction createDepthPrePassMaterial(baseMaterial) {\n    baseMaterial.depthWrite = false;\n    baseMaterial.depthFunc = THREE.EqualDepth;\n    baseMaterial.colorWrite = true;\n    harp_materials_1.enforceBlending(baseMaterial);\n    const depthPassMaterial = baseMaterial.clone();\n    depthPassMaterial.depthWrite = true;\n    depthPassMaterial.depthTest = true;\n    depthPassMaterial.depthFunc = THREE.LessDepth;\n    depthPassMaterial.colorWrite = false;\n    depthPassMaterial.opacity = 1.0;\n    depthPassMaterial.blending = THREE.NoBlending;\n    return depthPassMaterial;\n}\nexports.createDepthPrePassMaterial = createDepthPrePassMaterial;\n// tslint:disable:max-line-length\n/**\n * Clones a given mesh to render it in the depth prepass with another material. Both the original\n * and depth prepass meshes, when rendered in the correct order, create the proper depth prepass\n * effect. The original mesh material is slightly modified by [[createDepthPrePassMaterial]] to\n * support the depth prepass. This method is usable only if the material of this mesh has an\n * opacity value in the range `(0,1)`.\n *\n * The DepthPrePass object is created wis a slightly smaller `renderOrder` as the original mesh\n * to ensure that it's rendered first.\n *\n * @param mesh original mesh\n * @returns `Mesh` depth pre pass\n */\n// tslint:enable:max-line-length\nfunction createDepthPrePassMesh(mesh) {\n    const originalGeometry = mesh.geometry;\n    if (!(originalGeometry instanceof THREE.BufferGeometry)) {\n        throw new Error(\"#createDepthPassMesh only BufferGeometry is supported\");\n    }\n    const positionAttribute = originalGeometry.getAttribute(\"position\");\n    if (!positionAttribute) {\n        throw new Error(\"#createDepthPassMesh position attribute not found\");\n    }\n    const depthPassGeometry = new THREE.BufferGeometry();\n    depthPassGeometry.setAttribute(\"position\", positionAttribute);\n    const uvAttribute = originalGeometry.getAttribute(\"uv\");\n    if (uvAttribute) {\n        depthPassGeometry.setAttribute(\"uv\", uvAttribute);\n    }\n    const normalAttribute = originalGeometry.getAttribute(\"normal\");\n    if (normalAttribute) {\n        depthPassGeometry.setAttribute(\"normal\", normalAttribute);\n    }\n    const extrusionAxisAttribute = originalGeometry.getAttribute(\"extrusionAxis\");\n    if (extrusionAxisAttribute) {\n        depthPassGeometry.setAttribute(\"extrusionAxis\", extrusionAxisAttribute);\n    }\n    if (originalGeometry.index) {\n        depthPassGeometry.setIndex(originalGeometry.index);\n    }\n    for (const group of originalGeometry.groups) {\n        const { start, count, materialIndex } = group;\n        depthPassGeometry.addGroup(start, count, materialIndex);\n    }\n    const depthPassMaterial = mesh.material instanceof Array\n        ? mesh.material.map(createDepthPrePassMaterial)\n        : createDepthPrePassMaterial(mesh.material);\n    const depthPassMesh = new THREE.Mesh(depthPassGeometry, depthPassMaterial);\n    depthPassMesh.renderOrder = mesh.renderOrder - DEPTH_PRE_PASS_RENDER_ORDER_OFFSET;\n    return depthPassMesh;\n}\nexports.createDepthPrePassMesh = createDepthPrePassMesh;\n/**\n * Sets up all the needed stencil logic needed for the depth pre-pass.\n *\n * This logic is in place to avoid z-fighting artifacts that can appear in geometries that have\n * coplanar triangles inside the same mesh.\n *\n * @param depthMesh Mesh created by `createDepthPrePassMesh`.\n * @param colorMesh Original mesh.\n */\nfunction setDepthPrePassStencil(depthMesh, colorMesh) {\n    // Set up depth mesh stencil logic.\n    // Set the depth pre-pass stencil bit for all processed fragments. We use\n    // `THREE.AlwaysStencilFunc` and not `THREE.NotEqualStencilFunc` to force all fragments to pass\n    // the stencil test and write the correct depth value.\n    const depthMaterial = depthMesh.material;\n    depthMaterial.stencilWrite = true;\n    depthMaterial.stencilFail = THREE.KeepStencilOp;\n    depthMaterial.stencilZFail = THREE.KeepStencilOp;\n    depthMaterial.stencilZPass = THREE.ReplaceStencilOp;\n    depthMaterial.stencilFunc = THREE.AlwaysStencilFunc;\n    depthMaterial.stencilRef = 0xff;\n    depthMaterial.stencilFuncMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;\n    // Set up color mesh stencil logic.\n    // Only write color for pixels with the depth pre-pass stencil bit set. Also, once a pixel is\n    // rendered, set the stencil bit to 0 to prevent subsequent pixels in the same clip position\n    // from rendering color again.\n    const colorMaterial = colorMesh.material;\n    colorMaterial.stencilWrite = true;\n    colorMaterial.stencilFail = THREE.KeepStencilOp;\n    colorMaterial.stencilZFail = THREE.KeepStencilOp;\n    colorMaterial.stencilZPass = THREE.ZeroStencilOp;\n    colorMaterial.stencilFunc = THREE.EqualStencilFunc;\n    colorMaterial.stencilRef = 0xff;\n    colorMaterial.stencilFuncMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;\n}\nexports.setDepthPrePassStencil = setDepthPrePassStencil;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/DepthPrePass.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Status of the elevation range calculation.\n */\nvar CalculationStatus;\n(function (CalculationStatus) {\n    // Calculated approximately. A more precise result may be available later.\n    CalculationStatus[CalculationStatus[\"PendingApproximate\"] = 0] = \"PendingApproximate\";\n    // Calculation completed. The result is final, won't improve upon retrying.\n    CalculationStatus[CalculationStatus[\"FinalPrecise\"] = 1] = \"FinalPrecise\";\n})(CalculationStatus = exports.CalculationStatus || (exports.CalculationStatus = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/FrustumIntersection.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/FrustumIntersection.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst ElevationRangeSource_1 = __webpack_require__(/*! ./ElevationRangeSource */ \"./node_modules/@here/harp-mapview/lib/ElevationRangeSource.js\");\nconst MapTileCuller_1 = __webpack_require__(/*! ./MapTileCuller */ \"./node_modules/@here/harp-mapview/lib/MapTileCuller.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\nconst tmpVectors3 = [new THREE.Vector3(), new THREE.Vector3()];\nconst tmpVector4 = new THREE.Vector4();\n/**\n * Represents a unique TileKey and the area it takes up on screen.\n *\n * Note, in certain tiling projections, it is possible to have an offset, which represents a tile\n * which has fully wrapped around, hence this defaults to 0 to simplify usage for projections which\n * don't require it.\n */\nclass TileKeyEntry {\n    constructor(tileKey, area, offset = 0, minElevation = 0, maxElevation = 0, distance = 0) {\n        this.tileKey = tileKey;\n        this.area = area;\n        this.offset = offset;\n        this.minElevation = minElevation;\n        this.maxElevation = maxElevation;\n        this.distance = distance;\n    }\n}\nexports.TileKeyEntry = TileKeyEntry;\nfunction getGeoBox(tilingScheme, childTileKey, offset) {\n    const geoBox = tilingScheme.getGeoBox(childTileKey);\n    const longitudeOffset = 360.0 * offset;\n    geoBox.northEast.longitude += longitudeOffset;\n    geoBox.southWest.longitude += longitudeOffset;\n    return geoBox;\n}\n/**\n * Computes the tiles intersected by the frustum defined by the current camera setup.\n */\nclass FrustumIntersection {\n    constructor(m_camera, mapView, m_extendedFrustumCulling, m_tileWrappingEnabled, m_enableMixedLod) {\n        this.m_camera = m_camera;\n        this.mapView = mapView;\n        this.m_extendedFrustumCulling = m_extendedFrustumCulling;\n        this.m_tileWrappingEnabled = m_tileWrappingEnabled;\n        this.m_enableMixedLod = m_enableMixedLod;\n        this.m_frustum = new THREE.Frustum();\n        // used to project global coordinates into camera local coordinates\n        this.m_viewProjectionMatrix = new THREE.Matrix4();\n        this.m_rootTileKeys = [];\n        this.m_tileKeyEntries = new Map();\n        this.m_mapTileCuller = new MapTileCuller_1.MapTileCuller(m_camera);\n    }\n    /**\n     * Return camera used for generating frustum.\n     */\n    get camera() {\n        return this.m_camera;\n    }\n    /**\n     * Return projection used to convert geo coordinates to world coordinates.\n     */\n    get projection() {\n        return this.mapView.projection;\n    }\n    /**\n     * Updates the frustum to match the current camera setup.\n     */\n    updateFrustum(projectionMatrixOverride) {\n        this.m_viewProjectionMatrix.multiplyMatrices(projectionMatrixOverride !== undefined\n            ? projectionMatrixOverride\n            : this.m_camera.projectionMatrix, this.m_camera.matrixWorldInverse);\n        this.m_frustum.setFromMatrix(this.m_viewProjectionMatrix);\n        if (this.m_extendedFrustumCulling) {\n            this.m_mapTileCuller.setup();\n        }\n        this.computeRequiredInitialRootTileKeys(this.m_camera.position);\n    }\n    /**\n     * Computes the tiles intersected by the updated frustum, see [[updateFrustum]].\n     *\n     * @param tilingScheme The tiling scheme used to generate the tiles.\n     * @param elevationRangeSource Source of elevation range data if any.\n     * @param zoomLevels A list of zoom levels to render.\n     * @param dataSources A list of data sources to render.\n     * @returns The computation result, see [[FrustumIntersection.Result]].\n     */\n    compute(tilingScheme, elevationRangeSource, zoomLevels, dataSources) {\n        this.m_tileKeyEntries.clear();\n        let calculationFinal = true;\n        // Compute target tile area in clip space size.\n        // A tile should take up roughly 256x256 pixels on screen in accordance to\n        // the zoom level chosen by [MapViewUtils.calculateZoomLevelFromDistance].\n        harp_utils_1.assert(this.mapView.viewportHeight !== 0);\n        const targetTileArea = Math.pow(256 / this.mapView.viewportHeight, 2);\n        const obbIntersections = this.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical;\n        const tileBounds = obbIntersections ? new harp_geoutils_1.OrientedBox3() : new THREE.Box3();\n        const uniqueZoomLevels = new Set(zoomLevels);\n        // create tile key map per zoom level\n        for (const zoomLevel of uniqueZoomLevels) {\n            this.m_tileKeyEntries.set(zoomLevel, new Map());\n        }\n        for (const item of this.m_rootTileKeys) {\n            const tileKeyEntry = new TileKeyEntry(item.tileKey, Infinity, item.offset, item.minElevation, item.maxElevation);\n            for (const zoomLevel of uniqueZoomLevels) {\n                const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);\n                tileKeyEntries.set(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(item.tileKey, item.offset), tileKeyEntry);\n            }\n        }\n        const useElevationRangeSource = elevationRangeSource !== undefined &&\n            elevationRangeSource.getTilingScheme() === tilingScheme;\n        const workList = [...this.m_rootTileKeys.values()];\n        while (workList.length > 0) {\n            const tileEntry = workList.pop();\n            if (tileEntry === undefined) {\n                break;\n            }\n            // Stop subdivision if hightest visible level is reached\n            const tileKey = tileEntry.tileKey;\n            const subdivide = dataSources.some((ds, i) => ds.shouldSubdivide(zoomLevels[i], tileKey));\n            if (!subdivide) {\n                continue;\n            }\n            // Stop subdivision if area of tile is too small(mixed LOD only)\n            if (this.m_enableMixedLod && tileEntry.area < targetTileArea) {\n                continue;\n            }\n            const parentTileKey = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, tileEntry.offset);\n            // delete parent tile key from applicable zoom levels\n            for (const zoomLevel of uniqueZoomLevels) {\n                if (tileKey.level >= zoomLevel) {\n                    continue;\n                }\n                const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);\n                tileKeyEntries.delete(parentTileKey);\n            }\n            for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n                const offset = tileEntry.offset;\n                const tileKeyAndOffset = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);\n                const geoBox = getGeoBox(tilingScheme, childTileKey, offset);\n                // For tiles without elevation range source, default 0 (getGeoBox always\n                // returns box with altitude min/max equal to zero) will be propagated as\n                // min and max elevation, these tiles most probably contains features that\n                // lays directly on the ground surface.\n                if (useElevationRangeSource) {\n                    const range = elevationRangeSource.getElevationRange(childTileKey);\n                    geoBox.southWest.altitude = range.minElevation;\n                    geoBox.northEast.altitude = range.maxElevation;\n                    calculationFinal =\n                        calculationFinal &&\n                            range.calculationStatus === ElevationRangeSource_1.CalculationStatus.FinalPrecise;\n                }\n                this.mapView.projection.projectBox(geoBox, tileBounds);\n                const { area, distance } = this.computeTileAreaAndDistance(tileBounds);\n                if (area > 0) {\n                    const subTileEntry = new TileKeyEntry(childTileKey, area, offset, geoBox.southWest.altitude, // minElevation\n                    geoBox.northEast.altitude, // maxElevation\n                    distance);\n                    // insert sub tile entry into tile entries map per zoom level\n                    for (const zoomLevel of uniqueZoomLevels) {\n                        if (subTileEntry.tileKey.level > zoomLevel) {\n                            continue;\n                        }\n                        const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);\n                        tileKeyEntries.set(tileKeyAndOffset, subTileEntry);\n                    }\n                    workList.push(subTileEntry);\n                }\n            }\n        }\n        return { tileKeyEntries: this.m_tileKeyEntries, calculationFinal };\n    }\n    /**\n     * Estimate screen space area of tile and distance to center of tile\n     * @param tileBounds The bounding volume of a tile\n     * @return Area estimate and distance to tile center in clip space\n     */\n    computeTileAreaAndDistance(tileBounds) {\n        if (tileBounds instanceof THREE.Box3) {\n            if ((this.m_extendedFrustumCulling &&\n                !this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds)) ||\n                !this.m_frustum.intersectsBox(tileBounds)) {\n                return {\n                    area: 0,\n                    distance: Infinity\n                };\n            }\n        }\n        else if (!tileBounds.intersects(this.m_frustum)) {\n            return {\n                area: 0,\n                distance: Infinity\n            };\n        }\n        // Project tile bounds center\n        const center = tileBounds.getCenter(tmpVectors3[0]);\n        const projectedPoint = tmpVector4\n            .set(center.x, center.y, center.z, 1.0)\n            .applyMatrix4(this.m_viewProjectionMatrix);\n        // Estimate objects screen space size with diagonal of bounds\n        // Dividing by w projects object size to screen space\n        const size = tileBounds.getSize(tmpVectors3[1]);\n        const objectSize = (0.5 * size.length()) / projectedPoint.w;\n        return {\n            area: objectSize * objectSize,\n            distance: projectedPoint.z / projectedPoint.w\n        };\n    }\n    /**\n     * Create a list of root nodes to test against the frustum. The root nodes each start at level 0\n     * and have an offset (see [[Tile]]) based on:\n     * - the current position [[worldCenter]].\n     * - the height of the camera above the world.\n     * - the field of view of the camera (the maximum value between the horizontal / vertical\n     *   values)\n     * - the tilt of the camera (because we see more tiles when tilted).\n     *\n     * @param worldCenter The center of the camera in world space.\n     */\n    computeRequiredInitialRootTileKeys(worldCenter) {\n        this.m_rootTileKeys = [];\n        const rootTileKey = harp_geoutils_1.TileKey.fromRowColumnLevel(0, 0, 0);\n        const tileWrappingEnabled = this.mapView.projection.type === harp_geoutils_1.ProjectionType.Planar;\n        if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {\n            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, 0, 0));\n            return;\n        }\n        const worldGeoPoint = this.mapView.projection.unprojectPoint(worldCenter);\n        const startOffset = Math.round(worldGeoPoint.longitude / 360.0);\n        // This algorithm computes the number of offsets we need to test. The following diagram may\n        // help explain the algorithm below.\n        //\n        //   |🎥\n        //   |.\\ .\n        //   | . \\  .\n        // z |  .  \\   .c2\n        //   |  c1.  \\b    .\n        //   |     .   \\      .\n        //___|a___d1.____\\e______.d2______f\n        //\n        // Where:\n        // - 🎥 is the camera\n        // - z is the height of the camera above the ground.\n        // - a is a right angle.\n        // - b is the look at vector of the camera.\n        // - c1 and c2 are the frustum planes of the camera.\n        // - c1 to c2 is the fov.\n        // - d1 and d2 are the intersection points of the frustum with the world plane.\n        // - e is the tilt/pitch of the camera.\n        // - f is the world\n        //\n        // The goal is to find the distance from e->d2. This is a longitude value, and we convert it\n        // to some offset range. Note e->d2 >= e->d1 (because we can't have a negative tilt).\n        // To find e->d2, we use the right triangle 🎥, a, d2 and subtract the distance a->d2 with\n        // a->e.\n        // a->d2 is found using the angle between a and d2 from the 🎥, this is simply e (because of\n        // similar triangles, angle between a, 🎥 and e equals the tilt) + half of the fov (because\n        // we need the angle between e, 🎥 and d2) and using trigonometry, result is therefore:\n        // (tan(a->d2) * z).\n        // a->e needs just the tilt and trigonometry to compute, result is: (tan(a->e) * z).\n        const camera = this.m_camera;\n        const cameraPitch = Utils_1.MapViewUtils.extractAttitude(this.mapView, camera).pitch;\n        // Ensure that the aspect is >= 1.\n        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n        // Angle between a->d2, note, the fov is vertical, hence we translate to horizontal.\n        const totalAngleRad = THREE.Math.degToRad((camera.fov * aspect) / 2) + cameraPitch;\n        // Length a->d2\n        const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;\n        // Length a->e\n        const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;\n        // Length e -> d2\n        const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;\n        const worldLeftPoint = new THREE.Vector3(worldCenter.x - worldLengthHorizontal, worldCenter.y, worldCenter.z);\n        const worldLeftGeoPoint = this.mapView.projection.unprojectPoint(worldLeftPoint);\n        // We multiply by SQRT2 because we need to account for a rotated view (in which case there\n        // are more tiles that can be seen).\n        const offsetRange = THREE.Math.clamp(Math.ceil(Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2), 0, \n        // We can store currently up to 16 unique keys(2^4, where 4 is the default bit-shift\n        // value which is used currently in the [[VisibleTileSet]] methods) hence we can have a\n        // maximum range of 7 (because 2*7+1 = 15).\n        7);\n        for (let offset = -offsetRange + startOffset; offset <= offsetRange + startOffset; offset++) {\n            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, offset, 0, 0));\n        }\n    }\n}\nexports.FrustumIntersection = FrustumIntersection;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/FrustumIntersection.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapTileCuller.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapTileCuller.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Second step tile culling: Do additional check for intersection of box and frustum by checking if\n * the frustum is outside any plane of the tiles `bbox` (oriented, not AABB). It's in the inverse of\n * the standard frustum test, which excludes many cases where the large terrain tiles straddle the\n * planes of the frustum.\n *\n * @see http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm\n */\nclass MapTileCuller {\n    /**\n     * Constructs a `MapTileCuller`.\n     *\n     * @param m_camera A `THREE.Camera`.\n     */\n    constructor(m_camera) {\n        this.m_camera = m_camera;\n        this.m_globalFrustumMin = new THREE.Vector3();\n        this.m_globalFrustumMax = new THREE.Vector3();\n        this.m_frustumCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n    }\n    /**\n     * Sets up culling and computes frustum corners. You mus call this function before the culling\n     * starts.\n     */\n    setup() {\n        const frustumCorners = this.getFrustumCorners();\n        const matrix = this.m_camera.matrixWorld;\n        this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        for (const frustumCorner of frustumCorners) {\n            frustumCorner.applyMatrix4(matrix);\n            this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);\n            this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);\n            this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);\n            this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);\n            this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);\n            this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);\n        }\n    }\n    /**\n     * Checks if the tile's bounding box intersects with the current view's frustum.\n     *\n     * @param tileBounds The bounding box for the tile.\n     */\n    frustumIntersectsTileBox(tileBounds) {\n        const globalFrustumMin = this.m_globalFrustumMin;\n        const globalFrustumMax = this.m_globalFrustumMax;\n        if (globalFrustumMax.x < tileBounds.min.x ||\n            globalFrustumMax.y < tileBounds.min.y ||\n            globalFrustumMax.z < tileBounds.min.z ||\n            globalFrustumMin.x > tileBounds.max.x ||\n            globalFrustumMin.y > tileBounds.max.y ||\n            globalFrustumMin.z > tileBounds.max.z) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns the eight corners of the frustum.\n     */\n    getFrustumCorners() {\n        const frustumCorners = this.m_frustumCorners;\n        const invProjMatrix = this.m_camera.projectionMatrixInverse;\n        let cornerIndex = 0;\n        function addPoint(x, y, z) {\n            frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);\n        }\n        const w = 1;\n        const h = 1;\n        const n = -1;\n        const f = 1;\n        // near\n        addPoint(-w, -h, n);\n        addPoint(w, -h, n);\n        addPoint(-w, h, n);\n        addPoint(w, h, n);\n        // far\n        addPoint(-w, -h, f);\n        addPoint(w, -h, f);\n        addPoint(-w, h, f);\n        addPoint(w, h, f);\n        return frustumCorners;\n    }\n}\nexports.MapTileCuller = MapTileCuller;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapTileCuller.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapView.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapView.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst AnimatedExtrusionHandler_1 = __webpack_require__(/*! ./AnimatedExtrusionHandler */ \"./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js\");\nconst BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ \"./node_modules/@here/harp-mapview/lib/BackgroundDataSource.js\");\nconst CameraMovementDetector_1 = __webpack_require__(/*! ./CameraMovementDetector */ \"./node_modules/@here/harp-mapview/lib/CameraMovementDetector.js\");\nconst ClipPlanesEvaluator_1 = __webpack_require__(/*! ./ClipPlanesEvaluator */ \"./node_modules/@here/harp-mapview/lib/ClipPlanesEvaluator.js\");\nconst composing_1 = __webpack_require__(/*! ./composing */ \"./node_modules/@here/harp-mapview/lib/composing/index.js\");\nconst ConcurrentDecoderFacade_1 = __webpack_require__(/*! ./ConcurrentDecoderFacade */ \"./node_modules/@here/harp-mapview/lib/ConcurrentDecoderFacade.js\");\nconst CopyrightInfo_1 = __webpack_require__(/*! ./copyrights/CopyrightInfo */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js\");\nconst FrustumIntersection_1 = __webpack_require__(/*! ./FrustumIntersection */ \"./node_modules/@here/harp-mapview/lib/FrustumIntersection.js\");\nconst overlayOnElevation_1 = __webpack_require__(/*! ./geometry/overlayOnElevation */ \"./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js\");\nconst PhasedTileGeometryManager_1 = __webpack_require__(/*! ./geometry/PhasedTileGeometryManager */ \"./node_modules/@here/harp-mapview/lib/geometry/PhasedTileGeometryManager.js\");\nconst TileGeometryManager_1 = __webpack_require__(/*! ./geometry/TileGeometryManager */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js\");\nconst MapViewImageCache_1 = __webpack_require__(/*! ./image/MapViewImageCache */ \"./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js\");\nconst MapViewFog_1 = __webpack_require__(/*! ./MapViewFog */ \"./node_modules/@here/harp-mapview/lib/MapViewFog.js\");\nconst PickHandler_1 = __webpack_require__(/*! ./PickHandler */ \"./node_modules/@here/harp-mapview/lib/PickHandler.js\");\nconst PoiManager_1 = __webpack_require__(/*! ./poi/PoiManager */ \"./node_modules/@here/harp-mapview/lib/poi/PoiManager.js\");\nconst PoiRendererFactory_1 = __webpack_require__(/*! ./poi/PoiRendererFactory */ \"./node_modules/@here/harp-mapview/lib/poi/PoiRendererFactory.js\");\nconst PoiTableManager_1 = __webpack_require__(/*! ./poi/PoiTableManager */ \"./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js\");\nconst PolarTileDataSource_1 = __webpack_require__(/*! ./PolarTileDataSource */ \"./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js\");\nconst ScreenCollisions_1 = __webpack_require__(/*! ./ScreenCollisions */ \"./node_modules/@here/harp-mapview/lib/ScreenCollisions.js\");\nconst ScreenProjector_1 = __webpack_require__(/*! ./ScreenProjector */ \"./node_modules/@here/harp-mapview/lib/ScreenProjector.js\");\nconst SkyBackground_1 = __webpack_require__(/*! ./SkyBackground */ \"./node_modules/@here/harp-mapview/lib/SkyBackground.js\");\nconst Statistics_1 = __webpack_require__(/*! ./Statistics */ \"./node_modules/@here/harp-mapview/lib/Statistics.js\");\nconst FontCatalogLoader_1 = __webpack_require__(/*! ./text/FontCatalogLoader */ \"./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js\");\nconst MapViewState_1 = __webpack_require__(/*! ./text/MapViewState */ \"./node_modules/@here/harp-mapview/lib/text/MapViewState.js\");\nconst TextCanvasFactory_1 = __webpack_require__(/*! ./text/TextCanvasFactory */ \"./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js\");\nconst TextElementsRenderer_1 = __webpack_require__(/*! ./text/TextElementsRenderer */ \"./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js\");\nconst ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ \"./node_modules/@here/harp-mapview/lib/ThemeHelpers.js\");\nconst ThemeLoader_1 = __webpack_require__(/*! ./ThemeLoader */ \"./node_modules/@here/harp-mapview/lib/ThemeLoader.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\nconst VisibleTileSet_1 = __webpack_require__(/*! ./VisibleTileSet */ \"./node_modules/@here/harp-mapview/lib/VisibleTileSet.js\");\n// Cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = \"development\" === \"production\";\nif (isProduction) {\n    // In production: silence logging below error.\n    harp_utils_1.LoggerManager.instance.setLogLevelForAll(harp_utils_1.LogLevel.Error);\n}\nelse {\n    // In dev: silence logging below log (silences \"debug\" and \"trace\" levels).\n    harp_utils_1.LoggerManager.instance.setLogLevelForAll(harp_utils_1.LogLevel.Log);\n}\nvar MapViewEventNames;\n(function (MapViewEventNames) {\n    /** Called before this `MapView` starts to render a new frame. */\n    MapViewEventNames[\"Update\"] = \"update\";\n    /** Called when the WebGL canvas is resized. */\n    MapViewEventNames[\"Resize\"] = \"resize\";\n    /** Called when the frame is about to be rendered. */\n    MapViewEventNames[\"Render\"] = \"render\";\n    /** Called after a frame has been rendered. */\n    MapViewEventNames[\"AfterRender\"] = \"didrender\";\n    /** Called after the first frame has been rendered. */\n    MapViewEventNames[\"FirstFrame\"] = \"first-render\";\n    /** Called when the first view has all the necessary tiles loaded and rendered. */\n    MapViewEventNames[\"FrameComplete\"] = \"frame-complete\";\n    /** Called when the theme has been loaded with the internal [[ThemeLoader]]. */\n    MapViewEventNames[\"ThemeLoaded\"] = \"theme-loaded\";\n    /** Called when the animation mode has started. */\n    MapViewEventNames[\"AnimationStarted\"] = \"animation-started\";\n    /** Called when the animation mode has stopped. */\n    MapViewEventNames[\"AnimationFinished\"] = \"animation-finished\";\n    /** Called when a camera interaction has been detected. */\n    MapViewEventNames[\"MovementStarted\"] = \"movement-started\";\n    /** Called when a camera interaction has been stopped. */\n    MapViewEventNames[\"MovementFinished\"] = \"movement-finished\";\n    /** Called when a data source has been connected or failed to connect. */\n    MapViewEventNames[\"DataSourceConnect\"] = \"datasource-connect\";\n    /** Emitted when copyright info of rendered map has been changed. */\n    MapViewEventNames[\"CopyrightChanged\"] = \"copyright-changed\";\n    /** Called when the WebGL context is lost. */\n    MapViewEventNames[\"ContextLost\"] = \"webglcontext-lost\";\n    /** Called when the WebGL context is restored. */\n    MapViewEventNames[\"ContextRestored\"] = \"webglcontext-restored\";\n    /** Called when camera position has been changed. */\n    MapViewEventNames[\"CameraPositionChanged\"] = \"camera-changed\";\n})(MapViewEventNames = exports.MapViewEventNames || (exports.MapViewEventNames = {}));\nconst logger = harp_utils_1.LoggerManager.instance.create(\"MapView\");\nconst DEFAULT_CLEAR_COLOR = 0xefe9e1;\nconst DEFAULT_FOV_CALCULATION = { type: \"dynamic\", fov: 40 };\nconst DEFAULT_CAM_NEAR_PLANE = 0.1;\nconst DEFAULT_CAM_FAR_PLANE = 4000000;\nconst MAX_FIELD_OF_VIEW = 140;\nconst MIN_FIELD_OF_VIEW = 10;\n// All objects in fallback tiles are reduced by this amount.\nexports.FALLBACK_RENDER_ORDER_OFFSET = 20000;\nconst DEFAULT_MIN_ZOOM_LEVEL = 1;\n/**\n * Default maximum zoom level.\n */\nconst DEFAULT_MAX_ZOOM_LEVEL = 20;\n/**\n * Default minimum camera height.\n */\nconst DEFAULT_MIN_CAMERA_HEIGHT = 20;\n/**\n * Amount of framerate values to pick average from\n */\nconst FRAME_RATE_RING_SIZE = 12;\n/**\n * Default starting value for FPS computation.\n */\nconst FALLBACK_FRAME_RATE = 30;\n/**\n * Zoom level to request terrain tiles for getting the height of the camera above terrain.\n */\nconst TERRAIN_ZOOM_LEVEL = 4;\n/**\n * Style set used by [[PolarTileDataSource]] by default.\n */\nconst DEFAULT_POLAR_STYLE_SET_NAME = \"polar\";\n// Event type: cast needed to workaround wrong THREE.js typings.\nconst UPDATE = { type: MapViewEventNames.Update };\nconst RENDER_EVENT = { type: MapViewEventNames.Render };\nconst DID_RENDER_EVENT = { type: MapViewEventNames.AfterRender };\nconst FIRST_FRAME_EVENT = { type: MapViewEventNames.FirstFrame };\nconst FRAME_COMPLETE_EVENT = { type: MapViewEventNames.FrameComplete };\nconst THEME_LOADED_EVENT = { type: MapViewEventNames.ThemeLoaded };\nconst ANIMATION_STARTED_EVENT = { type: MapViewEventNames.AnimationStarted };\nconst ANIMATION_FINISHED_EVENT = { type: MapViewEventNames.AnimationFinished };\nconst MOVEMENT_STARTED_EVENT = { type: MapViewEventNames.MovementStarted };\nconst MOVEMENT_FINISHED_EVENT = { type: MapViewEventNames.MovementFinished };\nconst CONTEXT_LOST_EVENT = { type: MapViewEventNames.ContextLost };\nconst CONTEXT_RESTORED_EVENT = { type: MapViewEventNames.ContextRestored };\nconst COPYRIGHT_CHANGED_EVENT = { type: MapViewEventNames.CopyrightChanged };\nconst cache = {\n    vector2: [new THREE.Vector2()],\n    vector3: [new THREE.Vector3()]\n};\n/**\n * Hint for the WebGL implementation on which power mode to prefer.\n *\n * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12\n */\nvar MapViewPowerPreference;\n(function (MapViewPowerPreference) {\n    /** Default value. */\n    MapViewPowerPreference[\"Default\"] = \"default\";\n    /** Lower power mode, used to conserve energy. */\n    MapViewPowerPreference[\"LowPower\"] = \"low-power\";\n    /** Maximum performance. */\n    MapViewPowerPreference[\"HighPerformance\"] = \"high-performance\";\n})(MapViewPowerPreference = exports.MapViewPowerPreference || (exports.MapViewPowerPreference = {}));\n/**\n * Default settings used by [[MapView]] collected in one place.\n */\nexports.MapViewDefaults = {\n    projection: harp_geoutils_1.mercatorProjection,\n    maxVisibleDataSourceTiles: 100,\n    extendedFrustumCulling: true,\n    tileCacheSize: 200,\n    resourceComputationType: VisibleTileSet_1.ResourceComputationType.EstimationInMb,\n    quadTreeSearchDistanceUp: 3,\n    quadTreeSearchDistanceDown: 2,\n    pixelRatio: typeof window !== \"undefined\" && window.devicePixelRatio !== undefined\n        ? window.devicePixelRatio\n        : 1.0,\n    geoCenter: new harp_geoutils_1.GeoCoordinates(25, 0, 30000000),\n    target: new harp_geoutils_1.GeoCoordinates(25, 0),\n    zoomLevel: 5,\n    tilt: 0,\n    heading: 0,\n    theme: {}\n};\n/**\n * The core class of the library to call in order to create a map visualization. It needs to be\n * linked to datasources.\n */\nclass MapView extends THREE.EventDispatcher {\n    /**\n     * Constructs a new `MapView` with the given options or canvas element.\n     *\n     * @param options The `MapView` options or the HTML canvas element used to display the map.\n     */\n    constructor(options) {\n        super();\n        this.dumpNext = false;\n        this.m_renderLabels = true;\n        this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisions();\n        this.m_visibleTileSetLock = false;\n        this.m_tileWrappingEnabled = true;\n        this.m_zoomLevel = DEFAULT_MIN_ZOOM_LEVEL;\n        this.m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;\n        this.m_maxZoomLevel = DEFAULT_MAX_ZOOM_LEVEL;\n        this.m_minCameraHeight = DEFAULT_MIN_CAMERA_HEIGHT;\n        this.m_screenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1);\n        /**\n         * Relative to eye camera.\n         *\n         * This camera is internal camera used to improve precision\n         * when rendering geometries.\n         */\n        this.m_rteCamera = new THREE.PerspectiveCamera();\n        this.m_viewRanges = {\n            near: DEFAULT_CAM_NEAR_PLANE,\n            far: DEFAULT_CAM_FAR_PLANE,\n            minimum: DEFAULT_CAM_NEAR_PLANE,\n            maximum: DEFAULT_CAM_FAR_PLANE\n        };\n        this.m_scene = new THREE.Scene();\n        this.m_fog = new MapViewFog_1.MapViewFog(this.m_scene);\n        this.m_mapTilesRoot = new THREE.Object3D();\n        this.m_mapAnchors = new THREE.Object3D();\n        this.m_animationCount = 0;\n        this.m_drawing = false;\n        this.m_updatePending = false;\n        this.m_frameNumber = 0;\n        this.m_maxFps = 0;\n        this.m_detectedFps = FALLBACK_FRAME_RATE;\n        this.m_forceCameraAspect = undefined;\n        //\n        // sources\n        //\n        this.m_tileDataSources = [];\n        this.m_connectedDataSources = new Set();\n        this.m_failedDataSources = new Set();\n        this.m_enablePolarDataSource = true;\n        // gestures\n        this.m_raycaster = new THREE.Raycaster();\n        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));\n        this.m_sphere = new THREE.Sphere(undefined, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);\n        this.m_theme = {};\n        this.m_themeIsLoading = false;\n        this.m_firstFrameRendered = false;\n        this.m_firstFrameComplete = false;\n        this.m_initialTextPlacementDone = false;\n        this.m_frameTimeIndex = 0;\n        this.m_frameTimeRing = [];\n        this.m_imageCache = new MapViewImageCache_1.MapViewImageCache(this);\n        this.m_poiManager = new PoiManager_1.PoiManager(this);\n        this.m_poiTableManager = new PoiTableManager_1.PoiTableManager(this);\n        this.m_lastTileIds = \"\";\n        this.m_copyrightInfo = [];\n        /**\n         * Default handler for webglcontextlost event.\n         *\n         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.\n         */\n        this.onWebGLContextLost = (event) => {\n            this.dispatchEvent(CONTEXT_LOST_EVENT);\n            logger.warn(\"WebGL context lost\", event);\n        };\n        /**\n         * Default handler for webglcontextrestored event.\n         *\n         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.\n         */\n        this.onWebGLContextRestored = (event) => {\n            this.dispatchEvent(CONTEXT_RESTORED_EVENT);\n            if (this.m_renderer !== undefined) {\n                if (this.m_theme !== undefined && this.m_theme.clearColor !== undefined) {\n                    this.m_renderer.setClearColor(new THREE.Color(this.m_theme.clearColor));\n                }\n                else {\n                    this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);\n                }\n                this.update();\n            }\n            logger.warn(\"WebGL context restored\", event);\n        };\n        // make a copy to avoid unwanted changes to the original options.\n        this.m_options = Object.assign({}, options);\n        this.m_uriResolver = this.m_options.uriResolver;\n        if (this.m_options.minZoomLevel !== undefined) {\n            this.m_minZoomLevel = this.m_options.minZoomLevel;\n        }\n        if (this.m_options.maxZoomLevel !== undefined) {\n            this.m_maxZoomLevel = this.m_options.maxZoomLevel;\n        }\n        if (this.m_options.minCameraHeight !== undefined) {\n            this.m_minCameraHeight = this.m_options.minCameraHeight;\n        }\n        if (this.m_options.decoderUrl !== undefined) {\n            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultScriptUrl = this.m_uriResolver\n                ? this.m_uriResolver.resolveUri(this.m_options.decoderUrl)\n                : this.m_options.decoderUrl;\n        }\n        if (this.m_options.decoderCount !== undefined) {\n            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;\n        }\n        this.m_visibleTileSetOptions = Object.assign(Object.assign({}, exports.MapViewDefaults), { clipPlanesEvaluator: options.clipPlanesEvaluator !== undefined\n                ? options.clipPlanesEvaluator\n                : ClipPlanesEvaluator_1.createDefaultClipPlanesEvaluator() });\n        if (options.projection !== undefined) {\n            this.m_visibleTileSetOptions.projection = options.projection;\n        }\n        if (options.extendedFrustumCulling !== undefined) {\n            this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;\n        }\n        if (options.maxVisibleDataSourceTiles !== undefined) {\n            this.m_visibleTileSetOptions.maxVisibleDataSourceTiles =\n                options.maxVisibleDataSourceTiles;\n        }\n        if (options.tileCacheSize !== undefined) {\n            this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;\n        }\n        if (options.resourceComputationType !== undefined) {\n            this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;\n        }\n        if (options.quadTreeSearchDistanceUp !== undefined) {\n            this.m_visibleTileSetOptions.quadTreeSearchDistanceUp =\n                options.quadTreeSearchDistanceUp;\n        }\n        if (options.quadTreeSearchDistanceDown !== undefined) {\n            this.m_visibleTileSetOptions.quadTreeSearchDistanceDown =\n                options.quadTreeSearchDistanceDown;\n        }\n        if (options.enablePolarDataSource !== undefined) {\n            this.m_enablePolarDataSource = options.enablePolarDataSource;\n        }\n        this.m_pixelRatio = options.pixelRatio;\n        if (options.maxFps !== undefined) {\n            this.m_maxFps = Math.max(0, options.maxFps);\n        }\n        this.m_options.enableStatistics = this.m_options.enableStatistics === true;\n        this.m_languages = this.m_options.languages;\n        if (!isProduction &&\n            this.m_options.collisionDebugCanvas !== undefined &&\n            this.m_options.collisionDebugCanvas !== null) {\n            this.m_collisionDebugCanvas = this.m_options.collisionDebugCanvas;\n            this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisionsDebug(this.m_collisionDebugCanvas);\n        }\n        this.handleRequestAnimationFrame = this.renderFunc.bind(this);\n        this.handlePostponedAnimationFrame = this.postponedAnimationFrame.bind(this);\n        this.m_pickHandler = new PickHandler_1.PickHandler(this, this.m_rteCamera, this.m_options.enableRoadPicking === true);\n        if (this.m_options.tileWrappingEnabled !== undefined) {\n            this.m_tileWrappingEnabled = this.m_options.tileWrappingEnabled;\n        }\n        // Initialization of the stats\n        this.setupStats(this.m_options.enableStatistics);\n        this.canvas.addEventListener(\"webglcontextlost\", this.onWebGLContextLost);\n        this.canvas.addEventListener(\"webglcontextrestored\", this.onWebGLContextRestored);\n        // Initialization of the renderer\n        this.m_renderer = new THREE.WebGLRenderer({\n            canvas: this.canvas,\n            antialias: this.nativeWebglAntialiasEnabled,\n            alpha: this.m_options.alpha,\n            preserveDrawingBuffer: this.m_options.preserveDrawingBuffer === true,\n            powerPreference: this.m_options.powerPreference === undefined\n                ? MapViewPowerPreference.Default\n                : this.m_options.powerPreference\n        });\n        this.m_renderer.autoClear = false;\n        // This is detailed at https://threejs.org/docs/#api/renderers/WebGLRenderer.info\n        // When using several WebGLRenderer#render calls per frame, it is the only way to get\n        // correct rendering data from ThreeJS.\n        this.m_renderer.info.autoReset = false;\n        this.setupRenderer();\n        this.m_options.fovCalculation =\n            this.m_options.fovCalculation === undefined\n                ? DEFAULT_FOV_CALCULATION\n                : this.m_options.fovCalculation;\n        this.m_options.fovCalculation.fov = THREE.Math.clamp(this.m_options.fovCalculation.fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);\n        // Initialization of mCamera and mVisibleTiles\n        const { width, height } = this.getCanvasClientSize();\n        const aspect = width / height;\n        this.m_camera = new THREE.PerspectiveCamera(this.m_options.fovCalculation.fov, aspect, DEFAULT_CAM_NEAR_PLANE, DEFAULT_CAM_FAR_PLANE);\n        this.m_camera.up.set(0, 0, 1);\n        this.m_lookAtDistance = 0;\n        this.m_focalLength = 0;\n        this.m_scene.add(this.m_camera); // ensure the camera is added to the scene.\n        this.m_screenProjector = new ScreenProjector_1.ScreenProjector(this.m_camera);\n        // setup camera with initial position\n        this.setupCamera(options);\n        this.m_movementDetector = new CameraMovementDetector_1.CameraMovementDetector(this.m_options.movementThrottleTimeout, () => this.movementStarted(), () => this.movementFinished());\n        const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;\n        this.mapRenderingManager = new composing_1.MapRenderingManager(width, height, this.m_options.dynamicPixelRatio, mapPassAntialiasSettings);\n        this.m_tileGeometryManager =\n            this.m_options.enablePhasedLoading === true\n                ? new PhasedTileGeometryManager_1.PhasedTileGeometryManager(this)\n                : new TileGeometryManager_1.SimpleTileGeometryManager(this);\n        if (options.enableMixedLod !== undefined) {\n            this.m_enableMixedLod = options.enableMixedLod;\n        }\n        this.m_visibleTiles = this.createVisibleTileSet();\n        this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionHandler(this);\n        this.m_backgroundDataSource = new BackgroundDataSource_1.BackgroundDataSource();\n        this.addDataSource(this.m_backgroundDataSource);\n        if (this.m_enablePolarDataSource) {\n            const styleSetName = options.polarStyleSetName !== undefined\n                ? options.polarStyleSetName\n                : DEFAULT_POLAR_STYLE_SET_NAME;\n            this.m_polarDataSource = new PolarTileDataSource_1.PolarTileDataSource({\n                styleSetName,\n                geometryLevelOffset: options.polarGeometryLevelOffset\n            });\n            this.updatePolarDataSource();\n        }\n        if (options.backgroundTilingScheme !== undefined) {\n            this.m_backgroundDataSource.setTilingScheme(options.backgroundTilingScheme);\n        }\n        this.initTheme();\n        this.m_textElementsRenderer = this.createTextRenderer();\n        this.drawFrame();\n    }\n    /**\n     * @returns Whether label rendering is enabled.\n     */\n    get renderLabels() {\n        return this.m_renderLabels;\n    }\n    /**\n     * Enables or disables rendering of labels.\n     * @param value `true` to enable labels `false` to disable them.\n     */\n    set renderLabels(value) {\n        this.m_renderLabels = value;\n    }\n    /**\n     * @hidden\n     * The [[TextElementsRenderer]] select the visible [[TextElement]]s and renders them.\n     */\n    get textElementsRenderer() {\n        return this.m_textElementsRenderer;\n    }\n    /**\n     * @hidden\n     * The [[CameraMovementDetector]] detects camera movements. Made available for performance\n     * measurements.\n     */\n    get cameraMovementDetector() {\n        return this.m_movementDetector;\n    }\n    /**\n     * The [[AnimatedExtrusionHandler]] controls animated extrusion effect\n     * of the extruded objects in the [[Tile]]\n     */\n    get animatedExtrusionHandler() {\n        return this.m_animatedExtrusionHandler;\n    }\n    /**\n     * The [[TileGeometryManager]] manages geometry during loading and handles hiding geometry of\n     * specified [[GeometryKind]]s.\n     */\n    get tileGeometryManager() {\n        return this.m_tileGeometryManager;\n    }\n    get enableMixedLod() {\n        return this.m_enableMixedLod;\n    }\n    set enableMixedLod(enableMixedLod) {\n        // Skip unnecessary update\n        if (this.m_enableMixedLod === enableMixedLod) {\n            return;\n        }\n        this.m_enableMixedLod = enableMixedLod;\n        this.m_visibleTiles = this.createVisibleTileSet();\n        this.resetTextRenderer();\n        this.update();\n    }\n    /**\n     * Disposes this `MapView`.\n     *\n     * This function cleans the resources that are managed manually including those that exist in\n     * shared caches.\n     *\n     * Note: This function does not try to clean objects that can be disposed off easily by\n     * TypeScript's garbage collecting mechanism. Consequently, if you need to perform a full\n     * cleanup, you must ensure that all references to this `MapView` are removed.\n     */\n    dispose() {\n        if (this.m_movementFinishedUpdateTimerId) {\n            clearTimeout(this.m_movementFinishedUpdateTimerId);\n            this.m_movementFinishedUpdateTimerId = undefined;\n        }\n        if (this.m_animationFrameHandle !== undefined) {\n            cancelAnimationFrame(this.m_animationFrameHandle);\n            this.m_animationFrameHandle = undefined;\n        }\n        this.canvas.removeEventListener(\"webglcontextlost\", this.onWebGLContextLost);\n        this.canvas.removeEventListener(\"webglcontextrestored\", this.onWebGLContextRestored);\n        for (const dataSource of this.m_tileDataSources) {\n            dataSource.dispose();\n        }\n        this.m_visibleTiles.clearTileCache();\n        this.m_textElementsRenderer.clearRenderStates();\n        this.m_renderer.dispose();\n        this.m_imageCache.clear();\n        this.m_movementDetector.dispose();\n    }\n    /**\n     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of\n     * tiles.\n     */\n    get resourceComputationType() {\n        return this.m_visibleTiles.resourceComputationType;\n    }\n    set resourceComputationType(value) {\n        this.m_visibleTiles.resourceComputationType = value;\n    }\n    /**\n     * Returns the cache size.\n     */\n    getCacheSize() {\n        return this.m_visibleTiles.getDataSourceCacheSize();\n    }\n    /**\n     * Sets the cache size in number of tiles.\n     *\n     * @param size The cache size in tiles.\n     * @param numVisibleTiles The number of tiles visible, which is size/2 by default.\n     */\n    setCacheSize(size, numVisibleTiles) {\n        this.m_visibleTiles.setDataSourceCacheSize(size);\n        numVisibleTiles = numVisibleTiles !== undefined ? numVisibleTiles : size / 2;\n        this.m_visibleTiles.setNumberOfVisibleTiles(Math.floor(numVisibleTiles));\n        this.updateImages();\n        this.updateLighting();\n        this.m_textElementsRenderer.invalidateCache();\n        this.updateSkyBackground();\n        this.update();\n    }\n    /**\n     * Specfies whether extended frustum culling is enabled or disabled.\n     */\n    get extendedFrustumCulling() {\n        return this.m_options.extendedFrustumCulling !== undefined\n            ? this.m_visibleTileSetOptions.extendedFrustumCulling\n            : true;\n    }\n    /**\n     * Enable of disable extended frustum culling.\n     */\n    set extendedFrustumCulling(value) {\n        this.m_visibleTileSetOptions.extendedFrustumCulling = value;\n    }\n    /**\n     * Returns the status of frustum culling after each update.\n     */\n    get lockVisibleTileSet() {\n        return this.m_visibleTileSetLock;\n    }\n    /**\n     * Enable of disable frustum culling after each update.\n     */\n    set lockVisibleTileSet(value) {\n        this.m_visibleTileSetLock = value;\n    }\n    /**\n     * Gets the optional camera used to render the scene.\n     */\n    get pointOfView() {\n        return this.m_pointOfView;\n    }\n    /**\n     * Sets the optional camera used to render the scene.\n     */\n    set pointOfView(pointOfView) {\n        this.m_pointOfView = pointOfView;\n        this.update();\n    }\n    /**\n     * Loads a post effects definition file.\n     *\n     * @param postEffectsFile File URL describing the post effects.\n     */\n    loadPostEffects(postEffectsFile) {\n        fetch(postEffectsFile)\n            .then(response => response.json())\n            .then((postEffects) => {\n            this.m_postEffects = postEffects;\n            this.setPostEffects();\n        });\n    }\n    /**\n     * The abstraction of the [[MapRenderingManager]] API for post effects.\n     */\n    get postEffects() {\n        return this.m_postEffects;\n    }\n    set postEffects(postEffects) {\n        this.m_postEffects = postEffects;\n        this.setPostEffects();\n    }\n    /**\n     * Gets the current `Theme` used by this `MapView` to style map elements.\n     */\n    get theme() {\n        return this.m_theme;\n    }\n    /**\n     * Changes the `Theme` used by this `MapView` to style map elements.\n     */\n    set theme(theme) {\n        if (!ThemeLoader_1.ThemeLoader.isThemeLoaded(theme)) {\n            this.m_themeIsLoading = true;\n            // If theme is not yet loaded, let's set theme asynchronously\n            ThemeLoader_1.ThemeLoader.load(theme, { uriResolver: this.m_uriResolver })\n                .then(loadedTheme => {\n                this.m_themeIsLoading = false;\n                this.theme = loadedTheme;\n            })\n                .catch(error => {\n                this.m_themeIsLoading = false;\n                logger.error(`failed to set theme: ${error}`, error);\n            });\n            return;\n        }\n        // Fog and sky.\n        this.m_theme.fog = theme.fog;\n        this.m_theme.sky = theme.sky;\n        this.updateSkyBackground();\n        this.m_fog.reset(this.m_theme);\n        this.m_theme.lights = theme.lights;\n        this.updateLighting();\n        // Clear color.\n        this.m_theme.clearColor = theme.clearColor;\n        this.renderer.setClearColor(new THREE.Color(theme.clearColor));\n        // Images.\n        this.m_theme.images = theme.images;\n        this.m_theme.imageTextures = theme.imageTextures;\n        this.updateImages();\n        // POI tables.\n        this.m_theme.poiTables = theme.poiTables;\n        this.loadPoiTables();\n        // Text.\n        this.m_theme.textStyles = theme.textStyles;\n        this.m_theme.defaultTextStyle = theme.defaultTextStyle;\n        this.m_theme.fontCatalogs = theme.fontCatalogs;\n        this.resetTextRenderer();\n        if (this.m_theme.styles === undefined) {\n            this.m_theme.styles = {};\n        }\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.setTheme(this.m_theme);\n        }\n        this.m_theme.styles = theme.styles || {};\n        this.m_theme.definitions = theme.definitions;\n        for (const dataSource of this.m_tileDataSources) {\n            dataSource.setTheme(this.m_theme);\n        }\n        THEME_LOADED_EVENT.time = Date.now();\n        this.dispatchEvent(THEME_LOADED_EVENT);\n        this.update();\n    }\n    /**\n     * [[UriResolver]] used to resolve application/deployment specific `URI`s into actual `URLs`\n     * that can be loaded with `fetch`.\n     */\n    get uriResolver() {\n        return this.m_uriResolver;\n    }\n    /**\n     * Gets the value of the forced custom camera aspect.\n     * Every time a frame is rendered, `MapView` resets the camera aspect.\n     *\n     * You can disable this behavior by setting the value to `undefined`.\n     */\n    get forceCameraAspect() {\n        return this.m_forceCameraAspect;\n    }\n    /**\n     * Sets the custom forced camera aspect ratio to use while rendering.\n     */\n    set forceCameraAspect(aspect) {\n        this.m_forceCameraAspect = aspect;\n    }\n    /**\n     * Maximum FPS. If defined (and > 0) it is the maximum FPS that is used.\n     */\n    set maxFps(fps) {\n        this.m_maxFps = Math.max(0, fps);\n    }\n    get maxFps() {\n        return Math.max(0, this.m_maxFps);\n    }\n    /**\n     * Lists the ISO 639-1 language codes for DataSources to use.\n     */\n    get languages() {\n        return this.m_languages;\n    }\n    /**\n     * Sets the list of ISO 639-1 language codes for DataSources to use.\n     */\n    set languages(languages) {\n        this.m_languages = languages;\n        this.m_tileDataSources.forEach((dataSource) => {\n            dataSource.setLanguages(this.m_languages);\n        });\n        this.update();\n    }\n    get copyrightInfo() {\n        return this.m_copyrightInfo;\n    }\n    /**\n     * @hidden\n     * Disable all fading animations (for debugging and performance measurement). Defaults to\n     * `false`.\n     */\n    set disableFading(disable) {\n        this.m_textElementsRenderer.disableFading = disable;\n    }\n    get disableFading() {\n        return this.m_textElementsRenderer.disableFading;\n    }\n    /**\n     * @hidden\n     * Return current frame number.\n     */\n    get frameNumber() {\n        return this.m_frameNumber;\n    }\n    /**\n     * @hidden\n     * Reset the frame number to 0.\n     */\n    resetFrameNumber() {\n        this.m_frameNumber = 0;\n        this.m_previousFrameTimeStamp = undefined;\n    }\n    addEventListener(type, listener) {\n        super.addEventListener(type, listener);\n    }\n    removeEventListener(type, listener) {\n        super.removeEventListener(type, listener);\n    }\n    /**\n     * The HTML canvas element used by this `MapView`.\n     */\n    get canvas() {\n        return this.m_options.canvas;\n    }\n    /**\n     * The HTML canvas element used by this `MapView`.\n     */\n    get collisionDebugCanvas() {\n        return this.m_collisionDebugCanvas;\n    }\n    /**\n     * The THREE.js scene used by this `MapView`.\n     */\n    get scene() {\n        return this.m_scene;\n    }\n    /**\n     * The THREE.js camera used by this `MapView` to render the main scene.\n     */\n    get camera() {\n        return this.m_camera;\n    }\n    /**\n     * The THREE.js `WebGLRenderer` used by this scene.\n     */\n    get renderer() {\n        return this.m_renderer;\n    }\n    /**\n     * The color used to clear the view.\n     */\n    get clearColor() {\n        const rendererClearColor = this.m_renderer.getClearColor();\n        return rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;\n    }\n    /**\n     * The color used to clear the view.\n     */\n    set clearColor(color) {\n        this.m_renderer.setClearColor(color);\n    }\n    /**\n     * The projection used to project geo coordinates to world coordinates.\n     */\n    get projection() {\n        return this.m_visibleTileSetOptions.projection;\n    }\n    /**\n     * Changes the projection at run time.\n     *\n     * @param projection The [[Projection]] instance to use.\n     */\n    set projection(projection) {\n        // The geo center must be reset when changing the projection, because the\n        // camera's position is based on the projected geo center.\n        const target = Utils_1.MapViewUtils.rayCastWorldCoordinates(this, 0, 0);\n        if (target === null) {\n            throw new Error(\"MapView does not support a view pointing in the void.\");\n        }\n        const targetCoordinates = this.projection.unprojectPoint(target);\n        const targetDistance = this.camera.position.distanceTo(target);\n        const attitude = Utils_1.MapViewUtils.extractAttitude(this, this.camera);\n        const pitchDeg = THREE.Math.radToDeg(attitude.pitch);\n        const headingDeg = -THREE.Math.radToDeg(attitude.yaw);\n        this.m_visibleTileSetOptions.projection = projection;\n        this.updatePolarDataSource();\n        this.clearTileCache();\n        this.textElementsRenderer.clearRenderStates();\n        this.m_visibleTiles = this.createVisibleTileSet();\n        this.lookAt(targetCoordinates, targetDistance, pitchDeg, headingDeg);\n    }\n    /**\n     * Get camera clipping planes evaluator used.\n     */\n    get clipPlanesEvaluator() {\n        return this.m_visibleTileSetOptions.clipPlanesEvaluator;\n    }\n    /**\n     * Changes the clip planes evaluator at run time.\n     */\n    set clipPlanesEvaluator(clipPlanesEvaluator) {\n        this.m_visibleTileSetOptions.clipPlanesEvaluator = clipPlanesEvaluator;\n    }\n    /**\n     * The distance (in pixels) between the screen and the camera.\n     */\n    get focalLength() {\n        return this.m_focalLength;\n    }\n    /**\n     * Get distance from camera to the point of focus in world units.\n     */\n    get lookAtDistance() {\n        return this.m_lookAtDistance;\n    }\n    /**\n     * Get object describing frustum planes distances and min/max visibility range for actual\n     * camera setup.\n     * Near and far plane distance are self explanatory while minimum and maximum visibility range\n     * describes the extreme near/far planes distances that may be achieved with current camera\n     * settings, meaning at current zoom level (ground distance) and any possible orientation.\n     * @note Visibility is directly related to camera [[ClipPlaneEvaluator]] used and determines\n     * the maximum possible distance of camera far clipping plane regardless of tilt, but may change\n     * whenever zoom level changes. Distance is measured in world units which may be approximately\n     * equal to meters, but this depends on the distortion related to projection type used.\n     */\n    get viewRanges() {\n        return this.m_viewRanges;\n    }\n    /**\n     * The position in geo coordinates of the center of the scene.\n     */\n    get geoCenter() {\n        return this.projection.unprojectPoint(this.m_camera.position).normalized();\n    }\n    /**\n     * The position in geo coordinates of the center of the scene.\n     * Longitude values outside of -180 and +180 are acceptable.\n     */\n    set geoCenter(geoCenter) {\n        if (geoCenter.altitude !== undefined) {\n            this.projection.projectPoint(geoCenter, this.m_camera.position);\n        }\n        else {\n            // Preserve the current altitude\n            const altitude = this.geoCenter.altitude;\n            this.projection.projectPoint(new harp_geoutils_1.GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude), this.m_camera.position);\n        }\n        this.update();\n    }\n    /**\n     * The node in this MapView's scene containing the user [[MapAnchor]]s.\n     * All (first level) children of this node will be positioned in world space according to the\n     * [[MapAnchor.geoPosition]].\n     * Deeper level children can be used to position custom objects relative to the anchor node.\n     */\n    get mapAnchors() {\n        return this.m_mapAnchors;\n    }\n    /**\n     * The position in world coordinates of the center of the scene.\n     */\n    get worldCenter() {\n        return this.m_camera.position;\n    }\n    /**\n     * The root object of the scene. Contains all `rootObjects` of the [[Tile]]s.\n     */\n    get worldRootObject() {\n        return this.m_mapTilesRoot;\n    }\n    /**\n     * Get the [[PickHandler]] for this `mapView`.\n     */\n    get pickHandler() {\n        return this.m_pickHandler;\n    }\n    /**\n     * Get the [[ImageCache]] that belongs to this `MapView`.\n     */\n    get imageCache() {\n        return this.m_imageCache;\n    }\n    /**\n     * @hidden\n     * Get the [[PoiManager]] that belongs to this `MapView`.\n     */\n    get poiManager() {\n        return this.m_poiManager;\n    }\n    /**\n     * @hidden\n     * Get the array of [[PoiTableManager]] that belongs to this `MapView`.\n     */\n    get poiTableManager() {\n        return this.m_poiTableManager;\n    }\n    /**\n     * The minimum camera height in meters.\n     */\n    get minCameraHeight() {\n        return this.m_minCameraHeight;\n    }\n    /**\n     * The minimum zoom level.\n     */\n    get minZoomLevel() {\n        return this.m_minZoomLevel;\n    }\n    /**\n     * The minimum zoom level.\n     */\n    set minZoomLevel(zoomLevel) {\n        this.m_minZoomLevel = zoomLevel;\n        this.update();\n    }\n    /**\n     * The maximum zoom level. Default is 14.\n     */\n    get maxZoomLevel() {\n        return this.m_maxZoomLevel;\n    }\n    /**\n     * The maximum zoom level.\n     */\n    set maxZoomLevel(zoomLevel) {\n        this.m_maxZoomLevel = zoomLevel;\n        this.update();\n    }\n    /**\n     * Returns the zoom level for the given camera setup.\n     */\n    get zoomLevel() {\n        return this.m_zoomLevel;\n    }\n    set zoomLevel(zoomLevel) {\n        this.m_zoomLevel = THREE.Math.clamp(zoomLevel, this.m_minZoomLevel, this.m_maxZoomLevel);\n        Utils_1.MapViewUtils.zoomOnTargetPosition(this, 0, 0, this.m_zoomLevel);\n        this.update();\n    }\n    /**\n     * Returns the storage level for the given camera setup.\n     * Actual storage level of the rendered data also depends on [[DataSource.storageLevelOffset]].\n     */\n    get storageLevel() {\n        return THREE.Math.clamp(Math.floor(this.m_zoomLevel), this.m_minZoomLevel, this.m_maxZoomLevel);\n    }\n    /**\n     * Returns height of the viewport in pixels.\n     */\n    get viewportHeight() {\n        return this.canvas.height;\n    }\n    /**\n     * Returns `true` if the native WebGL antialiasing is enabled.\n     *\n     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.\n     */\n    get nativeWebglAntialiasEnabled() {\n        return this.m_options.enableNativeWebglAntialias === undefined\n            ? this.pixelRatio < 2.0\n            : this.m_options.enableNativeWebglAntialias;\n    }\n    /**\n     * Returns 'true' if the phased loading is currently enabled.\n     *\n     * @default true.\n     */\n    get phasedLoadingEnabled() {\n        return this.m_options.enablePhasedLoading !== false;\n    }\n    /**\n     * Returns [[DataSource]]s displayed by this `MapView`.\n     */\n    get dataSources() {\n        return this.m_tileDataSources;\n    }\n    /**\n     * Set's the way in which the fov is calculated on the map view. Note, for\n     * this to take visual effect, the map should be rendered after calling this\n     * function.\n     * @param fovCalculation How the FOV is calculated.\n     */\n    setFovCalculation(fovCalculation) {\n        this.m_options.fovCalculation = fovCalculation;\n        this.calculateFocalLength(this.m_renderer.getSize(cache.vector2[0]).height);\n        this.updateCameras();\n    }\n    /**\n     * Returns the unique [[DataSource]] matching the given name.\n     */\n    getDataSourceByName(dataSourceName) {\n        return this.m_tileDataSources.find(ds => ds.name === dataSourceName);\n    }\n    /**\n     * Returns the array of [[DataSource]]s referring to the same [[StyleSet]].\n     */\n    getDataSourcesByStyleSetName(styleSetName) {\n        return this.m_tileDataSources.filter(ds => ds.styleSetName === styleSetName);\n    }\n    /**\n     * Returns true if the specified [[DataSource]] is enabled.\n     */\n    isDataSourceEnabled(dataSource) {\n        return (dataSource.enabled &&\n            dataSource.ready() &&\n            this.m_connectedDataSources.has(dataSource.name));\n    }\n    /**\n     * Adds a new [[DataSource]] to this `MapView`. `MapView` needs at least one [[DataSource]] to\n     * display something.\n     *\n     * @param dataSource The data source.\n     */\n    addDataSource(dataSource) {\n        const twinDataSource = this.getDataSourceByName(dataSource.name);\n        if (twinDataSource !== undefined) {\n            throw new Error(`A DataSource with the name \"${dataSource.name}\" already exists in this MapView.`);\n        }\n        dataSource.attach(this);\n        dataSource.setEnableElevationOverlay(this.m_elevationProvider !== undefined);\n        this.m_tileDataSources.push(dataSource);\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.updateStorageLevelOffset();\n        }\n        return dataSource\n            .connect()\n            .then(() => {\n            return new Promise(resolve => {\n                if (this.theme !== undefined && this.theme.styles !== undefined) {\n                    resolve();\n                    return;\n                }\n                const resolveOnce = () => {\n                    this.removeEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);\n                    resolve();\n                };\n                this.addEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);\n            });\n        })\n            .then(() => {\n            const alreadyRemoved = this.m_tileDataSources.indexOf(dataSource) === -1;\n            if (alreadyRemoved) {\n                return;\n            }\n            dataSource.addEventListener(MapViewEventNames.Update, () => {\n                this.update();\n            });\n            dataSource.setTheme(this.m_theme);\n            this.m_connectedDataSources.add(dataSource.name);\n            this.dispatchEvent({\n                type: MapViewEventNames.DataSourceConnect,\n                dataSourceName: dataSource.name\n            });\n            this.update();\n        })\n            .catch(error => {\n            logger.error(`Failed to connect to datasource ${dataSource.name}: ${error.message}`);\n            this.m_failedDataSources.add(dataSource.name);\n            this.dispatchEvent({\n                type: MapViewEventNames.DataSourceConnect,\n                dataSourceName: dataSource.name,\n                error\n            });\n        });\n    }\n    /**\n     * Removes [[DataSource]] from this `MapView`.\n     *\n     * @param dataSource The data source to be removed\n     */\n    removeDataSource(dataSource) {\n        const dsIndex = this.m_tileDataSources.indexOf(dataSource);\n        if (dsIndex === -1) {\n            return;\n        }\n        dataSource.detach(this);\n        this.m_visibleTiles.removeDataSource(dataSource);\n        this.m_tileDataSources.splice(dsIndex, 1);\n        this.m_connectedDataSources.delete(dataSource.name);\n        this.m_failedDataSources.delete(dataSource.name);\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.updateStorageLevelOffset();\n        }\n        this.update();\n    }\n    /**\n     * Access the `VisibleTileSet` to get access to all current datasources and their visible tiles.\n     */\n    get visibleTileSet() {\n        return this.m_visibleTiles;\n    }\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements Array of [[TextElement]] to be added.\n     */\n    addOverlayText(textElements) {\n        this.m_textElementsRenderer.addOverlayText(textElements);\n        this.update();\n    }\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements Array of [[TextElement]] to be added.\n     */\n    clearOverlayText() {\n        this.m_textElementsRenderer.clearOverlayText();\n    }\n    /**\n     * The method that sets the camera to the desired angle (`tiltDeg`) and `distance` (in meters)\n     * to the `target` location, from a certain heading (`headingAngle`).\n     *\n     * @param target The location to look at.\n     * @param distance The distance of the camera to the target in meters.\n     * @param tiltDeg The camera tilt angle in degrees (0 is vertical), curbed below 89deg.\n     * @param headingDeg The camera heading angle in degrees and clockwise (as opposed to yaw),\n     * starting north.\n     */\n    lookAt(target, distance, tiltDeg = 0, headingDeg = 0) {\n        const limitedTilt = Math.min(Utils_1.MapViewUtils.MAX_TILT_DEG, tiltDeg);\n        // MapViewUtils#setRotation uses pitch, not tilt, which is different in sphere projection.\n        // But in sphere, in the tangent space of the target of the camera, pitch = tilt. So, put\n        // the camera on the target, so the tilt can be passed to getRotation as a pitch.\n        Utils_1.MapViewUtils.getCameraRotationAtTarget(this.projection, target, -headingDeg, limitedTilt, this.camera.quaternion);\n        Utils_1.MapViewUtils.getCameraPositionFromTargetCoordinates(target, distance, -headingDeg, limitedTilt, this.projection, this.camera.position);\n        this.camera.updateMatrixWorld(true);\n    }\n    /**\n     * Moves the camera to the specified [[GeoCoordinates]], sets the desired `zoomLevel` and\n     * adjusts the yaw and pitch. The pitch of the camera is always curbed so that the camera cannot\n     * look above the horizon. This paradigm is necessary in [[MapControls]], where the center of \\\n     * the screen is used for the orbiting interaction (3 fingers / right mouse button).\n     *\n     * @param geoPos Geolocation to move the camera to.\n     * @param zoomLevel Desired zoom level.\n     * @param yawDeg Camera yaw in degrees, counter-clockwise (as opposed to heading), starting\n     * north.\n     * @param pitchDeg Camera pitch in degrees.\n     */\n    setCameraGeolocationAndZoom(geoPos, zoomLevel, yawDeg = 0, pitchDeg = 0) {\n        this.geoCenter = geoPos;\n        let limitedPitch = Math.min(89, pitchDeg); // 90 leads to imprecision issues.\n        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            const maxPitchRadWithCurvature = Math.asin(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS /\n                (Utils_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this, zoomLevel) +\n                    harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS));\n            const maxPitchDegWithCurvature = THREE.Math.radToDeg(maxPitchRadWithCurvature);\n            limitedPitch = Math.min(limitedPitch, maxPitchDegWithCurvature);\n        }\n        Utils_1.MapViewUtils.zoomOnTargetPosition(this, 0, 0, zoomLevel);\n        Utils_1.MapViewUtils.setRotation(this, yawDeg, limitedPitch);\n        this.update();\n    }\n    /**\n     * Returns `true` if this `MapView` is constantly redrawing the scene.\n     */\n    get animating() {\n        return this.m_animationCount > 0;\n    }\n    /**\n     * Begin animating the scene.\n     */\n    beginAnimation() {\n        if (this.m_animationCount++ === 0) {\n            if (!this.m_updatePending) {\n                this.m_updatePending = true;\n                this.drawFrame();\n            }\n            ANIMATION_STARTED_EVENT.time = Date.now();\n            this.dispatchEvent(ANIMATION_STARTED_EVENT);\n        }\n    }\n    /**\n     * Stop animating the scene.\n     */\n    endAnimation() {\n        if (this.m_animationCount > 0) {\n            --this.m_animationCount;\n        }\n        if (this.m_animationCount === 0) {\n            ANIMATION_FINISHED_EVENT.time = Date.now();\n            this.dispatchEvent(ANIMATION_FINISHED_EVENT);\n        }\n    }\n    /**\n     * Returns `true` if the camera moved in the last frame.\n     */\n    get cameraIsMoving() {\n        return this.m_movementDetector.cameraIsMoving;\n    }\n    /**\n     * Returns `true` if the current frame will immediately be followed by another frame.\n     */\n    get isDynamicFrame() {\n        return (this.cameraIsMoving ||\n            this.animating ||\n            this.m_updatePending ||\n            this.m_animatedExtrusionHandler.isAnimating);\n    }\n    /**\n     * Returns the ratio between a pixel and a world unit for the current camera (in the center of\n     * the camera projection).\n     */\n    get pixelToWorld() {\n        if (this.m_pixelToWorld === undefined) {\n            // At this point fov calculation should be always defined.\n            harp_utils_1.assert(this.m_options.fovCalculation !== undefined);\n            // NOTE: Look at distance is the distance to camera focus (and pivot) point.\n            // In screen space this point is located in the center of canvas.\n            // Given that zoom level is not modified (clamped by camera pitch), the following\n            // formulas are all equivalent:\n            // lookAtDistance = (EQUATORIAL_CIRCUMFERENCE * focalLength) / (256 * zoomLevel^2);\n            // lookAtDistance = abs(cameraPos.z) / cos(cameraPitch);\n            // Here we may use precalculated distance (once pre frame):\n            const lookAtDistance = this.m_lookAtDistance;\n            // Find world space object size that corresponds to one pixel on screen.\n            this.m_pixelToWorld = Utils_1.MapViewUtils.calculateWorldSizeByFocalLength(this.m_focalLength, lookAtDistance, 1);\n        }\n        return this.m_pixelToWorld;\n    }\n    /**\n     * Returns the ratio between a world and a pixel unit for the current camera (in the center of\n     * the camera projection).\n     */\n    get worldToPixel() {\n        return 1.0 / this.pixelToWorld;\n    }\n    get pixelRatio() {\n        if (this.m_pixelRatio !== undefined) {\n            return this.m_pixelRatio;\n        }\n        return typeof window !== \"undefined\" && window.devicePixelRatio !== undefined\n            ? window.devicePixelRatio\n            : 1.0;\n    }\n    /**\n     * PixelRatio in the WebGlRenderer. May contain values > 1.0 for high resolution screens\n     * (HiDPI).\n     *\n     * A value of `undefined` will make the getter return `window.devicePixelRatio`, setting a value\n     * of `1.0` will disable the use of HiDPI on all devices.\n     *\n     * @note Since the current pixelRatio may have been used in some calculations (e.g. the icons)\n     * they may appear in the wrong size now. To ensure proper display of data, a call to\n     * `clearTileCache()` is required if the pixelRatio is changed after tiles have been loaded.\n     *\n     * @memberof MapView\n     */\n    set pixelRatio(pixelRatio) {\n        this.m_pixelRatio = pixelRatio;\n        if (this.renderer.getPixelRatio() !== this.pixelRatio) {\n            this.renderer.setPixelRatio(this.pixelRatio);\n        }\n    }\n    /**\n     * PixelRatio ratio for rendering when the camera is moving or an animation is running. Useful\n     * when rendering on high resolution displays with low performance GPUs that may be\n     * fill-rate-limited.\n     *\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. Values between 0.5 and\n     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger\n     * than `window.devicePixelRatio`.\n     *\n     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`\n     * defined, visual artifacts may occur, especially with thin lines..\n     *\n     * @note The resolution of icons and text labels is not affected.\n     *\n     * @default `undefined`\n     */\n    set dynamicPixelRatio(ratio) {\n        this.mapRenderingManager.lowResPixelRatio = ratio;\n    }\n    get dynamicPixelRatio() {\n        return this.mapRenderingManager.lowResPixelRatio;\n    }\n    /**\n     * Returns the screen position of the given geo coordinates.\n     *\n     * @param geoPos The geo coordinates.\n     * @returns The screen position in CSS/client coordinates (no pixel ratio applied) or\n     * `undefined`.\n     */\n    getScreenPosition(geoPos) {\n        this.projection.projectPoint(geoPos, cache.vector3[0]);\n        const p = this.m_screenProjector.project(cache.vector3[0]);\n        if (p !== undefined) {\n            const { width, height } = this.getCanvasClientSize();\n            p.x = p.x + width / 2;\n            p.y = height - (p.y + height / 2);\n        }\n        return p;\n    }\n    /**\n     * Returns a ray caster using the supplied screen positions.\n     *\n     * @param x The X position in css/client coordinates (without applied display ratio).\n     * @param y The Y position in css/client coordinates (without applied display ratio).\n     *\n     * @alpha\n     *\n     * @return Raycaster with origin at the camera and direction based on the supplied x / y screen\n     * points.\n     */\n    raycasterFromScreenPoint(x, y) {\n        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_rteCamera);\n        return this.m_raycaster;\n    }\n    /**\n     * Returns the world space position from the given screen position. The return value can be\n     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not\n     * intersecting the ground plane.\n     *\n     * @param x The X position in css/client coordinates (without applied display ratio).\n     * @param y The Y position in css/client coordinates (without applied display ratio).\n     */\n    getWorldPositionAt(x, y) {\n        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);\n        return this.projection.type === harp_geoutils_1.ProjectionType.Spherical\n            ? this.m_raycaster.ray.intersectSphere(this.m_sphere, cache.vector3[0])\n            : this.m_raycaster.ray.intersectPlane(this.m_plane, cache.vector3[0]);\n    }\n    /**\n     * Returns the [[GeoCoordinates]] from the given screen position. The return value can be\n     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not\n     * intersecting the ground plane.\n     *\n     * @param x The X position in css/client coordinates (without applied display ratio).\n     * @param y The Y position in css/client coordinates (without applied display ratio).\n     */\n    getGeoCoordinatesAt(x, y) {\n        const worldPosition = this.getWorldPositionAt(x, y);\n        if (!worldPosition) {\n            return null;\n        }\n        return this.projection.unprojectPoint(worldPosition);\n    }\n    /**\n     * Returns the normalized screen coordinates from the given pixel position.\n     *\n     * @param x The X position in css/client coordinates (without applied display ratio).\n     * @param y The Y position in css/client coordinates (without applied display ratio).\n     */\n    getNormalizedScreenCoordinates(x, y) {\n        // use clientWidth and clientHeight as it does not apply the pixelRatio and\n        // therefore supports also HiDPI devices\n        const { width, height } = this.getCanvasClientSize();\n        return new THREE.Vector3((x / width) * 2 - 1, -((y / height) * 2) + 1, 0);\n    }\n    /**\n     * Do a raycast on all objects in the scene. Useful for picking. Limited to objects that\n     * THREE.js can raycast, the solid lines that get their geometry in the shader cannot be tested\n     * for intersection.\n     *\n     * Note, if a [[DataSource]] adds an [[Object3D]] to a [[Tile]], it will be only pickable once\n     * [[MapView.render]] has been called, this is because [[MapView.render]] method creates the\n     * internal three.js root [[Object3D]] which is used in the [[PickHandler]] internally.\n     * This method will not test for intersection custom objects added to the scene by for\n     * example calling directly the [[scene.add]] method from THREE.\n     *\n     * @param x The X position in css/client coordinates (without applied display ratio).\n     * @param y The Y position in css/client coordinates (without applied display ratio).\n     * @returns The list of intersection results.\n     */\n    intersectMapObjects(x, y) {\n        return this.m_pickHandler.intersectMapObjects(x, y);\n    }\n    /**\n     * Resize the HTML canvas element and the THREE.js `WebGLRenderer`.\n     *\n     * @param width The new width.\n     * @param height The new height.\n     */\n    resize(width, height) {\n        this.m_renderer.setSize(width, height, false);\n        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {\n            this.m_renderer.setPixelRatio(this.pixelRatio);\n        }\n        if (this.mapRenderingManager !== undefined) {\n            this.mapRenderingManager.setSize(width, height);\n        }\n        if (this.collisionDebugCanvas !== undefined) {\n            this.collisionDebugCanvas.width = width;\n            this.collisionDebugCanvas.height = height;\n        }\n        this.updateCameras();\n        this.update();\n        this.dispatchEvent({\n            type: MapViewEventNames.Resize,\n            size: {\n                width,\n                height\n            }\n        });\n    }\n    /**\n     * Redraws scene immediately\n     *\n     * @note Before using this method, set `synchronousRendering` to `true`\n     * in the [[MapViewOptions]]\n     */\n    renderSync() {\n        this.renderFunc(harp_utils_1.PerformanceTimer.now());\n    }\n    /**\n     * Requests a redraw of the scene.\n     */\n    update() {\n        this.dispatchEvent(UPDATE);\n        if (this.m_updatePending) {\n            return;\n        } // compress the update request\n        this.m_updatePending = true;\n        if (this.animating) {\n            return;\n        } // nothing to do\n        this.drawFrame();\n    }\n    /**\n     * Returns `true` if an update has already been requested, such that after a currently rendering\n     * frame, the next frame will be rendered immediately.\n     */\n    get updatePending() {\n        return this.m_updatePending;\n    }\n    /**\n     * Requests a redraw of the scene.\n     * @deprecated Use the [[update]] method instead.\n     */\n    requestUpdateIfNeeded() {\n        this.update();\n    }\n    /**\n     * Clear the tile cache.\n     *\n     * Remove the [[Tile]] objects created by cacheable [[DataSource]]s. If a [[DataSource]] name is\n     * provided, this method restricts the eviction the [[DataSource]] with the given name.\n     *\n     * @param dataSourceName The name of the [[DataSource]].\n     */\n    clearTileCache(dataSourceName) {\n        if (dataSourceName !== undefined) {\n            const dataSource = this.getDataSourceByName(dataSourceName);\n            if (dataSource) {\n                this.m_visibleTiles.clearTileCache(dataSource);\n                dataSource.clearCache();\n            }\n        }\n        else {\n            this.m_visibleTiles.clearTileCache();\n            this.m_tileDataSources.forEach(dataSource => dataSource.clearCache());\n        }\n        if (this.m_elevationProvider !== undefined) {\n            this.m_elevationProvider.clearCache();\n        }\n    }\n    /**\n     * Apply visitor to all visible tiles.\n     *\n     * @param fun Visitor function\n     */\n    forEachVisibleTile(fun) {\n        this.m_visibleTiles.forEachVisibleTile(fun);\n    }\n    /**\n     * Apply a visitor function to all tiles in the cache.\n     *\n     * @param visitor Visitor function\n     */\n    forEachCachedTile(visitor) {\n        this.m_visibleTiles.forEachCachedTile(visitor);\n    }\n    /**\n     * Visit each tile in visible, rendered, and cached sets.\n     *\n     *  * Visible and temporarily rendered tiles will be marked for update and retained.\n     *  * Cached but not rendered/visible will be evicted.\n     *\n     * @param dataSource If passed, only the tiles from this [[DataSource]] instance are processed.\n     * If `undefined`, tiles from all [[DataSource]]s are processed.\n     */\n    markTilesDirty(dataSource) {\n        this.m_visibleTiles.markTilesDirty(dataSource);\n    }\n    /**\n     * Sets the DataSource which contains the elevations, the elevation range source, and the\n     * elevation provider. Only a single elevation source is possible per [[MapView]]\n     *\n     * If the terrain-datasource is merged with this repository, we could internally construct\n     * the [[ElevationRangeSource]] and the [[ElevationProvider]] and access would be granted to\n     * the application when it asks for it, to simplify the API.\n     *\n     * @param elevationSource The datasource containing the terrain tiles.\n     * @param elevationRangeSource Allows access to the elevation min / max per tile.\n     * @param elevationProvider Allows access to the elevation at a given location or a ray\n     *      from the camera.\n     */\n    setElevationSource(elevationSource, elevationRangeSource, elevationProvider) {\n        // Try to remove incase this method was already called, will do nothing if it doesn't exist.\n        this.removeDataSource(elevationSource);\n        this.addDataSource(elevationSource);\n        this.m_elevationRangeSource = elevationRangeSource;\n        this.m_elevationRangeSource.connect();\n        this.m_elevationProvider = elevationProvider;\n        this.dataSources.forEach(dataSource => {\n            dataSource.setEnableElevationOverlay(true);\n        });\n        this.m_tileGeometryManager.setTileUpdateCallback((tile) => {\n            overlayOnElevation_1.overlayOnElevation(tile);\n        });\n        this.clearTileCache();\n    }\n    /**\n     * Clears any elevation sources and provider previously set.\n     * @param elevationSource The datasource to be cleared.\n     */\n    clearElevationSource(elevationSource) {\n        this.removeDataSource(elevationSource);\n        this.m_elevationRangeSource = undefined;\n        this.m_elevationProvider = undefined;\n        this.dataSources.forEach(dataSource => {\n            dataSource.setEnableElevationOverlay(false);\n        });\n        this.m_tileGeometryManager.setTileUpdateCallback(undefined);\n        this.clearTileCache();\n    }\n    /**\n     * Public access to [[MapViewFog]] allowing to toggle it by setting its `enabled` property.\n     */\n    get fog() {\n        return this.m_fog;\n    }\n    setPostEffects() {\n        // First clear all the effects, then enable them from what is specified.\n        this.mapRenderingManager.bloom.enabled = false;\n        this.mapRenderingManager.outline.enabled = false;\n        this.mapRenderingManager.vignette.enabled = false;\n        this.mapRenderingManager.sepia.enabled = false;\n        if (this.m_postEffects !== undefined) {\n            if (this.m_postEffects.bloom !== undefined) {\n                this.mapRenderingManager.bloom = this.m_postEffects.bloom;\n            }\n            if (this.m_postEffects.outline !== undefined) {\n                this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;\n                this.mapRenderingManager.updateOutline(this.m_postEffects.outline);\n            }\n            if (this.m_postEffects.vignette !== undefined) {\n                this.mapRenderingManager.vignette = this.m_postEffects.vignette;\n            }\n            if (this.m_postEffects.sepia !== undefined) {\n                this.mapRenderingManager.sepia = this.m_postEffects.sepia;\n            }\n        }\n    }\n    /**\n     * Returns the elevation provider.\n     */\n    get elevationProvider() {\n        return this.m_elevationProvider;\n    }\n    /**\n     * Plug-in PolarTileDataSource for spherical projection and plug-out otherwise\n     */\n    updatePolarDataSource() {\n        const dataSource = this.m_polarDataSource;\n        if (this.m_enablePolarDataSource === true && dataSource !== undefined) {\n            const twinDataSource = this.getDataSourceByName(dataSource.name);\n            if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n                if (twinDataSource === undefined) {\n                    this.addDataSource(dataSource);\n                }\n            }\n            else {\n                if (twinDataSource !== undefined) {\n                    this.removeDataSource(dataSource);\n                }\n            }\n        }\n    }\n    /**\n     * Updates the camera and the projections and resets the screen collisions,\n     * note, setupCamera must be called before this is called.\n     * @param viewRanges optional parameter that supplies new view ranges, most importantly\n     * near/far clipping planes distance. If parameter is not provided view ranges will be\n     * calculated from [[ClipPlaneEvaluator]] used in [[VisibleTileSet]].\n     */\n    updateCameras(viewRanges) {\n        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);\n        this.m_camera.aspect =\n            this.m_forceCameraAspect !== undefined ? this.m_forceCameraAspect : width / height;\n        this.setFovOnCamera(this.m_options.fovCalculation, height);\n        // When calculating clip planes account for the highest building on the earth,\n        // multiplying its height by projection scaling factor. This approach assumes\n        // constantHeight property of extruded polygon technique is set as default false,\n        // otherwise the near plane margins will be bigger then required, but still correct.\n        const projectionScale = this.projection.getScaleFactor(this.camera.position);\n        const maxGeometryHeightScaled = projectionScale *\n            this.m_tileDataSources.reduce((r, ds) => Math.max(r, ds.maxGeometryHeight), 0);\n        // Copy all properties from new view ranges to our readonly object.\n        // This allows to keep all view ranges references valid and keeps up-to-date\n        // information within them. Works the same as copping all properties one-by-one.\n        Object.assign(this.m_viewRanges, viewRanges === undefined\n            ? this.m_visibleTiles.updateClipPlanes(maxGeometryHeightScaled)\n            : viewRanges);\n        this.m_camera.near = this.m_viewRanges.near;\n        this.m_camera.far = this.m_viewRanges.far;\n        this.m_camera.updateProjectionMatrix();\n        this.m_camera.updateMatrixWorld(false);\n        // Update the \"relative to eye\" camera. Copy the public camera parameters\n        // and place the \"relative to eye\" at the world's origin.\n        this.m_rteCamera.copy(this.m_camera);\n        this.m_rteCamera.position.setScalar(0);\n        this.m_rteCamera.updateMatrixWorld(true);\n        this.m_screenCamera.left = width / -2;\n        this.m_screenCamera.right = width / 2;\n        this.m_screenCamera.bottom = height / -2;\n        this.m_screenCamera.top = height / 2;\n        this.m_screenCamera.updateProjectionMatrix();\n        this.m_screenCamera.updateMatrixWorld(false);\n        this.m_screenProjector.update(this.camera, width, height);\n        this.m_screenCollisions.update(width, height);\n        this.m_pixelToWorld = undefined;\n        const cameraPitch = Utils_1.MapViewUtils.extractAttitude(this, this.m_camera).pitch;\n        const cameraPosZ = this.getCameraHeightAboveTerrain(TERRAIN_ZOOM_LEVEL);\n        const target = Utils_1.MapViewUtils.rayCastWorldCoordinates(this, 0, 0);\n        if (target !== null) {\n            this.m_lookAtDistance = target.sub(this.camera.position).length();\n            const zoomLevelDistance = cameraPosZ / Math.cos(Math.min(cameraPitch, Math.PI / 3));\n            this.m_zoomLevel = Utils_1.MapViewUtils.calculateZoomLevelFromDistance(this, zoomLevelDistance);\n            this.m_fog.update(this, this.m_viewRanges.maximum);\n        }\n    }\n    /**\n     * Returns the height of the camera above the earths surface.\n     *\n     * If there is an ElevationProvider, this is used. Otherwise the projection is used to determine\n     * how high the camera is above the surface.\n     *\n     * @param level Which level to request the surface height from.\n     * @return Height in world units.\n     */\n    getCameraHeightAboveTerrain(level) {\n        if (this.elevationProvider !== undefined) {\n            const heightAboveTerrain = this.elevationProvider.getHeight(this.geoCenter, level);\n            if (heightAboveTerrain !== undefined) {\n                const height = this.projection.unprojectAltitude(this.m_camera.position) - heightAboveTerrain;\n                return Math.max(height, 1);\n            }\n        }\n        return Math.abs(this.projection.groundDistance(this.m_camera.position));\n    }\n    detectCurrentFps(now) {\n        // Skip the first frames, they are from not originated from requestAnimationFrame()\n        if (this.m_previousRequestAnimationTime !== undefined && this.m_frameNumber > 5) {\n            const currentFps = 1000 / (now - this.m_previousRequestAnimationTime);\n            this.m_frameTimeRing[this.m_frameTimeIndex % FRAME_RATE_RING_SIZE] = currentFps;\n            this.m_frameTimeIndex++;\n            const capturedFrames = Math.min(this.m_frameTimeIndex, FRAME_RATE_RING_SIZE);\n            let sum = 0;\n            for (let i = 0; i < capturedFrames; i++) {\n                sum += this.m_frameTimeRing[i];\n            }\n            this.m_detectedFps = sum / capturedFrames;\n        }\n        this.m_previousRequestAnimationTime = now;\n    }\n    /**\n     * Draw a new frame.\n     */\n    drawFrame() {\n        if (this.m_drawing || this.m_options.synchronousRendering) {\n            return;\n        }\n        // Cancel an active requestAnimationFrame() cycle. Failure to do this may end up in\n        // rendering multiple times during a single frame.\n        if (this.m_animationFrameHandle !== undefined) {\n            cancelAnimationFrame(this.m_animationFrameHandle);\n            this.m_animationFrameHandle = undefined;\n        }\n        if (this.m_maxFps <= 0) {\n            // Render at maximum FPS.\n            this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);\n            return;\n        }\n        // Magic ingredient to compensate time flux.\n        const fudgeTimeInMs = 3;\n        const vSyncFrameTime = 1000 / this.m_detectedFps;\n        const frameInterval = 1000 / this.m_maxFps;\n        const previousFrameTime = this.m_previousFrameTimeStamp === undefined ? 0 : this.m_previousFrameTimeStamp;\n        // Compute a practical value to compare against.\n        const targetTime = previousFrameTime + frameInterval - vSyncFrameTime - fudgeTimeInMs;\n        this.m_targetRequestAnimationTime = targetTime;\n        this.postponedAnimationFrame(previousFrameTime);\n    }\n    postponedAnimationFrame(now) {\n        if (this.m_targetRequestAnimationTime === undefined) {\n            return;\n        }\n        if (this.m_animationFrameHandle !== undefined) {\n            cancelAnimationFrame(this.m_animationFrameHandle);\n            this.m_animationFrameHandle = undefined;\n        }\n        this.detectCurrentFps(now);\n        this.m_animationFrameHandle = requestAnimationFrame(now > this.m_targetRequestAnimationTime\n            ? this.handleRequestAnimationFrame\n            : this.handlePostponedAnimationFrame);\n    }\n    /**\n     * Draw a new frame.\n     */\n    renderFunc(time) {\n        this.render(time);\n    }\n    /**\n     * Returns the list of the enabled data sources.\n     */\n    getEnabledTileDataSources() {\n        // ### build this list once decoders && datasources are ready\n        const enabledDataSources = [];\n        for (const dataSource of this.m_tileDataSources) {\n            if (this.isDataSourceEnabled(dataSource)) {\n                enabledDataSources.push(dataSource);\n            }\n        }\n        return enabledDataSources;\n    }\n    /**\n     * Renders the current frame.\n     */\n    render(time) {\n        if (this.m_drawing) {\n            return;\n        }\n        ++this.m_frameNumber;\n        const stats = Statistics_1.PerformanceStatistics.instance;\n        const gatherStatistics = stats.enabled;\n        const frameStartTime = time;\n        RENDER_EVENT.time = time;\n        this.dispatchEvent(RENDER_EVENT);\n        let currentFrameEvent;\n        if (gatherStatistics) {\n            currentFrameEvent = stats.currentFrame;\n            currentFrameEvent.setValue(\"renderCount.frameNumber\", this.m_frameNumber);\n            if (this.m_previousFrameTimeStamp !== undefined) {\n                const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;\n                if (gatherStatistics) {\n                    currentFrameEvent.setValue(\"render.fullFrameTime\", timeSincePreviousFrame);\n                    // For convenience and easy readability\n                    currentFrameEvent.setValue(\"render.fps\", 1000 / timeSincePreviousFrame);\n                }\n            }\n        }\n        this.m_previousFrameTimeStamp = frameStartTime;\n        let setupTime;\n        let cullTime;\n        let textPlacementTime;\n        let drawTime;\n        let textDrawTime;\n        let endTime;\n        this.m_renderer.info.reset();\n        this.m_updatePending = false;\n        this.m_thisFrameTilesChanged = undefined;\n        this.m_drawing = true;\n        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {\n            this.m_renderer.setPixelRatio(this.pixelRatio);\n        }\n        this.updateCameras();\n        this.m_renderer.clear();\n        // clear the scene\n        while (this.m_mapTilesRoot.children.length > 0) {\n            this.m_mapTilesRoot.remove(this.m_mapTilesRoot.children[0]);\n        }\n        if (gatherStatistics) {\n            setupTime = harp_utils_1.PerformanceTimer.now();\n        }\n        // TBD: Update renderList only any of its params (camera, etc...) has changed.\n        if (!this.lockVisibleTileSet) {\n            const viewRangesStatus = this.m_visibleTiles.updateRenderList(this.storageLevel, Math.floor(this.zoomLevel), this.getEnabledTileDataSources(), this.m_elevationRangeSource);\n            // View ranges has changed due to features (with elevation) that affects clip planes\n            // positioning, update cameras with new clip planes positions.\n            if (viewRangesStatus.viewRangesChanged) {\n                this.updateCameras(viewRangesStatus.viewRanges);\n            }\n        }\n        if (gatherStatistics) {\n            cullTime = harp_utils_1.PerformanceTimer.now();\n        }\n        const renderList = this.m_visibleTiles.dataSourceTileList;\n        // no need to check everything if we're not going to create text renderer.\n        renderList.forEach(({ zoomLevel, renderedTiles }) => {\n            renderedTiles.forEach(tile => {\n                this.renderTileObjects(tile, zoomLevel);\n                //We know that rendered tiles are visible (in the view frustum), so we update the\n                //frame number, note we don't do this for the visibleTiles because some may still be\n                //loading (and therefore aren't visible in the sense of being seen on the screen).\n                //Note also, this number isn't currently used anywhere so should be considered to be\n                //removed in the future (though could be good for debugging purposes).\n                tile.frameNumLastVisible = this.m_frameNumber;\n            });\n        });\n        // Check if this is the time to place the labels for the first time. Pretty much everything\n        // should have been loaded, and no animation should be running.\n        if (!this.m_initialTextPlacementDone &&\n            !this.m_firstFrameComplete &&\n            !this.isDynamicFrame &&\n            !this.m_themeIsLoading &&\n            this.m_poiTableManager.finishedLoading &&\n            this.m_visibleTiles.allVisibleTilesLoaded &&\n            this.m_connectedDataSources.size + this.m_failedDataSources.size ===\n                this.m_tileDataSources.length &&\n            !this.m_textElementsRenderer.initializing &&\n            !this.m_textElementsRenderer.loading) {\n            this.m_initialTextPlacementDone = true;\n        }\n        this.m_mapAnchors.children.forEach((childObject) => {\n            if (childObject.geoPosition === undefined) {\n                return;\n            }\n            this.projection.projectPoint(childObject.geoPosition, childObject.position);\n            childObject.position.sub(this.camera.position);\n        });\n        this.m_animatedExtrusionHandler.zoom = this.m_zoomLevel;\n        if (currentFrameEvent !== undefined) {\n            // Make sure the counters all have a value.\n            currentFrameEvent.addValue(\"renderCount.numTilesRendered\", 0);\n            currentFrameEvent.addValue(\"renderCount.numTilesVisible\", 0);\n            currentFrameEvent.addValue(\"renderCount.numTilesLoading\", 0);\n            // Increment the counters for all data sources.\n            renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {\n                currentFrameEvent.addValue(\"renderCount.numTilesRendered\", renderedTiles.size);\n                currentFrameEvent.addValue(\"renderCount.numTilesVisible\", visibleTiles.length);\n                currentFrameEvent.addValue(\"renderCount.numTilesLoading\", numTilesLoading);\n            });\n        }\n        if (this.m_movementDetector.checkCameraMoved(this, time)) {\n            const { yaw, pitch, roll } = Utils_1.MapViewUtils.extractAttitude(this, this.camera);\n            const { latitude, longitude, altitude } = this.geoCenter;\n            this.dispatchEvent({\n                type: MapViewEventNames.CameraPositionChanged,\n                latitude,\n                longitude,\n                altitude,\n                yaw,\n                pitch,\n                roll,\n                zoom: this.zoomLevel\n            });\n        }\n        // The camera used to render the scene.\n        const camera = this.m_pointOfView !== undefined ? this.m_pointOfView : this.m_rteCamera;\n        if (this.renderLabels) {\n            this.prepareRenderTextElements(time);\n        }\n        if (gatherStatistics) {\n            textPlacementTime = harp_utils_1.PerformanceTimer.now();\n        }\n        if (this.m_skyBackground !== undefined && this.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            this.m_skyBackground.updateCamera(this.m_camera);\n        }\n        this.mapRenderingManager.render(this.m_renderer, this.m_scene, camera, !this.isDynamicFrame);\n        if (gatherStatistics) {\n            drawTime = harp_utils_1.PerformanceTimer.now();\n        }\n        if (this.renderLabels) {\n            this.finishRenderTextElements();\n        }\n        if (gatherStatistics) {\n            textDrawTime = harp_utils_1.PerformanceTimer.now();\n        }\n        if (!this.m_firstFrameRendered) {\n            this.m_firstFrameRendered = true;\n            if (gatherStatistics) {\n                stats.appResults.set(\"firstFrame\", time);\n            }\n            FIRST_FRAME_EVENT.time = time;\n            this.dispatchEvent(FIRST_FRAME_EVENT);\n        }\n        this.m_visibleTiles.disposePendingTiles();\n        this.m_drawing = false;\n        if (this.animating || this.m_updatePending) {\n            this.drawFrame();\n        }\n        this.checkCopyrightUpdates();\n        if (currentFrameEvent !== undefined) {\n            endTime = harp_utils_1.PerformanceTimer.now();\n            currentFrameEvent.setValue(\"render.setupTime\", setupTime - frameStartTime);\n            currentFrameEvent.setValue(\"render.cullTime\", cullTime - setupTime);\n            currentFrameEvent.setValue(\"render.textPlacementTime\", textPlacementTime - cullTime);\n            currentFrameEvent.setValue(\"render.drawTime\", drawTime - textPlacementTime);\n            currentFrameEvent.setValue(\"render.textDrawTime\", textDrawTime - drawTime);\n            currentFrameEvent.setValue(\"render.cleanupTime\", endTime - textDrawTime);\n            currentFrameEvent.setValue(\"render.frameRenderTime\", endTime - frameStartTime);\n            Statistics_1.PerformanceStatistics.instance.storeFrameInfo(this.m_renderer.info);\n        }\n        DID_RENDER_EVENT.time = time;\n        this.dispatchEvent(DID_RENDER_EVENT);\n        // After completely rendering this frame, it is checked if this frame was the first complete\n        // frame, with no more tiles, geometry and labels waiting to be added, and no animation\n        // running. The initial placement of text in this render call may have changed the loading\n        // state of the TextElementsRenderer, so this has to be checked again.\n        if (!this.m_firstFrameComplete &&\n            this.m_initialTextPlacementDone &&\n            !this.isDynamicFrame &&\n            !this.textElementsRenderer.loading) {\n            this.m_firstFrameComplete = true;\n            if (gatherStatistics) {\n                stats.appResults.set(\"firstFrameComplete\", time);\n            }\n            FRAME_COMPLETE_EVENT.time = time;\n            this.dispatchEvent(FRAME_COMPLETE_EVENT);\n        }\n    }\n    renderTileObjects(tile, zoomLevel) {\n        const worldOffsetX = tile.computeWorldOffsetX();\n        if (tile.willRender(zoomLevel)) {\n            for (const object of tile.objects) {\n                object.position.copy(tile.center);\n                if (object.displacement !== undefined) {\n                    object.position.add(object.displacement);\n                }\n                object.position.x += worldOffsetX;\n                object.position.sub(this.m_camera.position);\n                if (tile.localTangentSpace) {\n                    object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());\n                }\n                object.frustumCulled = false;\n                if (object._backupRenderOrder === undefined) {\n                    object._backupRenderOrder = object.renderOrder;\n                }\n                const isBuilding = object.userData !== undefined &&\n                    object.userData.kind !== undefined &&\n                    object.userData.kind.includes(harp_datasource_protocol_1.GeometryKind.Building);\n                // When falling back to a parent tile (i.e. tile.levelOffset < 0) there will\n                // be overlaps with the already loaded tiles. Therefore all (flat) objects\n                // in a fallback tile must be shifted, such that their renderOrder is less\n                // than the groundPlane that each neighbouring Tile has (it has a renderOrder\n                // of -10000, see addGroundPlane in TileGeometryCreator), only then can we be\n                // sure that nothing of the parent will be rendered on top of the children,\n                // as such, we shift using the FALLBACK_RENDER_ORDER_OFFSET.\n                // This does not apply to buildings b/c they are 3d and the overlaps\n                // are resolved with a depth prepass. Note we set this always to ensure that if\n                // the Tile is used as a fallback, and then used normally, that we have the correct\n                // renderOrder.\n                object.renderOrder =\n                    object._backupRenderOrder +\n                        (!isBuilding && tile.levelOffset < 0\n                            ? exports.FALLBACK_RENDER_ORDER_OFFSET * tile.levelOffset\n                            : 0);\n                this.m_mapTilesRoot.add(object);\n            }\n        }\n        tile.didRender();\n    }\n    prepareRenderTextElements(time) {\n        // Disable rendering of text elements for debug camera. TextElements are rendered using an\n        // orthographic camera that covers the entire available screen space. Unfortunately, this\n        // particular camera set up is not compatible with the debug camera.\n        const debugCameraActive = this.m_pointOfView !== undefined;\n        if (debugCameraActive) {\n            return;\n        }\n        this.m_textElementsRenderer.placeText(this.m_visibleTiles.dataSourceTileList, this.projection, time);\n    }\n    finishRenderTextElements() {\n        const canRenderTextElements = this.m_pointOfView === undefined;\n        if (canRenderTextElements) {\n            // copy far value from scene camera, as the distance to the POIs matter now.\n            this.m_screenCamera.far = this.m_viewRanges.maximum;\n            this.m_textElementsRenderer.renderText(this.m_screenCamera);\n        }\n    }\n    initTheme() {\n        const theme = harp_utils_1.getOptionValue(this.m_options.theme, exports.MapViewDefaults.theme);\n        this.m_themeIsLoading = true;\n        Promise.resolve(theme)\n            // tslint:disable-next-line: no-shadowed-variable\n            .then(theme => ThemeLoader_1.ThemeLoader.load(theme, { uriResolver: this.m_uriResolver }))\n            // tslint:disable-next-line: no-shadowed-variable\n            .then(theme => {\n            this.m_themeIsLoading = false;\n            this.theme = theme;\n        })\n            .catch(error => {\n            this.m_themeIsLoading = false;\n            const themeName = typeof this.m_options.theme === \"string\" ? ` from ${this.m_options.theme}` : \"\";\n            logger.error(`Failed to load theme${themeName}: ${error}`, error);\n        });\n    }\n    setupCamera(options) {\n        const { width, height } = this.getCanvasClientSize();\n        const defaultGeoCenter = exports.MapViewDefaults.geoCenter;\n        this.projection.projectPoint(defaultGeoCenter, this.m_camera.position);\n        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            this.m_camera.lookAt(this.scene.position);\n        }\n        this.m_lookAtDistance = defaultGeoCenter.altitude;\n        this.calculateFocalLength(height);\n        this.m_visibleTiles = this.createVisibleTileSet();\n        this.setInitialCameraPosition(options);\n        // ### move & customize\n        this.resize(width, height);\n        this.m_screenCamera.position.z = 1;\n        this.m_screenCamera.near = 0;\n    }\n    setInitialCameraPosition(options) {\n        const target = harp_geoutils_1.GeoCoordinates.fromObject(harp_utils_1.getOptionValue(options.target, exports.MapViewDefaults.target));\n        target.altitude = 0; // ensure that look at target has height of 0\n        const zoomLevel = harp_utils_1.getOptionValue(options.zoomLevel, exports.MapViewDefaults.zoomLevel);\n        const tilt = harp_utils_1.getOptionValue(options.tilt, exports.MapViewDefaults.tilt);\n        const heading = harp_utils_1.getOptionValue(options.heading, exports.MapViewDefaults.heading);\n        this.lookAt(target, 300000, tilt, heading);\n        this.zoomLevel = zoomLevel;\n    }\n    createVisibleTileSet() {\n        const enableMixedLod = this.m_enableMixedLod === undefined\n            ? this.projection.type === harp_geoutils_1.ProjectionType.Spherical\n            : this.m_enableMixedLod;\n        return new VisibleTileSet_1.VisibleTileSet(new FrustumIntersection_1.FrustumIntersection(this.m_camera, this, this.m_visibleTileSetOptions.extendedFrustumCulling, this.m_tileWrappingEnabled, enableMixedLod), this.m_tileGeometryManager, this.m_visibleTileSetOptions);\n    }\n    updateSkyBackground() {\n        if (this.m_theme === undefined) {\n            return;\n        }\n        const theme = this.m_theme;\n        if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky !== undefined) {\n            // there is a sky in the view and there is a sky option in the theme. Update the colors\n            this.updateSkyBackgroundColors(theme.sky, theme.clearColor);\n        }\n        else if (this.m_skyBackground === undefined && theme.sky !== undefined) {\n            // there is no sky in the view but there is a sky option in the theme\n            this.addNewSkyBackground(theme.sky, theme.clearColor);\n            return;\n        }\n        else if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky === undefined) {\n            // there is a sky in the view, but not in the theme\n            this.removeSkyBackGround();\n        }\n    }\n    addNewSkyBackground(sky, clearColor) {\n        if (sky.type === \"gradient\" && sky.groundColor === undefined) {\n            sky.groundColor = harp_utils_1.getOptionValue(clearColor, \"#000000\");\n        }\n        this.m_skyBackground = new SkyBackground_1.SkyBackground(sky, this.projection.type, this.m_camera);\n        this.m_scene.background = this.m_skyBackground.texture;\n    }\n    removeSkyBackGround() {\n        this.m_scene.background = null;\n        if (this.m_skyBackground !== undefined) {\n            this.m_skyBackground.dispose();\n            this.m_skyBackground = undefined;\n        }\n    }\n    updateSkyBackgroundColors(sky, clearColor) {\n        if (sky.type === \"gradient\" && sky.groundColor === undefined) {\n            sky.groundColor = harp_utils_1.getOptionValue(clearColor, \"#000000\");\n        }\n        if (this.m_skyBackground !== undefined) {\n            this.m_skyBackground.updateTexture(sky, this.projection.type);\n        }\n    }\n    updateLighting() {\n        if (!this.m_theme) {\n            return;\n        }\n        const theme = this.m_theme;\n        if (theme.clearColor !== undefined) {\n            this.m_renderer.setClearColor(new THREE.Color(theme.clearColor));\n        }\n        if (this.m_createdLights) {\n            this.m_createdLights.forEach((light) => {\n                this.m_scene.remove(light);\n            });\n        }\n        if (theme.lights !== undefined) {\n            this.m_createdLights = [];\n            theme.lights.forEach((lightDescription) => {\n                const light = ThemeHelpers_1.createLight(lightDescription);\n                if (!light) {\n                    logger.warn(\n                    // tslint:disable-next-line: max-line-length\n                    `MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`);\n                    return;\n                }\n                this.m_scene.add(light);\n                this.m_createdLights.push(light);\n            });\n        }\n    }\n    movementStarted() {\n        this.m_textElementsRenderer.movementStarted();\n        MOVEMENT_STARTED_EVENT.time = Date.now();\n        this.dispatchEvent(MOVEMENT_STARTED_EVENT);\n    }\n    movementFinished() {\n        this.m_textElementsRenderer.movementFinished();\n        MOVEMENT_FINISHED_EVENT.time = Date.now();\n        this.dispatchEvent(MOVEMENT_FINISHED_EVENT);\n        // render at the next possible time.\n        if (!this.animating) {\n            if (this.m_movementFinishedUpdateTimerId !== undefined) {\n                clearTimeout(this.m_movementFinishedUpdateTimerId);\n            }\n            this.m_movementFinishedUpdateTimerId = setTimeout(() => {\n                this.m_movementFinishedUpdateTimerId = undefined;\n                this.update();\n            }, 0);\n        }\n    }\n    /**\n     * Check if the set of visible tiles changed since the last frame.\n     *\n     * May be called multiple times per frame.\n     *\n     * Equality is computed by creating a string containing the IDs of the tiles.\n     */\n    checkIfTilesChanged() {\n        if (this.m_thisFrameTilesChanged !== undefined) {\n            return this.m_thisFrameTilesChanged;\n        }\n        const renderList = this.m_visibleTiles.dataSourceTileList;\n        const tileIdList = [];\n        tileIdList.length = 0;\n        renderList.forEach(({ dataSource, renderedTiles }) => {\n            renderedTiles.forEach(tile => {\n                tileIdList.push(dataSource.name + \"-\" + tile.tileKey.mortonCode());\n            });\n        });\n        tileIdList.sort();\n        const newTileIds = tileIdList.join(\"#\");\n        if (newTileIds !== this.m_lastTileIds) {\n            this.m_lastTileIds = newTileIds;\n            this.m_thisFrameTilesChanged = true;\n        }\n        else {\n            this.m_thisFrameTilesChanged = false;\n        }\n        return this.m_thisFrameTilesChanged;\n    }\n    checkCopyrightUpdates() {\n        if (!this.checkIfTilesChanged()) {\n            return;\n        }\n        const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();\n        if (newCopyrightInfo === this.m_copyrightInfo) {\n            return;\n        }\n        if (newCopyrightInfo.length === this.m_copyrightInfo.length) {\n            let allEqual = true;\n            for (let i = 0; i < newCopyrightInfo.length; i++) {\n                const a = newCopyrightInfo[i];\n                const b = this.m_copyrightInfo[i];\n                if (a.label !== b.label) {\n                    allEqual = false;\n                    break;\n                }\n            }\n            if (allEqual) {\n                return;\n            }\n        }\n        this.m_copyrightInfo = newCopyrightInfo;\n        this.dispatchEvent(COPYRIGHT_CHANGED_EVENT);\n    }\n    getRenderedTilesCopyrightInfo() {\n        let result = [];\n        for (const tileList of this.m_visibleTiles.dataSourceTileList) {\n            for (const tile of tileList.renderedTiles.values()) {\n                const tileCopyrightInfo = tile.copyrightInfo;\n                if (tileCopyrightInfo === undefined || tileCopyrightInfo.length === 0) {\n                    continue;\n                }\n                result = CopyrightInfo_1.CopyrightInfo.mergeArrays(result, tileCopyrightInfo);\n            }\n        }\n        return result;\n    }\n    updateImages() {\n        if (!this.m_theme) {\n            return;\n        }\n        const theme = this.m_theme;\n        this.m_imageCache.clear();\n        this.poiManager.clear();\n        if (theme.images !== undefined) {\n            for (const name of Object.keys(theme.images)) {\n                const image = theme.images[name];\n                this.m_imageCache.addImage(name, image.url, image.preload === true);\n                if (typeof image.atlas === \"string\") {\n                    this.poiManager.addTextureAtlas(name, image.atlas);\n                }\n            }\n        }\n        if (theme.imageTextures !== undefined) {\n            theme.imageTextures.forEach((imageTexture) => {\n                this.poiManager.addImageTexture(imageTexture);\n            });\n        }\n    }\n    loadPoiTables() {\n        if (this.m_theme === undefined) {\n            return;\n        }\n        this.poiTableManager.clear();\n        // Add the POI tables defined in the theme.\n        this.poiTableManager\n            .loadPoiTables(this.m_theme)\n            .then(() => this.update())\n            .catch(() => this.update());\n    }\n    setupStats(enable) {\n        // tslint:disable-next-line:no-unused-expression\n        new Statistics_1.PerformanceStatistics(enable, 1000);\n    }\n    setupRenderer() {\n        this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);\n        this.m_scene.add(this.m_mapTilesRoot);\n        this.m_scene.add(this.m_mapAnchors);\n    }\n    createTextRenderer() {\n        const updateCallback = () => {\n            this.update();\n        };\n        return new TextElementsRenderer_1.TextElementsRenderer(new MapViewState_1.MapViewState(this, this.checkIfTilesChanged.bind(this)), this.m_camera, updateCallback, this.m_screenCollisions, this.m_screenProjector, new TextCanvasFactory_1.TextCanvasFactory(this.m_renderer), this.m_poiManager, new PoiRendererFactory_1.PoiRendererFactory(this), new FontCatalogLoader_1.FontCatalogLoader(this.m_theme), this.m_theme, this.m_options);\n    }\n    resetTextRenderer() {\n        const overlayText = this.m_textElementsRenderer.overlayText;\n        this.m_textElementsRenderer = this.createTextRenderer();\n        if (overlayText !== undefined) {\n            this.m_textElementsRenderer.addOverlayText(overlayText);\n        }\n    }\n    limitFov(fov, aspect) {\n        fov = THREE.Math.clamp(fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);\n        let hFov = THREE.Math.radToDeg(Utils_1.MapViewUtils.calculateHorizontalFovByVerticalFov(THREE.Math.degToRad(fov), aspect));\n        if (hFov > MAX_FIELD_OF_VIEW || hFov < MIN_FIELD_OF_VIEW) {\n            hFov = THREE.Math.clamp(hFov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);\n            fov = THREE.Math.radToDeg(Utils_1.MapViewUtils.calculateVerticalFovByHorizontalFov(THREE.Math.degToRad(hFov), aspect));\n        }\n        return fov;\n    }\n    /**\n     * Sets the field of view calculation, and applies it immediately to the camera.\n     *\n     * @param type How to calculate the FOV\n     */\n    setFovOnCamera(fovCalculation, height) {\n        let fov = 0;\n        if (fovCalculation.type === \"fixed\") {\n            this.calculateFocalLength(height);\n            fov = fovCalculation.fov;\n        }\n        else {\n            harp_utils_1.assert(this.m_focalLength !== 0);\n            fov = Utils_1.MapViewUtils.calculateFovByFocalLength(this.m_focalLength, height);\n        }\n        this.m_camera.fov = this.limitFov(fov, this.m_camera.aspect);\n    }\n    /**\n     * Sets the focal length based on the supplied fov and the height of the canvas. This must be\n     * called at least once. This is necessary to be recalled when the [[FovCalculation]]'s type is\n     * fixed. In such cases, when the height changes, the focal length must be readjusted whereas\n     * the FOV stays the same. The opposite is true for the dynamic case, where the focal length is\n     * fixed but the FOV changes.\n     * @param height Height of the canvas in css / client pixels.\n     */\n    calculateFocalLength(height) {\n        harp_utils_1.assert(this.m_options.fovCalculation !== undefined);\n        this.m_focalLength = Utils_1.MapViewUtils.calculateFocalLengthByVerticalFov(THREE.Math.degToRad(this.m_options.fovCalculation.fov), height);\n    }\n    /**\n     * Get canvas client size in css/client pixels.\n     *\n     * Supports canvases not attached to DOM, which have 0 as `clientWidth` and `clientHeight` by\n     * calculating it from actual canvas size and current pixel ratio.\n     */\n    getCanvasClientSize() {\n        const { clientWidth, clientHeight } = this.canvas;\n        if (clientWidth === 0 ||\n            clientHeight === 0 ||\n            typeof clientWidth !== \"number\" ||\n            typeof clientHeight !== \"number\") {\n            const pixelRatio = this.m_renderer.getPixelRatio();\n            return {\n                width: Math.round(this.canvas.width / pixelRatio),\n                height: Math.round(this.canvas.height / pixelRatio)\n            };\n        }\n        else {\n            return { width: clientWidth, height: clientHeight };\n        }\n    }\n}\nexports.MapView = MapView;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapView.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewFog.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewFog.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\n/**\n * Manages the fog display in [[MapView]].\n */\nclass MapViewFog {\n    /**\n     * Constructs a `MapViewFog` instance.\n     *\n     * @param m_scene The scene used in [[MapView]] that contains the map objects.\n     */\n    constructor(m_scene) {\n        this.m_scene = m_scene;\n        this.m_enabled = true;\n        this.m_fog = new THREE.Fog(0x000000); // Default color asked by DefinitelyTyped.\n        this.m_fogIsDefined = false;\n        this.m_cachedTheme = { styles: {} };\n    }\n    /**\n     * Allows for disabling the fog, even if it is defined in the theme. Use this property for\n     * custom views like the demo app's debug camera. However, if the theme does not define a\n     * fog, enabling this property here has no effect.\n     *\n     * @param value A boolean that specifies whether the fog should be enabled or disabled.\n     */\n    set enabled(enableFog) {\n        this.m_enabled = enableFog;\n        if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {\n            this.add();\n        }\n        else if (!enableFog && this.m_scene.fog !== null) {\n            this.remove();\n        }\n    }\n    /**\n     * Returns the current fog status, enabled or disabled.\n     */\n    get enabled() {\n        return this.m_enabled;\n    }\n    /**\n     * Sets the fog depending on the [[Theme]] instance provided. This function is called when a\n     * theme is loaded. Fog is added only if the theme contains a fog definition with a:\n     * - `color` property, used to set the fog color.\n     * - `startRatio` property, used to set the start distance of the fog as a ratio of the far\n     * clipping plane distance.\n     *\n     * @param theme A [[Theme]] instance.\n     */\n    reset(theme) {\n        this.m_cachedTheme = theme;\n        if (theme !== undefined &&\n            theme.fog !== undefined &&\n            theme.fog.color !== undefined &&\n            theme.fog.startRatio !== undefined) {\n            this.m_fogIsDefined = true;\n            this.m_fog.color.set(theme.fog.color);\n            if (this.m_enabled && this.m_scene.fog === null) {\n                this.add();\n            }\n        }\n        else {\n            this.m_fogIsDefined = false;\n            if (this.m_scene.fog !== null) {\n                this.remove();\n            }\n        }\n    }\n    /**\n     * Updates the fog at runtime, depending on the camera.\n     *\n     * @param camera An instance of a `THREE.Camera` with a `far` property.\n     */\n    update(mapView, viewDistance) {\n        if (this.m_scene.fog !== null &&\n            this.m_cachedTheme !== undefined &&\n            this.m_cachedTheme.fog &&\n            this.m_cachedTheme.fog.startRatio !== undefined &&\n            (mapView.camera.far !== undefined || viewDistance !== undefined)) {\n            // If maximum visibility range is available use it instead of camera.far distance,\n            // this makes fog independent from dynamic camera planes and keeps consistent\n            // distance based \"melting\" (fog) effect during a tilt.\n            const viewRange = viewDistance !== undefined ? viewDistance : mapView.camera.far;\n            // TODO: We may move below constants to theme Fog definition\n            // Density of the fog when viewing straight along the horizon line.\n            const horizontalDensity = 1.0;\n            // Theoretical density of the fog when viewing straight from top to down.\n            const verticalDensity = 0.0;\n            // The fraction of the maximum viewing distance along the eye vector\n            // to start applying the fog.\n            const startRatio = this.m_cachedTheme.fog.startRatio;\n            // The fraction of maximum viewing range at which fog fully covers geometry.\n            const endRatio = 1.0;\n            harp_utils_1.assert(startRatio <= endRatio);\n            const target = Utils_1.MapViewUtils.rayCastWorldCoordinates(mapView, 0, 0);\n            if (target === null) {\n                throw new Error(\"MapView does not support a view pointing in the void.\");\n            }\n            const t = Math.abs(Math.cos(Utils_1.MapViewUtils.extractSphericalCoordinatesFromLocation(mapView, mapView.camera, mapView.projection.unprojectPoint(target)).tilt));\n            const density = harp_utils_1.MathUtils.smoothStep(horizontalDensity, verticalDensity, t);\n            this.m_fog.near = harp_utils_1.MathUtils.lerp(viewRange * startRatio, viewRange, 1.0 - density);\n            this.m_fog.far = harp_utils_1.MathUtils.lerp(viewRange * endRatio, viewRange, density);\n            this.m_fog.near = Math.min(this.m_fog.near, mapView.camera.far);\n            this.m_fog.far = Math.min(this.m_fog.far, mapView.camera.far);\n        }\n    }\n    /**\n     * Handles fog addition.\n     */\n    add() {\n        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...\n        this.m_scene.fog = this.m_fog;\n        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.\n        this.setFogInRawShaderMaterials(true);\n    }\n    /**\n     * Handles fog removal.\n     */\n    remove() {\n        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...\n        this.m_scene.fog = null;\n        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.\n        this.setFogInRawShaderMaterials(false);\n    }\n    /**\n     * ThreeJS lets users manage the `RawShaderMaterial` themselves, so they need to be modified\n     * explicitly.\n     *\n     * @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js#L298\n     */\n    setFogInRawShaderMaterials(enableFog) {\n        this.m_scene.traverse(object => {\n            if (!(object instanceof THREE.Mesh)) {\n                return;\n            }\n            if (!(object.material instanceof THREE.Material)) {\n                return;\n            }\n            // HighPrecisionLineMaterial does not support fog\n            if (object.material instanceof harp_materials_1.HighPrecisionLineMaterial) {\n                return;\n            }\n            // We may skip redundant updates.\n            if (object.material.fog === enableFog) {\n                return;\n            }\n            object.material.fog = enableFog;\n            // Fog properties can't be easily changed at runtime (once the material\n            // is rendered at least once) and thus requires building of new shader\n            // program - force material update.\n            object.material.needsUpdate = true;\n        });\n    }\n}\nexports.MapViewFog = MapViewFog;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapViewFog.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/MapViewPoints.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/MapViewPoints.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * `MapViewPoints` is a class to extend for the `\"circles\"` and `\"squares\"` [[Technique]]s to\n * implement raycasting of [[THREE.Points]] as expected in [[MapView]], that is in screen space. It\n * copies the behaviour of the `raycast` method in [[THREE.Points]] and dispatches it to its\n * children classes, [[Circles]] and [[Squares]], who hold the intersection testing in the\n * `testPoint` method. This class also has the ability to dismiss the testing via the\n * `enableRayTesting` flag.\n *\n * Its main motivation is to handle the point styles of XYZ projects.\n *\n * @see https://github.com/mrdoob/three.js/blob/master/src/objects/Points.js\n */\nclass MapViewPoints extends THREE.Points {\n    constructor() {\n        super(...arguments);\n        /**\n         * This allows to discard the ray testing.\n         */\n        this.enableRayTesting = true;\n    }\n    /**\n     * This method is similar to the original method `raycast` in [[THREE.Points]] except that it\n     * then calls the tailored `testPoint` method in the children classes to test intersections\n     * depending on whether the points are circles or squares, which [[THREE.Points]] cannot do.\n     *\n     * @param raycaster The raycaster.\n     * @param intersects The array to fill with the results.\n     */\n    raycast(raycaster, intersects) {\n        if (!this.enableRayTesting) {\n            return;\n        }\n        const geometry = this.geometry;\n        const matrixWorld = this.matrixWorld;\n        const screenCoords = raycaster.ray.origin\n            .clone()\n            .add(raycaster.ray.direction)\n            .project(raycaster.mapView.camera);\n        const { clientWidth, clientHeight } = raycaster.mapView.canvas;\n        const mouseCoords = new THREE.Vector2(Math.ceil(((screenCoords.x + 1) / 2) * clientWidth), Math.ceil(((1 - screenCoords.y) / 2) * clientHeight));\n        if (geometry instanceof THREE.BufferGeometry) {\n            const point = new THREE.Vector3();\n            const index = geometry.index;\n            const attributes = geometry.attributes;\n            const positions = attributes.position.array;\n            if (index !== null) {\n                const indices = index.array;\n                for (let i = 0, il = indices.length; i < il; i++) {\n                    const a = indices[i];\n                    point.fromArray(positions, a * 3);\n                    const pointInfo = getPointInfo(point, matrixWorld, raycaster, clientWidth, clientHeight);\n                    if (pointInfo.pointIsOnScreen) {\n                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);\n                    }\n                }\n            }\n            else {\n                for (let i = 0, l = positions.length / 3; i < l; i++) {\n                    point.fromArray(positions, i * 3);\n                    const pointInfo = getPointInfo(point, matrixWorld, raycaster, clientWidth, clientHeight);\n                    if (pointInfo.pointIsOnScreen) {\n                        this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, i, pointInfo.distance, intersects);\n                    }\n                }\n            }\n        }\n        else {\n            const vertices = geometry.vertices;\n            for (let index = 0; index < vertices.length; index++) {\n                const point = vertices[index];\n                const pointInfo = getPointInfo(point, matrixWorld, raycaster, clientWidth, clientHeight);\n                if (pointInfo.pointIsOnScreen) {\n                    this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, index, pointInfo.distance, intersects);\n                }\n            }\n        }\n    }\n}\nexports.MapViewPoints = MapViewPoints;\nfunction getPointInfo(point, matrixWorld, raycaster, width, height) {\n    const worldPosition = point.clone();\n    worldPosition.applyMatrix4(matrixWorld);\n    const distance = worldPosition.distanceTo(raycaster.ray.origin);\n    worldPosition.project(raycaster.mapView.camera);\n    const relativeScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);\n    const pointIsOnScreen = relativeScreenPosition.x < 1 &&\n        relativeScreenPosition.x > -1 &&\n        relativeScreenPosition.y < 1 &&\n        relativeScreenPosition.y > -1;\n    if (pointIsOnScreen) {\n        worldPosition.x = ((worldPosition.x + 1) / 2) * width;\n        worldPosition.y = ((1 - worldPosition.y) / 2) * height;\n        const absoluteScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);\n        return {\n            absoluteScreenPosition,\n            pointIsOnScreen,\n            distance\n        };\n    }\n    return {\n        pointIsOnScreen\n    };\n}\n/**\n * Point object that implements the raycasting of circles in screen space.\n */\nclass Circles extends MapViewPoints {\n    /** @override */\n    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {\n        const dx = screenPosition.x - pickCoordinates.x;\n        const dy = screenPosition.y - pickCoordinates.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const radius = this.material.size / 2;\n        if (dist <= radius) {\n            intersects.push({\n                point,\n                distance,\n                index,\n                object: this\n            });\n        }\n    }\n}\nexports.Circles = Circles;\n/**\n * Point object that implements the raycasting of squares in screen space.\n */\nclass Squares extends MapViewPoints {\n    /** @override */\n    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {\n        const dx = screenPosition.x - pickCoordinates.x;\n        const dy = screenPosition.y - pickCoordinates.y;\n        const halfSize = this.material.size / 2;\n        if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {\n            intersects.push({\n                point,\n                distance,\n                index,\n                object: this\n            });\n        }\n    }\n}\nexports.Squares = Squares;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/MapViewPoints.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PathBlockingElement.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PathBlockingElement.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * This path in world coordinates is projected to screen space and blocks all other labels.\n *\n * It could be used for example:\n * - Border rejects labels.\n * - Route blocks street labels from being rendered underneath.\n *\n * Could potentially be expanded in future to have a priority, however for now, this isn't required.\n */\nclass PathBlockingElement {\n    /**\n     * Constructs a path from a list of points.\n     * Pre allocates the [[screenSpaceLines]] used to render.\n     * @param points Points in world coordinates.\n     */\n    constructor(points) {\n        this.points = points;\n        this.screenSpaceLines = new Array(points.length >= 2 ? points.length - 1 : 0);\n        for (let i = 0; i < this.screenSpaceLines.length; i++) {\n            this.screenSpaceLines[i] = new THREE.Line3(new THREE.Vector3(), new THREE.Vector3());\n        }\n    }\n}\nexports.PathBlockingElement = PathBlockingElement;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/PathBlockingElement.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PickHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PickHandler.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ \"./node_modules/@here/harp-mapview/lib/MapViewPoints.js\");\nconst RoadPicker_1 = __webpack_require__(/*! ./RoadPicker */ \"./node_modules/@here/harp-mapview/lib/RoadPicker.js\");\n/**\n * Describes the general type of a picked object.\n */\nvar PickObjectType;\n(function (PickObjectType) {\n    /**\n     * Unspecified.\n     */\n    PickObjectType[PickObjectType[\"Unspecified\"] = 0] = \"Unspecified\";\n    /**\n     * A point object.\n     */\n    PickObjectType[PickObjectType[\"Point\"] = 1] = \"Point\";\n    /**\n     * A line object.\n     */\n    PickObjectType[PickObjectType[\"Line\"] = 2] = \"Line\";\n    /**\n     * An area object.\n     */\n    PickObjectType[PickObjectType[\"Area\"] = 3] = \"Area\";\n    /**\n     * The text part of a [[TextElement]]\n     */\n    PickObjectType[PickObjectType[\"Text\"] = 4] = \"Text\";\n    /**\n     * The Icon of a [[TextElement]].\n     */\n    PickObjectType[PickObjectType[\"Icon\"] = 5] = \"Icon\";\n    /**\n     * Any general 3D object, for example, a landmark.\n     */\n    PickObjectType[PickObjectType[\"Object3D\"] = 6] = \"Object3D\";\n})(PickObjectType = exports.PickObjectType || (exports.PickObjectType = {}));\n/**\n * Handles the picking of scene geometry and roads.\n */\nclass PickHandler {\n    constructor(mapView, camera, enableRoadPicking = true) {\n        this.mapView = mapView;\n        this.camera = camera;\n        this.enableRoadPicking = enableRoadPicking;\n        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));\n        if (enableRoadPicking) {\n            this.m_roadPicker = new RoadPicker_1.RoadPicker(mapView);\n        }\n    }\n    /**\n     * The `RoadPicker` class manages picking of roads, which may not be pickable in THREE.js,\n     * since their geometry is generated in the vertex shader. The `RoadPicker` requires that\n     * all [[Tile]]s are registered before they can be picked successfully.\n     */\n    registerTile(tile) {\n        return this.m_roadPicker !== undefined ? this.m_roadPicker.registerTile(tile) : undefined;\n    }\n    /**\n     * Does a raycast on all objects in the scene; useful for picking. This function is Limited to\n     * objects that THREE.js can raycast. However, any solid lines that have their geometry in the\n     * shader cannot be tested for intersection.\n     *\n     * @param x The X position in CSS/client coordinates, without the applied display ratio.\n     * @param y The Y position in CSS/client coordinates, without the applied display ratio.\n     * @returns the list of intersection results.\n     */\n    intersectMapObjects(x, y) {\n        const worldPos = this.mapView.getNormalizedScreenCoordinates(x, y);\n        const rayCaster = this.mapView.raycasterFromScreenPoint(x, y);\n        const pickResults = [];\n        if (this.mapView.textElementsRenderer !== undefined) {\n            const { clientWidth, clientHeight } = this.mapView.canvas;\n            const screenX = worldPos.x * clientWidth * 0.5 * this.mapView.pixelRatio;\n            const screenY = worldPos.y * clientHeight * 0.5 * this.mapView.pixelRatio;\n            const scenePosition = new THREE.Vector2(screenX, screenY);\n            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickResults);\n        }\n        // calculate objects intersecting the picking ray\n        const intersects = rayCaster.intersectObjects(this.mapView.worldRootObject.children, true);\n        for (const intersect of intersects) {\n            const pickResult = {\n                type: PickObjectType.Unspecified,\n                point: intersect.point,\n                distance: intersect.distance,\n                intersection: intersect\n            };\n            if (intersect.object.userData === undefined ||\n                intersect.object.userData.feature === undefined) {\n                pickResults.push(pickResult);\n                continue;\n            }\n            const featureData = intersect.object.userData.feature;\n            this.addObjInfo(featureData, intersect, pickResult);\n            if (featureData.objInfos !== undefined) {\n                const featureId = featureData.objInfos.length === 1\n                    ? harp_datasource_protocol_1.getFeatureId(featureData.objInfos[0])\n                    : undefined;\n                pickResult.featureId = featureId;\n            }\n            let pickObjectType;\n            switch (featureData.geometryType) {\n                case harp_datasource_protocol_1.GeometryType.Point:\n                case harp_datasource_protocol_1.GeometryType.Text:\n                    pickObjectType = PickObjectType.Point;\n                    break;\n                case harp_datasource_protocol_1.GeometryType.Line:\n                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:\n                case harp_datasource_protocol_1.GeometryType.SolidLine:\n                case harp_datasource_protocol_1.GeometryType.TextPath:\n                    pickObjectType = PickObjectType.Line;\n                    break;\n                case harp_datasource_protocol_1.GeometryType.Polygon:\n                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:\n                    pickObjectType = PickObjectType.Area;\n                    break;\n                case harp_datasource_protocol_1.GeometryType.Object3D:\n                    pickObjectType = PickObjectType.Object3D;\n                    break;\n                default:\n                    pickObjectType = PickObjectType.Unspecified;\n            }\n            pickResult.type = pickObjectType;\n            pickResults.push(pickResult);\n        }\n        if (this.enableRoadPicking) {\n            const planeIntersectPosition = new THREE.Vector3();\n            const cameraPos = this.mapView.camera.position.clone();\n            rayCaster.setFromCamera(worldPos, this.mapView.camera);\n            rayCaster.ray.intersectPlane(this.m_plane, planeIntersectPosition);\n            this.mapView.forEachVisibleTile(tile => {\n                this.m_roadPicker.intersectRoads(tile, cameraPos, planeIntersectPosition, pickResults);\n            });\n        }\n        pickResults.sort((a, b) => {\n            return a.distance - b.distance;\n        });\n        return pickResults;\n    }\n    addObjInfo(featureData, intersect, pickResult) {\n        if (pickResult.intersection.object instanceof MapViewPoints_1.MapViewPoints) {\n            pickResult.userData = featureData.objInfos[intersect.index];\n            return;\n        }\n        else if (featureData.objInfos === undefined ||\n            featureData.starts === undefined ||\n            intersect.faceIndex === undefined) {\n            return;\n        }\n        if (featureData.starts.length > 1) {\n            let objInfosIndex = 0;\n            for (const polygonStartFace of featureData.starts) {\n                if (polygonStartFace > intersect.faceIndex * 3) {\n                    break;\n                }\n                objInfosIndex++;\n            }\n            pickResult.userData = featureData.objInfos[objInfosIndex - 1];\n        }\n        else {\n            pickResult.userData = featureData.objInfos[0];\n        }\n    }\n}\nexports.PickHandler = PickHandler;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/PickHandler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst index_decoder_1 = __webpack_require__(/*! @here/harp-datasource-protocol/index-decoder */ \"./node_modules/@here/harp-datasource-protocol/index-decoder.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst DataSource_1 = __webpack_require__(/*! ./DataSource */ \"./node_modules/@here/harp-mapview/lib/DataSource.js\");\nconst DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\");\nconst Tile_1 = __webpack_require__(/*! ./Tile */ \"./node_modules/@here/harp-mapview/lib/Tile.js\");\n/**\n * [[DataSource]] providing geometry for poles\n */\nclass PolarTileDataSource extends DataSource_1.DataSource {\n    constructor({ name = \"polar\", styleSetName, minZoomLevel, maxZoomLevel, storageLevelOffset = -2, geometryLevelOffset = -1, debugTiles = false }) {\n        super(name, styleSetName, minZoomLevel, maxZoomLevel, storageLevelOffset);\n        this.m_tilingScheme = harp_geoutils_1.polarTilingScheme;\n        this.m_maxLatitude = harp_geoutils_1.MathUtils.radToDeg(harp_geoutils_1.MercatorConstants.MAXIMUM_LATITUDE);\n        this.m_geometryLevelOffset = geometryLevelOffset;\n        this.m_debugTiles = debugTiles;\n        this.cacheable = false;\n    }\n    /** @override */\n    dispose() {\n        if (this.m_northPoleMaterial) {\n            this.m_northPoleMaterial.dispose();\n            delete this.m_northPoleMaterial;\n        }\n        if (this.m_southPoleMaterial) {\n            this.m_southPoleMaterial.dispose();\n            delete this.m_southPoleMaterial;\n        }\n        if (this.m_styleSetEvaluator) {\n            delete this.m_styleSetEvaluator;\n        }\n    }\n    createMaterial(kind, styleSetEvaluator) {\n        const env = new index_decoder_1.MapEnv({\n            $geometryType: \"polygon\",\n            $layer: \"earth\",\n            kind\n        });\n        const techniques = styleSetEvaluator.getMatchingTechniques(env);\n        return techniques.length !== 0\n            ? DecodedTileHelpers_1.createMaterial({ technique: techniques[0], level: 1 })\n            : undefined;\n    }\n    /** @override */\n    setStyleSet(styleSet, definitions, languages) {\n        this.dispose();\n        if (styleSet !== undefined) {\n            this.m_styleSetEvaluator = new index_decoder_1.StyleSetEvaluator(styleSet, definitions);\n            this.m_northPoleMaterial = this.createMaterial(\"north_pole\", this.m_styleSetEvaluator);\n            this.m_southPoleMaterial = this.createMaterial(\"south_pole\", this.m_styleSetEvaluator);\n        }\n        this.mapView.markTilesDirty(this);\n    }\n    /** @override */\n    setTheme(theme, languages) {\n        const styleSet = (this.styleSetName !== undefined && theme.styles && theme.styles[this.styleSetName]) ||\n            [];\n        this.setStyleSet(styleSet, theme.definitions, languages);\n    }\n    /** @override */\n    canGetTile(zoomLevel, tileKey) {\n        if (zoomLevel !== tileKey.level || tileKey.level < 1) {\n            return false;\n        }\n        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);\n        return north > this.m_maxLatitude || south < -this.m_maxLatitude;\n    }\n    /** @override */\n    shouldSubdivide(zoomLevel, tileKey) {\n        if (zoomLevel <= tileKey.level) {\n            return false;\n        }\n        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);\n        return north > this.m_maxLatitude || south < -this.m_maxLatitude;\n    }\n    /** @override */\n    getTilingScheme() {\n        return this.m_tilingScheme;\n    }\n    /** @override */\n    getTile(tileKey) {\n        const tile = new Tile_1.Tile(this, tileKey);\n        this.createTileGeometry(tile);\n        return tile;\n    }\n    get geometryLevelOffset() {\n        return this.m_geometryLevelOffset;\n    }\n    set geometryLevelOffset(geometryLevelOffset) {\n        this.m_geometryLevelOffset = geometryLevelOffset;\n    }\n    intersectEdge(latitude, a, b) {\n        const latA = a.latitude;\n        const latB = b.latitude;\n        let lonA = a.longitude;\n        let lonB = b.longitude;\n        if (Math.abs(latA) === 90) {\n            lonA = lonB;\n        }\n        if (Math.abs(latB) === 90) {\n            lonB = lonA;\n        }\n        const deltaLat = latB - latA;\n        const deltaLon = lonB - lonA;\n        const scale = (latitude - latA) / deltaLat;\n        return new harp_geoutils_1.GeoCoordinates(latitude, lonA + deltaLon * scale, 0);\n    }\n    createTileGeometry(tile) {\n        const { north, south } = tile.geoBox;\n        const isNorthPole = north > 0 && south >= 0;\n        const material = isNorthPole ? this.m_northPoleMaterial : this.m_southPoleMaterial;\n        if (material === undefined) {\n            tile.forceHasGeometry(true);\n            return;\n        }\n        const srcProjection = this.m_tilingScheme.projection;\n        const dstProjection = this.projection;\n        const maxLat = this.m_maxLatitude;\n        const poleLat = isNorthPole ? maxLat : -maxLat;\n        const box = this.m_tilingScheme.boundingBoxGenerator.getWorldBox(tile.tileKey);\n        const pBL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.min.y, 0));\n        const pBR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.min.y, 0));\n        const pTR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.max.y, 0));\n        const pTL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.max.y, 0));\n        let points;\n        let needsGeometryCut = false;\n        // special case where tile contains half of the hemisphere\n        if (tile.tileKey.level === 1) {\n            const isLeftHalf = box.min.x === 0;\n            const poleX = isLeftHalf ? box.max.x : box.min.x;\n            const poleY = (box.max.y + box.min.y) / 2;\n            const pPole = srcProjection.unprojectPoint(new THREE.Vector3(poleX, poleY, 0));\n            // coordinates are not used, needed for right position\n            const pXX = isLeftHalf ? pBL : pBR;\n            points = isNorthPole\n                ? isLeftHalf\n                    ? [pPole, pTR, pXX, pBR]\n                    : [pPole, pBL, pXX, pTL]\n                : isLeftHalf\n                    ? [pPole, pBR, pXX, pTR]\n                    : [pPole, pTL, pXX, pBL];\n            needsGeometryCut = true;\n        }\n        else {\n            // ccw for north, cw for south\n            points = isNorthPole ? [pBL, pBR, pTR, pTL] : [pBL, pTL, pTR, pBR];\n            const lats = points.map(p => p.latitude);\n            const lmax = Math.max(...lats);\n            const lmin = Math.min(...lats);\n            const isAllPointsOut = isNorthPole ? lmax < poleLat : lmin > poleLat;\n            if (isAllPointsOut) {\n                return;\n            }\n            const isSomePointsOut = isNorthPole ? lmin < poleLat : lmax > poleLat;\n            needsGeometryCut = isSomePointsOut;\n            if (needsGeometryCut) {\n                const nearest = lats.indexOf(isNorthPole ? lmax : lmin);\n                if (nearest !== 0) {\n                    for (let i = 0; i < nearest; i++) {\n                        points.push(points.shift());\n                    }\n                }\n            }\n        }\n        if (needsGeometryCut) {\n            const centerX = (box.min.x + box.max.x) / 2;\n            const centerY = (box.min.y + box.max.y) / 2;\n            const center = srcProjection.unprojectPoint(new THREE.Vector3(centerX, centerY, 0));\n            harp_geoutils_1.TransverseMercatorUtils.alignLongitude(points, center);\n            // points aligned as follows:\n            // a - nearest to the pole, always in\n            // b - next to nearest\n            // c - farthes from the pole, always out\n            // d - prev from nearest\n            const a = points[0];\n            const b = points[1];\n            const c = points[2];\n            const d = points[3];\n            const inPointB = Math.abs(b.latitude) >= maxLat;\n            const inPointD = Math.abs(d.latitude) >= maxLat;\n            const cutStart = inPointB\n                ? this.intersectEdge(poleLat, b, c)\n                : this.intersectEdge(poleLat, a, b);\n            const cutEnd = inPointD\n                ? this.intersectEdge(poleLat, d, c)\n                : this.intersectEdge(poleLat, a, d);\n            points.splice(inPointB ? 2 : 1, 4, cutStart);\n            const level = tile.tileKey.level - this.storageLevelOffset + this.m_geometryLevelOffset;\n            // tslint:disable-next-line:no-bitwise\n            const subdivisions = 1 << Math.max(0, level);\n            const step = 360 / subdivisions;\n            const cutIndexStart = Math.floor((cutStart.longitude + 180) / step);\n            const cutIndexEnd = Math.ceil((cutEnd.longitude + 180) / step);\n            for (let i = cutIndexStart + 1; i < cutIndexEnd; i++) {\n                points.push(new harp_geoutils_1.GeoCoordinates(poleLat, i * step - 180, 0));\n            }\n            points.push(cutEnd);\n            if (inPointD) {\n                points.push(d);\n            }\n        }\n        const g = new THREE.Geometry();\n        for (const point of points) {\n            const projected = dstProjection.projectPoint(point, new THREE.Vector3());\n            g.vertices.push(projected.sub(tile.center));\n        }\n        for (let i = 1; i < points.length - 1; i++) {\n            g.faces.push(isNorthPole ? new THREE.Face3(0, i, i + 1) : new THREE.Face3(0, i + 1, i));\n        }\n        const geometry = new THREE.BufferGeometry();\n        geometry.fromGeometry(g);\n        g.dispose();\n        const mesh = new THREE.Mesh(geometry, material);\n        mesh.userData = {\n            dataSource: this.name,\n            tileKey: tile.tileKey\n        };\n        if (this.m_debugTiles) {\n            const color = Math.round(Math.abs(Math.sin(11 * tile.tileKey.mortonCode())) * 0xffffff);\n            mesh.material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 });\n            tile.objects.push(new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color, wireframe: true })));\n        }\n        tile.objects.push(mesh);\n    }\n}\nexports.PolarTileDataSource = PolarTileDataSource;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/PolarTileDataSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/RoadPicker.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/RoadPicker.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst Expr_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/Expr */ \"./node_modules/@here/harp-datasource-protocol/lib/Expr.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst PickHandler_1 = __webpack_require__(/*! ./PickHandler */ \"./node_modules/@here/harp-mapview/lib/PickHandler.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"RoadPicker\");\nconst MAX_DISTANCE_ERROR = 0.01;\n/**\n * The `RoadPicker` class manages picking of roads, which may not be pickable in THREE.js, since\n * their geometry is generated in the vertex shader.\n */\nclass RoadPicker {\n    constructor(m_mapView) {\n        this.m_mapView = m_mapView;\n    }\n    /**\n     * Registers a tile with the `RoadPicker`. This function extracts line data from the [[Tile]],\n     * but only if the tile has the necessary [[ExtendedTileInfo]] that allows for road features to\n     * be reconstructed.\n     *\n     * @param tile The tile to register.\n     */\n    registerTile(tile) {\n        harp_utils_1.assert(tile.decodedTile !== undefined);\n        if (tile.decodedTile === undefined || tile.decodedTile.tileInfo === undefined) {\n            return undefined;\n        }\n        const extendedTileInfo = tile.decodedTile.tileInfo;\n        const lineFeatures = extendedTileInfo.lineGroup;\n        if (lineFeatures === undefined || lineFeatures.numFeatures === 0) {\n            // tileInfo not of expected type [[ExtendedTileInfo]]\n            return undefined;\n        }\n        const widths = [];\n        widths.length = lineFeatures.numFeatures;\n        const mapView = this.m_mapView;\n        for (let i = 0; i < lineFeatures.numFeatures; i++) {\n            const technique = extendedTileInfo.techniqueCatalog[lineFeatures.techniqueIndex[i]];\n            const isDynamic = technique.metricUnit === \"Pixel\" ||\n                Expr_1.Expr.isExpr(technique.lineWidth) ||\n                typeof technique.lineWidth === \"string\";\n            widths[i] =\n                technique.lineWidth !== undefined\n                    ? isDynamic\n                        ? () => {\n                            const unitFactor = technique.metricUnit === \"Pixel\" ? mapView.pixelToWorld : 1.0;\n                            return (harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, mapView.zoomLevel, mapView.pixelToWorld) *\n                                unitFactor *\n                                0.5);\n                        }\n                        : technique.lineWidth\n                    : 1.0;\n        }\n        const objInfos = extendedTileInfo.lineGroup.userData;\n        const roadIntersectionData = {\n            ids: lineFeatures.featureIds,\n            techniqueIndex: lineFeatures.techniqueIndex,\n            starts: lineFeatures.positionIndex,\n            widths,\n            positions: lineFeatures.positions,\n            techniques: extendedTileInfo.techniqueCatalog,\n            objInfos\n        };\n        return roadIntersectionData;\n    }\n    /**\n     * Tests the `pickPos` point for intersection with all roads on a tile.\n     *\n     * @param tile The tile to pick.\n     * @param eyePos The WorldPosition of eye or camera to compute distances.\n     * @param pickPos The WorldPosition of the picked point, on the plane.\n     * @param results The existing array of [[PickResult]]; new results should be appended.\n     */\n    intersectRoads(tile, eyePos, pickPos, results) {\n        if (tile.boundingBox.distanceToPoint(pickPos) > MAX_DISTANCE_ERROR) {\n            // outside of bounding box of tile\n            return false;\n        }\n        const roadIntersectionData = tile.roadIntersectionData;\n        if (roadIntersectionData === undefined) {\n            return false;\n        }\n        const ids = roadIntersectionData.ids;\n        const techniques = roadIntersectionData.techniques;\n        const techniqueIndices = roadIntersectionData.techniqueIndex;\n        const numFeatures = ids.length;\n        const positions = roadIntersectionData.positions;\n        const widths = roadIntersectionData.widths;\n        const px = pickPos.x - tile.center.x;\n        const py = pickPos.y - tile.center.y;\n        const pickDistance = pickPos.distanceTo(eyePos);\n        if (widths.length !== ids.length ||\n            ids.length !== techniqueIndices.length ||\n            techniqueIndices.length !== roadIntersectionData.starts.length) {\n            logger.error(\"The amount of widths, ids, techniqueIndices and starts has to be the same\");\n            return false;\n        }\n        for (let i = 0; i < numFeatures; i++) {\n            const technique = techniques[techniqueIndices[i]];\n            // if the technique is marked as background or as transient, we ignore it for picking\n            if ( /*technique.isBackground === true ||*/technique.transient === true) {\n                continue;\n            }\n            const featureStart = roadIntersectionData.starts[i];\n            const featureEnd = i < numFeatures - 1\n                ? roadIntersectionData.starts[i + 1]\n                : roadIntersectionData.positions.length;\n            let startX = positions[featureStart];\n            let startY = positions[featureStart + 1];\n            const widthEntry = widths[i];\n            const actualWidth = Math.max(1, typeof widthEntry === \"function\" ? widthEntry() : widthEntry);\n            const lineWidthSqr = actualWidth * actualWidth;\n            let closestDistSqr = Number.MAX_VALUE;\n            for (let j = featureStart + 2; j < featureEnd; j += 2) {\n                const endX = positions[j];\n                const endY = positions[j + 1];\n                const distSqr = harp_utils_1.Math2D.distToSegmentSquared(px, py, startX, startY, endX, endY);\n                if (distSqr < lineWidthSqr) {\n                    if (distSqr < closestDistSqr) {\n                        closestDistSqr = distSqr;\n                    }\n                }\n                startX = endX;\n                startY = endY;\n            }\n            if (closestDistSqr < Number.MAX_VALUE) {\n                const roadPickResult = {\n                    type: PickHandler_1.PickObjectType.Line,\n                    point: pickPos,\n                    distance: pickDistance,\n                    distFromCenter: Math.sqrt(closestDistSqr),\n                    featureId: ids[i],\n                    positions: positions.slice(featureStart, featureEnd),\n                    technique\n                };\n                this.addUserData(roadPickResult, i, roadIntersectionData.objInfos);\n                results.push(roadPickResult);\n            }\n        }\n        return false;\n    }\n    addUserData(roadPickResult, index, objInfos) {\n        if (objInfos !== undefined && objInfos.length > 0) {\n            roadPickResult.userData = Object.assign({}, objInfos[index]);\n        }\n    }\n}\nexports.RoadPicker = RoadPicker;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/RoadPicker.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ScreenCollisions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ScreenCollisions.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DebugContext_1 = __webpack_require__(/*! ./DebugContext */ \"./node_modules/@here/harp-mapview/lib/DebugContext.js\");\n// tslint:disable-next-line:no-var-requires\nconst RBush = __webpack_require__(/*! rbush */ \"./node_modules/rbush/rbush.min.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"ScreenCollissions\");\nclass CollisionBox extends harp_utils_1.Math2D.Box {\n    constructor(box) {\n        super();\n        if (box !== undefined) {\n            this.copy(box);\n        }\n    }\n    copy(box) {\n        if (box instanceof harp_utils_1.Math2D.Box) {\n            this.set(box.x, box.y, box.w, box.h);\n        }\n        else if (box instanceof THREE.Box2) {\n            this.set(box.min.x, box.min.y, box.max.x - box.min.x, box.max.y - box.min.y);\n        }\n        else {\n            this.set(box.minX, box.minY, box.maxX - box.minX, box.maxY - box.minY);\n        }\n        return this;\n    }\n    get minX() {\n        return this.x;\n    }\n    set minX(minX) {\n        this.x = minX;\n    }\n    get maxX() {\n        return this.x + this.w;\n    }\n    set maxX(maxX) {\n        this.w = maxX - this.x;\n    }\n    get minY() {\n        return this.y;\n    }\n    set minY(minY) {\n        this.y = minY;\n    }\n    get maxY() {\n        return this.y + this.h;\n    }\n    set maxY(maxY) {\n        this.h = maxY - this.y;\n    }\n}\nexports.CollisionBox = CollisionBox;\n/**\n * Collision box with additional boxes defining tighter bounds for the enclosed feature\n * (e.g.glyph bounds for text).\n */\nclass DetailedCollisionBox extends CollisionBox {\n    constructor(box, detailBoxes) {\n        super(box);\n        this.detailBoxes = detailBoxes;\n    }\n}\nexports.DetailedCollisionBox = DetailedCollisionBox;\nfunction isLineWithBound(box) {\n    return box.line !== undefined;\n}\nexports.isLineWithBound = isLineWithBound;\nconst tmpCollisionBox = new CollisionBox();\n/**\n * @hidden\n */\nclass ScreenCollisions {\n    /**\n     * Constructs a new ScreenCollisions object.\n     */\n    constructor() {\n        /** The screen bounding box. */\n        this.screenBounds = new harp_utils_1.Math2D.Box();\n        /** Tree of allocated bounds. */\n        this.rtree = new RBush();\n        //\n    }\n    /**\n     * Resets the list of allocated screen bounds.\n     */\n    reset() {\n        this.rtree.clear();\n    }\n    /**\n     * Updates the screen bounds that are used to check if bounding boxes are visible.\n     *\n     * @param width The width of the container.\n     * @param height The height of the container.\n     */\n    update(width, height) {\n        this.screenBounds.set(width / -2, height / -2, width, height);\n        this.reset();\n    }\n    /**\n     * Marks the region of the screen intersecting with the given bounding box as allocated.\n     *\n     * @param bounds The bounding box in NDC scaled coordinates (i.e. top left is -width/2,\n     * -height/2)\n     */\n    allocate(bounds) {\n        const bbox = !(bounds instanceof CollisionBox) ? new CollisionBox(bounds) : bounds;\n        this.rtree.insert(bbox);\n    }\n    /**\n     * Inserts the given bounds into the rtree.\n     *\n     * @param bounds The bounding boxes (the bounding boxes must be in the space returned from the\n     * ScreenProjector.project method).\n     */\n    allocateIBoxes(bounds) {\n        this.rtree.load(bounds);\n    }\n    /**\n     * Search for all bounds in the tree intersecting with the given box.\n     * @param box The box used for the search.\n     * @returns An array of all IBoxes intersecting with the given box.\n     */\n    search(box) {\n        return this.rtree.search(box);\n    }\n    /**\n     * Checks if the given bounding box is already allocated.\n     *\n     * @param bounds The bounding box in world coordinates.\n     */\n    isAllocated(bounds) {\n        const collisionBox = bounds instanceof CollisionBox ? bounds : tmpCollisionBox.copy(bounds);\n        const results = this.search(collisionBox);\n        return this.intersectsDetails(collisionBox, results);\n    }\n    /**\n     * Checks if the given screen bounds intersects with the frustum of the active camera.\n     *\n     * @param bounds The bounding box in world coordinates.\n     */\n    isVisible(bounds) {\n        return this.screenBounds.intersects(bounds);\n    }\n    /**\n     * Checks if the given screen bounds is contained within the frustum of the active camera.\n     *\n     * @param bounds The bounding box in world coordinates.\n     */\n    isFullyVisible(bounds) {\n        return this.screenBounds.containsBox(bounds);\n    }\n    /**\n     * Test whether a given [[CollisionBox]] intersects with any of the details in the specified\n     * [[IBox]]es.\n     *\n     * @param testBox The box to test for intersection.\n     * @param boxes The candidate boxes the test box may intersect with. It's assumed that the\n     * global bounds of these boxes intersect with the given test box.\n     * @returns `true` if any intersection found.\n     */\n    intersectsDetails(testBox, boxes) {\n        for (const box of boxes) {\n            if (box instanceof DetailedCollisionBox) {\n                for (const detailBox of box.detailBoxes) {\n                    if (detailBox.intersects(testBox)) {\n                        return true;\n                    }\n                }\n            }\n            else if (isLineWithBound(box)) {\n                const boundedLine = box;\n                if (this.intersectsLine(testBox, boundedLine)) {\n                    return true;\n                }\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Computes the intersection between the supplied CollisionBox and the LineWithBound.\n     * @note The [[CollisionBox]] is in Screen Bounds space, whereas the line must be\n     * in Screen Coordinate space\n     * @deprecated Because this is meant just for testing.\n     */\n    intersectsLine(bbox, boundedLine) {\n        const line = boundedLine.line;\n        // Note, these aren't normalized, but it doesn't matter, we are just interested\n        // in the sign.\n        const lineXDiffTransformed = line.end.x - line.start.x;\n        // Sign of bottom left, bottom right, top left and top right corners.\n        let signBL;\n        let signBR;\n        let signTL;\n        let signTR;\n        if (lineXDiffTransformed !== 0) {\n            const lineYDiffTransformed = line.end.y - line.start.y;\n            const normalX = lineYDiffTransformed;\n            const normalY = -lineXDiffTransformed;\n            const D = line.start.y - (lineYDiffTransformed / lineXDiffTransformed) * line.start.x;\n            signBL = Math.sign(bbox.minX * normalX + (bbox.minY - D) * normalY);\n            signBR = Math.sign(bbox.maxX * normalX + (bbox.minY - D) * normalY);\n            signTL = Math.sign(bbox.minX * normalX + (bbox.maxY - D) * normalY);\n            signTR = Math.sign(bbox.maxX * normalX + (bbox.maxY - D) * normalY);\n        }\n        else {\n            signBL = Math.sign(bbox.minX - line.start.x);\n            signBR = Math.sign(bbox.maxX - line.start.x);\n            signTL = Math.sign(bbox.minX - line.start.x);\n            signTR = Math.sign(bbox.maxX - line.start.x);\n        }\n        return signBL !== signBR || signBL !== signTL || signBL !== signTR;\n    }\n}\nexports.ScreenCollisions = ScreenCollisions;\n/**\n * @hidden\n *\n * Shows requests for screen space during labelling in an HTML canvas, which should be sized like\n * the actual map canvas. It can be placed on top of the map canvas to show exactly which requests\n * for screen space were done.\n *\n * Also logs statistics.\n */\nclass ScreenCollisionsDebug extends ScreenCollisions {\n    /**\n     * Constructs a new ScreenCollisions object which renders its state to a 2D canvas.\n     */\n    constructor(debugCanvas) {\n        super();\n        /** 2D rendering context. */\n        this.m_renderContext = null;\n        this.m_renderingEnabled = false;\n        this.m_numAllocations = 0;\n        this.m_numSuccessfulTests = 0;\n        this.m_numFailedTests = 0;\n        this.m_numSuccessfulVisibilityTests = 0;\n        this.m_numFailedVisibilityTests = 0;\n        if (debugCanvas !== undefined && debugCanvas !== null) {\n            this.m_renderContext = debugCanvas.getContext(\"2d\");\n        }\n    }\n    /**\n     * Resets the list of allocated bounds and clears the debug canvas.\n     * @override\n     */\n    reset() {\n        super.reset();\n        this.m_numAllocations = 0;\n        this.m_numSuccessfulTests = 0;\n        this.m_numFailedTests = 0;\n        this.m_numSuccessfulVisibilityTests = 0;\n        this.m_numFailedVisibilityTests = 0;\n    }\n    /**\n     * Updates the screen bounds used to check if bounding boxes are visible.\n     *\n     * @param width The width of the container.\n     * @param height The height of the container.\n     * @override\n     */\n    update(width, height) {\n        if (this.m_renderingEnabled) {\n            logger.log(\n            // tslint:disable-next-line: max-line-length\n            `Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `);\n        }\n        super.update(width, height);\n        if (this.m_renderContext !== null) {\n            this.m_renderContext.canvas.width = width;\n            this.m_renderContext.canvas.height = height;\n        }\n        // activate in the browser with:\n        // window.__debugContext.setValue(\"DEBUG_SCREEN_COLLISIONS\", true)\n        this.m_renderingEnabled = DebugContext_1.debugContext.getValue(\"DEBUG_SCREEN_COLLISIONS\");\n    }\n    /**\n     * Marks the region of the screen intersecting with the given bounding box as allocated.\n     *\n     * @param bounds the bounding box in world coordinates.\n     * @override\n     */\n    allocate(bounds) {\n        super.allocate(bounds);\n        this.m_numAllocations++;\n        if (this.m_renderingEnabled && this.m_renderContext !== null) {\n            this.m_renderContext.strokeStyle = \"#6666ff\";\n            this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.y - 1, bounds.w, -bounds.h);\n        }\n    }\n    /** @override */\n    allocateIBoxes(boundsArray) {\n        for (const bounds of boundsArray) {\n            this.m_numAllocations++;\n            if (this.m_renderingEnabled && this.m_renderContext !== null) {\n                this.m_renderContext.strokeStyle = \"#aa2222\";\n                this.m_renderContext.strokeRect(bounds.minX - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.minY - 1, bounds.maxX - bounds.minX, -(bounds.maxY - bounds.minY));\n            }\n        }\n        super.allocateIBoxes(boundsArray);\n    }\n    /** @override */\n    intersectsDetails(testBox, boxes) {\n        const collisionFound = super.intersectsDetails(testBox, boxes);\n        if (this.m_renderingEnabled && this.m_renderContext !== null) {\n            const offset = collisionFound ? 2 : 0;\n            this.m_renderContext.strokeStyle = collisionFound ? \"#FF0000\" : \"#00ff00\";\n            this.m_renderContext.strokeRect(testBox.x - this.screenBounds.x - offset, this.screenBounds.y + this.screenBounds.h - testBox.y - 1 + offset, testBox.w + 2 * offset, -testBox.h - 2 * offset);\n        }\n        if (collisionFound) {\n            this.m_numFailedTests++;\n        }\n        else {\n            this.m_numSuccessfulTests++;\n        }\n        return collisionFound;\n    }\n    /**\n     * Checks if the given screen bounds intersects with the frustum of the active camera.\n     *\n     * @param bounds The bounding box in world coordinates.\n     * @override\n     */\n    isVisible(bounds) {\n        const visible = super.isVisible(bounds);\n        if (visible) {\n            this.m_numSuccessfulVisibilityTests++;\n        }\n        else {\n            this.m_numFailedVisibilityTests++;\n        }\n        return visible;\n    }\n}\nexports.ScreenCollisionsDebug = ScreenCollisionsDebug;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ScreenCollisions.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ScreenProjector.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ScreenProjector.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Determines whether a position in NDC (Normalized Device Coordinates) is inside the screen.\n * @param ndc The position to check.\n */\nfunction isOnScreen(ndc) {\n    return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;\n}\n/**\n * @hidden\n * Handles the projection of world coordinates to screen coordinates.\n */\nclass ScreenProjector {\n    /**\n     * Constructs a new `ScreenProjector`.\n     *\n     * @param m_camera Camera to project against.\n     */\n    constructor(m_camera) {\n        this.m_camera = m_camera;\n        this.m_width = 0;\n        this.m_height = 0;\n    }\n    /**\n     * Height of the screen.\n     */\n    get width() {\n        return this.m_width;\n    }\n    /**\n     * Width of the screen.\n     */\n    get height() {\n        return this.m_height;\n    }\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if\n     * outside the near / far plane.\n     */\n    project(source, target = new THREE.Vector2()) {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (p.z > -1 && p.z < 1) {\n            return this.ndcToScreen(p, target);\n        }\n        return undefined;\n    }\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if\n     * outside the screen.\n     */\n    projectOnScreen(source, target = new THREE.Vector2()) {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (isOnScreen(p)) {\n            return this.ndcToScreen(p, target);\n        }\n        return undefined;\n    }\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates. The z component between -1 and 1 is also returned.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector3} target The target vector.\n     * @returns {THREE.Vector3} The projected vector (the parameter 'target') or undefined if\n     * outside the near / far plane.\n     */\n    project3(source, target = new THREE.Vector3()) {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (p.z > -1 && p.z < 1) {\n            target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2, p.z);\n            return target;\n        }\n        return undefined;\n    }\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector. Stores\n     * result in NDC in the target vector.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector3} target The target vector.\n     * @returns {THREE.Vector3} The projected vector (the parameter 'target').\n     */\n    projectVector(source, target) {\n        target.set(source.x, source.y, source.z).project(this.m_camera);\n        return target;\n    }\n    /**\n     * Fast test to check if projected point is on screen.\n     *\n     * @returns {boolean} `true` if point is on screen, `false` otherwise.\n     */\n    onScreen(source) {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        return isOnScreen(p);\n    }\n    /**\n     * Update the `ScreenProjector` with the latest values of the screen and the camera.\n     *\n     * @param {THREE.Camera} camera Camera to project against.\n     * @param {number} width Width of screen/canvas.\n     * @param {number} height Height of screen/canvas.\n     */\n    update(camera, width, height) {\n        this.m_camera = camera;\n        this.m_width = width;\n        this.m_height = height;\n    }\n    ndcToScreen(ndc, screenCoords) {\n        return screenCoords.set((ndc.x * this.m_width) / 2, (ndc.y * this.m_height) / 2);\n    }\n}\nexports.ScreenProjector = ScreenProjector;\nScreenProjector.tempV2 = new THREE.Vector2();\nScreenProjector.tempV3 = new THREE.Vector3();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ScreenProjector.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyBackground.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyBackground.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ \"./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js\");\nconst SkyGradientTexture_1 = __webpack_require__(/*! ./SkyGradientTexture */ \"./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js\");\n/**\n * Class that handles [[MapView]]'s sky background.\n */\nclass SkyBackground {\n    /**\n     * Constructs a new `SkyBackground`.\n     *\n     * @param m_sky Sky configuration parameters.\n     * @param m_projectionType [[MapView]]'s projection type.\n     * @param camera [[MapView]]'s camera.\n     */\n    constructor(m_sky, m_projectionType, camera) {\n        this.m_sky = m_sky;\n        this.m_projectionType = m_projectionType;\n        switch (this.m_sky.type) {\n            case \"gradient\":\n                this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(this.m_sky, this.m_projectionType);\n                this.updateCamera(camera);\n                break;\n            case \"cubemap\": {\n                this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(this.m_sky);\n                break;\n            }\n        }\n    }\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        this.m_skyTexture.dispose();\n    }\n    /**\n     * Sky texture.\n     */\n    get texture() {\n        return this.m_skyTexture.texture;\n    }\n    /**\n     * This method updates the skybox based on the camera position (needed for some types of sky).\n     *\n     * @param camera The camera used in the map view.\n     */\n    updateCamera(camera) {\n        if (this.m_sky.type === \"gradient\") {\n            this.m_skyTexture.update(camera);\n        }\n    }\n    /**\n     * Updates the sky texture with new parameters.\n     *\n     * @param params New sky configuration parameters.\n     * @param projectionType Which projection is used, this may also change (in which case the\n     * textures should be recreated).\n     */\n    updateTexture(params, projectionType) {\n        const isSameSkyType = this.m_sky.type === params.type && this.m_projectionType === projectionType;\n        switch (params.type) {\n            case \"gradient\":\n                if (isSameSkyType) {\n                    this.m_skyTexture.updateTexture(params);\n                }\n                else {\n                    this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(params, projectionType);\n                }\n                break;\n            case \"cubemap\": {\n                if (isSameSkyType) {\n                    this.m_skyTexture.updateTexture(params);\n                }\n                else {\n                    this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(params);\n                }\n                break;\n            }\n        }\n        this.m_projectionType = projectionType;\n        this.m_sky = params;\n    }\n}\nexports.SkyBackground = SkyBackground;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/SkyBackground.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"SkyCubemapTexture\");\n/**\n * Number of faces that form a [[SkyCubemapTexture]].\n */\nexports.SKY_CUBEMAP_FACE_COUNT = 6;\n/**\n * Maps the faceId to the expected position in the threejs faces array.\n */\nvar SkyCubemapFaceId;\n(function (SkyCubemapFaceId) {\n    SkyCubemapFaceId[SkyCubemapFaceId[\"positiveX\"] = 0] = \"positiveX\";\n    SkyCubemapFaceId[SkyCubemapFaceId[\"negativeX\"] = 1] = \"negativeX\";\n    SkyCubemapFaceId[SkyCubemapFaceId[\"positiveY\"] = 2] = \"positiveY\";\n    SkyCubemapFaceId[SkyCubemapFaceId[\"negativeY\"] = 3] = \"negativeY\";\n    SkyCubemapFaceId[SkyCubemapFaceId[\"positiveZ\"] = 4] = \"positiveZ\";\n    SkyCubemapFaceId[SkyCubemapFaceId[\"negativeZ\"] = 5] = \"negativeZ\";\n})(SkyCubemapFaceId = exports.SkyCubemapFaceId || (exports.SkyCubemapFaceId = {}));\n/**\n * Class that handles loading all 6 faces of a [[CubeTexture]], to be used with [[SkyBackground]].\n */\nclass SkyCubemapTexture {\n    /**\n     * Constructs a new `SkyCubemapTexture`.\n     *\n     * @param sky Initial [[CubemapSky]] configuration.\n     */\n    constructor(sky) {\n        const faces = this.createCubemapFaceArray(sky);\n        this.m_skybox =\n            faces !== undefined ? new three_1.CubeTextureLoader().load(faces) : new three_1.CubeTexture();\n    }\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        this.m_skybox.dispose();\n    }\n    /**\n     * `SkyCubemapTexture`'s texture resource.\n     */\n    get texture() {\n        return this.m_skybox;\n    }\n    /**\n     * Updates the `SkyCubemapTexture` with new parameters.\n     *\n     * @param params New [[CubemapSky]] configuration.\n     */\n    updateTexture(sky) {\n        const faces = this.createCubemapFaceArray(sky);\n        if (faces === undefined) {\n            return;\n        }\n        this.m_skybox = new three_1.CubeTextureLoader().load(faces);\n    }\n    createCubemapFaceArray(sky) {\n        const faces = [\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined\n        ];\n        for (let i = 0; i < exports.SKY_CUBEMAP_FACE_COUNT; ++i) {\n            const face = sky[SkyCubemapFaceId[i]];\n            if (face === undefined) {\n                logger.error(`Face \"${SkyCubemapFaceId[i]}\" was not defined.`);\n                return;\n            }\n            faces[i] = face;\n        }\n        return faces;\n    }\n}\nexports.SkyCubemapTexture = SkyCubemapTexture;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"three\");\nexports.DEFAULT_TEXTURE_SIZE = 512;\nexports.DEFAULT_MONOMIAL_POWER = 1;\n// Vectors used for skybox bitmap computation.\nconst cameraDir = [\n    new three_1.Vector3(1, 0, 0),\n    new three_1.Vector3(-1, 0, 0),\n    new three_1.Vector3(0, -1, 0),\n    new three_1.Vector3(0, 1, 0),\n    new three_1.Vector3(0, 0, 1),\n    new three_1.Vector3(0, 0, -1)\n];\nconst cameraRight = [\n    new three_1.Vector3(0, 0, -1),\n    new three_1.Vector3(0, 0, 1),\n    new three_1.Vector3(1, 0, 0),\n    new three_1.Vector3(1, 0, 0),\n    new three_1.Vector3(1, 0, 0),\n    new three_1.Vector3(-1, 0, 0)\n];\nconst cameraUp = [\n    new three_1.Vector3(0, 1, 0),\n    new three_1.Vector3(0, 1, 0),\n    new three_1.Vector3(0, 0, 1),\n    new three_1.Vector3(0, 0, -1),\n    new three_1.Vector3(0, 1, 0),\n    new three_1.Vector3(0, 1, 0)\n];\n/**\n * Class tha generates a texture containing a linear gradient, to be used with [[SkyBackground]].\n *\n * The gradient is mapped onto a sphere, where `topColor` maps to the top of the upper hemisphere,\n * `bottomColor` to the bottom of the upper hemisphere, and `groundColor` fills the bottom\n *  hemisphere..\n */\nclass SkyGradientTexture {\n    /**\n     * Constructs a new `SkyGradientTexture`.\n     *\n     * @param sky Initial [[GradientSky]] configuration.\n     * @param m_projectionType [[MapView]]'s projection type.\n     * @param m_height Optional height parameter.\n     */\n    constructor(sky, m_projectionType, m_height = exports.DEFAULT_TEXTURE_SIZE) {\n        this.m_projectionType = m_projectionType;\n        this.m_height = m_height;\n        const topColor = new three_1.Color(sky.topColor);\n        const bottomColor = new three_1.Color(sky.bottomColor);\n        const groundColor = new three_1.Color(sky.groundColor);\n        this.m_width = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : this.m_height;\n        this.m_faceCount = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : 6.0;\n        this.m_faces = [];\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            const data = new Uint8Array(3 * this.m_width * this.m_height);\n            this.fillTextureData(data, i, topColor, bottomColor, groundColor, sky.monomialPower);\n            const texture = new three_1.DataTexture(data, this.m_width, this.m_height, three_1.RGBFormat);\n            texture.needsUpdate = true;\n            texture.unpackAlignment = 1;\n            this.m_faces.push(texture);\n        }\n        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {\n            this.m_skybox = new three_1.CubeTexture(this.m_faces);\n            this.m_skybox.needsUpdate = true;\n        }\n        else {\n            this.m_farClipPlaneDividedVertically = new three_1.Line3();\n            this.m_groundPlane = new three_1.Plane(new three_1.Vector3(0, 0, 1));\n            this.m_bottomMidFarPoint = new three_1.Vector3();\n            this.m_topMidFarPoint = new three_1.Vector3();\n            this.m_horizonPosition = new three_1.Vector3();\n            this.m_farClipPlaneCorners = [\n                new three_1.Vector3(),\n                new three_1.Vector3(),\n                new three_1.Vector3(),\n                new three_1.Vector3()\n            ];\n        }\n    }\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            this.m_faces[i].dispose();\n        }\n        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {\n            this.m_skybox.dispose();\n        }\n    }\n    /**\n     * `SkyGradientTexture`'s texture resource (simple texture or cubemap depending on\n     * [[MapView]]'s projection).\n     */\n    get texture() {\n        return this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? this.m_faces[0] : this.m_skybox;\n    }\n    /**\n     * This method updates the position of the texture depending on the camera frustum.\n     *\n     * @param camera The camera used in the map view.\n     */\n    update(camera) {\n        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Planar) {\n            this.setHorizonPosition(camera);\n            this.updateTexturePosition();\n        }\n    }\n    /**\n     * Updates the `SkyGradientTexture` with new parameters.\n     *\n     * @param params New [[GradientSky]] configuration.\n     */\n    updateTexture(sky) {\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            this.fillTextureData(this.m_faces[i].image.data, i, new three_1.Color(sky.topColor), new three_1.Color(sky.bottomColor), new three_1.Color(sky.groundColor), sky.monomialPower);\n            this.m_faces[i].needsUpdate = true;\n        }\n        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {\n            this.m_skybox.needsUpdate = true;\n        }\n    }\n    // When creating the texture, a Uint8Array is required, because the resulting texture passed\n    // to the scene as a background, is a texImage2D object, that does not accept UintClampedArray\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n    // But, when updating the texture, a Uint8ClampedArray is passed as argument, because\n    // this.m_texture.image.data returns a Uint8ClampedArray. That's why this method accepts both.\n    fillTextureData(data, faceIdx, topColor, bottomColor, groundColor, monomialPower) {\n        const color = new three_1.Color();\n        const dir = new three_1.Vector3();\n        const right = new three_1.Vector3();\n        const up = new three_1.Vector3();\n        const upDir = new three_1.Vector3(0, 0, 1);\n        for (let i = 0; i < this.m_height; ++i) {\n            for (let j = 0; j < this.m_width; ++j) {\n                if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {\n                    const offsetX = right\n                        .copy(cameraRight[faceIdx])\n                        .multiplyScalar(((j + 0.5) / this.m_width) * 2.0 - 1.0);\n                    const offsetY = up\n                        .copy(cameraUp[faceIdx])\n                        .multiplyScalar(((i + 0.5) / this.m_height) * 2.0 - 1.0);\n                    dir.copy(cameraDir[faceIdx])\n                        .add(offsetX)\n                        .add(offsetY)\n                        .normalize();\n                    const t = Math.max(upDir.dot(dir), 0);\n                    color\n                        .copy(groundColor)\n                        .lerp(bottomColor, Math.min(t * 100, 1))\n                        .lerp(topColor, t ** harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER))\n                        .multiplyScalar(255);\n                }\n                else {\n                    const t = i / this.m_height;\n                    if (i === 0) {\n                        color.copy(groundColor).multiplyScalar(255);\n                    }\n                    else {\n                        color\n                            .copy(bottomColor)\n                            .lerp(topColor, t ** harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER))\n                            .multiplyScalar(255);\n                    }\n                }\n                data[i * this.m_width * 3 + j * 3] = color.r;\n                data[i * this.m_width * 3 + j * 3 + 1] = color.g;\n                data[i * this.m_width * 3 + j * 3 + 2] = color.b;\n            }\n        }\n    }\n    setHorizonPosition(camera) {\n        this.m_farClipPlaneCorners[0].set(-1, -1, 1).unproject(camera);\n        this.m_farClipPlaneCorners[1].set(1, -1, 1).unproject(camera);\n        this.m_farClipPlaneCorners[2].set(-1, 1, 1).unproject(camera);\n        this.m_farClipPlaneCorners[3].set(1, 1, 1).unproject(camera);\n        this.m_bottomMidFarPoint.copy(this.m_farClipPlaneCorners[0])\n            .add(this.m_farClipPlaneCorners[1])\n            .multiplyScalar(0.5);\n        this.m_topMidFarPoint.copy(this.m_farClipPlaneCorners[2])\n            .add(this.m_farClipPlaneCorners[3])\n            .multiplyScalar(0.5);\n        this.m_farClipPlaneDividedVertically.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);\n        const hasIntersection = this.m_groundPlane.intersectLine(this.m_farClipPlaneDividedVertically, this.m_horizonPosition);\n        // When there is no intersection between the ground plane and the\n        // farClipPlaneDividedVertically, be sure that the horizon is reset. Otherwise a previous\n        // intersection point stored in the m_horizonPosition will be considered the valid one.\n        if (!hasIntersection) {\n            this.m_horizonPosition.set(0.0, 0.0, 0.0);\n        }\n    }\n    updateTexturePosition() {\n        const coveredBySky = this.m_bottomMidFarPoint.distanceTo(this.m_horizonPosition);\n        const frustumHeight = this.m_farClipPlaneDividedVertically.distance();\n        const skyRatio = coveredBySky / frustumHeight;\n        // If there is no intersection between the ground plane and the line that defines the far\n        // clip plane divided vertically, it means that there is no sky visible and therefore the\n        // ground color should be displayed. When there is no intersection, the length of the\n        // this.m_horizonPosition is still equal to zero, as threejs initialize an empty vector with\n        // all the three components to zero.\n        // If there is an intersection, calculate the offset.\n        const ratio = this.m_horizonPosition.length() === 0 ? 1 : skyRatio - 2 / this.m_height;\n        // If the bottom part of the far clipping plane is under the ground plane, scroll the\n        // texture down. Otherwise, the camera is looking at the sky, therefore, scroll the texture\n        // up.\n        this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint.z <= 0 ? -ratio : skyRatio);\n    }\n}\nexports.SkyGradientTexture = SkyGradientTexture;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/SkyGradientTexture.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Statistics.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Statistics.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"Statistics\");\n/**\n * A simple ring buffer to store the last `n` values of the timer. The buffer works on\n * a First-In-First-Out (FIFO) basis.\n */\nclass RingBuffer {\n    /**\n     * Sets up the ring buffer.\n     *\n     * @param capacity The buffer's capacity.\n     */\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.buffer = new Array(capacity);\n        this.capacity = capacity;\n        this.head = this.tail = this.size = 0;\n    }\n    /**\n     * Clears the contents, removes all elements.\n     */\n    clear() {\n        this.head = this.tail = this.size = 0;\n    }\n    /**\n     * Adds a single element to the ring buffer.\n     *\n     * @param data Data element.\n     */\n    enqOne(data) {\n        let next = this.head + 1;\n        if (next >= this.capacity) {\n            next = 0;\n        }\n        if (this.size < this.capacity) {\n            this.size++;\n        }\n        this.buffer[this.head] = data;\n        this.head = next;\n        if (this.size === this.capacity) {\n            this.tail = this.head;\n        }\n    }\n    /**\n     * Adds one or more elements.\n     *\n     * @param data The elements to add.\n     */\n    enq(...data) {\n        for (const v of data) {\n            this.enqOne(v);\n        }\n    }\n    /**\n     * Obtains the oldest element (FIFO). May throw an exception if a buffer underrun occurs.\n     * Before calling this method, make sure that `size > 0`.\n     */\n    deq() {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n        const data = this.buffer[this.tail];\n        let next = this.tail + 1;\n        if (next >= this.capacity) {\n            next = 0;\n        }\n        if (this.size > 0) {\n            this.size--;\n        }\n        this.tail = next;\n        return data;\n    }\n    /**\n     * Obtains the oldest element (FIFO) without removing it. Throws an exception if a buffer is\n     * empty. Before calling this method, make sure that `size > 0`.\n     */\n    get top() {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n        return this.buffer[this.tail];\n    }\n    /**\n     * Obtains the latest element (LIFO) without removing it. Throws an exception if a buffer is\n     * empty. Before calling this method, make sure that `size > 0`.\n     */\n    get bottom() {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n        let previous = this.head - 1;\n        if (previous < 0) {\n            previous = this.capacity - 1;\n        }\n        return this.buffer[previous];\n    }\n    /**\n     * Creates an iterator for the buffer.\n     */\n    iterator() {\n        return new RingBuffer.Iterator(this);\n    }\n    /**\n     * Returns a copy of the buffer, where the elements are properly sorted from oldest to newest.\n     */\n    asArray() {\n        const array = new Array();\n        for (let i = 0; i < this.size; i++) {\n            array.push(this.buffer[(this.tail + i) % this.capacity]);\n        }\n        return array;\n    }\n}\nexports.RingBuffer = RingBuffer;\n(function (RingBuffer) {\n    /**\n     * A local class for RingBuffer<T>\n     */\n    class Iterator {\n        /**\n         * Creates an iterator for the ring buffer.\n         *\n         * @param m_buffer `Ringbuffer` to iterate over.\n         * @param m_index Start index.\n         */\n        constructor(m_buffer, m_index = 0) {\n            this.m_buffer = m_buffer;\n            this.m_index = m_index;\n        }\n        /**\n         * Gets the iterator's current value. This function does not fail even if an overrun occurs.\n         * To detect an overrun, watch the result for [[next]].\n         */\n        get value() {\n            return this.m_buffer.buffer[(this.m_buffer.tail + this.m_index) % this.m_buffer.capacity];\n        }\n        /**\n         * Advances the iterator to the next element.\n         *\n         * @returns `true` if the iterator is still valid; `false` if an overrun occurs.\n         */\n        next() {\n            this.m_index++;\n            return this.m_index < this.m_buffer.size;\n        }\n    }\n    RingBuffer.Iterator = Iterator;\n})(RingBuffer = exports.RingBuffer || (exports.RingBuffer = {}));\n/**\n * A simple timer that stores only the latest measurement.\n */\nclass SimpleTimer {\n    constructor(statistics, name) {\n        this.statistics = statistics;\n        this.name = name;\n        /** `true` if timer has been started. */\n        this.running = false;\n    }\n    /**\n     * Gets the latest measurement. This function may return `undefined` if no measurement\n     * was done.\n     */\n    get value() {\n        return this.m_currentValue;\n    }\n    /**\n     * Sets the measurement value for the amount of time that has elapsed from start() to stop().\n     * Use this function to override the timer's duration.\n     *\n     * @param val The timer's duration.\n     */\n    setValue(val) {\n        this.m_currentValue = val;\n    }\n    /**\n     * Resets the value to be able to start again.\n     */\n    reset() {\n        this.m_currentValue = undefined;\n    }\n    /**\n     * Starts the timer. Returns the current time, based on `Performance.now()`.\n     */\n    start() {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' is already running\");\n        }\n        this.running = true;\n        return (this.m_currentValue = harp_utils_1.PerformanceTimer.now());\n    }\n    /**\n     * Stops the timer. Requires that the timer has started.\n     */\n    stop() {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (!this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' has not been started\");\n        }\n        else {\n            // this.currentValue is a number now!\n            const t = harp_utils_1.PerformanceTimer.now() - (this.m_currentValue || 0);\n            this.m_currentValue = t;\n            this.setValue(t);\n            this.running = false;\n            return t;\n        }\n    }\n    /**\n     * Samples the timer. Requires that the timer has started.\n     *\n     * @returns the current timer value; `-1` if statistics are disabled.\n     */\n    now() {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (!this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' has not been started\");\n        }\n        else {\n            const t = harp_utils_1.PerformanceTimer.now() - (this.m_currentValue || 0);\n            return t;\n        }\n    }\n}\nexports.SimpleTimer = SimpleTimer;\n/**\n * A timer that stores the last `n` samples in a ring buffer.\n */\nclass SampledTimer extends SimpleTimer {\n    /**\n     * Creates a `SampledTimer` instance. Must still be added to statistics if it should be logged!\n     *\n     * @param statistics Statistics to use for management.\n     * @param name Name of the timer. Use colons to build a hierarchy.\n     */\n    constructor(statistics, name) {\n        super(statistics, name);\n        this.statistics = statistics;\n        this.name = name;\n        /**\n         * The number of times the timer has reset.\n         */\n        this.numResets = 0;\n        /**\n         * Maximum samples until the statistics are reset and updated, which may destroy a median\n         * computation.\n         */\n        this.maxNumSamples = 1000;\n        /**\n         * The array of sampled values, its length cannot exceed `maxNumSamples`.\n         */\n        this.samples = new RingBuffer(this.maxNumSamples);\n    }\n    /**\n     * Resets the timer and clears all of its historical values.\n     * @override\n     */\n    reset() {\n        super.reset();\n        this.getStats();\n        this.samples.clear();\n        this.numResets++;\n    }\n    /**\n     * Add a single measurement to the sample.\n     *\n     * @param val A measurement to add.\n     * @override\n     */\n    setValue(val) {\n        super.setValue(val);\n        if (val !== undefined) {\n            this.samples.enqOne(val);\n        }\n    }\n    /**\n     * Updates the `min`, `max`, `avg`, and `median` values. Currently, this function is expensive,\n     * as it requires a copy of the sampled values.\n     */\n    getStats() {\n        return computeArrayStats(this.samples.asArray());\n    }\n}\nexports.SampledTimer = SampledTimer;\n/**\n * Only exported for testing\n * @ignore\n *\n * Compute the [[ArrayStats]] for the passed in array of numbers.\n *\n * @param {number[]} samples Array containing sampled values. Will be modified (!) by sorting the\n *      entries.\n * @returns {(Stats | undefined)}\n */\nfunction computeArrayStats(samples) {\n    if (samples.length === 0) {\n        return undefined;\n    }\n    samples.sort((a, b) => {\n        return a - b;\n    });\n    const min = samples[0];\n    const max = samples[samples.length - 1];\n    let median;\n    let median75;\n    let median90;\n    let median95;\n    let median97;\n    let median99;\n    let median999;\n    if (samples.length === 1) {\n        median75 = median90 = median95 = median97 = median99 = median999 = median = samples[0];\n    }\n    else if (samples.length === 2) {\n        median = samples[0] * 0.5 + samples[1] * 0.5;\n        median75 = median90 = median95 = median97 = median99 = median999 = samples[1];\n    }\n    else {\n        const mid = Math.floor(samples.length / 2);\n        median =\n            samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];\n        const mid75 = Math.round(samples.length * 0.75) - 1;\n        median75 = samples[mid75];\n        const mid90 = Math.round(samples.length * 0.9) - 1;\n        median90 = samples[mid90];\n        const mid95 = Math.round(samples.length * 0.95) - 1;\n        median95 = samples[mid95];\n        const mid97 = Math.round(samples.length * 0.97) - 1;\n        median97 = samples[mid97];\n        const mid99 = Math.round(samples.length * 0.99) - 1;\n        median99 = samples[mid99];\n        const mid999 = Math.round(samples.length * 0.999) - 1;\n        median999 = samples[mid999];\n    }\n    let sum = 0;\n    for (let i = 0, l = samples.length; i < l; i++) {\n        sum += samples[i];\n    }\n    const avg = sum / samples.length;\n    return {\n        min,\n        max,\n        avg,\n        median,\n        median75,\n        median90,\n        median95,\n        median97,\n        median99,\n        median999,\n        numSamples: samples.length\n    };\n}\nexports.computeArrayStats = computeArrayStats;\n/**\n * Only exported for testing\n * @ignore\n *\n * Compute the averages for the passed in array of numbers.\n *\n * @param {number[]} samples Array containing sampled values.\n * @returns {(Stats | undefined)}\n */\nfunction computeArrayAverage(samples) {\n    if (samples.length === 0) {\n        return undefined;\n    }\n    let sum = 0;\n    for (let i = 0, l = samples.length; i < l; i++) {\n        sum += samples[i];\n    }\n    const avg = sum / samples.length;\n    return avg;\n}\nexports.computeArrayAverage = computeArrayAverage;\n/**\n * Measures a sequence of connected events, such as multiple processing stages in a function.\n * Each stage is identified with a timer name, that must be a valid timer in the statistics\n * object. Additionally, all timers within a `MultiStageTimer` must be unique.\n *\n * Internally, the `MultiStageTimer` manages a list of timers where at the end of each stage,\n * one timer stops and the next timer starts.\n */\nclass MultiStageTimer {\n    /**\n     * Defines the `MultiStageTimer` with a list of timer names that represent its stages.\n     *\n     * @param statistics The statistics object that manages the timers.\n     * @param name Name of this `MultiStageTimer`.\n     * @param stages List of timer names.\n     */\n    constructor(statistics, name, stages) {\n        this.statistics = statistics;\n        this.name = name;\n        this.stages = stages;\n        if (stages.length < 1) {\n            throw new Error(\"MultiStageTimer needs stages\");\n        }\n        stages.forEach(stage => {\n            if (!statistics.hasTimer(stage)) {\n                throw new Error(\"Unknown timer: \" + stage);\n            }\n        });\n    }\n    /**\n     * Gets the timer value for the last stage. If the `MultiStageTimer` did not finish its\n     * last stage, the value is `undefined`.\n     */\n    get value() {\n        return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;\n    }\n    /**\n     * Resets the timers across all stages.\n     */\n    reset() {\n        if (!this.statistics.enabled) {\n            return;\n        }\n        this.stages.forEach(stage => {\n            this.statistics.getTimer(stage).reset();\n        });\n    }\n    /**\n     * Starts the `MultiStageTimer` at its first stage.\n     */\n    start() {\n        this.stage = this.stages[0];\n        return this.statistics.getTimer(this.stages[0]).value || -1;\n    }\n    /**\n     * Stops the `MultiStageTimer`. Returns the measurement of the last stage, which may be\n     * `undefined` if not all stages started.\n     */\n    stop() {\n        this.stage = undefined;\n        return this.value !== undefined ? this.value : -1;\n    }\n    /**\n     * Gets the current stage.\n     */\n    get stage() {\n        return this.currentStage;\n    }\n    /**\n     * Sets the current stage. If a new stage is provided, the current timer (if available) is\n     * stopped, and the next timer is started. If the timer in the next stage is `undefined`,\n     * this is equivalent to calling `stop` on the `MultiStageTimer`.\n     *\n     * @param stage The next stage to start.\n     */\n    set stage(stage) {\n        if (this.currentStage === stage) {\n            return;\n        }\n        if (this.statistics.enabled && this.currentStage !== undefined) {\n            this.statistics.getTimer(this.currentStage).stop();\n        }\n        this.currentStage = stage;\n        if (this.statistics.enabled && this.currentStage !== undefined) {\n            this.statistics.getTimer(this.currentStage).start();\n        }\n    }\n}\nexports.MultiStageTimer = MultiStageTimer;\n/**\n * Manages a set of timers. The main objective of `Statistics` is to log these timers. You can\n * disable statistics to minimize their impact on performance.\n */\nclass Statistics {\n    /**\n     * Sets up a group of timers.\n     *\n     * @param name The statistics name, for logging purposes.\n     * @param enabled If `false`, the timers do not measure the performance.\n     */\n    constructor(name, enabled = false) {\n        this.name = name;\n        this.enabled = enabled;\n        this.timers = new Map();\n        this.nullTimer = new SimpleTimer(this, \"<null>\");\n    }\n    /**\n     * Adds a timer, based on the name specified.\n     *\n     * @param name The timer's name; must be unique.\n     */\n    createTimer(name, keepSamples = true) {\n        const timer = keepSamples ? new SampledTimer(this, name) : new SimpleTimer(this, name);\n        return this.addTimer(timer);\n    }\n    /**\n     * Adds the timer specified.\n     *\n     * @param timer The timer's name, which must be unique within this statistics object.\n     */\n    addTimer(timer) {\n        if (this.timers.get(timer.name) !== undefined) {\n            throw new Error(\"Duplicate timer name: '\" + timer.name + \"'\");\n        }\n        this.timers.set(timer.name, timer);\n        return timer;\n    }\n    /**\n     * Gets a timer by name.\n     *\n     * @param name The timer's name.\n     */\n    getTimer(name) {\n        if (!this.enabled) {\n            return this.nullTimer;\n        }\n        const t = this.timers.get(name);\n        return t === undefined ? this.nullTimer : t;\n    }\n    /**\n     * Checks if a timer with the specified name already exists.\n     *\n     * @param name The timer's name.\n     * @returns `true` if a timer with `name` already exists; `false` otherwise.\n     */\n    hasTimer(name) {\n        const t = this.timers.get(name);\n        return t !== undefined;\n    }\n    /**\n     * Resets all timers.\n     */\n    reset() {\n        this.timers.forEach((timer) => {\n            timer.reset();\n        });\n    }\n    /**\n     * Prints all values to the console.\n     *\n     * @param header Optional header line.\n     * @param footer Optional footer line.\n     */\n    log(header, footer) {\n        if (header !== undefined || this.name !== undefined) {\n            logger.log(header !== undefined ? header : this.name);\n        }\n        let maxNameLength = 0;\n        this.timers.forEach((timer) => {\n            maxNameLength = Math.max(maxNameLength, timer.name.length);\n        });\n        // simple printing function for number limits the number of decimal points.\n        const print = (v) => {\n            return v !== undefined ? v.toFixed(5) : \"?\";\n        };\n        this.timers.forEach((timer) => {\n            let s = timer.name + \": \" + \" \".repeat(maxNameLength - timer.name.length);\n            s += print(timer.value);\n            // sampled timers also update their stats and log them\n            if (timer instanceof SampledTimer) {\n                const simpleStats = timer.getStats();\n                if (simpleStats !== undefined) {\n                    s +=\n                        `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +\n                            `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +\n                            `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +\n                            `N=${print(simpleStats.numSamples)} ]`;\n                }\n            }\n            logger.log(s);\n        });\n        if (footer !== undefined) {\n            logger.log(footer);\n        }\n    }\n}\nexports.Statistics = Statistics;\n/**\n * Class containing all counters, timers and events of the current frame.\n */\nclass FrameStats {\n    constructor() {\n        this.entries = new Map();\n        this.messages = undefined;\n    }\n    /**\n     * Retrieve the value of the performance number.\n     *\n     * @param name Name of the performance number.\n     * @returns The value of the performance number or `undefined` if it has not been declared by\n     *      `setValue` before.\n     */\n    getValue(name) {\n        return this.entries.get(name);\n    }\n    /**\n     * Set the value of the performance number.\n     *\n     * @param name Name of the performance number.\n     * @param name New value of the performance number.\n     */\n    setValue(name, value) {\n        this.entries.set(name, value);\n    }\n    /**\n     * Add a value to the current value of the performance number. If the performance is not known,\n     * it will be initialized with `value`.\n     *\n     * @param name Name of the performance number.\n     * @param name Value to be added to the performance number.\n     */\n    addValue(name, value) {\n        const oldValue = this.entries.get(name);\n        this.entries.set(name, value + (oldValue === undefined ? 0 : oldValue));\n    }\n    /**\n     * Add a text message to the frame, like \"Font XYZ has been loaded\"\n     *\n     * @param message The message to add.\n     */\n    addMessage(message) {\n        if (this.messages === undefined) {\n            this.messages = [];\n        }\n        this.messages.push(message);\n    }\n    /**\n     * Reset all known performance values to `0` and the messages to `undefined`.\n     */\n    reset() {\n        this.entries.forEach((value, name) => {\n            this.entries.set(name, 0);\n        });\n        this.messages = undefined;\n    }\n}\nexports.FrameStats = FrameStats;\n/**\n * @ignore\n * Only exported for testing.\n *\n * Instead of passing around an array of objects, we store the frame statistics as an object of\n * arrays. This allows convenient computations from [[RingBuffer]],\n */\nclass FrameStatsArray {\n    constructor(capacity = 0) {\n        this.capacity = capacity;\n        this.frameEntries = new Map();\n        this.messages = new RingBuffer(capacity);\n    }\n    get length() {\n        return this.messages.size;\n    }\n    reset() {\n        this.frameEntries.forEach((buffer, name) => {\n            buffer.clear();\n        });\n        this.messages.clear();\n    }\n    addFrame(frameStats) {\n        const currentSize = this.length;\n        const frameEntries = this.frameEntries;\n        frameStats.entries.forEach((value, name) => {\n            let buffer = frameEntries.get(name);\n            if (buffer === undefined) {\n                // If there is a buffer that has not been known before, add it to the known buffers,\n                // fill it up with with 0 to the size of all the other buffers to make them of equal\n                // size to make PerfViz happy.\n                buffer = new RingBuffer(this.capacity);\n                for (let i = 0; i < currentSize; i++) {\n                    buffer.enqOne(0);\n                }\n                this.frameEntries.set(name, buffer);\n            }\n            buffer.enqOne(value);\n        });\n        this.messages.enq(frameStats.messages);\n    }\n    /**\n     * Prints all values to the console.\n     */\n    log() {\n        let maxNameLength = 0;\n        this.frameEntries.forEach((buffer, name) => {\n            maxNameLength = Math.max(maxNameLength, name.length);\n        });\n        // simple printing function for number limits the number of decimal points.\n        const print = (v) => {\n            return v !== undefined ? v.toFixed(5) : \"?\";\n        };\n        this.frameEntries.forEach((buffer, name) => {\n            let s = name + \": \" + \" \".repeat(maxNameLength - name.length);\n            const simpleStats = computeArrayStats(buffer.asArray());\n            if (simpleStats !== undefined) {\n                s +=\n                    `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +\n                        `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +\n                        `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +\n                        `N=${print(simpleStats.numSamples)} ]`;\n            }\n            logger.log(s);\n        });\n    }\n}\nexports.FrameStatsArray = FrameStatsArray;\n/**\n * Performance measurement central. Maintains the current [[FrameStats]], which holds all individual\n * performance numbers.\n *\n * Implemented as an instance for easy access.\n */\nclass PerformanceStatistics {\n    /**\n     * Creates an instance of PerformanceStatistics. Overrides the current `instance`.\n     *\n     * @param {boolean} [enabled=true] If `false` the performance values will not be stored.\n     * @param {number} [maxNumFrames=1000] The maximum number of frames that are to be stored.\n     * @memberof PerformanceStatistics\n     */\n    constructor(enabled = true, maxNumFrames = 1000) {\n        this.enabled = enabled;\n        this.maxNumFrames = maxNumFrames;\n        /**\n         * Current frame statistics. Contains all values for the current frame. Will be cleared when\n         * [[PerformanceStatistics#storeFrameInfo]] is called.\n         *\n         * @type {FrameStats}\n         * @memberof PerformanceStatistics\n         */\n        this.currentFrame = new FrameStats();\n        /**\n         * Additional results stored for the current application run, not per frame. Only the last value\n         * is stored.\n         *\n         * @type {(Map<string, number>)}\n         */\n        this.appResults = new Map();\n        /**\n         * Additional configuration values stored for the current application run, not per frame. Only\n         * the last value is stored.\n         *\n         * @type {(Map<string, string>)}\n         * @memberof PerformanceStatistics\n         */\n        this.configs = new Map();\n        PerformanceStatistics.m_instance = this;\n        this.m_frameEvents = new FrameStatsArray(maxNumFrames);\n    }\n    /**\n     * Returns `true` when the maximum number of storable frames is reached.\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberof PerformanceStatistics\n     */\n    get isFull() {\n        return this.m_frameEvents.length >= this.maxNumFrames;\n    }\n    /**\n     * Global instance to the instance. The current instance can be overridden by creating a new\n     * `PerformanceStatistics`.\n     */\n    static get instance() {\n        if (PerformanceStatistics.m_instance === undefined) {\n            PerformanceStatistics.m_instance = new PerformanceStatistics(false, 0);\n        }\n        return PerformanceStatistics.m_instance;\n    }\n    /**\n     * @ignore\n     * Only exported for testing.\n     *\n     * Return the array of frame events.\n     */\n    get frameEvents() {\n        return this.m_frameEvents;\n    }\n    /**\n     * Clears all settings, all stored frame events as well as the current frame values.\n     *\n     * @memberof PerformanceStatistics\n     */\n    clear() {\n        this.clearFrames();\n        this.configs.clear();\n        this.appResults.clear();\n    }\n    /**\n     * Clears only all stored frame events as well as the current frame values.\n     *\n     * @memberof PerformanceStatistics\n     */\n    clearFrames() {\n        this.m_frameEvents.reset();\n        this.currentFrame.reset();\n    }\n    /**\n     * Stores the current frame events into the array of events. Uses [[THREE.WebGLInfo]] to add the\n     * render state information to the current frame.\n     *\n     * @param {THREE.WebGLInfo} webGlInfo\n     * @returns {boolean} Returns `false` if the maximum number of storable frames has been reached.\n     * @memberof PerformanceStatistics\n     */\n    storeFrameInfo(webGlInfo) {\n        if (this.m_frameEvents.length >= this.maxNumFrames) {\n            return false;\n        }\n        if (webGlInfo !== undefined) {\n            if (webGlInfo.render !== undefined) {\n                this.currentFrame.setValue(\"gl.numCalls\", webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls);\n                this.currentFrame.setValue(\"gl.numPoints\", webGlInfo.render.points === null ? 0 : webGlInfo.render.points);\n                this.currentFrame.setValue(\"gl.numLines\", webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines);\n                this.currentFrame.setValue(\"gl.numTriangles\", webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles);\n            }\n            if (webGlInfo.memory !== undefined) {\n                this.currentFrame.setValue(\"gl.numGeometries\", webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries);\n                this.currentFrame.setValue(\"gl.numTextures\", webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures);\n            }\n            if (webGlInfo.programs !== undefined) {\n                this.currentFrame.setValue(\"gl.numPrograms\", webGlInfo.programs === null ? 0 : webGlInfo.programs.length);\n            }\n        }\n        if (window !== undefined && window.performance !== undefined) {\n            const memory = window.performance.memory;\n            if (memory !== undefined) {\n                this.currentFrame.setValue(\"memory.totalJSHeapSize\", memory.totalJSHeapSize);\n                this.currentFrame.setValue(\"memory.usedJSHeapSize\", memory.usedJSHeapSize);\n                this.currentFrame.setValue(\"memory.jsHeapSizeLimit\", memory.jsHeapSizeLimit);\n            }\n        }\n        this.m_frameEvents.addFrame(this.currentFrame);\n        this.currentFrame.reset();\n        return true;\n    }\n    /**\n     * Logs all values to the logger.\n     *\n     * @param header Optional header line.\n     * @param footer Optional footer line.\n     */\n    log(header, footer) {\n        logger.log(header !== undefined ? header : \"PerformanceStatistics\");\n        const appResults = this.appResults;\n        appResults.forEach((value, name) => {\n            logger.log(name, value);\n        });\n        const configs = this.configs;\n        configs.forEach((value, name) => {\n            logger.log(name, value);\n        });\n        this.m_frameEvents.log();\n        if (footer !== undefined) {\n            logger.log(footer);\n        }\n    }\n    /**\n     * Convert to a plain object that can be serialized. Required to copy the test results over to\n     * nightwatch.\n     */\n    getAsPlainObject(onlyLastFrame = false) {\n        const appResults = {};\n        const configs = {};\n        const frames = {};\n        const plainObject = {\n            configs,\n            appResults,\n            frames\n        };\n        const appResultValues = this.appResults;\n        appResultValues.forEach((value, name) => {\n            appResults[name] = value;\n        });\n        const configValues = this.configs;\n        configValues.forEach((value, name) => {\n            configs[name] = value;\n        });\n        if (onlyLastFrame) {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames[name] = buffer.bottom;\n            }\n        }\n        else {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames[name] = buffer.asArray();\n            }\n        }\n        plainObject.messages = this.m_frameEvents.messages.asArray();\n        return plainObject;\n    }\n    /**\n     * Convert the last frame values to a plain object that can be serialized. Required to copy the\n     * test results over to nightwatch.\n     */\n    getLastFrameStatistics() {\n        return this.getAsPlainObject(true);\n    }\n    /**\n     * Convert to a plain object that can be serialized. Required to copy the test results over to\n     * nightwatch.\n     */\n    getAsSimpleFrameStatistics(onlyLastFrame = false) {\n        const configs = new Map();\n        const appResults = new Map();\n        const frames = new Map();\n        const simpleStatistics = {\n            configs,\n            appResults,\n            frames,\n            messages: this.m_frameEvents.messages.asArray()\n        };\n        const appResultValues = this.appResults;\n        appResultValues.forEach((value, name) => {\n            appResults.set(name, value);\n        });\n        const configValues = this.configs;\n        configValues.forEach((value, name) => {\n            configs.set(name, value);\n        });\n        if (onlyLastFrame) {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames.set(name, buffer.bottom);\n            }\n        }\n        else {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames.set(name, buffer.asArray());\n            }\n        }\n        return simpleStatistics;\n    }\n}\nexports.PerformanceStatistics = PerformanceStatistics;\nPerformanceStatistics.m_instance = undefined;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/Statistics.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ThemeHelpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ThemeHelpers.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Returns `three.js` pixel format object basing on a [[PixelFormat]] specified.\n */\nfunction toPixelFormat(format) {\n    switch (format) {\n        case \"Alpha\":\n            return THREE.AlphaFormat;\n        case \"RGB\":\n            return THREE.RGBFormat;\n        case \"RGBA\":\n            return THREE.RGBAFormat;\n        case \"Luminance\":\n            return THREE.LuminanceFormat;\n        case \"LuminanceAlpha\":\n            return THREE.LuminanceAlphaFormat;\n        case \"RGBE\":\n            return THREE.RGBEFormat;\n        case \"Depth\":\n            return THREE.DepthFormat;\n        case \"DepthStencil\":\n            return THREE.DepthStencilFormat;\n        case \"Red\":\n            return THREE.RedFormat;\n        default:\n            throw new Error(`invalid pixel format: ${format}`);\n    }\n}\nexports.toPixelFormat = toPixelFormat;\n/**\n * Returns `three.js` texture data types based on a [[TextureDataType]] specified.\n */\nfunction toTextureDataType(dataType) {\n    switch (dataType) {\n        case \"UnsignedByte\":\n            return THREE.UnsignedByteType;\n        case \"Byte\":\n            return THREE.ByteType;\n        case \"Short\":\n            return THREE.ShortType;\n        case \"UnsignedShort\":\n            return THREE.UnsignedShortType;\n        case \"Int\":\n            return THREE.IntType;\n        case \"UnsignedInt\":\n            return THREE.UnsignedIntType;\n        case \"Float\":\n            return THREE.FloatType;\n        case \"HalfFloat\":\n            return THREE.HalfFloatType;\n        default:\n            throw new Error(`invalid texture data type: ${dataType}`);\n    }\n}\nexports.toTextureDataType = toTextureDataType;\n/**\n * Returns `three.js` wrapping mode object based on a [[WrappingMode]] specified.\n */\nfunction toWrappingMode(mode) {\n    switch (mode) {\n        case \"clamp\":\n            return THREE.ClampToEdgeWrapping;\n        case \"repeat\":\n            return THREE.RepeatWrapping;\n        case \"mirror\":\n            return THREE.MirroredRepeatWrapping;\n        default:\n            throw new Error(`invalid wrapping mode: ${mode}`);\n    }\n}\nexports.toWrappingMode = toWrappingMode;\n/**\n * Returns `three.js` texture filter object based on a [[MagFilter]] or [[MinFilter]] specified.\n */\nfunction toTextureFilter(filter) {\n    switch (filter) {\n        case \"nearest\":\n            return THREE.NearestFilter;\n        case \"nearestMipMapNearest\":\n            return THREE.NearestMipMapNearestFilter;\n        case \"nearestMipMapLinear\":\n            return THREE.NearestMipMapLinearFilter;\n        case \"linear\":\n            return THREE.LinearFilter;\n        case \"linearMipMapNearest\":\n            return THREE.LinearMipMapNearestFilter;\n        case \"linearMipMapLinear\":\n            return THREE.LinearMipMapLinearFilter;\n        default:\n            throw new Error(`invalid texture filter: ${filter}`);\n    }\n}\nexports.toTextureFilter = toTextureFilter;\n/**\n * Create a specific light for lightening the map.\n */\nfunction createLight(lightDescription) {\n    switch (lightDescription.type) {\n        case \"ambient\": {\n            const light = new THREE.AmbientLight(lightDescription.color, lightDescription.intensity);\n            light.name = lightDescription.name;\n            return light;\n        }\n        case \"directional\": {\n            const light = new THREE.DirectionalLight(lightDescription.color, lightDescription.intensity);\n            light.name = lightDescription.name;\n            if (lightDescription.castShadow !== undefined) {\n                light.castShadow = lightDescription.castShadow;\n            }\n            light.position.set(lightDescription.direction.x, lightDescription.direction.y, lightDescription.direction.z);\n            light.position.normalize();\n            return light;\n        }\n    }\n}\nexports.createLight = createLight;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ThemeHelpers.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/ThemeLoader.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/ThemeLoader.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst Theme_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/Theme */ \"./node_modules/@here/harp-datasource-protocol/lib/Theme.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ \"./node_modules/@here/harp-mapview/lib/SkyCubemapTexture.js\");\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nexports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;\n/**\n * Loads and validates a theme from URL objects.\n */\nclass ThemeLoader {\n    /**\n     * Loads a [[Theme]] from a remote resource, provided as a URL that points to a\n     * JSON-encoded theme.\n     *\n     * By default, resolves following features of theme:\n     *\n     *  -  `extends` - loads and merges all inherited themes (see [[resolveBaseTheme]])\n     *  -  `ref` - resolves all `ref` instances to their values defined in `definitions` section\n     *     of theme (see [[resolveThemeReferences]])\n     *\n     * Relative URIs of reference resources are resolved to full URL using the document's base URL\n     * (see [[resolveUrls]]).\n     *\n     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with by\n     * providing [[UriResolver]] using [[ThemeLoadOptions.uriResolver]] option.\n     *\n     * @param theme [[Theme]] instance or theme URL to the theme.\n     * @param options Optional, a [[ThemeLoadOptions]] objects containing any custom settings for\n     *    this load request.\n     */\n    static async load(theme, options) {\n        options = options || {};\n        if (typeof theme === \"string\") {\n            const uriResolver = options.uriResolver;\n            const themeUrl = uriResolver !== undefined ? uriResolver.resolveUri(theme) : theme;\n            const response = await fetch(themeUrl, { signal: options.signal });\n            if (!response.ok) {\n                throw new Error(`ThemeLoader#load: cannot load theme: ${response.statusText}`);\n            }\n            theme = (await response.json());\n            theme.url = harp_utils_1.resolveReferenceUri(harp_utils_1.getAppBaseUrl(), themeUrl);\n            theme = this.resolveUrls(theme, uriResolver);\n        }\n        else if (theme.url === undefined) {\n            // assume that theme url is same as baseUrl\n            theme.url = harp_utils_1.getAppBaseUrl();\n            theme = this.resolveUrls(theme, options.uriResolver);\n        }\n        if (theme === null || theme === undefined) {\n            throw new Error(\"ThemeLoader#load: loaded resource is not valid JSON\");\n        }\n        theme = theme;\n        ThemeLoader.checkTechniqueSupport(theme);\n        const resolveDefinitions = harp_utils_1.getOptionValue(options.resolveDefinitions, false);\n        theme = await ThemeLoader.resolveBaseThemes(theme, options);\n        if (resolveDefinitions) {\n            const contextLoader = new harp_utils_1.ContextLogger(options.logger || console, `when processing Theme ${theme.url}:`);\n            ThemeLoader.resolveThemeReferences(theme, contextLoader);\n        }\n        return theme;\n    }\n    /**\n     * Checks if `theme` instance is completely loaded, meaning that `extends` property is resolved.\n     *\n     * @param theme\n     */\n    static isThemeLoaded(theme) {\n        return theme.extends === undefined;\n    }\n    /**\n     * @deprecated Please use `ThemeLoader.load`\n     *\n     * Loads a [[Theme]] from a remote resource, provided as a URL that points to a JSON-encoded\n     * theme.\n     *\n     * @param themeUrl The URL to the theme.\n     *\n     */\n    static async loadAsync(themeUrl) {\n        return ThemeLoader.load(themeUrl);\n    }\n    /**\n     * Resolves all [[Theme]]'s relatives URLs to full URL using the [[Theme]]'s URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     *\n     * This method mutates original `theme` instance.\n     *\n     * @param theme The [[Theme]] to resolve.\n     */\n    static resolveUrls(theme, uriResolver) {\n        // Ensure that all resources referenced in theme by relative URIs are in fact relative to\n        // theme.\n        if (theme.url === undefined) {\n            return theme;\n        }\n        const childUrlResolver = harp_utils_1.composeUriResolvers(uriResolver, new harp_utils_1.RelativeUriResolver(theme.url));\n        if (theme.extends) {\n            theme.extends = (Array.isArray(theme.extends) ? theme.extends : [theme.extends]).map(baseTheme => {\n                if (typeof baseTheme === \"string\") {\n                    return childUrlResolver.resolveUri(baseTheme);\n                }\n                else {\n                    if (baseTheme.url !== undefined) {\n                        return baseTheme;\n                    }\n                    else {\n                        baseTheme.url = theme.url;\n                        return this.resolveUrls(baseTheme, uriResolver);\n                    }\n                }\n            });\n        }\n        if (theme.sky && theme.sky.type === \"cubemap\") {\n            for (let i = 0; i < SkyCubemapTexture_1.SKY_CUBEMAP_FACE_COUNT; ++i) {\n                const faceUrl = theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]];\n                if (faceUrl !== undefined) {\n                    theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]] = childUrlResolver.resolveUri(faceUrl);\n                }\n            }\n        }\n        if (theme.images) {\n            for (const name of Object.keys(theme.images)) {\n                const image = theme.images[name];\n                image.url = childUrlResolver.resolveUri(image.url);\n                if (image.atlas !== undefined) {\n                    image.atlas = childUrlResolver.resolveUri(image.atlas);\n                }\n            }\n        }\n        if (theme.fontCatalogs) {\n            for (const font of theme.fontCatalogs) {\n                font.url = childUrlResolver.resolveUri(font.url);\n            }\n        }\n        if (theme.poiTables) {\n            for (const poiTable of theme.poiTables) {\n                poiTable.url = childUrlResolver.resolveUri(poiTable.url);\n            }\n        }\n        if (theme.styles) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                const styleSet = theme.styles[styleSetName];\n                for (const style of styleSet) {\n                    if (!style.attr) {\n                        continue;\n                    }\n                    [\"map\", \"normalMap\", \"displacementMap\", \"roughnessMap\"].forEach(texturePropertyName => {\n                        const textureProperty = style.attr[texturePropertyName];\n                        if (textureProperty && typeof textureProperty === \"string\") {\n                            style.attr[texturePropertyName] = childUrlResolver.resolveUri(textureProperty);\n                        }\n                    });\n                }\n            }\n        }\n        return theme;\n    }\n    static checkTechniqueSupport(theme) {\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                for (const style of theme.styles[styleSetName]) {\n                    switch (style.technique) {\n                        // TODO: Re-enable this once \"dashed-line\" is deprecated.\n                        /* case \"dashed-line\":\n                            console.warn(\n                                `Using deprecated \"dashed-line\" technique.\n                                Use \"solid-line\" technique instead`\n                            ); */\n                        default:\n                            break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Expand all `ref` expressions in [[Theme]] basing on `definitions`.\n     *\n     * This method mutates original `theme` instance.\n     */\n    static resolveThemeReferences(theme, contextLogger) {\n        if (theme.definitions !== undefined) {\n            contextLogger.pushAttr(\"definitions\");\n            /**\n             * First, try to resolve all internal references in definitions, so if we may save few\n             * CPU cycles if some definition is used many times in actual style sets.\n             */\n            for (const definitionName in theme.definitions) {\n                if (!theme.definitions.hasOwnProperty(definitionName)) {\n                    continue;\n                }\n                const def = theme.definitions[definitionName];\n                if (Theme_1.isActualSelectorDefinition(def)) {\n                    contextLogger.pushAttr(definitionName);\n                    const resolvedDef = ThemeLoader.resolveStyle(def, theme.definitions, contextLogger);\n                    contextLogger.pop();\n                    if (resolvedDef === undefined) {\n                        contextLogger.pushAttr(definitionName);\n                        contextLogger.warn(\"skipping invalid style in definition\");\n                        contextLogger.pop();\n                        delete theme.definitions[definitionName];\n                    }\n                    else {\n                        theme.definitions[definitionName] = resolvedDef;\n                    }\n                }\n            }\n            contextLogger.pop();\n        }\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                contextLogger.pushAttr(\"styles\");\n                contextLogger.pushAttr(styleSetName);\n                theme.styles[styleSetName] = ThemeLoader.resolveStyleSet(theme.styles[styleSetName], theme.definitions, contextLogger);\n                contextLogger.pop();\n                contextLogger.pop();\n            }\n        }\n        return theme;\n    }\n    /**\n     * Expand all `ref` in [[StyleSet]] basing on `definitions`.\n     */\n    static resolveStyleSet(styleSet, definitions, contextLogger) {\n        const result = [];\n        for (let index = 0; index < styleSet.length; ++index) {\n            const currentStyle = styleSet[index];\n            contextLogger.pushIndex(index);\n            const resolvedStyle = ThemeLoader.resolveStyle(currentStyle, definitions, contextLogger);\n            if (resolvedStyle !== undefined) {\n                result.push(resolvedStyle);\n            }\n            else {\n                contextLogger.warn(\"invalid style, ignored\");\n            }\n            contextLogger.pop();\n        }\n        return result;\n    }\n    /**\n     * Expand all `ref` in [[Style]] instance basing on `definitions`.\n     */\n    static resolveStyle(style, definitions, contextLogger) {\n        if (Theme_1.isJsonExprReference(style)) {\n            // expand and instantiate references to style definitions.\n            const def = definitions && definitions[style[1]];\n            if (!def) {\n                contextLogger.warn(`invalid reference '${style[1]}' - not found`);\n                return undefined;\n            }\n            if (!Theme_1.isActualSelectorDefinition(def)) {\n                contextLogger.warn(`invalid reference '${style[1]}' - expected style definition`);\n                return undefined;\n            }\n            // instantiate the style\n            style = harp_utils_1.cloneDeep(def);\n        }\n        style = style;\n        if (Array.isArray(style.when)) {\n            contextLogger.pushAttr(\"when\");\n            const resolvedWhen = this.resolveExpressionReferences(style.when, definitions, contextLogger);\n            contextLogger.pop();\n            if (resolvedWhen === undefined) {\n                return undefined;\n            }\n            style.when = resolvedWhen;\n        }\n        if (style.attr !== undefined) {\n            const attr = style.attr;\n            contextLogger.pushAttr(\"attr\");\n            for (const prop in attr) {\n                if (!attr.hasOwnProperty(prop)) {\n                    continue;\n                }\n                const value = attr[prop];\n                if (!Array.isArray(value)) {\n                    continue; // nothing to do\n                }\n                contextLogger.pushAttr(prop);\n                const resolvedValue = this.resolveExpressionReferences(value, definitions, contextLogger);\n                contextLogger.pop();\n                if (resolvedValue !== undefined) {\n                    attr[prop] = resolvedValue;\n                }\n                else {\n                    delete attr[prop];\n                }\n            }\n            contextLogger.pop();\n        }\n        return style;\n    }\n    /**\n     * Resolve `[ref, ...]` in expressions.\n     *\n     * Returns `undefined` some reference was invalid (missing or wrong type).\n     */\n    static resolveExpressionReferences(value, definitions, contextLogger) {\n        let failed = false;\n        function resolveInternal(node) {\n            if (Theme_1.isJsonExprReference(node)) {\n                const defName = node[1];\n                const def = definitions && definitions[defName];\n                if (def === undefined) {\n                    contextLogger.warn(`invalid reference '${defName}' - not found`);\n                    failed = true;\n                    return undefined;\n                }\n                if (Theme_1.isLiteralDefinition(def) || harp_datasource_protocol_1.isJsonExpr(def)) {\n                    return def;\n                }\n                if (Theme_1.isBoxedDefinition(def)) {\n                    return def.value;\n                }\n                contextLogger.warn(`invalid reference '${defName}' - expected value definition`);\n                failed = true;\n                return undefined;\n            }\n            else if (Array.isArray(node)) {\n                const result = [...node];\n                for (let i = 1; i < result.length; ++i) {\n                    result[i] = resolveInternal(result[i]);\n                }\n                return result;\n            }\n            else {\n                return node;\n            }\n        }\n        const r = resolveInternal(value);\n        if (failed) {\n            return undefined;\n        }\n        return r;\n    }\n    /**\n     * Realize `extends` clause by merging `theme` with its base [[Theme]].\n     *\n     * @param theme [Theme] object\n     * @param options Optional, a [[ThemeLoadOptions]] objects containing any custom settings for\n     *    this load request.\n     */\n    static async resolveBaseThemes(theme, options) {\n        options = options || {};\n        if (theme.extends === undefined) {\n            return theme;\n        }\n        const maxInheritanceDepth = harp_utils_1.getOptionValue(options.maxInheritanceDepth, exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH);\n        if (maxInheritanceDepth <= 0) {\n            throw new Error(`maxInheritanceDepth reached when attempting to load base theme`);\n        }\n        const baseThemes = !Array.isArray(theme.extends) ? [theme.extends] : theme.extends;\n        delete theme.extends;\n        let baseThemesMerged = {};\n        for (const baseTheme of baseThemes) {\n            const actualBaseTheme = await ThemeLoader.load(baseTheme, Object.assign(Object.assign({}, options), { resolveDefinitions: false, maxInheritanceDepth: maxInheritanceDepth - 1 }));\n            baseThemesMerged = ThemeLoader.mergeThemes(actualBaseTheme, baseThemesMerged);\n        }\n        return ThemeLoader.mergeThemes(theme, baseThemesMerged);\n    }\n    static mergeThemes(theme, baseTheme) {\n        const definitions = Object.assign(Object.assign({}, baseTheme.definitions), theme.definitions);\n        const styles = Object.assign(Object.assign({}, baseTheme.styles), theme.styles);\n        return Object.assign(Object.assign(Object.assign({}, baseTheme), theme), { definitions, styles });\n    }\n}\nexports.ThemeLoader = ThemeLoader;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/ThemeLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Tile.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Tile.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Statistics_1 = __webpack_require__(/*! ./Statistics */ \"./node_modules/@here/harp-mapview/lib/Statistics.js\");\nconst TextElementGroup_1 = __webpack_require__(/*! ./text/TextElementGroup */ \"./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js\");\nconst TextElementGroupPriorityList_1 = __webpack_require__(/*! ./text/TextElementGroupPriorityList */ \"./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"Tile\");\n/**\n * Minimum estimated size of a JS object.\n */\nconst MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;\nconst MINIMUM_OBJECT_SIZE_ESTIMATION = 100;\n/**\n * Compute the memory footprint of `TileFeatureData`.\n */\nfunction getFeatureDataSize(featureData) {\n    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;\n    if (featureData.starts !== undefined) {\n        numBytes += featureData.starts.length * 8;\n    }\n    if (featureData.objInfos !== undefined) {\n        // 16 (estimated) bytes per objInfos\n        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;\n    }\n    return numBytes;\n}\nexports.getFeatureDataSize = getFeatureDataSize;\n/**\n * Compute the memory footprint of `RoadIntersectionData`.\n */\nfunction getRoadIntersectionDataSize(intersectionData) {\n    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;\n    // 8 bytes per techniqueIndex\n    // 8 bytes per start\n    // 8 bytes per width\n    // 8 bytes per position\n    // 100 (estimated) bytes per technique\n    const bytesPerEntry = 8 + 8 + 8 + 8 + MINIMUM_OBJECT_SIZE_ESTIMATION;\n    const numEntries = intersectionData.techniqueIndex.length;\n    numBytes += intersectionData.techniqueIndex.length * bytesPerEntry;\n    if (intersectionData.ids !== undefined) {\n        numBytes += numEntries * 8;\n    }\n    if (intersectionData.objInfos !== undefined) {\n        // 16 (estimated) bytes per objInfos\n        numBytes += numEntries * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;\n    }\n    return numBytes;\n}\n/**\n * Missing Typedoc\n */\nvar TileLoaderState;\n(function (TileLoaderState) {\n    TileLoaderState[TileLoaderState[\"Initialized\"] = 0] = \"Initialized\";\n    TileLoaderState[TileLoaderState[\"Loading\"] = 1] = \"Loading\";\n    TileLoaderState[TileLoaderState[\"Loaded\"] = 2] = \"Loaded\";\n    TileLoaderState[TileLoaderState[\"Decoding\"] = 3] = \"Decoding\";\n    TileLoaderState[TileLoaderState[\"Ready\"] = 4] = \"Ready\";\n    TileLoaderState[TileLoaderState[\"Canceled\"] = 5] = \"Canceled\";\n    TileLoaderState[TileLoaderState[\"Failed\"] = 6] = \"Failed\";\n})(TileLoaderState = exports.TileLoaderState || (exports.TileLoaderState = {}));\n/**\n * The class that holds the tiled data for a [[DataSource]].\n */\nclass Tile {\n    /**\n     * Creates a new [[Tile]].\n     *\n     * @param dataSource The [[DataSource]] that created this [[Tile]].\n     * @param tileKey The unique identifier for this [[Tile]]. Currently only up to level 24 is\n     * supported, because of the use of the upper bits for the offset.\n     * @param offset The optional offset, this is an integer which represents what multiple of 360\n     * degrees to shift, only useful for flat projections, hence optional.\n     * @param localTangentSpace Whether the tile geometry is in local tangent space or not.\n     */\n    constructor(dataSource, tileKey, offset = 0, localTangentSpace) {\n        this.dataSource = dataSource;\n        this.tileKey = tileKey;\n        this.offset = offset;\n        /**\n         * A list of the THREE.js objects stored in this `Tile`.\n         */\n        this.objects = [];\n        /**\n         * The optional list of HERE TileKeys of tiles with geometries that cross\n         * the boundaries of this `Tile`.\n         */\n        this.dependencies = new Array();\n        /**\n         * The bounding box of this `Tile` in world coordinates.\n         */\n        this.boundingBox = new harp_geoutils_1.OrientedBox3();\n        /**\n         * Maximum height of geometry on this tile above ground level.\n         */\n        this.maxGeometryHeight = 0;\n        /**\n         * Keeping some stats for the individual [[Tile]]s to analyze caching behavior.\n         *\n         * The frame the [[Tile]] was last requested. This is required to know when the given [[Tile]]\n         * can be removed from the cache.\n         */\n        this.frameNumLastRequested = -1;\n        /**\n         * The frame the `Tile` was first visible.\n         */\n        this.frameNumVisible = -1;\n        /**\n         * The last frame this `Tile` has been rendered (or was in the visible set). Used to determine\n         * visibility of `Tile` at the end of a frame, if the number is the current frame number, it is\n         * visible.\n         */\n        this.frameNumLastVisible = -1;\n        /**\n         * After removing from cache, this is the number of frames the `Tile` was visible.\n         */\n        this.numFramesVisible = 0;\n        /**\n         * Version stamp of the visibility set in the [[TileManager]]. If the counter is different, the\n         * visibility of the Tile's objects has to be calculated. Optimization to reduce overhead of\n         * computing visibility.\n         */\n        this.visibilityCounter = -1;\n        /**\n         * @hidden\n         *\n         * Used to tell if the Tile is used temporarily as a fallback tile.\n         *\n         * levelOffset is in in the range [-quadTreeSearchDistanceUp,\n         * quadTreeSearchDistanceDown], where these values come from the\n         * [[VisibleTileSetOptions]]\n         */\n        this.levelOffset = 0;\n        this.m_disposed = false;\n        this.m_localTangentSpace = false;\n        this.m_forceHasGeometry = undefined;\n        // TODO: Delay construction of text element groups until first text element is added.\n        // Used for [[TextElement]]s which the developer defines. Group created with maximum priority\n        // so that user text elements are placed before others.\n        this.m_userTextElements = new TextElementGroup_1.TextElementGroup(Number.MAX_SAFE_INTEGER);\n        // Used for [[TextElement]]s that are stored in the data, and that are placed explicitly,\n        // fading in and out.\n        this.m_textElementGroups = new TextElementGroupPriorityList_1.TextElementGroupPriorityList();\n        // Blocks other labels from showing.\n        this.m_pathBlockingElements = [];\n        // If `true`, the text content of the [[Tile]] changed.\n        this.m_textElementsChanged = false;\n        this.m_visibleArea = 0;\n        this.m_minElevation = 0;\n        this.m_maxElevation = 0;\n        // List of owned textures for disposal\n        this.m_ownedTextures = new WeakSet();\n        this.m_nextTextElementToOverlay = {\n            groupIndex: 0,\n            elementIndex: 0\n        };\n        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);\n        this.projection.projectBox(this.geoBox, this.boundingBox);\n        this.m_localTangentSpace = localTangentSpace !== undefined ? localTangentSpace : false;\n    }\n    /**\n     * The visibility status of the [[Tile]]. It is actually visible or planned to become visible.\n     */\n    get isVisible() {\n        // Tiles are not evaluated as invisible until the second frame they aren't requested.\n        // This happens in order to prevent that, during [[VisibleTileSet]] visibility evaluation,\n        // visible tiles that haven't yet been evaluated for the current frame are preemptively\n        // removed from [[DataSourceCache]].\n        return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;\n    }\n    set isVisible(visible) {\n        this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;\n    }\n    /**\n     * The [[Projection]] currently used by the [[MapView]].\n     */\n    get projection() {\n        return this.dataSource.projection;\n    }\n    /**\n     * The [[MapView]] this `Tile` belongs to.\n     */\n    get mapView() {\n        return this.dataSource.mapView;\n    }\n    /**\n     * Whether the data of this tile is in local tangent space or not.\n     * If the data is in local tangent space (i.e. up vector is (0,0,1) for high zoomlevels) then\n     * [[MapView]] will rotate the objects before rendering using the rotation matrix of the\n     * oriented [[boundingBox]].\n     */\n    get localTangentSpace() {\n        return this.m_localTangentSpace;\n    }\n    /*\n     * The size of this Tile in system memory.\n     */\n    get memoryUsage() {\n        if (this.m_resourceInfo === undefined) {\n            this.computeResourceInfo();\n        }\n        return this.m_resourceInfo.heapSize;\n    }\n    /**\n     * The center of this `Tile` in world coordinates.\n     */\n    get center() {\n        return this.boundingBox.position;\n    }\n    /**\n     * Compute [[TileResourceInfo]] of this `Tile`. May be using a cached value. The method\n     * `invalidateResourceInfo` can be called beforehand to force a recalculation.\n     *\n     * @returns `TileResourceInfo` for this `Tile`.\n     */\n    getResourceInfo() {\n        if (this.m_resourceInfo === undefined) {\n            this.computeResourceInfo();\n        }\n        return this.m_resourceInfo;\n    }\n    /**\n     * Force invalidation of the cached [[TileResourceInfo]]. Useful after the `Tile` has been\n     * modified.\n     */\n    invalidateResourceInfo() {\n        this.m_resourceInfo = undefined;\n    }\n    /**\n     * Add ownership of a texture to this tile. The texture will be disposed if the `Tile` is\n     * disposed.\n     * @param texture Texture to be owned by the `Tile`\n     */\n    addOwnedTexture(texture) {\n        this.m_ownedTextures.add(texture);\n    }\n    /**\n     * Gets the list of developer-defined [[TextElement]] in this `Tile`. This list is always\n     * rendered first.\n     */\n    get userTextElements() {\n        return this.m_userTextElements;\n    }\n    /**\n     * Adds a developer-defined [[TextElement]] to this `Tile`. The [[TextElement]] is always\n     * visible, if it's in the map's currently visible area.\n     *\n     * @param textElement The Text element to add.\n     */\n    addUserTextElement(textElement) {\n        this.m_userTextElements.elements.push(textElement);\n        this.textElementsChanged = true;\n    }\n    /**\n     * Removes a developer-defined [[TextElement]] from this `Tile`.\n     *\n     * @param textElement A developer-defined TextElement to remove.\n     * @returns `true` if the element has been removed successfully; `false` otherwise.\n     */\n    removeUserTextElement(textElement) {\n        const foundIndex = this.m_userTextElements.elements.indexOf(textElement);\n        if (foundIndex >= 0) {\n            this.m_userTextElements.elements.splice(foundIndex, 1);\n            this.textElementsChanged = true;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Adds a [[TextElement]] to this `Tile`, which is added to the visible set of\n     * [[TextElement]]s based on the capacity and visibility. The [[TextElement]]'s priority\n     * controls if or when it becomes visible.\n     *\n     * To ensure that a TextElement is visible, use a high value for its priority, such as\n     * `Number.MAX_SAFE_INTEGER`. Since the number of visible TextElements is limited by the\n     * screen space, not all TextElements are visible at all times.\n     *\n     * @param textElement The TextElement to add.\n     */\n    addTextElement(textElement) {\n        this.textElementGroups.add(textElement);\n        this.textElementsChanged = true;\n    }\n    /**\n     * Adds a [[PathBlockingElement]] to this `Tile`. This path has the highest priority and blocks\n     * all other labels. There maybe in future a use case to give it a priority, but as that isn't\n     * yet required, it is left to be implemented later if required.\n     * @param blockingElement Element which should block all other labels.\n     */\n    addBlockingElement(blockingElement) {\n        this.m_pathBlockingElements.push(blockingElement);\n    }\n    /**\n     * Removes a [[TextElement]] from this `Tile`. For the element to be removed successfully, the\n     * priority of the [[TextElement]] has to be equal to its priority when it was added.\n     *\n     * @param textElement The TextElement to remove.\n     * @returns `true` if the TextElement has been removed successfully; `false` otherwise.\n     */\n    removeTextElement(textElement) {\n        if (this.textElementGroups.remove(textElement)) {\n            this.textElementsChanged = true;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Gets the current [[GroupedPriorityList]] which contains a list of all [[TextElement]]s to be\n     * selected and placed for rendering.\n     */\n    get textElementGroups() {\n        return this.m_textElementGroups;\n    }\n    /**\n     * Gets the current modification state for the list of [[TextElement]]s in the `Tile`. If the\n     * value is `true` the TextElement is placed for rendering during the next frame.\n     */\n    get textElementsChanged() {\n        return this.m_textElementsChanged;\n    }\n    set textElementsChanged(changed) {\n        this.m_textElementsChanged = changed;\n    }\n    /**\n     * Returns true if the `Tile` has any text elements to render.\n     */\n    hasTextElements() {\n        return this.m_textElementGroups.count() > 0 || this.m_userTextElements.elements.length > 0;\n    }\n    /**\n     * Get the current blocking elements.\n     */\n    get blockingElements() {\n        return this.m_pathBlockingElements;\n    }\n    /**\n     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare its road\n     * geometry for picking.\n     */\n    prepareTileInfo() {\n        // If the tile is not ready for display, or if it has become invisible while being loaded,\n        // for example by moving the camera, the tile is not finished and its geometry is not\n        // created. This is an optimization for fast camera movements and zooms.\n        if (this.m_decodedTile === undefined || this.m_disposed || !this.isVisible) {\n            return;\n        }\n        if (this.m_decodedTile.tileInfo !== undefined) {\n            this.roadIntersectionData = this.dataSource.mapView.pickHandler.registerTile(this);\n        }\n    }\n    /**\n     * Called before [[MapView]] starts rendering this `Tile`.\n     *\n     * @param zoomLevel The current zoom level.\n     * @returns Returns `true` if this `Tile` should be rendered.\n     */\n    willRender(_zoomLevel) {\n        return true;\n    }\n    /**\n     * Called after [[MapView]] has rendered this `Tile`.\n     */\n    didRender() {\n        // to be overridden by subclasses\n    }\n    /**\n     * Estimated visible area of tile used for sorting the priorities during loading.\n     */\n    get visibleArea() {\n        return this.m_visibleArea;\n    }\n    set visibleArea(area) {\n        this.m_visibleArea = area;\n        if (this.tileLoader !== undefined) {\n            this.tileLoader.updatePriority(area);\n        }\n    }\n    /**\n     * Estimated tile's minimum elevation above the sea level.\n     * @note Negative values indicates depressions.\n     */\n    get minElevation() {\n        return this.m_minElevation;\n    }\n    set minElevation(elevation) {\n        this.m_minElevation = elevation;\n    }\n    /**\n     * Estimated maximum ground elevation above the sea level that may be found on tile.\n     * @note Negative values indicates depressions.\n     */\n    get maxElevation() {\n        return this.m_maxElevation;\n    }\n    set maxElevation(elevation) {\n        this.m_maxElevation = elevation;\n    }\n    /**\n     * Gets the decoded tile; it is removed after geometry handling.\n     */\n    get decodedTile() {\n        return this.m_decodedTile;\n    }\n    /**\n     * Applies the decoded tile to the tile.\n     * If the geometry is empty, then the tile's forceHasGeometry flag is set.\n     * Map is updated.\n     * @param decodedTile The decoded tile to set.\n     */\n    set decodedTile(decodedTile) {\n        this.m_decodedTile = decodedTile;\n        this.invalidateResourceInfo();\n        if (decodedTile === undefined) {\n            return;\n        }\n        if (decodedTile.geometries.length === 0) {\n            this.forceHasGeometry(true);\n        }\n        if (decodedTile.boundingBox !== undefined) {\n            // If the decoder provides a more accurate bounding box than the one we computed from\n            // the flat geo box we take it instead.\n            this.boundingBox.copy(decodedTile.boundingBox);\n        }\n        const stats = Statistics_1.PerformanceStatistics.instance;\n        if (stats.enabled && decodedTile.decodeTime !== undefined) {\n            stats.currentFrame.addValue(\"decode.decodingTime\", decodedTile.decodeTime);\n            stats.currentFrame.addValue(\"decode.decodedTiles\", 1);\n        }\n        if (decodedTile.copyrightHolderIds !== undefined) {\n            this.copyrightInfo = decodedTile.copyrightHolderIds.map(id => ({ id }));\n        }\n        this.dataSource.requestUpdate();\n    }\n    /**\n     * Remove the decodedTile when no longer needed.\n     */\n    removeDecodedTile() {\n        this.m_decodedTile = undefined;\n        this.invalidateResourceInfo();\n    }\n    /**\n     * Called by the [[TileLoader]] after the `Tile` has finished loading its map data. Can be used\n     * to add content to the `Tile`. The [[DecodedTile]] should still be available.\n     */\n    loadingFinished() {\n        // To be used in subclasses.\n    }\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free the geometry of a `Tile` object.\n     *\n     * @param object The object that references the geometry.\n     * @returns `true` if the geometry can be disposed.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    shouldDisposeObjectGeometry(object) {\n        return true;\n    }\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free a `Tile` object's material.\n     *\n     * @param object The object referencing the geometry.\n     * @returns `true` if the material can be disposed.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    shouldDisposeObjectMaterial(object) {\n        return true;\n    }\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free a Texture that is part of a `Tile` object's material.\n     *\n     * @param texture The texture about to be disposed.\n     * @returns `true` if the texture can be disposed.\n     */\n    shouldDisposeTexture(texture) {\n        return this.m_ownedTextures.has(texture);\n    }\n    /**\n     * Returns `true` if this `Tile` has been disposed.\n     */\n    get disposed() {\n        return this.m_disposed;\n    }\n    /**\n     * Gets the [[TileGeometryLoader]] that manages this tile.\n     */\n    get tileGeometryLoader() {\n        return this.m_tileGeometryLoader;\n    }\n    /**\n     * Sets the [[TileGeometryLoader]] to manage this tile.\n     *\n     * @param tileGeometryLoader A [[TileGeometryLoader]] instance to manage the geometry creation\n     *      for this tile.\n     */\n    set tileGeometryLoader(tileGeometryLoader) {\n        this.m_tileGeometryLoader = tileGeometryLoader;\n    }\n    /**\n     * `True` if the basic geometry has been loaded, and the `Tile` is ready  for display.\n     */\n    get basicGeometryLoaded() {\n        return this.m_tileGeometryLoader === undefined\n            ? this.hasGeometry\n            : this.m_tileGeometryLoader.basicGeometryLoaded || this.m_tileGeometryLoader.isFinished;\n    }\n    /**\n     * `True` if all geometry of the `Tile` has been loaded.\n     */\n    get allGeometryLoaded() {\n        return this.m_tileGeometryLoader === undefined\n            ? this.hasGeometry\n            : this.m_tileGeometryLoader.allGeometryLoaded || this.m_tileGeometryLoader.isFinished;\n    }\n    /**\n     * MapView checks if this `Tile` is ready to be rendered while culling.\n     *\n     * By default, MapView checks if the [[objects]] list is not empty. However, you can override\n     * this check by manually setting this property.\n     */\n    get hasGeometry() {\n        if (this.m_forceHasGeometry === undefined) {\n            return this.objects.length !== 0;\n        }\n        else {\n            return this.m_forceHasGeometry;\n        }\n    }\n    /**\n     * Overrides the default value for [[hasGeometry]] if value is not `undefined`.\n     *\n     * @param value A new value for the [[hasGeometry]] flag.\n     */\n    forceHasGeometry(value) {\n        this.m_forceHasGeometry = value;\n    }\n    /**\n     * Reset the visibility counter. This will force the visibility check to be rerun on all objects\n     * in this `Tile`.\n     */\n    resetVisibilityCounter() {\n        this.visibilityCounter = -1;\n    }\n    /**\n     * Gets the [[ITileLoader]] that manages this tile.\n     */\n    get tileLoader() {\n        return this.m_tileLoader;\n    }\n    /**\n     * Sets the [[ITileLoader]] to manage this tile.\n     *\n     * @param tileLoader A [[ITileLoader]] instance to manage the loading process for this tile.\n     */\n    set tileLoader(tileLoader) {\n        this.m_tileLoader = tileLoader;\n    }\n    /**\n     * Loads this `Tile` geometry.\n     */\n    load() {\n        const tileLoader = this.tileLoader;\n        if (tileLoader === undefined) {\n            return;\n        }\n        tileLoader\n            .loadAndDecode()\n            .then(tileLoaderState => {\n            harp_utils_1.assert(tileLoaderState === TileLoaderState.Ready);\n            const decodedTile = tileLoader.decodedTile;\n            this.decodedTile = decodedTile;\n        })\n            .catch(tileLoaderState => {\n            if (tileLoaderState !== TileLoaderState.Canceled &&\n                tileLoaderState !== TileLoaderState.Failed) {\n                logger.error(\"Unknown error\" + tileLoaderState);\n            }\n        });\n    }\n    /**\n     * Handler for animation of `Tile` geometries.\n     */\n    get animatedExtrusionTileHandler() {\n        return this.m_animatedExtrusionTileHandler;\n    }\n    set animatedExtrusionTileHandler(handler) {\n        this.m_animatedExtrusionTileHandler = handler;\n    }\n    get allTextElementsOverlaid() {\n        return (this.allGeometryLoaded &&\n            this.nextTextElementToOverlay.groupIndex >= this.m_textElementGroups.groups.size);\n    }\n    get nextTextElementToOverlay() {\n        return this.m_nextTextElementToOverlay;\n    }\n    set nextTextElementToOverlay(index) {\n        this.m_nextTextElementToOverlay = index;\n    }\n    /**\n     * Frees the rendering resources allocated by this `Tile`.\n     *\n     * The default implementation of this method frees the geometries and the materials for all the\n     * reachable objects.\n     * Textures are freed if they are owned by this `Tile` (i.e. if they where created by this\n     * `Tile`or if the ownership was explicitely set to this `Tile` by [[addOwnedTexture]]).\n     */\n    clear() {\n        const disposeMaterial = (material) => {\n            Object.getOwnPropertyNames(material).forEach((property) => {\n                const materialProperty = material[property];\n                if (materialProperty !== undefined && materialProperty instanceof THREE.Texture) {\n                    const texture = materialProperty;\n                    if (this.shouldDisposeTexture(texture)) {\n                        texture.dispose();\n                    }\n                }\n            });\n            material.dispose();\n        };\n        const disposeObject = (object) => {\n            if (object.geometry !== undefined && this.shouldDisposeObjectGeometry(object)) {\n                object.geometry.dispose();\n            }\n            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {\n                if (object.material instanceof Array) {\n                    object.material.forEach((material) => {\n                        if (material !== undefined) {\n                            disposeMaterial(material);\n                        }\n                    });\n                }\n                else {\n                    disposeMaterial(object.material);\n                }\n            }\n        };\n        this.objects.forEach((rootObject) => {\n            rootObject.traverse((object) => {\n                disposeObject(object);\n            });\n            disposeObject(rootObject);\n        });\n        this.objects.length = 0;\n        if (this.preparedTextPaths) {\n            this.preparedTextPaths = [];\n        }\n        if (this.m_animatedExtrusionTileHandler !== undefined) {\n            this.m_animatedExtrusionTileHandler.dispose();\n        }\n        this.clearTextElements();\n        this.invalidateResourceInfo();\n    }\n    /**\n     * Removes all [[TextElement]] from the tile.\n     */\n    clearTextElements() {\n        this.textElementsChanged = this.hasTextElements();\n        this.m_pathBlockingElements.splice(0);\n        this.textElementGroups.clear();\n        this.userTextElements.elements.length = 0;\n    }\n    /**\n     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.\n     */\n    dispose() {\n        if (this.m_disposed) {\n            return;\n        }\n        if (this.m_tileLoader) {\n            this.m_tileLoader.cancel();\n            this.m_tileLoader = undefined;\n        }\n        if (this.m_tileGeometryLoader !== undefined) {\n            this.m_tileGeometryLoader.dispose();\n            this.m_tileGeometryLoader = undefined;\n        }\n        this.clear();\n        this.userTextElements.elements.length = 0;\n        this.m_disposed = true;\n        // Ensure that tile is removable from tile cache.\n        this.frameNumLastRequested = 0;\n    }\n    /**\n     * Computes the offset in the x world coordinates corresponding to this tile, based on\n     * its [[offset]].\n     * @returns The x offset.\n     */\n    computeWorldOffsetX() {\n        return this.projection.worldExtent(0, 0).max.x * this.offset;\n    }\n    computeResourceInfo() {\n        let heapSize = 0;\n        let num3dObjects = 0;\n        let numTextElements = 0;\n        let numUserTextElements = 0;\n        const aggregatedObjSize = {\n            heapSize: 0,\n            gpuSize: 0\n        };\n        // Keep a map of the uuids of the larger objects, like Geometries, Materials and Attributes.\n        // They should be counted only once even if they are shared.\n        const visitedObjects = new Map();\n        for (const object of this.objects) {\n            if (object.visible) {\n                num3dObjects++;\n            }\n            Utils_1.MapViewUtils.estimateObject3dSize(object, aggregatedObjSize, visitedObjects);\n        }\n        for (const group of this.textElementGroups.groups) {\n            numTextElements += group[1].elements.length;\n        }\n        numUserTextElements = this.userTextElements.elements.length;\n        // 216 was the shallow size of a single TextElement last time it has been checked, 312 bytes\n        // was the minimum retained size of a TextElement that was not being rendered. If a\n        // TextElement is actually rendered, the size may be _much_ bigger.\n        heapSize += (numTextElements + numUserTextElements) * 312;\n        if (this.m_decodedTile !== undefined && this.m_decodedTile.tileInfo !== undefined) {\n            aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;\n        }\n        if (this.roadIntersectionData !== undefined) {\n            heapSize += getRoadIntersectionDataSize(this.roadIntersectionData);\n        }\n        this.m_resourceInfo = {\n            heapSize: aggregatedObjSize.heapSize + heapSize,\n            gpuSize: aggregatedObjSize.gpuSize,\n            num3dObjects,\n            numTextElements,\n            numUserTextElements\n        };\n    }\n}\nexports.Tile = Tile;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/Tile.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/Utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/Utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst EarthConstants_1 = __webpack_require__(/*! @here/harp-geoutils/lib/projection/EarthConstants */ \"./node_modules/@here/harp-geoutils/lib/projection/EarthConstants.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Tile_1 = __webpack_require__(/*! ./Tile */ \"./node_modules/@here/harp-mapview/lib/Tile.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"MapViewUtils\");\n// Estimation of the size of an Object3D with all the simple properties, like matrices and flags.\n// There may be cases where it is possible to construct Object3Ds with considerable less memory\n// consumption, but this value is used to simplify the estimation.\nconst MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1000;\nconst MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;\n// Caching those for performance reasons.\nconst groundNormalPlanarProj = new THREE.Vector3(0, 0, 1);\nconst groundPlane = new THREE.Plane(groundNormalPlanarProj.clone());\nconst groundSphere = new THREE.Sphere(undefined, EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);\nconst rayCaster = new THREE.Raycaster();\n/**\n * Cached ThreeJS instances for realtime maths.\n */\nconst space = {\n    x: new THREE.Vector3(),\n    y: new THREE.Vector3(),\n    z: new THREE.Vector3()\n};\nconst tangentSpace = {\n    x: new THREE.Vector3(),\n    y: new THREE.Vector3(),\n    z: new THREE.Vector3()\n};\nconst cache = {\n    quaternions: [new THREE.Quaternion(), new THREE.Quaternion()],\n    vector3: [new THREE.Vector3(), new THREE.Vector3()],\n    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],\n    transforms: [\n        {\n            xAxis: new THREE.Vector3(),\n            yAxis: new THREE.Vector3(),\n            zAxis: new THREE.Vector3(),\n            position: new THREE.Vector3()\n        }\n    ]\n};\nvar MapViewUtils;\n(function (MapViewUtils) {\n    MapViewUtils.MAX_TILT_DEG = 89;\n    /**\n     * Zooms and moves the map in such a way that the given target position remains at the same\n     * position after the zoom.\n     *\n     * @param mapView Instance of MapView.\n     * @param targetPositionOnScreenXinNDC Target x position in NDC space.\n     * @param targetPositionOnScreenYinNDC Target y position in NDC space.\n     * @param zoomLevel The desired zoom level.\n     * @param maxTiltAngle The maximum tilt angle to comply by, in globe projection, in radian.\n     */\n    function zoomOnTargetPosition(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel, maxTiltAngle = Math.PI / 2) {\n        // Get current target position in world space before we zoom.\n        const targetPosition = rayCastWorldCoordinates(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC);\n        const groundDistance = calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel);\n        // Set the cameras height according to the given zoom level.\n        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            mapView.camera.position.setZ(groundDistance);\n        }\n        else if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            mapView.camera.position.setLength(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS + groundDistance);\n        }\n        // In sphere, we may have to also orbit the camera around the position located at the\n        // center of the screen, in order to limit the tilt to `maxTiltAngle`, as we change\n        // this tilt by changing the camera's height above.\n        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            const centerScreenTarget = rayCastWorldCoordinates(mapView, 0, 0);\n            if (centerScreenTarget !== null) {\n                const tilt = extractSphericalCoordinatesFromLocation(mapView, mapView.camera, mapView.projection.unprojectPoint(centerScreenTarget)).tilt;\n                const deltaTilt = tilt - maxTiltAngle;\n                if (deltaTilt > 0) {\n                    orbitFocusPoint(mapView, 0, deltaTilt, maxTiltAngle);\n                }\n            }\n        }\n        // Get new target position after the zoom\n        const newTargetPosition = rayCastWorldCoordinates(mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC);\n        if (!targetPosition || !newTargetPosition) {\n            return;\n        }\n        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            // Calculate the difference and pan the map to maintain the map relative to the target\n            // position.\n            targetPosition.sub(newTargetPosition);\n            panCameraAboveFlatMap(mapView, targetPosition.x, targetPosition.y);\n        }\n        else if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            panCameraAroundGlobe(mapView, targetPosition, newTargetPosition);\n        }\n    }\n    MapViewUtils.zoomOnTargetPosition = zoomOnTargetPosition;\n    /**\n     * Orbits the camera around the focus point of the camera.\n     *\n     * @param mapView The [[MapView]] instance to manipulate.\n     * @param deltaAzimuthDeg Delta azimuth in degrees.\n     * @param deltaTiltDeg Delta tilt in degrees.\n     * @param maxTiltAngleRad The maximum tilt between the camera and its target in radian.\n     */\n    function orbitFocusPoint(mapView, deltaAzimuthDeg, deltaTiltDeg, maxTiltAngleRad = Math.PI / 2) {\n        const target = rayCastWorldCoordinates(mapView, 0, 0);\n        if (target === null) {\n            throw new Error(\"MapView does not support a view pointing in the void\");\n        }\n        const targetCoordinates = mapView.projection.unprojectPoint(target);\n        const sphericalCoordinates = extractSphericalCoordinatesFromLocation(mapView, mapView.camera, targetCoordinates);\n        const tiltDeg = Math.max(Math.min(THREE.Math.radToDeg(maxTiltAngleRad), deltaTiltDeg + THREE.Math.radToDeg(sphericalCoordinates.tilt)), 0);\n        mapView.lookAt(targetCoordinates, target.distanceTo(mapView.camera.position), tiltDeg, THREE.Math.radToDeg(sphericalCoordinates.azimuth + Math.PI) + deltaAzimuthDeg);\n    }\n    MapViewUtils.orbitFocusPoint = orbitFocusPoint;\n    /**\n     * Returns the [[GeoCoordinates]] of the camera, given its target coordinates on the map and its\n     * zoom, yaw and pitch.\n     *\n     * @param targetCoordinates Coordinates of the center of the view.\n     * @param distance Distance to the target in meters.\n     * @param yawDeg Camera yaw in degrees.\n     * @param pitchDeg Camera pitch in degrees.\n     * @param projection Active MapView, needed to get the camera fov and map projection.\n     * @param result Optional output vector.\n     * @returns Camera position in world space.\n     */\n    function getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, projection, result = new THREE.Vector3()) {\n        const pitchRad = THREE.Math.degToRad(pitchDeg);\n        const altitude = Math.cos(pitchRad) * distance;\n        const yawRad = THREE.Math.degToRad(yawDeg);\n        projection.projectPoint(targetCoordinates, result);\n        const groundDistance = distance * Math.sin(pitchRad);\n        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            result.x = result.x + Math.sin(yawRad) * groundDistance;\n            result.y = result.y - Math.cos(yawRad) * groundDistance;\n            result.z = result.z + altitude;\n        }\n        else if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            // In globe yaw and pitch are understood to be in tangent space. The approach below is\n            // to find the Z and Y tangent space axes, then rotate Y around Z by the given yaw, and\n            // set its new length (groundDistance). Finally the up vector's length is set to the\n            // camera height and added to the transformed Y above.\n            // Get the Z axis in tangent space: it is the normalized position vector of the target.\n            tangentSpace.z.copy(result).normalize();\n            // Get the Y axis (north axis in tangent space):\n            tangentSpace.y\n                .set(0, 0, 1)\n                .projectOnPlane(tangentSpace.z)\n                .normalize();\n            // Rotate this north axis by the given yaw, giving the camera direction relative to\n            // the target.\n            cache.quaternions[0].setFromAxisAngle(tangentSpace.z, yawRad - Math.PI);\n            tangentSpace.y.applyQuaternion(cache.quaternions[0]);\n            // Push the camera to the specified distance.\n            tangentSpace.y.setLength(groundDistance);\n            // Now get the actual camera position vector: from the target position, add the\n            // previous computation to get the projection of the camera on the ground, then add\n            // the height of the camera in the tangent space.\n            const height = distance * Math.cos(pitchRad);\n            result.add(tangentSpace.y).add(tangentSpace.z.setLength(height));\n            const a = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS + altitude;\n            const b = Math.sin(pitchRad) * distance;\n            const cameraHeight = Math.sqrt(a * a + b * b);\n            result.setLength(cameraHeight);\n        }\n        return result;\n    }\n    MapViewUtils.getCameraPositionFromTargetCoordinates = getCameraPositionFromTargetCoordinates;\n    /**\n     * @deprecated use getCameraPositionFromTargetCoordinates instead\n     */\n    function getCameraCoordinatesFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView) {\n        return mapView.projection.unprojectPoint(getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView.projection, cache.vector3[1]));\n    }\n    MapViewUtils.getCameraCoordinatesFromTargetCoordinates = getCameraCoordinatesFromTargetCoordinates;\n    /**\n     * Casts a ray in NDC space from the current map view and returns the intersection point of that\n     * ray wih the map in world space.\n     *\n     * @param mapView Instance of MapView.\n     * @param pointOnScreenXinNDC X coordinate in NDC space.\n     * @param pointOnScreenYinNDC Y coordinate in NDC space.\n     * @param elevation Optional param used to offset the ground plane. Used when wanting to pan\n     * based on a plane at some altitude. Necessary for example when panning with terrain.\n     *\n     * @returns Intersection coordinates, or `null` if raycast failed.\n     */\n    function rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC, elevation) {\n        const pointInNDCPosition = new THREE.Vector3(pointOnScreenXinNDC, pointOnScreenYinNDC, 0);\n        cache.vector3[1].copy(mapView.camera.position);\n        cache.matrix4[0].extractRotation(mapView.camera.matrixWorld);\n        // Prepare the unprojection matrix which projects from NDC space to camera space\n        // and takes the current rotation of the camera into account.\n        cache.matrix4[1].multiplyMatrices(cache.matrix4[0], cache.matrix4[1].getInverse(mapView.camera.projectionMatrix));\n        // Unproject the point via the unprojection matrix.\n        const pointInCameraSpace = pointInNDCPosition.applyMatrix4(cache.matrix4[1]);\n        // Use the point in camera space as the vector towards this point.\n        rayCaster.set(cache.vector3[1], pointInCameraSpace.normalize());\n        if (elevation !== undefined) {\n            groundPlane.constant = -elevation;\n        }\n        const worldPosition = new THREE.Vector3();\n        const result = mapView.projection.type === harp_geoutils_1.ProjectionType.Planar\n            ? rayCaster.ray.intersectPlane(groundPlane, worldPosition)\n            : rayCaster.ray.intersectSphere(groundSphere, worldPosition);\n        groundPlane.constant = 0;\n        return result;\n    }\n    MapViewUtils.rayCastWorldCoordinates = rayCastWorldCoordinates;\n    /**\n     * Pans the camera according to the projection.\n     *\n     * @param mapView Instance of MapView.\n     * @param xOffset In world space. Value > 0 will pan the map to the right, value < 0 will pan\n     * the map to the left in default camera orientation.\n     * @param yOffset In world space. Value > 0 will pan the map upwards, value < 0 will pan the map\n     * downwards in default camera orientation.\n     */\n    function panCameraAboveFlatMap(mapView, offsetX, offsetY) {\n        mapView.camera.position.x += offsetX;\n        mapView.camera.position.y += offsetY;\n    }\n    MapViewUtils.panCameraAboveFlatMap = panCameraAboveFlatMap;\n    /**\n     * The function doing a pan in the spherical space when [[MapView]]'s active [[ProjectionType]]\n     * is spherical. In other words, the function that rotates the camera around the globe.\n     *\n     * @param mapView MapView instance.\n     * @param fromWorld Start vector representing the scene position of a geolocation.\n     * @param toWorld End vector representing the scene position of a geolocation.\n     */\n    function panCameraAroundGlobe(mapView, fromWorld, toWorld) {\n        cache.quaternions[0]\n            .setFromUnitVectors(fromWorld.normalize(), toWorld.normalize())\n            .inverse();\n        cache.matrix4[0].makeRotationFromQuaternion(cache.quaternions[0]);\n        mapView.camera.applyMatrix(cache.matrix4[0]);\n        mapView.camera.updateMatrixWorld();\n    }\n    MapViewUtils.panCameraAroundGlobe = panCameraAroundGlobe;\n    /**\n     * Rotates the camera by the given delta yaw and delta pitch. The pitch will be clamped to the\n     * maximum possible tilt to the new target, and under the horizon in sphere projection.\n     *\n     * @param mapView The [[MapView]] instance in use.\n     * @param deltaYawDeg Delta yaw in degrees.\n     * @param deltaPitchDeg Delta pitch in degrees.\n     * @param maxTiltAngleRad Max tilt angle in radians.\n     */\n    function rotate(mapView, deltaYawDeg, deltaPitchDeg = 0, maxTiltAngleRad = Math.PI / 4) {\n        // 1. Apply yaw: rotate around the vertical axis.\n        mapView.camera.rotateOnWorldAxis(mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical\n            ? cache.vector3[0].copy(mapView.camera.position).normalize()\n            : cache.vector3[0].set(0, 0, 1), harp_geoutils_1.MathUtils.degToRad(-deltaYawDeg));\n        mapView.camera.updateMatrixWorld();\n        // 2. Apply pitch: rotate around the camera's local X axis.\n        if (deltaPitchDeg === 0) {\n            return;\n        }\n        const pitch = MapViewUtils.extractAttitude(mapView, mapView.camera).pitch;\n        // `maxTiltAngle` is equivalent to a `maxPitchAngle` in flat projections.\n        let newPitch = THREE.Math.clamp(pitch + THREE.Math.degToRad(deltaPitchDeg), 0, maxTiltAngleRad);\n        // In sphere projection, the value of a maximum pitch is smaller than the value of the\n        // maximum tilt, as the curvature of the surface adds up to it.\n        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            // Deduce max pitch from max tilt. To this end the sine law of triangles is used below.\n            const maxPitch = Math.asin((EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS * Math.sin(Math.PI - maxTiltAngleRad)) /\n                mapView.camera.position.length());\n            newPitch = Math.min(newPitch, maxPitch);\n        }\n        mapView.camera.rotateX(newPitch - pitch);\n    }\n    MapViewUtils.rotate = rotate;\n    /**\n     * Computes the rotation of the camera according to yaw and pitch in degrees. The computations\n     * hinge on the current `projection` and `target`, because yaw and pitch are defined in\n     * tangent space of the target point.\n     *\n     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the\n     * map.\n     *\n     * @param projection Current projection.\n     * @param target The camera target.\n     * @param yawDeg Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.\n     * @param pitchDeg Pitch in degrees.\n     */\n    function getCameraRotationAtTarget(projection, target, yawDeg, pitchDeg, result = new THREE.Quaternion()) {\n        const transform = cache.transforms[0];\n        projection.localTangentSpace(target, transform);\n        cache.matrix4[0].makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);\n        result.setFromRotationMatrix(cache.matrix4[0]);\n        cache.quaternions[0].setFromAxisAngle(cache.vector3[1].set(0, 0, 1), THREE.Math.degToRad(yawDeg));\n        cache.quaternions[1].setFromAxisAngle(cache.vector3[1].set(1, 0, 0), THREE.Math.degToRad(pitchDeg));\n        result.multiply(cache.quaternions[0]);\n        result.multiply(cache.quaternions[1]);\n        return result;\n    }\n    MapViewUtils.getCameraRotationAtTarget = getCameraRotationAtTarget;\n    /**\n     * Sets the rotation of the camera according to yaw and pitch in degrees. The computations hinge\n     * on the current projection and `geoCenter`, because yaw and pitch are defined in tangent\n     * space. In particular, `MapView#geoCenter` needs to be set before calling `setRotation`.\n     *\n     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the\n     * map.\n     *\n     * @param mapView Instance of MapView.\n     * @param yawDeg Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.\n     * @param pitchDeg Pitch in degrees.\n     */\n    function setRotation(mapView, yawDeg, pitchDeg) {\n        getCameraRotationAtTarget(mapView.projection, mapView.geoCenter, yawDeg, pitchDeg, mapView.camera.quaternion);\n    }\n    MapViewUtils.setRotation = setRotation;\n    /**\n     * Extracts yaw, pitch, and roll rotation in radians.\n     * - Yaw : Rotation around the vertical axis, counter-clockwise (as opposed to azimuth),\n     * starting north.\n     * - Pitch :Rotation around the horizontal axis.\n     * - Roll : Rotation around the view axis.\n     *\n     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles\n     *\n     * @param options Subset of necessary [[MapView]] properties.\n     * @param object The [[THREE.Object3D]] instance to extract the rotations from.\n     */\n    function extractAttitude(options, object) {\n        // 1. Build the matrix of the tangent space of the object.\n        cache.vector3[1].setFromMatrixPosition(object.matrixWorld); // Ensure using world position.\n        options.projection.localTangentSpace(options.projection.unprojectPoint(cache.vector3[1]), {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n        cache.matrix4[1].makeBasis(tangentSpace.x, tangentSpace.y, tangentSpace.z);\n        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.\n        cache.matrix4[0].getInverse(cache.matrix4[1]).multiply(object.matrixWorld);\n        space.x.setFromMatrixColumn(cache.matrix4[0], 0);\n        space.y.setFromMatrixColumn(cache.matrix4[0], 1);\n        space.z.setFromMatrixColumn(cache.matrix4[0], 2);\n        // 3. Deduce orientation from the base axes.\n        let yaw = 0;\n        let pitch = 0;\n        let roll = 0;\n        const EPS = 1e-5;\n        // Decompose rotation matrix into Z0 X Z1 Euler angles.\n        const d = space.z.dot(cache.vector3[1].set(0, 0, 1));\n        if (d < 1.0 - EPS) {\n            if (d > -1.0 + EPS) {\n                yaw = Math.atan2(space.z.x, -space.z.y);\n                pitch = Math.acos(space.z.z);\n                roll = Math.atan2(space.x.z, space.y.z);\n            }\n            else {\n                // Looking bottom-up with space.z.z == -1.0\n                yaw = -Math.atan2(-space.y.x, space.x.x);\n                pitch = 180;\n                roll = 0;\n            }\n        }\n        else {\n            // Looking top-down with space.z.z == 1.0\n            yaw = Math.atan2(-space.y.x, space.x.x);\n            pitch = 0.0;\n            roll = 0.0;\n        }\n        return {\n            yaw,\n            pitch,\n            roll\n        };\n    }\n    MapViewUtils.extractAttitude = extractAttitude;\n    /**\n     * Gets the spherical coordinates in radian of the object to the coordinates of `point`.\n     *\n     * Note: this method can be used to get the direction that an object points to, when `location`\n     * is the target of that object, by adding PI to it. Otherwise it only returns the spherical\n     * coordinates of `object` in the tangent space of `location`.\n     *\n     * @param mapView The [[MapView]] instance to consider.\n     * @param object The object to get the coordinates from.\n     * @param location The reference point.\n     */\n    function extractSphericalCoordinatesFromLocation(mapView, object, location) {\n        mapView.projection.localTangentSpace(location, {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n        let tilt = 0;\n        let azimuth = 0;\n        // Get point to object vector in `cache.vector3[1]` and deduce `tilt` from the angle with\n        // tangent Z.\n        cache.vector3[1]\n            .copy(object.position)\n            .sub(cache.vector3[0])\n            .normalize();\n        if (cache.vector3[1].dot(tangentSpace.z) > 1 - 1e-5) {\n            // Top down view: the azimuth of the object would be opposite the yaw, and clockwise.\n            azimuth = Math.PI - extractAttitude(mapView, object).yaw;\n            // Wrap between -PI and PI.\n            azimuth = Math.atan2(Math.sin(azimuth), Math.cos(azimuth));\n            tilt = 0;\n            return { tilt, azimuth };\n        }\n        tilt = cache.vector3[1].angleTo(tangentSpace.z);\n        // Tilted view: the azimuth is the direction of the object from the origin.\n        cache.vector3[1]\n            .copy(object.position)\n            .sub(cache.vector3[0])\n            .projectOnPlane(tangentSpace.z)\n            .normalize();\n        azimuth = cache.vector3[1].angleTo(tangentSpace.y);\n        if (cache.vector3[1].cross(tangentSpace.y).dot(tangentSpace.z) < 0) {\n            azimuth = -azimuth;\n        }\n        return { tilt, azimuth };\n    }\n    MapViewUtils.extractSphericalCoordinatesFromLocation = extractSphericalCoordinatesFromLocation;\n    /**\n     * Get perspective camera frustum planes distances.\n     * @return all plane distances in helper object.\n     */\n    function getCameraFrustumPlanes(camera) {\n        const near = camera.near;\n        const far = camera.far;\n        let top = (near * Math.tan(THREE.Math.degToRad(0.5 * camera.fov))) / camera.zoom;\n        let height = 2 * top;\n        let width = camera.aspect * height;\n        let left = -0.5 * width;\n        const view = camera.view;\n        if (view !== null && view.enabled) {\n            const fullWidth = view.fullWidth;\n            const fullHeight = view.fullHeight;\n            left += (view.offsetX * width) / fullWidth;\n            top -= (view.offsetY * height) / fullHeight;\n            width *= view.width / fullWidth;\n            height *= view.height / fullHeight;\n        }\n        // Correct by skew factor\n        left += camera.filmOffset !== 0 ? (near * camera.filmOffset) / camera.getFilmWidth() : 0;\n        return {\n            left,\n            right: left + width,\n            top,\n            bottom: top - height,\n            near,\n            far\n        };\n    }\n    MapViewUtils.getCameraFrustumPlanes = getCameraFrustumPlanes;\n    /**\n     * Casts a ray in NDC space from the current view of the camera and returns the intersection\n     * point of that ray against the map in geo coordinates. The return value can be `null` when\n     * the raycast is above the horizon.\n     *\n     * @param mapView Instance of MapView.\n     * @param pointOnScreenXNDC  Abscissa in NDC space.\n     * @param pointOnScreenYNDC  Ordinate in NDC space.\n     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.\n     */\n    function rayCastGeoCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC) {\n        const worldCoordinates = rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC);\n        if (!worldCoordinates) {\n            return null;\n        }\n        return mapView.projection.unprojectPoint(worldCoordinates);\n    }\n    MapViewUtils.rayCastGeoCoordinates = rayCastGeoCoordinates;\n    /**\n     * Calculates and returns the distance from the ground, which is needed to put the camera to\n     * this height, to see the size of the area that would be covered by one tile for the given zoom\n     * level.\n     *\n     * @param mapView Instance of MapView.\n     * @param options Subset of necessary [[MapView]] properties.\n     */\n    function calculateDistanceToGroundFromZoomLevel(options, zoomLevel) {\n        const cameraPitch = extractAttitude(options, options.camera).pitch;\n        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);\n        return ((options.focalLength * tileSize) / 256) * Math.cos(cameraPitch);\n    }\n    MapViewUtils.calculateDistanceToGroundFromZoomLevel = calculateDistanceToGroundFromZoomLevel;\n    /**\n     * Calculates and returns the distance to the target point.\n     *\n     * @param options Necessary subset of MapView properties to compute the distance.\n     * @param zoomLevel The zoom level to get the equivalent height to.\n     */\n    function calculateDistanceFromZoomLevel(options, zoomLevel) {\n        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);\n        return (options.focalLength * tileSize) / 256;\n    }\n    MapViewUtils.calculateDistanceFromZoomLevel = calculateDistanceFromZoomLevel;\n    /**\n     * Calculates the zoom level, which corresponds to the current distance from\n     * camera to lookAt point.\n     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in\n     * between zoom levels. By setting the zoom level, you change the height position of the camera\n     * in away that the field of view of the camera should be able to cover one tile for the given\n     * zoom level.\n     *\n     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you\n     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of\n     * you.\n     *\n     * @param options Subset of necessary [[MapView]] properties.\n     * @param distance The distance in meters, which are scene units in [[MapView]].\n     */\n    function calculateZoomLevelFromDistance(options, distance) {\n        const tileSize = (256 * distance) / options.focalLength;\n        const zoomLevel = THREE.Math.clamp(Math.log2(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize), options.minZoomLevel, options.maxZoomLevel);\n        // Round to avoid modify the zoom level without distance change, with the imprecision\n        // introduced by raycasting.\n        return Math.round(zoomLevel * 10e15) / 10e15;\n    }\n    MapViewUtils.calculateZoomLevelFromDistance = calculateZoomLevelFromDistance;\n    /**\n     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.\n     * This is useful as the depth values are not stored in the depth buffer linearly, and this can\n     * lead into confusing behavior when not taken into account.\n     *\n     * @param clipDistance Distance from the camera in clip space (range: [0, 1]).\n     * @param camera Camera applying the perspective projection.\n     */\n    function calculateDepthFromClipDistance(clipDistance, camera) {\n        const perspCam = camera;\n        const cameraRange = perspCam.far - perspCam.near;\n        const viewSpaceDistance = clipDistance * perspCam.far;\n        return (1.0 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);\n    }\n    MapViewUtils.calculateDepthFromClipDistance = calculateDepthFromClipDistance;\n    /**\n     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into\n     * [0..cameraFar].\n     *\n     * @param distance Distance from the camera (range: [0, 1]).\n     * @param camera Camera applying the perspective projection.\n     */\n    function cameraToWorldDistance(distance, camera) {\n        const perspCam = camera;\n        return distance * perspCam.far;\n    }\n    MapViewUtils.cameraToWorldDistance = cameraToWorldDistance;\n    /**\n     * Calculates vertical field of view for given horizontal field of vision and aspect ratio.\n     *\n     * @param hFov Horizontal field of view in rad.\n     * @param aspect Aspect ratio.\n     */\n    function calculateVerticalFovByHorizontalFov(hFov, aspect) {\n        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);\n    }\n    MapViewUtils.calculateVerticalFovByHorizontalFov = calculateVerticalFovByHorizontalFov;\n    /**\n     * Calculates horizontal field of view for given vertical field of vision and aspect ratio.\n     *\n     * @param hFov Vertical field of view in rad.\n     * @param aspect Aspect ratio.\n     */\n    function calculateHorizontalFovByVerticalFov(vFov, aspect) {\n        return 2 * Math.atan(Math.tan(vFov / 2) * aspect);\n    }\n    MapViewUtils.calculateHorizontalFovByVerticalFov = calculateHorizontalFovByVerticalFov;\n    /**\n     * Calculates the focal length based on the vertical FOV and height.\n     *\n     * @param vFov Vertical field of view in rad.\n     * @param height Height of canvas in pixels.\n     */\n    function calculateFocalLengthByVerticalFov(vFov, height) {\n        return height / 2 / Math.tan(vFov / 2);\n    }\n    MapViewUtils.calculateFocalLengthByVerticalFov = calculateFocalLengthByVerticalFov;\n    /**\n     * Calculates the vertical field of view based on the focal length and the height.\n     *\n     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param height Height of canvas in pixels.\n     */\n    function calculateFovByFocalLength(focalLength, height) {\n        return THREE.Math.radToDeg(2 * Math.atan(height / 2 / focalLength));\n    }\n    MapViewUtils.calculateFovByFocalLength = calculateFovByFocalLength;\n    /**\n     * Calculates object's screen size based on the focal length and it's camera distance.\n     *\n     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param distance Object distance in world space.\n     * @param worldSize Object size in world space.\n     * @return object size in screen space.\n     */\n    function calculateScreenSizeByFocalLength(focalLength, distance, worldSize) {\n        return (focalLength * worldSize) / distance;\n    }\n    MapViewUtils.calculateScreenSizeByFocalLength = calculateScreenSizeByFocalLength;\n    /**\n     * Calculates object's world size based on the focal length and it's camera distance.\n     *\n     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param distance Object distance in world space.\n     * @param screenSize Object size in screen space.\n     * @return object size in world space.\n     */\n    function calculateWorldSizeByFocalLength(focalLength, distance, screenSize) {\n        return (distance * screenSize) / focalLength;\n    }\n    MapViewUtils.calculateWorldSizeByFocalLength = calculateWorldSizeByFocalLength;\n    /**\n     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials\n     * and/or attributes will be counted multiple times.\n     *\n     * @param object The mesh object to evaluate\n     * @param size The [[MemoryUsage]] to update.\n     * @param visitedObjects Optional map to store large objects that could be shared.\n     *\n     * @returns Estimate of object size in bytes for heap and GPU.\n     */\n    function estimateObject3dSize(object, parentSize, visitedObjects) {\n        const size = parentSize !== undefined\n            ? parentSize\n            : {\n                heapSize: 0,\n                gpuSize: 0\n            };\n        if (visitedObjects === undefined) {\n            visitedObjects = new Map();\n        }\n        estimateMeshSize(object, size, visitedObjects);\n        if (object.children.length > 0) {\n            for (const child of object.children) {\n                estimateObject3dSize(child, size, visitedObjects);\n            }\n        }\n        return size;\n    }\n    MapViewUtils.estimateObject3dSize = estimateObject3dSize;\n    /**\n     * Check if tiles or other content is currently being loaded.\n     *\n     * This method can be removed once HARP-7932 is implemented.\n     *\n     * @returns `true` if MapView has visible tiles or other content that is being loaded.\n     */\n    function mapViewIsLoading(mapView) {\n        let numTilesLoading = 0;\n        for (const tileList of mapView.visibleTileSet.dataSourceTileList) {\n            numTilesLoading += tileList.numTilesLoading;\n            for (const tile of tileList.visibleTiles) {\n                if (tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {\n                    numTilesLoading++;\n                }\n                if (tile.tileGeometryLoader !== undefined && !tile.tileGeometryLoader.isFinished) {\n                    numTilesLoading++;\n                }\n            }\n        }\n        let isLoading = numTilesLoading > 0;\n        if (mapView.textElementsRenderer !== undefined) {\n            isLoading = isLoading || mapView.textElementsRenderer.loading;\n        }\n        isLoading =\n            isLoading ||\n                !mapView.poiTableManager.finishedLoading ||\n                !mapView.visibleTileSet.allVisibleTilesLoaded;\n        return isLoading;\n    }\n    MapViewUtils.mapViewIsLoading = mapViewIsLoading;\n    function estimateTextureSize(texture, objectSize, visitedObjects) {\n        if (texture === null || texture === undefined || texture.image === undefined) {\n            return;\n        }\n        if (texture.uuid !== undefined && visitedObjects.get(texture.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(texture.uuid, true);\n        // May be HTMLImage or ImageData\n        const image = texture.image;\n        // Assuming RGBA\n        const imageBytes = 4 * image.width * image.height;\n        objectSize.heapSize += imageBytes;\n        objectSize.gpuSize += imageBytes;\n    }\n    function estimateMaterialSize(material, objectSize, visitedObjects) {\n        if (material.uuid !== undefined && visitedObjects.get(material.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(material.uuid, true);\n        if (material instanceof THREE.RawShaderMaterial ||\n            material instanceof THREE.ShaderMaterial) {\n            const rawMaterial = material;\n            for (const name in rawMaterial.uniforms) {\n                if (rawMaterial.uniforms[name] !== undefined) {\n                    const uniform = rawMaterial.uniforms[name];\n                    if (uniform instanceof THREE.Texture) {\n                        estimateTextureSize(uniform, objectSize, visitedObjects);\n                    }\n                }\n            }\n        }\n        else if (material instanceof THREE.MeshBasicMaterial ||\n            material instanceof harp_materials_1.MapMeshBasicMaterial) {\n            const meshMaterial = material;\n            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);\n        }\n        else if (material instanceof harp_materials_1.MapMeshStandardMaterial) {\n            const standardMaterial = material;\n            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);\n        }\n        else if (material instanceof THREE.LineBasicMaterial ||\n            material instanceof THREE.LineDashedMaterial) {\n            // Nothing to be done here\n        }\n        else {\n            logger.warn(\"estimateMeshSize: unidentified material: \", material);\n        }\n    }\n    function estimateAttributeSize(attribute, attrName, objectSize, visitedObjects) {\n        // Attributes (apparently) do not have their uuid set up.\n        if (attribute.uuid === undefined) {\n            attribute.uuid = THREE.Math.generateUUID();\n        }\n        if (visitedObjects.get(attribute.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(attribute.uuid, true);\n        let attrBytes = 0;\n        let bytesPerElement = 4;\n        if (attribute.array.BYTES_PER_ELEMENT !== undefined) {\n            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;\n        }\n        if (attribute instanceof THREE.InterleavedBufferAttribute ||\n            attribute instanceof THREE.BufferAttribute) {\n            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;\n        }\n        else {\n            logger.warn(\"estimateMeshSize: unidentified attribute: \", attrName);\n        }\n        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;\n        objectSize.gpuSize += attrBytes;\n    }\n    function estimateGeometrySize(geometry, objectSize, visitedObjects) {\n        const isNewObject = geometry.uuid === undefined || visitedObjects.get(geometry.uuid) !== true;\n        if (!isNewObject) {\n            return;\n        }\n        visitedObjects.set(geometry.uuid, true);\n        let bufferGeometry;\n        if (geometry instanceof THREE.Geometry) {\n            // Each vertex is represented as 3 floats vector (24 bytes).\n            objectSize.heapSize += geometry.vertices.length * 24;\n            // Face: 3 indices (24 byte), 1 normal (3 floats = 24). Vertex normals and\n            // colors are not counted here.\n            objectSize.heapSize += geometry.faces.length * (24 + 24);\n            // Additionally, the internal _bufferGeometry is also counted:\n            bufferGeometry = geometry._bufferGeometry;\n        }\n        else if (geometry instanceof THREE.BufferGeometry) {\n            bufferGeometry = geometry;\n        }\n        if (bufferGeometry === undefined) {\n            // Nothing more to calculate.\n            return;\n        }\n        const attributes = bufferGeometry.attributes;\n        if (attributes === undefined) {\n            logger.warn(\"estimateGeometrySize: unidentified geometry: \", geometry);\n            return;\n        }\n        for (const property in attributes) {\n            if (attributes[property] !== undefined) {\n                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);\n            }\n        }\n        if (bufferGeometry.index !== null) {\n            estimateAttributeSize(bufferGeometry.index, \"index\", objectSize, visitedObjects);\n        }\n    }\n    function estimateMeshSize(object, objectSize, visitedObjects) {\n        if (!object.isObject3D || object instanceof THREE.Scene) {\n            return;\n        }\n        if (object.uuid !== undefined && visitedObjects.get(object.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(object.uuid, true);\n        if (object.isMesh || object.isLine || object.isPoints) {\n            // Estimated minimum impact on heap.\n            let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;\n            const gpuSize = 0;\n            // Cast to Points class which contains the minimal required properties sub-set.\n            const mesh = object;\n            // Calculate material(s) impact.\n            if (mesh.material !== undefined) {\n                if (Array.isArray(mesh.material)) {\n                    const materials = mesh.material;\n                    for (const material of materials) {\n                        estimateMaterialSize(material, objectSize, visitedObjects);\n                    }\n                }\n                else {\n                    const material = mesh.material;\n                    estimateMaterialSize(material, objectSize, visitedObjects);\n                }\n            }\n            // Calculate cost of geometry.\n            if (mesh.geometry !== undefined) {\n                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);\n            }\n            // Add info that is required for picking (parts of) objects and match them to\n            // the featureID in the map data.\n            const featureData = object.userData !== undefined\n                ? object.userData.feature\n                : undefined;\n            if (featureData !== undefined) {\n                heapSize += Tile_1.getFeatureDataSize(featureData);\n            }\n            objectSize.heapSize += heapSize;\n            objectSize.gpuSize += gpuSize;\n        }\n        else {\n            logger.warn(\"estimateMeshSize: unidentified object\", object);\n        }\n    }\n    /**\n     * Gets language list used by the browser\n     *\n     * @returns Array of iso language codes\n     */\n    function getBrowserLanguages() {\n        if (navigator.languages !== undefined && navigator.languages.length > 0) {\n            const languageList = [];\n            for (const lang of navigator.languages) {\n                languageList.push(getIsoLanguageCode(lang));\n            }\n            return languageList;\n        }\n        if (navigator.language !== undefined) {\n            return [getIsoLanguageCode(navigator.language)];\n        }\n        return undefined;\n    }\n    MapViewUtils.getBrowserLanguages = getBrowserLanguages;\n    /**\n     * Gets ISO-639-1 language code from browser's code (ex. en for en-US)\n     */\n    function getIsoLanguageCode(language) {\n        return language.substring(0, 2);\n    }\n})(MapViewUtils = exports.MapViewUtils || (exports.MapViewUtils = {}));\n/** @hidden */\nconst powerOfTwo = [\n    0x1,\n    0x2,\n    0x4,\n    0x8,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x100,\n    0x200,\n    0x400,\n    0x800,\n    0x1000,\n    0x2000,\n    0x4000,\n    0x8000,\n    0x10000,\n    0x20000,\n    0x40000,\n    0x80000,\n    0x100000,\n    0x200000,\n    0x400000,\n    0x800000,\n    0x1000000,\n    0x2000000,\n    0x4000000,\n    0x8000000,\n    0x10000000,\n    0x20000000,\n    0x40000000,\n    0x80000000,\n    0x100000000,\n    0x200000000,\n    0x400000000,\n    0x800000000,\n    0x1000000000,\n    0x2000000000,\n    0x4000000000,\n    0x8000000000,\n    0x10000000000,\n    0x20000000000,\n    0x40000000000,\n    0x80000000000,\n    0x100000000000,\n    0x200000000000,\n    0x400000000000,\n    0x800000000000,\n    0x1000000000000,\n    0x2000000000000,\n    0x4000000000000,\n    0x8000000000000,\n    0x10000000000000\n];\nvar TileOffsetUtils;\n(function (TileOffsetUtils) {\n    /**\n     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the\n     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because\n     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the\n     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24\n     * levels. Given the current support up to level 19 this should be fine.\n     *\n     * @param tileKey The unique [[TileKey]] from which to compute the unique key.\n     * @param offset How much the given [[TileKey]] is offset\n     * @param bitshift How much space we have to store the offset. The default of 4 means we have\n     *      enough space to store 16 unique tiles in a single view.\n     */\n    function getKeyForTileKeyAndOffset(tileKey, offset, bitshift = 4) {\n        const shiftedOffset = getShiftedOffset(offset, bitshift);\n        return tileKey.mortonCode() + shiftedOffset;\n    }\n    TileOffsetUtils.getKeyForTileKeyAndOffset = getKeyForTileKeyAndOffset;\n    /**\n     * Extracts the offset and morton key from the given key (must be created by:\n     * [[getKeyForTileKeyAndOffset]])\n     *\n     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and\n     * would truncate the numbers, hence using powers of two.\n     *\n     * @param key Key to extract offset and morton key.\n     * @param bitshift How many bits to shift by, must be the same as was used when creating the\n     * key.\n     */\n    function extractOffsetAndMortonKeyFromKey(key, bitshift = 4) {\n        let offset = 0;\n        let mortonCode = key;\n        let i = 0;\n        // Compute the offset\n        for (; i < bitshift; i++) {\n            // Note, we use 52, because 2^53-1 is the biggest value, the highest value\n            // that can be set is the bit in the 52th position.\n            const num = powerOfTwo[52 - i];\n            if (mortonCode >= num) {\n                mortonCode -= num;\n                offset += powerOfTwo[bitshift - 1 - i];\n            }\n        }\n        // We subtract half of the total amount, this undoes what is computed in getShiftedOffset\n        offset -= powerOfTwo[bitshift - 1];\n        return { offset, mortonCode };\n    }\n    TileOffsetUtils.extractOffsetAndMortonKeyFromKey = extractOffsetAndMortonKeyFromKey;\n    /**\n     * Returns the key of the parent. Key must have been computed using the function\n     * [[getKeyForTileKeyAndOffset]].\n     *\n     * @param calculatedKey Key to decompose\n     * @param bitshift Bit shift used to create the key\n     */\n    function getParentKeyFromKey(calculatedKey, bitshift = 4) {\n        const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);\n        const parentTileKey = harp_geoutils_1.TileKey.fromMortonCode(harp_geoutils_1.TileKey.parentMortonCode(mortonCode));\n        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);\n    }\n    TileOffsetUtils.getParentKeyFromKey = getParentKeyFromKey;\n    /**\n     * Packs the supplied offset into the high bits, where the highbits are between 2^52 and\n     * 2^(52-bitshift).\n     *\n     * Offsets are wrapped around, to fit in the offsetBits. In practice, this doesn't really\n     * matter, this is primarily used to find a unique id, if there is an offset 10, which is\n     * wrapped to 2, it doesn't matter, because the offset of 10 is still stored in the tile.\n     * What can be a problem though is that the cache gets filled up and isn't emptied.\n     *\n     * Note, because bit shifting in JavaScript works on 32 bit integers, we use powers of 2 to set\n     * the high bits instead.\n     *\n     * @param offset Offset to pack into the high bits.\n     * @param offsetBits How many bits to use to pack the offset.\n     */\n    function getShiftedOffset(offset, offsetBits = 4) {\n        let result = 0;\n        const totalOffsetsToStore = powerOfTwo[offsetBits];\n        //Offsets are stored by adding half 2 ^ (bitshift - 1), i.e.half of the max amount stored,\n        //and then wrapped based on this value.For example, given a bitshift of 3, and an offset -\n        //3, it would have 4 added(half of 2 ^ 3), and be stored as 1, 3 would have 4 added and be\n        //stored as 7, 4 would be added with 4 and be stored as 0 (it wraps around).\n        offset += totalOffsetsToStore / 2;\n        while (offset < 0) {\n            offset += totalOffsetsToStore;\n        }\n        while (offset >= totalOffsetsToStore) {\n            offset -= totalOffsetsToStore;\n        }\n        // Offset is now a number between >= 0 and < totalOffsetsToStore\n        for (let i = 0; i < offsetBits && offset > 0; i++) {\n            // tslint:disable: no-bitwise\n            // 53 is used because 2^53-1 is the biggest number that Javascript can represent as an\n            // integer safely.\n            if (offset & 0x1) {\n                result += powerOfTwo[53 - offsetBits + i];\n            }\n            offset >>>= 1;\n            // tslint:enable: no-bitwise\n        }\n        harp_utils_1.assert(offset === 0);\n        return result;\n    }\n})(TileOffsetUtils = exports.TileOffsetUtils || (exports.TileOffsetUtils = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/Utils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/VisibleTileSet.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/VisibleTileSet.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ \"./node_modules/@here/harp-lrucache/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-mapview/lib/Utils.js\");\n/**\n * Way the memory consumption of a tile is computed. Either in number of tiles, or in MegaBytes. If\n * it is in MB, an estimation is used.\n */\nvar ResourceComputationType;\n(function (ResourceComputationType) {\n    ResourceComputationType[ResourceComputationType[\"EstimationInMb\"] = 0] = \"EstimationInMb\";\n    ResourceComputationType[ResourceComputationType[\"NumberOfTiles\"] = 1] = \"NumberOfTiles\";\n})(ResourceComputationType = exports.ResourceComputationType || (exports.ResourceComputationType = {}));\nconst MB_FACTOR = 1.0 / (1024.0 * 1024.0);\n/**\n * Wrapper for LRU cache that encapsulates tiles caching for any [[DataSource]] used.\n *\n * Provides LRU based caching mechanism where each tile is identified by its tile key\n * (morton code) and data source name.\n * Tiles are kept in the cache based on last recently used policy, cached tile may be evicted\n * only when cache reaches full saturation and tile is no longer visible.\n * @note Currently cached entries (tiles) are identified by unique tile code (morton code) and\n * data source name, thus it is required that each [[DataSource]] used should have unique\n * name, but implementation could be improved to omit this limitation.\n */\nclass DataSourceCache {\n    constructor(cacheSize, rct = ResourceComputationType.EstimationInMb) {\n        this.m_disposedTiles = [];\n        this.m_resourceComputationType = rct;\n        this.m_tileCache = new harp_lrucache_1.LRUCache(cacheSize, (tile) => {\n            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {\n                // Default is size in MB.\n                return tile.memoryUsage * MB_FACTOR;\n            }\n            else {\n                return 1;\n            }\n        });\n        this.m_tileCache.evictionCallback = (_, tile) => {\n            if (tile.tileLoader !== undefined) {\n                // Cancel downloads as early as possible.\n                tile.tileLoader.cancel();\n            }\n            this.m_disposedTiles.push(tile);\n        };\n        this.m_tileCache.canEvict = (_, tile) => {\n            // Tiles can be evicted that weren't requested in the last frame.\n            return !tile.isVisible;\n        };\n    }\n    /**\n     * Creates unique tile key for caching based on morton code, tile offset and its data source.\n     *\n     * @param mortonCode The tile morton code.\n     * @param offset The tile offset.\n     * @param dataSource The [[DataSource]] from which tile was loaded.\n     */\n    static getKey(mortonCode, offset, dataSource) {\n        return `${dataSource.name}_${mortonCode}_${offset}`;\n    }\n    /**\n     * Create unique tile identifier for caching, based on tile object passed in.\n     *\n     * @param tile The tile for which key is generated.\n     */\n    static getKeyForTile(tile) {\n        return DataSourceCache.getKey(tile.tileKey.mortonCode(), tile.offset, tile.dataSource);\n    }\n    /**\n     * Get information how cached tiles affects cache space available.\n     *\n     * The way how cache evaluates the __resources size__ have a big influence on entire\n     * caching mechanism, if [[resourceComputationType]] is set to:\n     * [[ResourceComputationType.EstimationInMb]] then each tiles contributes to cache size\n     * differently depending on the memory consumed, on other side\n     * [[ResourceComputationType.NumberOfTiles]] says each tile occupies single slot in cache,\n     * so its real memory consumed does not matter affect caching behavior. Of course in\n     * the second scenario cache may grow significantly in terms of memory usage and thus it\n     * is out of control.\n     *\n     * @return [[ResourceComputationType]] enum that describes if resources are counted by\n     * space occupied in memory or just by number of them.\n     */\n    get resourceComputationType() {\n        return this.m_resourceComputationType;\n    }\n    /**\n     * Get the cache capacity measured as number if megabytes or number of entries.\n     *\n     * The total cached tiles size determines cache saturation, if it reaches the capacity value\n     * then the resources becomes evicted (released) starting from the oldest (the latest used).\n     *\n     * @see size.\n     * @see resourceComputationType.\n     */\n    get capacity() {\n        return this.m_tileCache.capacity;\n    }\n    /**\n     * Get total cache size described as number of megabytes consumed or number of tiles stored.\n     *\n     * @see capacity.\n     * @see resourceComputationType.\n     */\n    get size() {\n        return this.m_tileCache.size;\n    }\n    /**\n     * Set cache capacity and the algorithm used for cache size calculation.\n     *\n     * @see capacity.\n     * @see resourceComputationType.\n     * @param size The new capacity declared in megabytes or number of entires.\n     * @param rct The enum value that determines how size and capacity are evaluated.\n     */\n    setCapacity(size, rct) {\n        this.m_resourceComputationType = rct;\n        this.m_tileCache.setCapacityAndMeasure(size, (tile) => {\n            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {\n                // Default is size in MB.\n                return tile.memoryUsage * MB_FACTOR;\n            }\n            else {\n                return 1;\n            }\n        });\n    }\n    /**\n     * Get tile cached or __undefined__ if tile is not yet in cache.\n     *\n     * @param mortonCode En unique tile morton code.\n     * @param offset Tile offset.\n     * @param dataSource A [[DataSource]] the tile comes from.\n     */\n    get(mortonCode, offset, dataSource) {\n        return this.m_tileCache.get(DataSourceCache.getKey(mortonCode, offset, dataSource));\n    }\n    /**\n     * Add new tile to the cache.\n     *\n     * @param mortonCode En unique tile code (morton code).\n     * @param offset The tile offset.\n     * @param dataSource A [[DataSource]] the tile comes from.\n     * @param tile The tile reference.\n     */\n    set(mortonCode, offset, dataSource, tile) {\n        this.m_tileCache.set(DataSourceCache.getKey(mortonCode, offset, dataSource), tile);\n    }\n    /**\n     * Delete tile from cache.\n     *\n     * @note This method will not call eviction callback.\n     * @param tile The tile reference to be removed from cache.\n     */\n    delete(tile) {\n        const tileKey = DataSourceCache.getKeyForTile(tile);\n        this.deleteByKey(tileKey);\n    }\n    /**\n     * Delete tile using its unique identifier.\n     *\n     * @note Tile identifier its constructed using information about tile code (morton code) and its\n     * [[DataSource]].\n     * @note This is explicit removal thus eviction callback will not be processed.\n     * @see DataSourceCache.getKey.\n     * @param tileKey The unique tile identifier.\n     */\n    deleteByKey(tileKey) {\n        this.m_tileCache.delete(tileKey);\n    }\n    /**\n     * Dispose all tiles releasing their internal data.\n     */\n    disposeTiles() {\n        this.m_disposedTiles.forEach(tile => {\n            tile.dispose();\n        });\n        this.m_disposedTiles.length = 0;\n    }\n    /**\n     * Shrink cache to its allowed capacity.\n     *\n     * This method should be called each time after operations are performed on the cache entries,\n     * in order to keep cache size consistent. It informs caching mechanism to invalidate memory\n     * consumed by its entries and check if cache is overgrown, is such case some tiles will be\n     * evicted.\n     */\n    shrinkToCapacity() {\n        this.m_tileCache.shrinkToCapacity();\n    }\n    /**\n     * Evict all cached tiles implicitly even without checking if still in use.\n     */\n    evictAll() {\n        this.m_tileCache.evictAll();\n    }\n    /**\n     * Evict selected tiles implicitly.\n     *\n     * @param selector The callback used to determine if tile should be evicted.\n     */\n    evictSelected(selector) {\n        this.m_tileCache.evictSelected(selector);\n    }\n    /**\n     * Call functor (callback) on each tile store in cache.\n     *\n     * Optionally you may specify from which [[DataSource]] tiles should be processed.\n     * This limits the tiles visited to a sub-set originating from single [[DataSource]].\n     * @param callback The function to be called for each visited tile.\n     * @param inDataSource The optional [[DataSource]] to which tiles should belong.\n     */\n    forEach(callback, inDataSource) {\n        this.m_tileCache.forEach((entry, key) => {\n            if (inDataSource === undefined || entry.dataSource === inDataSource) {\n                callback(entry, key);\n            }\n        });\n    }\n}\n/**\n * Manages visible [[Tile]]s for [[MapView]].\n *\n * Responsible for election of rendered tiles:\n *  - quad-tree traversal\n *  - frustum culling\n *  - sorting tiles by relevance (visible area) to prioritize load\n *  - limiting number of visible tiles\n *  - caching tiles\n *  - searching cache to replace visible but yet empty tiles with already loaded siblings in nearby\n *    zoom levels\n */\nclass VisibleTileSet {\n    constructor(m_frustumIntersection, m_tileGeometryManager, options) {\n        this.m_frustumIntersection = m_frustumIntersection;\n        this.m_tileGeometryManager = m_tileGeometryManager;\n        this.dataSourceTileList = [];\n        this.allVisibleTilesLoaded = false;\n        this.m_projectionMatrixOverride = new THREE.Matrix4();\n        this.m_viewRange = { near: 0.1, far: Infinity, minimum: 0.1, maximum: Infinity };\n        this.m_resourceComputationType = ResourceComputationType.EstimationInMb;\n        this.options = options;\n        this.m_resourceComputationType =\n            options.resourceComputationType === undefined\n                ? ResourceComputationType.EstimationInMb\n                : options.resourceComputationType;\n        this.m_dataSourceCache = new DataSourceCache(this.options.tileCacheSize, this.m_resourceComputationType);\n    }\n    /**\n     * Returns cache size.\n     */\n    getDataSourceCacheSize() {\n        return this.options.tileCacheSize;\n    }\n    /**\n     * Sets cache size.\n     *\n     * @param size cache size\n     * @param computationType Optional value specifying the way a [[Tile]]s cache usage is computed,\n     *      either based on size in MB (mega bytes) or in number of tiles. Defaults to\n     *      `ResourceComputationType.EstimationInMb`.\n     */\n    setDataSourceCacheSize(size, computationType = ResourceComputationType.EstimationInMb) {\n        this.options.tileCacheSize = size;\n        // This effectively invalidates DataSourceCache\n        this.resourceComputationType = computationType;\n    }\n    /**\n     * Retrieves maximum number of visible tiles.\n     */\n    getNumberOfVisibleTiles() {\n        return this.options.maxVisibleDataSourceTiles;\n    }\n    /**\n     * Sets maximum number of visible tiles.\n     *\n     * @param size size of visible tiles array\n     */\n    setNumberOfVisibleTiles(size) {\n        this.options.maxVisibleDataSourceTiles = size;\n    }\n    /**\n     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of\n     * tiles.\n     */\n    get resourceComputationType() {\n        return this.m_resourceComputationType;\n    }\n    /**\n     * Sets the way tile cache is managing its elements.\n     *\n     * Cache may be either keeping number of elements stored or the memory consumed by them.\n     *\n     * @param computationType Type of algorith used in cache for checking full saturation,\n     * may be counting number of elements or memory consumed by them.\n     */\n    set resourceComputationType(computationType) {\n        this.m_resourceComputationType = computationType;\n        this.m_dataSourceCache.setCapacity(this.options.tileCacheSize, computationType);\n    }\n    /**\n     * Evaluate frustum near/far clip planes and visibility ranges.\n     */\n    updateClipPlanes(maxElevation, minElevation) {\n        if (maxElevation !== undefined) {\n            this.options.clipPlanesEvaluator.maxElevation = maxElevation;\n        }\n        if (minElevation !== undefined) {\n            this.options.clipPlanesEvaluator.minElevation = minElevation;\n        }\n        this.m_viewRange = this.options.clipPlanesEvaluator.evaluateClipPlanes(this.m_frustumIntersection.mapView);\n        return this.m_viewRange;\n    }\n    /**\n     * Calculates a new set of visible tiles.\n     * @param storageLevel The camera storage level, see [[MapView.storageLevel]].\n     * @param zoomLevel The camera zoom level.\n     * @param dataSources The data sources for which the visible tiles will be calculated.\n     * @param elevationRangeSource Source of elevation range data if any.\n     * @returns view ranges and their status since last update (changed or not).\n     */\n    updateRenderList(storageLevel, zoomLevel, dataSources, elevationRangeSource) {\n        let allVisibleTilesLoaded = true;\n        const visibleTileKeysResult = this.getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource);\n        this.dataSourceTileList = [];\n        for (const { dataSource, visibleTileKeys } of visibleTileKeysResult.tileKeys) {\n            // Sort by distance to camera, now the tiles that are further away are at the end\n            // of the list.\n            //\n            // Sort is unstable if distance is equal, which happens a lot when looking top-down.\n            // Unstable sorting makes label placement unstable at tile borders, leading to\n            // flickering.\n            visibleTileKeys.sort((a, b) => {\n                const distanceDiff = a.distance - b.distance;\n                // Take care or numerical precision issues\n                const minDiff = (a.distance + b.distance) * 0.000001;\n                return Math.abs(distanceDiff) < minDiff\n                    ? a.tileKey.mortonCode() - b.tileKey.mortonCode()\n                    : distanceDiff;\n            });\n            const actuallyVisibleTiles = [];\n            let allDataSourceTilesLoaded = true;\n            let numTilesLoading = 0;\n            // Create actual tiles only for the allowed number of visible tiles\n            const displayZoomLevel = dataSource.getDisplayZoomLevel(zoomLevel);\n            for (let i = 0; i < visibleTileKeys.length &&\n                actuallyVisibleTiles.length < this.options.maxVisibleDataSourceTiles; i++) {\n                const tileEntry = visibleTileKeys[i];\n                const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset);\n                if (tile === undefined) {\n                    continue;\n                }\n                tile.prepareTileInfo();\n                allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;\n                if (!tile.allGeometryLoaded) {\n                    numTilesLoading++;\n                }\n                else {\n                    tile.numFramesVisible++;\n                    if (tile.frameNumVisible < 0) {\n                        // Store the fist frame the tile became visible.\n                        tile.frameNumVisible = dataSource.mapView.frameNumber;\n                    }\n                }\n                // Update the visible area of the tile. This is used for those tiles that are\n                // currently loaded and are waiting to be decoded to sort the jobs by area.\n                tile.visibleArea = tileEntry.area;\n                tile.minElevation = tileEntry.minElevation;\n                tile.maxElevation = tileEntry.maxElevation;\n                actuallyVisibleTiles.push(tile);\n            }\n            this.m_tileGeometryManager.updateTiles(actuallyVisibleTiles);\n            this.dataSourceTileList.push({\n                dataSource,\n                storageLevel,\n                zoomLevel: displayZoomLevel,\n                allVisibleTileLoaded: allDataSourceTilesLoaded,\n                numTilesLoading,\n                visibleTiles: actuallyVisibleTiles,\n                renderedTiles: new Map()\n            });\n            allVisibleTilesLoaded = allVisibleTilesLoaded && allDataSourceTilesLoaded;\n        }\n        this.allVisibleTilesLoaded =\n            allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;\n        this.fillMissingTilesFromCache();\n        this.forEachCachedTile(tile => {\n            // Remove all tiles that are still being loaded, but are no longer visible. They have to\n            // be reloaded when they become visible again. Hopefully, they are still in the browser\n            // cache by then.\n            if (!tile.isVisible && tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {\n                // The internal TileLoader is cancelled automatically when the Tile is disposed.\n                this.disposeTile(tile);\n            }\n        });\n        this.m_dataSourceCache.shrinkToCapacity();\n        let minElevation;\n        let maxElevation;\n        this.dataSourceTileList.forEach(renderListEntry => {\n            // Calculate min/max elevation from every data source tiles,\n            // data sources without elevationRangeSource will contribute to\n            // values with zero levels for both elevations.\n            const tiles = renderListEntry.renderedTiles;\n            tiles.forEach(tile => {\n                minElevation = harp_utils_1.MathUtils.min2(minElevation, tile.minElevation);\n                maxElevation = harp_utils_1.MathUtils.max2(maxElevation, tile.maxElevation + tile.maxGeometryHeight);\n            });\n        });\n        if (minElevation === undefined) {\n            minElevation = 0;\n        }\n        if (maxElevation === undefined) {\n            maxElevation = 0;\n        }\n        // If clip planes evaluator depends on the tiles elevation re-calculate\n        // frustum planes and update the camera near/far plane distances.\n        let viewRangesChanged = false;\n        const oldViewRanges = this.m_viewRange;\n        const newViewRanges = this.updateClipPlanes(maxElevation, minElevation);\n        viewRangesChanged = viewRangesEqual(newViewRanges, oldViewRanges) === false;\n        return {\n            viewRanges: newViewRanges,\n            viewRangesChanged\n        };\n    }\n    /**\n     * Gets the tile corresponding to the given data source, key and offset, creating it if\n     * necessary.\n     *\n     * @param dataSource The data source the tile belongs to.\n     * @param tileKey The key identifying the tile.\n     * @param offset Tile offset.\n     * @return The tile if it was found or created, undefined otherwise.\n     */\n    getTile(dataSource, tileKey, offset = 0) {\n        const cacheOnly = false;\n        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly);\n    }\n    /**\n     * Gets the tile corresponding to the given data source, key and offset from the cache.\n     *\n     * @param dataSource The data source the tile belongs to.\n     * @param tileKey The key identifying the tile.\n     * @param offset Tile offset.\n     * @return The tile if found in cache, undefined otherwise.\n     */\n    getCachedTile(dataSource, tileKey, offset = 0) {\n        harp_utils_1.assert(dataSource.cacheable);\n        const cacheOnly = true;\n        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly);\n    }\n    /**\n     * Gets the tile corresponding to the given data source, key and offset from the rendered tiles.\n     *\n     * @param dataSource The data source the tile belongs to.\n     * @param tileKey The key identifying the tile.\n     * @param offset Tile offset.\n     * @return The tile if found among the rendered tiles, undefined otherwise.\n     */\n    getRenderedTile(dataSource, tileKey, offset = 0) {\n        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {\n            return list.dataSource === dataSource;\n        });\n        if (dataSourceVisibleTileList === undefined) {\n            return undefined;\n        }\n        return dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset));\n    }\n    /**\n     * Gets the tile corresponding to the given data source and location from the rendered tiles.\n     *\n     * @param dataSource The data source the tile belongs to.\n     * @param geoPoint The geolocation included within the tile.\n     * @return The tile if found among the rendered tiles, undefined otherwise.\n     */\n    getRenderedTileAtLocation(dataSource, geoPoint, offset = 0) {\n        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {\n            return list.dataSource === dataSource;\n        });\n        if (dataSourceVisibleTileList === undefined) {\n            return undefined;\n        }\n        const tilingScheme = dataSource.getTilingScheme();\n        const visibleLevel = dataSourceVisibleTileList.zoomLevel;\n        const visibleTileKey = tilingScheme.getTileKey(geoPoint, visibleLevel);\n        if (!visibleTileKey) {\n            return undefined;\n        }\n        let tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(visibleTileKey, offset));\n        if (tile !== undefined) {\n            return tile;\n        }\n        const { searchLevelsUp, searchLevelsDown } = this.getCacheSearchLevels(dataSource, visibleLevel);\n        let parentTileKey = visibleTileKey;\n        for (let levelOffset = 1; levelOffset <= searchLevelsUp; ++levelOffset) {\n            parentTileKey = parentTileKey.parent();\n            tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(parentTileKey, offset));\n            if (tile !== undefined) {\n                return tile;\n            }\n        }\n        const worldPoint = tilingScheme.projection.projectPoint(geoPoint);\n        for (let levelOffset = 1; levelOffset <= searchLevelsDown; ++levelOffset) {\n            const childLevel = visibleLevel + levelOffset;\n            const childTileKey = harp_geoutils_1.TileKeyUtils.worldCoordinatesToTileKey(tilingScheme, worldPoint, childLevel);\n            if (childTileKey) {\n                tile = dataSourceVisibleTileList.renderedTiles.get(Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset));\n                if (tile !== undefined) {\n                    return tile;\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Removes all internal bookkeeping entries and cache related to specified datasource.\n     *\n     * Called by [[MapView]] when [[DataSource]] has been removed from [[MapView]].\n     */\n    removeDataSource(dataSource) {\n        this.clearTileCache(dataSource);\n        this.dataSourceTileList = this.dataSourceTileList.filter(tileList => tileList.dataSource !== dataSource);\n    }\n    /**\n     * Clear the tile cache.\n     *\n     * Remove the [[Tile]] objects created by cacheable [[DataSource]]. If a [[DataSource]] name is\n     * provided, this method restricts the eviction the [[DataSource]] with the given name.\n     *\n     * @param dataSourceName The name of the [[DataSource]].\n     */\n    clearTileCache(dataSource) {\n        if (dataSource !== undefined) {\n            this.m_dataSourceCache.evictSelected((tile, _) => {\n                return tile.dataSource === dataSource;\n            });\n        }\n        else {\n            this.m_dataSourceCache.evictAll();\n        }\n    }\n    /**\n     * Visit each tile in visible, rendered, and cached sets.\n     *\n     *  * Visible and temporarily rendered tiles will be marked for update and retained.\n     *  * Cached but not rendered/visible will be evicted.\n     *\n     * @param dataSource If passed, only the tiles from this [[DataSource]] instance are processed.\n     *     If `undefined`, tiles from all [[DataSource]]s are processed.\n     */\n    markTilesDirty(dataSource) {\n        if (dataSource === undefined) {\n            this.dataSourceTileList.forEach(renderListEntry => {\n                this.markDataSourceTilesDirty(renderListEntry);\n            });\n        }\n        else {\n            const renderListEntry = this.dataSourceTileList.find(e => e.dataSource === dataSource);\n            if (renderListEntry === undefined) {\n                return;\n            }\n            this.markDataSourceTilesDirty(renderListEntry);\n        }\n    }\n    /**\n     * Dispose tiles that are marked for removal by [[LRUCache]] algorithm.\n     */\n    disposePendingTiles() {\n        this.m_dataSourceCache.disposeTiles();\n    }\n    /**\n     * Process callback function [[fun]] with each visible tile in set.\n     *\n     * @param fun The callback function to be called.\n     */\n    forEachVisibleTile(fun) {\n        for (const listEntry of this.dataSourceTileList) {\n            listEntry.renderedTiles.forEach(fun);\n        }\n    }\n    /**\n     * Process callback function [[fun]] with each tile in the cache.\n     *\n     * Optional [[dataSource]] parameter limits processing to the tiles that belongs to\n     * DataSource passed in.\n     *\n     * @param fun The callback function to be called.\n     * @param dataSource The optional DataSource reference for tiles selection.\n     */\n    forEachCachedTile(fun, dataSource) {\n        this.m_dataSourceCache.forEach((tile, _) => fun(tile), dataSource);\n    }\n    /**\n     * Dispose a `Tile` from cache, 'dispose()' is also called on the tile to free its resources.\n     */\n    disposeTile(tile) {\n        // TODO: Consider using evict here!\n        this.m_dataSourceCache.delete(tile);\n        tile.dispose();\n    }\n    getCacheSearchLevels(dataSource, visibleLevel) {\n        const searchLevelsUp = Math.min(this.options.quadTreeSearchDistanceUp, Math.max(0, visibleLevel - dataSource.minZoomLevel));\n        const searchLevelsDown = Math.min(this.options.quadTreeSearchDistanceDown, Math.max(0, dataSource.maxZoomLevel - visibleLevel));\n        return { searchLevelsUp, searchLevelsDown };\n    }\n    /**\n     * Search cache to replace visible but yet empty tiles with already loaded siblings in nearby\n     * zoom levels.\n     *\n     * Useful, when zooming in/out and when \"newly elected\" tiles are not yet loaded. Prevents\n     * flickering by rendering already loaded tiles from upper/higher zoom levels.\n     */\n    fillMissingTilesFromCache() {\n        this.dataSourceTileList.forEach(renderListEntry => {\n            const dataSource = renderListEntry.dataSource;\n            const displayZoomLevel = renderListEntry.zoomLevel;\n            const renderedTiles = renderListEntry.renderedTiles;\n            // Direction in quad tree to search: up -> shallower levels, down -> deeper levels.\n            let SearchDirection;\n            (function (SearchDirection) {\n                SearchDirection[SearchDirection[\"NONE\"] = 0] = \"NONE\";\n                SearchDirection[SearchDirection[\"UP\"] = 1] = \"UP\";\n                SearchDirection[SearchDirection[\"DOWN\"] = 2] = \"DOWN\";\n                SearchDirection[SearchDirection[\"BOTH\"] = 3] = \"BOTH\";\n            })(SearchDirection || (SearchDirection = {}));\n            let defaultSearchDirection = SearchDirection.NONE;\n            const { searchLevelsUp, searchLevelsDown } = this.getCacheSearchLevels(dataSource, displayZoomLevel);\n            defaultSearchDirection =\n                searchLevelsDown > 0 && searchLevelsUp > 0\n                    ? SearchDirection.BOTH\n                    : searchLevelsDown > 0\n                        ? SearchDirection.DOWN\n                        : searchLevelsUp > 0\n                            ? SearchDirection.UP\n                            : SearchDirection.NONE;\n            const incompleteTiles = new Map();\n            renderListEntry.visibleTiles.forEach(tile => {\n                const tileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(tile.tileKey, tile.offset);\n                tile.levelOffset = 0;\n                if (tile.hasGeometry || defaultSearchDirection === SearchDirection.NONE) {\n                    renderedTiles.set(tileCode, tile);\n                }\n                else {\n                    // if dataSource supports cache and it was existing before this render\n                    // then enable searching for loaded tiles in cache\n                    incompleteTiles.set(tileCode, defaultSearchDirection);\n                }\n            });\n            if (incompleteTiles.size === 0) {\n                // short circuit, nothing to be done\n                return;\n            }\n            // Minor optimization for the fallback search, only check parent tiles once, otherwise\n            // the recursive algorithm checks all parent tiles multiple times, the key is the code\n            // of the tile that is checked and the value is whether a parent was found or not.\n            const checkedTiles = new Map();\n            // Iterate over incomplete (not loaded tiles) and find their parents or children that\n            // are in cache that can be rendered temporarily until tile is loaded. Note, we favour\n            // falling back to parent tiles rather than children.\n            for (const [tileKeyCode, searchDirection] of incompleteTiles) {\n                if (searchDirection === SearchDirection.BOTH ||\n                    searchDirection === SearchDirection.UP) {\n                    if (this.findUp(tileKeyCode, displayZoomLevel, renderedTiles, checkedTiles, dataSource)) {\n                        // Continue to next entry so we don't search down.\n                        continue;\n                    }\n                }\n                if (searchDirection === SearchDirection.BOTH ||\n                    searchDirection === SearchDirection.DOWN) {\n                    this.findDown(tileKeyCode, displayZoomLevel, renderedTiles, dataSource);\n                }\n            }\n        });\n    }\n    findDown(tileKeyCode, displayZoomLevel, renderedTiles, dataSource) {\n        const { offset, mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(tileKeyCode);\n        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(mortonCode);\n        const tilingScheme = dataSource.getTilingScheme();\n        for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n            const childTileCode = Utils_1.TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);\n            const childTile = this.m_dataSourceCache.get(childTileKey.mortonCode(), offset, dataSource);\n            const nextLevelDiff = Math.abs(childTileKey.level - displayZoomLevel);\n            if (childTile !== undefined && childTile.hasGeometry) {\n                // childTile has geometry, so can be reused as fallback\n                renderedTiles.set(childTileCode, childTile);\n                childTile.levelOffset = nextLevelDiff;\n                continue;\n            }\n            // Recurse down until the max distance is reached.\n            if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {\n                this.findDown(childTileCode, displayZoomLevel, renderedTiles, dataSource);\n            }\n        }\n    }\n    /**\n     * Returns true if a tile was found in the cache which is a parent\n     * @param tileKeyCode Morton code of the current tile that should be searched for.\n     * @param displayZoomLevel The current zoom level of tiles that are to be displayed.\n     * @param renderedTiles The list of tiles that are shown to the user.\n     * @param checkedTiles Used to map a given code to a boolean which tells us if an ancestor is\n     * displayed or not.\n     * @param dataSource The provider of tiles.\n     * @returns Whether a parent tile exists.\n     */\n    findUp(tileKeyCode, displayZoomLevel, renderedTiles, checkedTiles, dataSource) {\n        const parentCode = Utils_1.TileOffsetUtils.getParentKeyFromKey(tileKeyCode);\n        // Check if another sibling has already added the parent.\n        if (renderedTiles.get(parentCode) !== undefined) {\n            return true;\n        }\n        const exists = checkedTiles.get(parentCode);\n        if (exists !== undefined) {\n            return exists;\n        }\n        const { offset, mortonCode } = Utils_1.TileOffsetUtils.extractOffsetAndMortonKeyFromKey(parentCode);\n        const parentTile = this.m_dataSourceCache.get(mortonCode, offset, dataSource);\n        const parentTileKey = parentTile ? parentTile.tileKey : harp_geoutils_1.TileKey.fromMortonCode(mortonCode);\n        const nextLevelDiff = Math.abs(displayZoomLevel - parentTileKey.level);\n        if (parentTile !== undefined && parentTile.hasGeometry) {\n            checkedTiles.set(parentCode, true);\n            // parentTile has geometry, so can be reused as fallback\n            renderedTiles.set(parentCode, parentTile);\n            // We want to have parent tiles as -ve, hence the minus.\n            parentTile.levelOffset = -nextLevelDiff;\n            return true;\n        }\n        else {\n            checkedTiles.set(parentCode, false);\n        }\n        // Recurse up until the max distance is reached or we go to the parent of all parents.\n        if (nextLevelDiff < this.options.quadTreeSearchDistanceUp && parentTileKey.level !== 0) {\n            const foundUp = this.findUp(parentCode, displayZoomLevel, renderedTiles, checkedTiles, dataSource);\n            // If there was a tile upstream found, then add it to the list, so we can\n            // early skip checkedTiles.\n            checkedTiles.set(parentCode, foundUp);\n            if (foundUp) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getTileImpl(dataSource, tileKey, offset, cacheOnly) {\n        function updateTile(tileToUpdate) {\n            if (tileToUpdate === undefined) {\n                return;\n            }\n            // Keep the tile from being removed from the cache.\n            tileToUpdate.frameNumLastRequested = dataSource.mapView.frameNumber;\n        }\n        if (!dataSource.cacheable && !cacheOnly) {\n            const resultTile = dataSource.getTile(tileKey);\n            updateTile(resultTile);\n            return resultTile;\n        }\n        const tileCache = this.m_dataSourceCache;\n        let tile = tileCache.get(tileKey.mortonCode(), offset, dataSource);\n        if (tile !== undefined && tile.offset === offset) {\n            updateTile(tile);\n            return tile;\n        }\n        if (cacheOnly) {\n            return undefined;\n        }\n        tile = dataSource.getTile(tileKey);\n        // TODO: Update all tile information including area, min/max elevation from TileKeyEntry\n        if (tile !== undefined) {\n            tile.offset = offset;\n            updateTile(tile);\n            tileCache.set(tileKey.mortonCode(), offset, dataSource, tile);\n            this.m_tileGeometryManager.initTile(tile);\n        }\n        return tile;\n    }\n    markDataSourceTilesDirty(renderListEntry) {\n        const dataSourceCache = this.m_dataSourceCache;\n        const retainedTiles = new Set();\n        function markTileDirty(tile, tileGeometryManager) {\n            const tileKey = DataSourceCache.getKeyForTile(tile);\n            if (!retainedTiles.has(tileKey)) {\n                retainedTiles.add(tileKey);\n                if (tile.tileGeometryLoader !== undefined) {\n                    tile.tileGeometryLoader.reset();\n                }\n                // Prevent label rendering issues when the style set is changing. Prevent Text\n                // element rendering that depends on cleaned font catalog data.\n                tile.clearTextElements();\n                tile.load();\n            }\n        }\n        renderListEntry.visibleTiles.forEach(tile => {\n            markTileDirty(tile, this.m_tileGeometryManager);\n        });\n        renderListEntry.renderedTiles.forEach(tile => {\n            markTileDirty(tile, this.m_tileGeometryManager);\n        });\n        dataSourceCache.forEach((tile, key) => {\n            if (!retainedTiles.has(key)) {\n                dataSourceCache.deleteByKey(key);\n                tile.dispose();\n            }\n        }, renderListEntry.dataSource);\n    }\n    // Computes the visible tile keys for each supplied data source.\n    getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource) {\n        const tileKeys = Array();\n        let allBoundingBoxesFinal = true;\n        if (dataSources.length === 0) {\n            return { tileKeys, allBoundingBoxesFinal };\n        }\n        const dataSourceBuckets = new Map();\n        dataSources.forEach(dataSource => {\n            const tilingScheme = dataSource.getTilingScheme();\n            const bucket = dataSourceBuckets.get(tilingScheme);\n            if (bucket === undefined) {\n                dataSourceBuckets.set(tilingScheme, [dataSource]);\n            }\n            else {\n                bucket.push(dataSource);\n            }\n        });\n        // If elevation is to be taken into account create extended frustum:\n        // (near ~0, far: maxVisibilityRange) that allows to consider tiles that\n        // are far below ground plane and high enough to intersect the frustum.\n        if (elevationRangeSource !== undefined) {\n            const fp = Utils_1.MapViewUtils.getCameraFrustumPlanes(this.m_frustumIntersection.camera);\n            fp.near = this.m_viewRange.minimum;\n            fp.far = this.m_viewRange.maximum;\n            this.m_projectionMatrixOverride.makePerspective(fp.left, fp.right, fp.bottom, fp.top, fp.near, fp.far);\n            this.m_frustumIntersection.updateFrustum(this.m_projectionMatrixOverride);\n        }\n        else {\n            this.m_frustumIntersection.updateFrustum();\n        }\n        // For each bucket of data sources with same tiling scheme, calculate frustum intersection\n        // once using the maximum display level.\n        for (const [tilingScheme, bucket] of dataSourceBuckets) {\n            const zoomLevels = bucket.map(dataSource => dataSource.getDisplayZoomLevel(zoomLevel));\n            const result = this.m_frustumIntersection.compute(tilingScheme, elevationRangeSource, zoomLevels, bucket);\n            allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;\n            for (const dataSource of bucket) {\n                // For each data source check what tiles from the intersection should be rendered\n                // at this zoom level.\n                const visibleTileKeys = [];\n                const displayZoomLevel = dataSource.getDisplayZoomLevel(zoomLevel);\n                for (const tileKeyEntry of result.tileKeyEntries.get(displayZoomLevel).values()) {\n                    if (dataSource.canGetTile(displayZoomLevel, tileKeyEntry.tileKey)) {\n                        visibleTileKeys.push(tileKeyEntry);\n                    }\n                }\n                tileKeys.push({ dataSource, visibleTileKeys });\n            }\n        }\n        return { tileKeys, allBoundingBoxesFinal };\n    }\n}\nexports.VisibleTileSet = VisibleTileSet;\nfunction viewRangesEqual(a, b) {\n    return (a.far === b.far && a.maximum === b.maximum && a.minimum === b.minimum && a.near === b.near);\n}\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/VisibleTileSet.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\n/**\n * Identifier of next decoder worker-service. Used to ensure uniqueness of service ids of decoders\n * dedicated to different datasources.\n */\nlet nextUniqueServiceId = 0;\n/**\n * Decoder based on [[ConcurrentWorkerSet]].\n *\n * Decodes tiles using workers running in separate contexts (also known as `WebWorkers`):\n * - connection establishment,\n * - sends decode requests,\n * - configuration.\n */\nclass WorkerBasedDecoder {\n    /**\n     * Creates a new `WorkerBasedDecoder`.\n     *\n     * @param workerSet [[ConcurrentWorkerSet]] this tiler will live in.\n     * @param decoderServiceType Service type identifier.\n     */\n    constructor(workerSet, decoderServiceType) {\n        this.workerSet = workerSet;\n        this.decoderServiceType = decoderServiceType;\n        this.m_serviceCreated = false;\n        this.workerSet.addReference();\n        this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;\n    }\n    /**\n     * Dispose of dedicated tile decoder services in workers and remove reference to underlying\n     * [[ConcurrentWorkerSet]].\n     */\n    dispose() {\n        if (this.m_serviceCreated) {\n            this.workerSet\n                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,\n                targetServiceId: this.serviceId\n            })\n                .catch(() => {\n                /* Ignoring these errors as underlying workers possibly do not exist anymore. */\n            });\n        }\n        this.workerSet.removeReference();\n    }\n    /**\n     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates\n     * dedicated [[TileDecoderService]]s in all workers to serve decode requests.\n     */\n    async connect() {\n        await this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        if (!this.m_serviceCreated) {\n            await this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,\n                targetServiceType: this.decoderServiceType,\n                targetServiceId: this.serviceId\n            });\n            this.m_serviceCreated = true;\n        }\n    }\n    /**\n     * Get [[Tile]] from tile decoder service in worker.\n     *\n     * Invokes [[DecodeTileRequest]] on [[TileDecoderService]] running in worker pool.\n     */\n    decodeTile(data, tileKey, projection, requestController) {\n        const tileKeyCode = tileKey.mortonCode();\n        const message = {\n            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.DecodeTileRequest,\n            tileKey: tileKeyCode,\n            data,\n            projection: harp_datasource_protocol_1.getProjectionName(projection)\n        };\n        const transferList = data instanceof ArrayBuffer ? [data] : undefined;\n        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);\n    }\n    /**\n     * Get [[TileInfo]] from tile decoder service in worker.\n     *\n     * Invokes [[TileInfoRequest]] on [[TileDecoderService]] running in worker pool.\n     */\n    getTileInfo(data, tileKey, projection, requestController) {\n        const tileKeyCode = tileKey.mortonCode();\n        const message = {\n            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.TileInfoRequest,\n            tileKey: tileKeyCode,\n            data,\n            projection: harp_datasource_protocol_1.getProjectionName(projection)\n        };\n        const transferList = data instanceof ArrayBuffer ? [data] : undefined;\n        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);\n    }\n    /**\n     * Configure tile decoder service in workers.\n     *\n     * Broadcasts [[ConfigurationMessage]] to all [[TileDecoderService]]s running in worker pool.\n     *\n     * @param styleSet  new [[StyleSet]], undefined means no change\n     * @param languages new list of languages\n     * @param options   new options, undefined options are not changed\n     */\n    configure(styleSet, definitions, languages, options) {\n        const message = {\n            service: this.serviceId,\n            type: harp_datasource_protocol_1.WorkerDecoderProtocol.DecoderMessageName.Configuration,\n            styleSet,\n            definitions,\n            options,\n            languages\n        };\n        this.workerSet.broadcastMessage(message);\n    }\n    /**\n     * The number of workers started for this decoder. The value is `undefined` until the workers\n     * have been created.\n     */\n    get workerCount() {\n        return this.workerSet.workerCount;\n    }\n}\nexports.WorkerBasedDecoder = WorkerBasedDecoder;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/WorkerBasedDecoder.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\n/**\n * Identifier of next tiler worker-service. Used to ensure uniqueness of service ids of tilers\n * dedicated to different datasources.\n */\nlet nextUniqueServiceId = 0;\n/**\n * Tiler based on [[ConcurrentWorkerSet]].\n *\n * Tiles payloads using workers running in separate contexts (also known as `WebWorkers`):\n * - connection establishment,\n * - sends tile requests,\n * - configuration.\n */\nclass WorkerBasedTiler {\n    /**\n     * Creates a new `WorkerBasedTiler`.\n     *\n     * @param workerSet [[ConcurrentWorkerSet]] this tiler will live in.\n     * @param tilerServiceType Service type identifier.\n     */\n    constructor(workerSet, tilerServiceType) {\n        this.workerSet = workerSet;\n        this.tilerServiceType = tilerServiceType;\n        this.m_serviceCreated = false;\n        this.workerSet.addReference();\n        this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId++}`;\n    }\n    /**\n     * Dispose of dedicated tiler services in workers and remove reference to underlying\n     * [[ConcurrentWorkerSet]].\n     */\n    dispose() {\n        if (this.m_serviceCreated) {\n            this.workerSet\n                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,\n                targetServiceId: this.serviceId\n            })\n                .catch(() => {\n                /* Ignoring these errors as underlying workers possibly do not exist anymore. */\n            });\n        }\n        this.workerSet.removeReference();\n    }\n    /**\n     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates\n     * dedicated [[TilerService]]s in all workers to serve tiling requests.\n     */\n    async connect() {\n        await this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        if (!this.m_serviceCreated) {\n            await this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,\n                targetServiceType: this.tilerServiceType,\n                targetServiceId: this.serviceId\n            });\n            this.m_serviceCreated = true;\n        }\n    }\n    /**\n     * Register index in the tiler. Indexes registered in the tiler can be later used to retrieved\n     * tiled payloads using `getTile`.\n     *\n     * @param indexId Index identifier.\n     * @param input Url to the index payload, or direct GeoJSON.\n     */\n    registerIndex(indexId, input) {\n        const message = {\n            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.RegisterIndex,\n            id: indexId,\n            input: input instanceof URL ? input.href : input\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n    /**\n     * Update index in the tiler. Indexes registered in the tiler can be later used to retrieved\n     * tiled payloads using `getTile`.\n     *\n     * @param indexId Index identifier.\n     * @param input Url to the index payload, or direct GeoJSON.\n     */\n    updateIndex(indexId, input) {\n        const message = {\n            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.UpdateIndex,\n            id: indexId,\n            input: input instanceof URL ? input.href : input\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n    /**\n     * Retrieves a tile for a previously registered index.\n     *\n     * @param indexId Index identifier.\n     * @param tileKey The [[TileKey]] that identifies the tile.\n     */\n    getTile(indexId, tileKey) {\n        const tileKeyCode = tileKey.mortonCode();\n        const message = {\n            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.TileRequest,\n            index: indexId,\n            tileKey: tileKeyCode\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n}\nexports.WorkerBasedTiler = WorkerBasedTiler;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/WorkerBasedTiler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Pass_1 = __webpack_require__(/*! ./Pass */ \"./node_modules/@here/harp-mapview/lib/composing/Pass.js\");\n/**\n * The `LowResRenderPass` renders the scene at a lower resolution into an internal\n * `WebGLRenderTarget`, and then copies the result into the frame buffer. The size of the internal\n * buffer is determined by the current frame buffer size multiplied by `pixelRatio`.\n *\n * @note Since no anti-aliasing is applied during dynamic rendering, visual artifacts may be\n * visible.\n */\nclass LowResRenderPass extends Pass_1.Pass {\n    /**\n     * The constructor for `LowResRenderPass`. It builds an internal scene with a camera looking at\n     * a quad.\n     *\n     * @param lowResPixelRatio The `pixelRatio` determines the resolution of the internal\n     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give\n     * good results. A value of `undefined` disables the low res render pass. The value should not\n     * be larger than`window.devicePixelRatio`.\n     */\n    constructor(lowResPixelRatio) {\n        super();\n        this.lowResPixelRatio = lowResPixelRatio;\n        this.m_renderTarget = null;\n        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        this.m_quadScene = new THREE.Scene();\n        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;\n        this.m_quadMaterial = new harp_materials_1.CopyMaterial(this.m_quadUniforms);\n        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);\n        this.m_savedWidth = 0;\n        this.m_savedHeight = 0;\n        this.m_quad.frustumCulled = false;\n        this.m_quadScene.add(this.m_quad);\n        this.m_pixelRatio = lowResPixelRatio;\n    }\n    /**\n     * Releases all used resources.\n     */\n    dispose() {\n        this.m_quadMaterial.dispose();\n        this.m_quad.geometry.dispose();\n        if (this.m_renderTarget !== null) {\n            this.m_renderTarget.dispose();\n            this.m_renderTarget = null;\n        }\n    }\n    /**\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. The value should not be larger than\n     * `window.devicePixelRatio`.\n     *\n     * @default `undefined`\n     */\n    set pixelRatio(ratio) {\n        this.m_pixelRatio = ratio;\n        if (this.m_renderTarget && this.pixelRatio !== undefined) {\n            this.m_renderTarget.setSize(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio));\n        }\n    }\n    get pixelRatio() {\n        return this.m_pixelRatio;\n    }\n    /**\n     * The render function of `LowResRenderPass`. It renders the whole scene into an internal\n     * `WebGLRenderTarget` instance with a lower resolution, using the passed in `WebGLRenderer`.\n     * The low resolution image is then copied to the `writeBuffer`, which is `undefined` in case it\n     * is the screen.\n     *\n     * @param renderer The ThreeJS WebGLRenderer instance to render the scene with.\n     * @param scene The ThreeJS Scene instance to render the scene with.\n     * @param camera The ThreeJS Camera instance to render the scene with.\n     * @param writeBuffer A ThreeJS WebGLRenderTarget instance to render the scene to.\n     * @param readBuffer A ThreeJS WebGLRenderTarget instance to render the scene.\n     * @override\n     */\n    render(renderer, scene, camera, writeBuffer, readBuffer) {\n        if (!this.enabled || this.pixelRatio === undefined) {\n            return;\n        }\n        // Initiates the local render target with the read buffer's dimensions, if not available.\n        if (this.m_renderTarget === null) {\n            this.m_savedWidth = readBuffer.width;\n            this.m_savedHeight = readBuffer.height;\n            this.m_renderTarget = new THREE.WebGLRenderTarget(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio), {\n                minFilter: THREE.LinearFilter,\n                magFilter: THREE.LinearFilter,\n                format: THREE.RGBAFormat,\n                depthBuffer: true,\n                stencilBuffer: true\n            });\n            this.m_renderTarget.texture.name = \"LowResRenderPass.sample\";\n        }\n        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;\n        this.m_quadUniforms.opacity.value = 1.0;\n        const oldRenderTarget = renderer.getRenderTarget();\n        renderer.setRenderTarget(this.m_renderTarget);\n        renderer.clear();\n        // Render into the low resolution internal render target.\n        renderer.render(scene, camera);\n        // Render the low resolution target into the screen.\n        // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        renderer.clear();\n        renderer.render(this.m_quadScene, this.m_localCamera);\n        renderer.setRenderTarget(oldRenderTarget);\n    }\n    /**\n     * Resize the internal render target to match the new size specified. The size of internal\n     * buffer depends on the `pixelRatio`.\n     *\n     * @param width New width to apply to the render target.\n     * @param height New height to apply to the render target.\n     * @override\n     */\n    setSize(width, height) {\n        this.m_savedWidth = width;\n        this.m_savedHeight = height;\n        if (this.m_renderTarget && this.pixelRatio !== undefined) {\n            this.m_renderTarget.setSize(Math.floor(width * this.pixelRatio), Math.floor(height * this.pixelRatio));\n        }\n    }\n}\nexports.LowResRenderPass = LowResRenderPass;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Pass_1 = __webpack_require__(/*! ./Pass */ \"./node_modules/@here/harp-mapview/lib/composing/Pass.js\");\n/**\n * This enum represents the sampling level to apply to a [[MSAARenderPass]] instance. At level 0,\n * only one sample is performed, which is like disabling the MSAA pass.\n */\nvar MSAASampling;\n(function (MSAASampling) {\n    MSAASampling[MSAASampling[\"Level_0\"] = 0] = \"Level_0\";\n    MSAASampling[MSAASampling[\"Level_1\"] = 1] = \"Level_1\";\n    MSAASampling[MSAASampling[\"Level_2\"] = 2] = \"Level_2\";\n    MSAASampling[MSAASampling[\"Level_3\"] = 3] = \"Level_3\";\n    MSAASampling[MSAASampling[\"Level_4\"] = 4] = \"Level_4\";\n    MSAASampling[MSAASampling[\"Level_5\"] = 5] = \"Level_5\";\n})(MSAASampling = exports.MSAASampling || (exports.MSAASampling = {}));\n/**\n * [[MapView]]'s MSAA implementation. MSAA stands for Multi Sampling Anti-Aliasing, and its concept\n * is to provide a rendering engine with additional color values for each pixel, so they can include\n * the missing bits between them on a screen. WebGL already comes with a native MSAA implementation\n * with four samples. Because of its native nature, it is more efficient and one may not want to use\n * MapView's MSAA implementation when these four samples are satisfying. However in some situations\n * they are not: on low devices, MSAA can impact the framerate and we may desire to reduce the\n * number of samples at runtime. On the other hand, when the interaction stops, the engine also\n * stops rendering the map, and because a map relies on many line-like patterns, aliasing can then\n * turn very noticeable. In such static renders, the number of samples could be dramatically\n * increased on a last frame to render.\n */\nclass MSAARenderPass extends Pass_1.Pass {\n    /**\n     * The constructor for `MSAARenderPass`. It builds an internal scene with a camera looking at a\n     * quad.\n     *\n     * @param m_scene The scene to render.\n     * @param m_camera The camera to render the scene through.\n     */\n    constructor() {\n        super();\n        /**\n         * The sampling level determines the number of samples that will be performed per frame.\n         * Renders will happen `2 ^ samplingLevel` time(s). `samplingLevel` stands between `0` and `5`.\n         * Therefore there can be between 1 and 32 samples.\n         *\n         * @default `SamplingLevel.Level_1`\n         */\n        this.samplingLevel = MSAASampling.Level_1;\n        this.m_renderTarget = null;\n        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        this.m_quadScene = new THREE.Scene();\n        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;\n        this.m_quadMaterial = new harp_materials_1.MSAAMaterial(this.m_quadUniforms);\n        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);\n        this.m_quad.frustumCulled = false;\n        this.m_quadScene.add(this.m_quad);\n    }\n    /**\n     * Releases all used resources.\n     */\n    dispose() {\n        if (this.m_renderTarget !== null) {\n            this.m_renderTarget.dispose();\n            this.m_renderTarget = null;\n        }\n    }\n    /**\n     * The render function of `MSAARenderPass`. At each call of this method, and for each sample,\n     * the [[MapView]] camera provided in the `render` method is offset within the dimension of a\n     * pixel on screen. It then renders the whole scene with this offset to a local\n     * `WebGLRenderTarget` instance, via a `WebGLRenderer` instance. Finally the local camera\n     * created in the constructor shoots the quad and renders to the write buffer or to the frame\n     * buffer. The quad material's opacity is modified so the renders can accumulate in the\n     * targetted buffer.\n     *\n     * The number of samples can be modified at runtime through the enum [[SamplingLevel]].\n     *\n     * If there is no further pass, the [[Pass.renderToScreen]] flag can be set to `true` to\n     * output directly to the framebuffer.\n     *\n     * @param renderer The ThreeJS WebGLRenderer instance to render the scene with.\n     * @param scene The ThreeJS Scene instance to render the scene with.\n     * @param camera The ThreeJS Camera instance to render the scene with.\n     * @param writeBuffer A ThreeJS WebGLRenderTarget instance to render the scene to.\n     * @param readBuffer A ThreeJS WebGLRenderTarget instance to render the scene.\n     * @override\n     */\n    render(renderer, scene, camera, writeBuffer, readBuffer) {\n        if (!this.enabled) {\n            return;\n        }\n        // Initiates the local render target with the read buffer's dimensions, if not available.\n        if (this.m_renderTarget === null) {\n            this.m_renderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n                minFilter: THREE.LinearFilter,\n                magFilter: THREE.LinearFilter,\n                format: THREE.RGBAFormat\n            });\n            this.m_renderTarget.texture.name = \"MSAARenderPass.sample\";\n        }\n        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;\n        const offsets = MSAARenderPass.OffsetVectors[this.samplingLevel];\n        const rendererClearColor = renderer.getClearColor();\n        const oldClearColor = rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;\n        // The method `camera.setViewOffset` will be called in the next loop. In order to maintain\n        // its usability externally (like for the triple view in mosaic demo) we must cache the\n        // previous values stored in `camera.view` and re-assign them at the end of the pass.\n        // 1. Create a default cache object, with default dimensions the size of our read buffer.\n        const oldView = {\n            enabled: camera.view !== null && camera.view.enabled,\n            fullWidth: readBuffer.width,\n            fullHeight: readBuffer.height,\n            x: 0,\n            y: 0,\n            width: readBuffer.width,\n            height: readBuffer.height\n        };\n        // 2. If `camera.view` has been enabled previously, then `setViewOffset` has been called\n        // externally: copy the existing `camera.view` values in the cache. Override the cache\n        // object with the values provided externally.\n        if (oldView.enabled && camera.view !== null) {\n            oldView.fullWidth = camera.view.fullWidth;\n            oldView.fullHeight = camera.view.fullHeight;\n            oldView.x = camera.view.offsetX;\n            oldView.y = camera.view.offsetY;\n            oldView.width = camera.view.width;\n            oldView.height = camera.view.height;\n        }\n        const oldRenderTarget = renderer.getRenderTarget();\n        for (let i = 0; i < offsets.length; i++) {\n            // 4. Then for each sample, call `setViewOffset` with our object. This also updates the\n            // `camera.view` object in Three.js.\n            const offset = offsets[i];\n            camera.setViewOffset(oldView.fullWidth, oldView.fullHeight, oldView.x + offset[0] / 16, oldView.y + offset[1] / 16, oldView.width, oldView.height);\n            // 5. Divide the opacity of the quad by the number of samples to accumulate on the\n            // target buffer, and reduce the impact of the offset on color to reduce banding. Then\n            // render.\n            const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;\n            const sampleWeight = 1.0 / offsets.length + uniformCenteredDistribution / 32;\n            this.m_quadUniforms.opacity.value = sampleWeight;\n            renderer.setRenderTarget(this.m_renderTarget);\n            renderer.clear();\n            renderer.render(scene, camera);\n            // 6. Render the quad on top of the previous renders.\n            // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`\n            renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n            if (i === 0) {\n                renderer.setClearColor(0x000000);\n                renderer.clear();\n            }\n            renderer.render(this.m_quadScene, this.m_localCamera);\n            if (i === 0 && rendererClearColor !== undefined) {\n                renderer.setClearColor(oldClearColor);\n            }\n        }\n        renderer.setRenderTarget(oldRenderTarget);\n        // 7. Restore `camera.view` as set externally (or not).\n        if (camera.view !== null) {\n            camera.view.enabled = oldView.enabled;\n            camera.view.offsetX = oldView.x;\n            camera.view.offsetY = oldView.y;\n        }\n    }\n    /**\n     * Resize the internal render target to match the new size specified.\n     *\n     * @param width New width to apply to the render target.\n     * @param height New height to apply to the render target.\n     * @override\n     */\n    setSize(width, height) {\n        if (this.m_renderTarget) {\n            this.m_renderTarget.setSize(width, height);\n        }\n    }\n}\nexports.MSAARenderPass = MSAARenderPass;\n// tslint:disable:max-line-length\n/**\n * The list of offsets to apply to the camera, per sampling level, adapted from :\n *\n * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n */\n// tslint:enable:max-line-length\n// tslint:disable-next-line:member-ordering\nMSAARenderPass.OffsetVectors = [\n    [[0, 0]],\n    [\n        [4, 4],\n        [-4, -4]\n    ],\n    [\n        [-2, -6],\n        [6, -2],\n        [-6, 2],\n        [2, 6]\n    ],\n    [\n        [1, -3],\n        [-1, 3],\n        [5, 1],\n        [-3, -5],\n        [-5, 5],\n        [-7, -1],\n        [3, 7],\n        [7, -7]\n    ],\n    [\n        [1, 1],\n        [-1, -3],\n        [-3, 2],\n        [4, -1],\n        [-5, -2],\n        [2, 5],\n        [5, 3],\n        [3, -5],\n        [-2, 6],\n        [0, -7],\n        [-4, -6],\n        [-6, 4],\n        [-8, 0],\n        [7, -4],\n        [6, 7],\n        [-7, -8]\n    ],\n    [\n        [-4, -7],\n        [-7, -5],\n        [-3, -5],\n        [-5, -4],\n        [-1, -4],\n        [-2, -2],\n        [-6, -1],\n        [-4, 0],\n        [-7, 1],\n        [-1, 2],\n        [-6, 3],\n        [-3, 3],\n        [-7, 6],\n        [-3, 6],\n        [-5, 7],\n        [-1, 7],\n        [5, -7],\n        [1, -6],\n        [6, -5],\n        [4, -4],\n        [2, -3],\n        [7, -2],\n        [1, -1],\n        [4, -1],\n        [2, 1],\n        [6, 2],\n        [0, 4],\n        [4, 4],\n        [2, 5],\n        [7, 5],\n        [5, 6],\n        [3, 7]\n    ]\n];\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst LowResRenderPass_1 = __webpack_require__(/*! ./LowResRenderPass */ \"./node_modules/@here/harp-mapview/lib/composing/LowResRenderPass.js\");\nconst MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ \"./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js\");\nconst Outline_1 = __webpack_require__(/*! ./Outline */ \"./node_modules/@here/harp-mapview/lib/composing/Outline.js\");\nconst Pass_1 = __webpack_require__(/*! ./Pass */ \"./node_modules/@here/harp-mapview/lib/composing/Pass.js\");\nconst UnrealBloomPass_1 = __webpack_require__(/*! ./UnrealBloomPass */ \"./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js\");\nconst DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_1;\nconst DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_4;\n/**\n * The implementation of [[IMapRenderingManager]] to instantiate in [[MapView]] and manage the map\n * rendering.\n */\nclass MapRenderingManager {\n    /**\n     * The constructor of `MapRenderingManager`.\n     *\n     * @param width Width of the frame buffer.\n     * @param height Height of the frame buffer.\n     * @param lowResPixelRatio The `pixelRatio` determines the resolution of the internal\n     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give\n     * good results. A value of `undefined` disables the low res render pass. The value should not\n     * be larger than`window.devicePixelRatio`.\n     * @param antialiasSetting The object defining the demeanor of MSAA.\n     */\n    constructor(width, height, lowResPixelRatio, antialiasSettings = { msaaEnabled: false }) {\n        this.bloom = {\n            enabled: false,\n            strength: 1.5,\n            radius: 0.4,\n            threshold: 0.85\n        };\n        this.outline = {\n            enabled: false,\n            thickness: 0.005,\n            color: \"#000000\",\n            ghostExtrudedPolygons: false,\n            needsUpdate: false\n        };\n        this.vignette = {\n            enabled: false,\n            offset: 1.0,\n            darkness: 1.0\n        };\n        this.sepia = {\n            enabled: false,\n            amount: 0.5\n        };\n        this.m_width = 1;\n        this.m_height = 1;\n        this.m_renderPass = new Pass_1.RenderPass();\n        this.m_target1 = new THREE.WebGLRenderTarget(1, 1);\n        this.m_target2 = new THREE.WebGLRenderTarget(1, 1);\n        this.m_sepiaPass = new Pass_1.ShaderPass(harp_materials_1.SepiaShader);\n        this.m_vignettePass = new Pass_1.ShaderPass(harp_materials_1.VignetteShader);\n        this.m_readBuffer = new THREE.WebGLRenderTarget(width, height);\n        this.m_msaaPass = new MSAARenderPass_1.MSAARenderPass();\n        this.m_msaaPass.enabled =\n            antialiasSettings !== undefined ? antialiasSettings.msaaEnabled === true : false;\n        this.m_dynamicMsaaSamplingLevel =\n            antialiasSettings.dynamicMsaaSamplingLevel === undefined\n                ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL\n                : antialiasSettings.dynamicMsaaSamplingLevel;\n        this.m_staticMsaaSamplingLevel =\n            antialiasSettings.staticMsaaSamplingLevel === undefined\n                ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL\n                : antialiasSettings.staticMsaaSamplingLevel;\n        this.m_lowResPass = new LowResRenderPass_1.LowResRenderPass(lowResPixelRatio);\n        this.m_lowResPass.enabled = lowResPixelRatio !== undefined;\n    }\n    updateOutline(options) {\n        this.outline.color = options.color;\n        this.outline.thickness = options.thickness;\n        this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;\n        this.outline.needsUpdate = true;\n    }\n    /**\n     * The method to call to render the map with the `MapRenderingManager` instance. It contains the\n     * chain of sub-passes that can transfer the write and read buffers, and other sheer rendering\n     * conditions as disabling AA when a high DPI device is in use.\n     *\n     * @param renderer The ThreeJS WebGLRenderer instance to render the map with.\n     * @param scene The ThreeJS Scene instance containing the map objects to render.\n     * @param camera The ThreeJS Camera instance to render the scene through.\n     * @param isStaticFrame Whether the frame to render is static or dynamic. Selects level of\n     * antialiasing.\n     */\n    render(renderer, scene, camera, isStaticFrame) {\n        const target = null;\n        if (!isStaticFrame && this.m_lowResPass.pixelRatio !== undefined) {\n            // Not designed to be combined with our own MSAA\n            this.m_lowResPass.renderToScreen = true;\n            this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);\n            return;\n        }\n        const usePostEffects = this.bloom.enabled ||\n            this.outline.enabled ||\n            this.vignette.enabled ||\n            this.sepia.enabled;\n        let activeTarget = null;\n        // 1. If the bloom is enabled, clear the depth.\n        if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {\n            renderer.setRenderTarget(this.m_target1);\n            renderer.clearDepth();\n        }\n        // 2. Render the map.\n        if (this.m_msaaPass.enabled) {\n            // Use a higher MSAA sampling level for static rendering.\n            this.m_msaaPass.samplingLevel = isStaticFrame\n                ? this.m_staticMsaaSamplingLevel\n                : this.m_dynamicMsaaSamplingLevel;\n            // MSAA is the only effect for the moment.\n            this.m_msaaPass.renderToScreen = !usePostEffects;\n            // Render to the specified target with the MSAA pass.\n            this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);\n        }\n        else {\n            if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {\n                activeTarget = this.m_target1;\n                this.m_renderPass.render(renderer, scene, camera, this.m_target1, null);\n            }\n            else if (!this.outline.enabled || (this.outline.enabled && !this.bloom.enabled)) {\n                renderer.render(scene, camera);\n            }\n        }\n        // 3. Apply effects\n        if (this.outline.enabled) {\n            if (this.m_outlineEffect === undefined) {\n                this.m_outlineEffect = new Outline_1.OutlineEffect(renderer);\n            }\n            if (this.outline.needsUpdate) {\n                this.m_outlineEffect.color = this.outline.color;\n                this.m_outlineEffect.thickness = this.outline.thickness;\n                this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;\n                this.outline.needsUpdate = false;\n            }\n            const nextEffectEnabled = this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;\n            if (nextEffectEnabled) {\n                activeTarget = this.m_target1;\n            }\n            renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null);\n            this.m_outlineEffect.render(scene, camera);\n        }\n        if (this.bloom.enabled) {\n            if (this.m_bloomPass === undefined) {\n                this.m_bloomPass = new UnrealBloomPass_1.BloomPass(new THREE.Vector2(this.m_width, this.m_height), this.bloom.strength, this.bloom.radius, this.bloom.threshold);\n            }\n            const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;\n            this.m_bloomPass.renderToScreen = !nextEffectEnabled;\n            this.m_bloomPass.radius = this.bloom.radius;\n            this.m_bloomPass.strength = this.bloom.strength;\n            this.m_bloomPass.threshold = this.bloom.threshold;\n            this.m_bloomPass.render(renderer, scene, camera, null, activeTarget);\n        }\n        else if (this.m_bloomPass !== undefined) {\n            this.m_bloomPass.dispose();\n            this.m_bloomPass = undefined;\n        }\n        if (this.vignette.enabled) {\n            const oldTarget = activeTarget;\n            const nextEffectEnabled = this.sepia.enabled;\n            this.m_vignettePass.uniforms.offset.value = this.vignette.offset;\n            this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;\n            this.m_vignettePass.renderToScreen = !nextEffectEnabled;\n            if (nextEffectEnabled) {\n                activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;\n            }\n            this.m_vignettePass.render(renderer, scene, camera, activeTarget, oldTarget);\n        }\n        if (this.sepia.enabled) {\n            this.m_sepiaPass.renderToScreen = true;\n            this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;\n            this.m_sepiaPass.render(renderer, scene, camera, null, activeTarget);\n        }\n    }\n    /**\n     * The resize function to call on resize events to resize the render targets. It shall include\n     * the resize methods of all the sub-passes used in `MapRenderingManager`.\n     *\n     * @param width New width to use.\n     * @param height New height to use.\n     */\n    setSize(width, height) {\n        this.m_readBuffer.setSize(width, height);\n        this.m_msaaPass.setSize(width, height);\n        if (this.m_bloomPass !== undefined) {\n            this.m_bloomPass.setSize(width, height);\n        }\n        this.m_lowResPass.setSize(width, height);\n        this.m_target1.setSize(width, height);\n        this.m_target2.setSize(width, height);\n        this.m_width = width;\n        this.m_height = height;\n    }\n    /**\n     * The `lowResPixelRatio` determines the resolution of the internal `WebGLRenderTarget`. Values\n     * between 0.5 and `window.devicePixelRatio` can be tried to give  good results. A value of\n     * `undefined` disables the low res render pass. The value should not be larger than\n     * `window.devicePixelRatio`.\n     */\n    get lowResPixelRatio() {\n        return this.m_lowResPass.pixelRatio;\n    }\n    set lowResPixelRatio(pixelRatio) {\n        this.m_lowResPass.pixelRatio = pixelRatio;\n        this.m_lowResPass.enabled = pixelRatio !== undefined;\n    }\n    /**\n     * Set the level of sampling while the user interacts.\n     *\n     * @param samplingLevel The sampling level.\n     */\n    set dynamicMsaaSamplingLevel(samplingLevel) {\n        this.m_dynamicMsaaSamplingLevel = samplingLevel;\n    }\n    /**\n     * Return the sampling level defined during continuous rendering.\n     */\n    get dynamicMsaaSamplingLevel() {\n        return this.m_dynamicMsaaSamplingLevel;\n    }\n    /**\n     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided\n     * in the [[MapRenderingManager.render]] method to render the scene.\n     *\n     * @param value If `true`, MSAA is enabled, disabled otherwise.\n     */\n    set msaaEnabled(value) {\n        this.m_msaaPass.enabled = value;\n    }\n    /**\n     * Return whether the MSAA is enabled.\n     */\n    get msaaEnabled() {\n        return this.m_msaaPass.enabled;\n    }\n    /**\n     * Set the sampling level for rendering static frames.\n     *\n     * @param samplingLevel The sampling level.\n     */\n    set staticMsaaSamplingLevel(samplingLevel) {\n        this.m_staticMsaaSamplingLevel = samplingLevel;\n    }\n    /**\n     * Return the sampling level defined for rendering static frames.\n     */\n    get staticMsaaSamplingLevel() {\n        return this.m_staticMsaaSamplingLevel;\n    }\n}\nexports.MapRenderingManager = MapRenderingManager;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/Outline.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/Outline.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst vertexShaderChunk = `\n    uniform float outlineThickness;\n\n    vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {\n\n        float thickness = outlineThickness;\n        const float ratio = 1.0;\n        vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );\n        vec4 norm = normalize( pos - pos2 );\n        return pos + norm * thickness * pos.w * ratio;\n\n    }`;\nconst vertexShaderChunk2 = `\n    #if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( STANDARD )\n        #ifndef USE_ENVMAP\n            vec3 objectNormal = normalize( normal );\n        #endif\n    #endif\n\n    #ifdef FLIP_SIDED\n        objectNormal = -objectNormal;\n    #endif\n\n    #ifdef DECLARE_TRANSFORMED\n        vec3 transformed = vec3( position );\n    #endif\n\n    gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );\n\n    #include <fog_vertex>`;\nconst fragmentShader = `\n    #include <common>\n    #include <fog_pars_fragment>\n\n    uniform vec3 outlineColor;\n    uniform float outlineAlpha;\n\n    void main() {\n\n        gl_FragColor = vec4( outlineColor, outlineAlpha );\n\n        #include <fog_fragment>\n\n    }`;\nclass OutlineEffect {\n    constructor(m_renderer) {\n        this.m_renderer = m_renderer;\n        this.enabled = true;\n        this.m_defaultThickness = 0.02;\n        this.m_defaultColor = new THREE.Color(0, 0, 0);\n        this.m_defaultAlpha = 1;\n        this.m_defaultKeepAlive = false;\n        this.m_ghostExtrudedPolygons = false;\n        this.m_cache = {};\n        this.m_removeThresholdCount = 60;\n        this.m_originalMaterials = {};\n        this.m_originalOnBeforeRenders = {};\n        this.m_shaderIDs = {\n            MeshBasicMaterial: \"basic\",\n            MeshLambertMaterial: \"lambert\",\n            MeshPhongMaterial: \"phong\",\n            MeshToonMaterial: \"phong\",\n            MeshStandardMaterial: \"physical\",\n            MeshPhysicalMaterial: \"physical\"\n        };\n        this.m_uniformsChunk = {\n            outlineThickness: { value: this.m_defaultThickness },\n            outlineColor: { value: this.m_defaultColor },\n            outlineAlpha: { value: this.m_defaultAlpha }\n        };\n        this.autoClear = m_renderer.autoClear;\n        this.domElement = m_renderer.domElement;\n        this.shadowMap = m_renderer.shadowMap;\n    }\n    set thickness(thickness) {\n        this.m_defaultThickness = thickness;\n        this.m_uniformsChunk.outlineThickness.value = thickness;\n        this.m_cache = {};\n    }\n    set color(color) {\n        this.m_defaultColor.set(color);\n        this.m_cache = {};\n    }\n    set ghostExtrudedPolygons(ghost) {\n        this.m_ghostExtrudedPolygons = ghost;\n    }\n    clear(color, depth, stencil) {\n        this.m_renderer.clear(color, depth, stencil);\n    }\n    getPixelRatio() {\n        return this.m_renderer.getPixelRatio();\n    }\n    setPixelRatio(value) {\n        this.m_renderer.setPixelRatio(value);\n    }\n    getSize(target) {\n        return this.m_renderer.getSize(target);\n    }\n    setSize(width, height, updateStyle) {\n        this.m_renderer.setSize(width, height, updateStyle);\n    }\n    setViewport(x, y, width, height) {\n        this.m_renderer.setViewport(x, y, width, height);\n    }\n    setScissor(x, y, width, height) {\n        this.m_renderer.setScissor(x, y, width, height);\n    }\n    setScissorTest(boolean) {\n        this.m_renderer.setScissorTest(boolean);\n    }\n    setRenderTarget(renderTarget) {\n        this.m_renderer.setRenderTarget(renderTarget);\n    }\n    render(scene, camera) {\n        // Re-rendering the scene with the outline effect enables to hide the\n        // extruded polygons and show only the outlines (it is a hack and should be\n        // implemented another way!).\n        if (this.m_ghostExtrudedPolygons) {\n            if (!this.enabled) {\n                this.m_renderer.render(scene, camera);\n                return;\n            }\n            const currentAutoClear = this.m_renderer.autoClear;\n            this.m_renderer.autoClear = this.autoClear;\n            this.m_renderer.render(scene, camera);\n            this.m_renderer.autoClear = currentAutoClear;\n        }\n        this.renderOutline(scene, camera);\n    }\n    renderOutline(scene, camera) {\n        const currentAutoClear = this.m_renderer.autoClear;\n        const currentSceneAutoUpdate = scene.autoUpdate;\n        const currentSceneBackground = scene.background;\n        const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;\n        scene.autoUpdate = false;\n        scene.background = null;\n        this.m_renderer.autoClear = false;\n        this.m_renderer.shadowMap.enabled = false;\n        scene.traverse(this.setOutlineMaterial.bind(this));\n        this.m_renderer.render(scene, camera);\n        scene.traverse(this.restoreOriginalMaterial.bind(this));\n        this.cleanupCache();\n        scene.autoUpdate = currentSceneAutoUpdate;\n        scene.background = currentSceneBackground;\n        this.m_renderer.autoClear = currentAutoClear;\n        this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;\n    }\n    createInvisibleMaterial() {\n        return new THREE.ShaderMaterial({ name: \"invisible\", visible: false });\n    }\n    createMaterial(originalMaterial) {\n        const shaderID = this.m_shaderIDs[originalMaterial.type];\n        let originalUniforms;\n        let originalVertexShader;\n        if (shaderID !== undefined) {\n            const shader = THREE.ShaderLib[shaderID];\n            originalUniforms = shader.uniforms;\n            originalVertexShader = shader.vertexShader;\n        }\n        else if (originalMaterial.isRawShaderMaterial === true) {\n            originalUniforms = originalMaterial.uniforms;\n            originalVertexShader = originalMaterial.vertexShader;\n            if (!/attribute\\s+vec3\\s+position\\s*;/.test(originalVertexShader) ||\n                !/attribute\\s+vec3\\s+normal\\s*;/.test(originalVertexShader)) {\n                return this.createInvisibleMaterial();\n            }\n        }\n        else if (originalMaterial.isShaderMaterial === true) {\n            originalUniforms = originalMaterial.uniforms;\n            originalVertexShader = originalMaterial.vertexShader;\n        }\n        else {\n            return this.createInvisibleMaterial();\n        }\n        const uniforms = Object.assign(Object.assign({}, originalUniforms), this.m_uniformsChunk);\n        const vertexShader = originalVertexShader\n            // put vertexShaderChunk right before \"void main() {...}\"\n            .replace(/void\\s+main\\s*\\(\\s*\\)/, vertexShaderChunk + \"\\nvoid main()\")\n            // put vertexShaderChunk2 the end of \"void main() {...}\"\n            // Note: here assums originalVertexShader ends with \"}\" of \"void main() {...}\"\n            .replace(/\\}\\s*$/, vertexShaderChunk2 + \"\\n}\")\n            // remove any light related lines\n            // Note: here is very sensitive to originalVertexShader\n            // TODO: consider safer way\n            .replace(/#include\\s+<[\\w_]*light[\\w_]*>/g, \"\");\n        const defines = {};\n        if (!/vec3\\s+transformed\\s*=/.test(originalVertexShader) &&\n            !/#include\\s+<begin_vertex>/.test(originalVertexShader)) {\n            defines.DECLARE_TRANSFORMED = true;\n        }\n        return new THREE.ShaderMaterial({\n            defines,\n            uniforms,\n            vertexShader,\n            fragmentShader,\n            side: THREE.BackSide,\n            //wireframe: true,\n            skinning: false,\n            morphTargets: false,\n            morphNormals: false,\n            fog: false\n        });\n    }\n    getOutlineMaterialFromCache(originalMaterial) {\n        let data = this.m_cache[originalMaterial.uuid];\n        if (data === undefined) {\n            data = {\n                material: this.createMaterial(originalMaterial),\n                used: true,\n                keepAlive: this.m_defaultKeepAlive,\n                count: 0\n            };\n            this.m_cache[originalMaterial.uuid] = data;\n        }\n        data.used = true;\n        return data.material;\n    }\n    getOutlineMaterial(originalMaterial) {\n        const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);\n        this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;\n        this.updateOutlineMaterial(outlineMaterial, originalMaterial);\n        return outlineMaterial;\n    }\n    setOutlineMaterial(object) {\n        if (object.material === undefined) {\n            return;\n        }\n        if (Array.isArray(object.material)) {\n            for (let i = 0, il = object.material.length; i < il; i++) {\n                object.material[i] = this.getOutlineMaterial(object.material[i]);\n            }\n        }\n        else {\n            object.material = this.getOutlineMaterial(object.material);\n        }\n        this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, this.onBeforeRender.bind(this));\n    }\n    restoreOriginalMaterial(object) {\n        if (object.material === undefined) {\n            return;\n        }\n        if (Array.isArray(object.material)) {\n            for (let i = 0, il = object.material.length; i < il; i++) {\n                object.material[i] = this.m_originalMaterials[object.material[i].uuid];\n            }\n        }\n        else {\n            object.material = this.m_originalMaterials[object.material.uuid];\n        }\n        object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];\n    }\n    onBeforeRender(renderer, scene, camera, geometry, material, group) {\n        const originalMaterial = this.m_originalMaterials[material.uuid];\n        // just in case\n        if (originalMaterial === undefined) {\n            return;\n        }\n        this.updateUniforms(material, originalMaterial);\n    }\n    updateUniforms(material, originalMaterial) {\n        const outlineParameters = originalMaterial.userData.outlineParameters;\n        material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n        if (outlineParameters !== undefined) {\n            if (outlineParameters.thickness !== undefined) {\n                material.uniforms.outlineThickness.value = outlineParameters.thickness;\n            }\n            if (outlineParameters.color !== undefined) {\n                material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n            }\n            if (outlineParameters.alpha !== undefined) {\n                material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n            }\n        }\n    }\n    updateOutlineMaterial(material, originalMaterial) {\n        if (material.name === \"invisible\") {\n            return;\n        }\n        const outlineParameters = originalMaterial.userData.outlineParameters;\n        material.skinning = originalMaterial.skinning;\n        material.morphTargets = originalMaterial.morphTargets;\n        material.morphNormals = originalMaterial.morphNormals;\n        material.fog = originalMaterial.fog;\n        if (outlineParameters !== undefined) {\n            material.visible =\n                originalMaterial.visible === false\n                    ? false\n                    : outlineParameters.visible !== undefined\n                        ? outlineParameters.visible\n                        : true;\n            material.transparent =\n                outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0\n                    ? true\n                    : originalMaterial.transparent;\n            if (outlineParameters.keepAlive !== undefined) {\n                this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n            }\n        }\n        else {\n            material.transparent = originalMaterial.transparent;\n            material.visible = originalMaterial.visible;\n        }\n        if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) {\n            material.visible = false;\n        }\n    }\n    cleanupCache() {\n        let keys;\n        // clear originialMaterials\n        keys = Object.keys(this.m_originalMaterials);\n        for (let i = 0, il = keys.length; i < il; i++) {\n            this.m_originalMaterials[keys[i]] = undefined;\n        }\n        // clear originalOnBeforeRenders\n        keys = Object.keys(this.m_originalOnBeforeRenders);\n        for (let i = 0, il = keys.length; i < il; i++) {\n            this.m_originalOnBeforeRenders[keys[i]] = undefined;\n        }\n        // remove unused outlineMaterial from cache\n        keys = Object.keys(this.m_cache);\n        for (const key of keys) {\n            if (this.m_cache[key].used === false) {\n                this.m_cache[key].count++;\n                if (this.m_cache[key].keepAlive === false &&\n                    this.m_cache[key].count > this.m_removeThresholdCount) {\n                    delete this.m_cache[key];\n                }\n            }\n            else {\n                this.m_cache[key].used = false;\n                this.m_cache[key].count = 0;\n            }\n        }\n    }\n}\nexports.OutlineEffect = OutlineEffect;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/Outline.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/Pass.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/Pass.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * The base class to extend for further passes in [[MapView]], like the [[MSAARenderPass]], possibly\n * a text pass, an AO effect etc. `Pass` provides the core logic for both :\n * - render passes (proper scene renders),\n * - and shader passes (quad renders, i.e. effects added on top of the render output as a\n * postprocess).\n *\n * Even some shader passes still actually fall within the render pass category as they need to\n * re-render the scene to then deduce an effect, such as masking, AO, DoF etc. Others just need the\n * previous input image to apply a shader on top of it, as for bloom or NVIDIA's FXAA for example.\n * These only are proper shader passes.\n */\nclass Pass {\n    constructor() {\n        this.enabled = false;\n        this.renderToScreen = false;\n        // tslint:enable:no-unused-variable\n    }\n    // tslint:disable-next-line:no-unused-variable\n    setSize(width, height) {\n        // Implemented in sub-classes.\n    }\n    // tslint:disable:no-unused-variable\n    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {\n        // Implemented in sub-classes.\n    }\n}\nexports.Pass = Pass;\n/**\n * The pass that does a default normal scene rendering for further post-effects.\n */\nclass RenderPass extends Pass {\n    constructor() {\n        super();\n    }\n    /** @override */\n    render(renderer, scene, camera, writeBuffer, readBuffer) {\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        renderer.render(scene, camera);\n    }\n}\nexports.RenderPass = RenderPass;\n/**\n * The base class to extend for post-effects on the final render (like Vignette, Sepia, color\n * correction...)\n */\nclass ShaderPass extends Pass {\n    constructor(shader, textureID = \"tDiffuse\") {\n        super();\n        this.textureID = textureID;\n        if (shader instanceof THREE.ShaderMaterial) {\n            this.uniforms = shader.uniforms;\n            this.material = shader;\n        }\n        else {\n            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n            this.material = new THREE.ShaderMaterial({\n                defines: Object.assign({}, shader.defines),\n                uniforms: this.uniforms,\n                vertexShader: shader.vertexShader,\n                fragmentShader: shader.fragmentShader\n            });\n        }\n        this.fsQuad = new FullScreenQuad(this.material);\n    }\n    /** @override */\n    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {\n        if (this.uniforms[this.textureID]) {\n            this.uniforms[this.textureID].value = readBuffer.texture;\n        }\n        this.fsQuad.material = this.material;\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        this.fsQuad.render(renderer);\n    }\n}\nexports.ShaderPass = ShaderPass;\nclass FullScreenQuad {\n    constructor(material) {\n        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        const geometry = new THREE.PlaneBufferGeometry(2, 2);\n        this.m_mesh = new THREE.Mesh(geometry, material);\n    }\n    get material() {\n        return this.m_mesh.material;\n    }\n    set material(value) {\n        this.m_mesh.material = value;\n    }\n    render(renderer) {\n        renderer.render(this.m_mesh, this.m_camera);\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/Pass.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Pass_1 = __webpack_require__(/*! ./Pass */ \"./node_modules/@here/harp-mapview/lib/composing/Pass.js\");\nconst BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nconst BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n/**\n * The TS version of ThreeJS's UnrealBloomPass.\n */\nclass BloomPass extends Pass_1.Pass {\n    constructor(resolution, strength, radius, threshold) {\n        super();\n        this.resolution = new THREE.Vector2(256, 256);\n        this.m_renderTargetsHorizontal = [];\n        this.m_renderTargetsVertical = [];\n        this.m_nMips = 5;\n        this.m_separableBlurMaterials = [];\n        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        this.m_scene = new THREE.Scene();\n        this.m_basic = new THREE.MeshBasicMaterial();\n        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));\n        this.m_bloomTintColors = [\n            new THREE.Vector3(1, 1, 1),\n            new THREE.Vector3(1, 1, 1),\n            new THREE.Vector3(1, 1, 1),\n            new THREE.Vector3(1, 1, 1),\n            new THREE.Vector3(1, 1, 1)\n        ];\n        this.strength = strength;\n        this.radius = radius;\n        this.threshold = threshold;\n        this.resolution = resolution;\n        this.m_quad.frustumCulled = false;\n        this.m_scene.add(this.m_quad);\n        const pars = {\n            minFilter: THREE.LinearFilter,\n            magFilter: THREE.LinearFilter,\n            format: THREE.RGBAFormat\n        };\n        let resx = Math.round(this.resolution.x / 2);\n        let resy = Math.round(this.resolution.y / 2);\n        this.m_renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n        this.m_renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n        this.m_renderTargetBright.texture.generateMipmaps = false;\n        for (let i = 0; i < this.m_nMips; i++) {\n            const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);\n            renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n            renderTargetHorizonal.texture.generateMipmaps = false;\n            this.m_renderTargetsHorizontal.push(renderTargetHorizonal);\n            const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);\n            renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n            renderTargetVertical.texture.generateMipmaps = false;\n            this.m_renderTargetsVertical.push(renderTargetVertical);\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n        this.m_highPassUniforms = THREE.UniformsUtils.clone(harp_materials_1.LuminosityHighPassShader.uniforms);\n        // tslint:disable:no-string-literal\n        this.m_highPassUniforms[\"luminosityThreshold\"].value = threshold;\n        this.m_highPassUniforms[\"smoothWidth\"].value = 0.01;\n        this.m_materialHighPassFilter = new THREE.ShaderMaterial({\n            uniforms: this.m_highPassUniforms,\n            vertexShader: harp_materials_1.LuminosityHighPassShader.vertexShader,\n            fragmentShader: harp_materials_1.LuminosityHighPassShader.fragmentShader,\n            defines: {}\n        });\n        // Gaussian Blur Materials\n        const kernelSizeArray = [3, 5, 7, 9, 11];\n        resx = Math.round(this.resolution.x / 2);\n        resy = Math.round(this.resolution.y / 2);\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n            this.m_separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n        // Composite material\n        this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);\n        this.m_compositeMaterial.uniforms[\"blurTexture1\"].value = this.m_renderTargetsVertical[0].texture;\n        this.m_compositeMaterial.uniforms[\"blurTexture2\"].value = this.m_renderTargetsVertical[1].texture;\n        this.m_compositeMaterial.uniforms[\"blurTexture3\"].value = this.m_renderTargetsVertical[2].texture;\n        this.m_compositeMaterial.uniforms[\"blurTexture4\"].value = this.m_renderTargetsVertical[3].texture;\n        this.m_compositeMaterial.uniforms[\"blurTexture5\"].value = this.m_renderTargetsVertical[4].texture;\n        this.m_compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n        this.m_compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n        this.m_compositeMaterial.needsUpdate = true;\n        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n        this.m_compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n        this.m_compositeMaterial.uniforms[\"bloomTintColors\"].value = this.m_bloomTintColors;\n        this.m_copyUniforms = THREE.UniformsUtils.clone(harp_materials_1.CopyShader.uniforms);\n        this.m_copyUniforms[\"opacity\"].value = 1.0;\n        // tslint:enable:no-string-literal\n        this.m_materialCopy = new THREE.ShaderMaterial({\n            uniforms: this.m_copyUniforms,\n            vertexShader: harp_materials_1.CopyShader.vertexShader,\n            fragmentShader: harp_materials_1.CopyShader.fragmentShader,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n            transparent: true\n        });\n    }\n    dispose() {\n        for (const rt of this.m_renderTargetsHorizontal) {\n            rt.dispose();\n        }\n        for (const rt of this.m_renderTargetsVertical) {\n            rt.dispose();\n        }\n        this.m_renderTargetBright.dispose();\n    }\n    /** @override */\n    setSize(width, height) {\n        let resx = Math.round(width / 2);\n        let resy = Math.round(height / 2);\n        this.m_renderTargetBright.setSize(resx, resy);\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_renderTargetsHorizontal[i].setSize(resx, resy);\n            this.m_renderTargetsVertical[i].setSize(resx, resy);\n            // tslint:disable-next-line:no-string-literal\n            this.m_separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n    }\n    /** @override */\n    render(renderer, scene, camera, writeBuffer, readBuffer) {\n        // tslint:disable:no-string-literal\n        // Render input to screen\n        if (this.renderToScreen) {\n            this.m_quad.material = this.m_basic;\n            this.m_basic.map = readBuffer.texture;\n            renderer.setRenderTarget(null);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n        }\n        // 1. Extract bright areas\n        this.m_highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n        this.m_highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n        this.m_quad.material = this.m_materialHighPassFilter;\n        renderer.setRenderTarget(this.m_renderTargetBright);\n        renderer.clear();\n        renderer.render(this.m_scene, this.m_camera);\n        // 2. Blur all the mips progressively\n        let inputRenderTarget = this.m_renderTargetBright;\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_quad.material = this.m_separableBlurMaterials[i];\n            this.m_separableBlurMaterials[i].uniforms[\"colorTexture\"].value =\n                inputRenderTarget.texture;\n            this.m_separableBlurMaterials[i].uniforms[\"direction\"].value = BlurDirectionX;\n            renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n            this.m_separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.m_renderTargetsHorizontal[i].texture;\n            this.m_separableBlurMaterials[i].uniforms[\"direction\"].value = BlurDirectionY;\n            renderer.setRenderTarget(this.m_renderTargetsVertical[i]);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n            inputRenderTarget = this.m_renderTargetsVertical[i];\n        }\n        // Composite all the mips\n        this.m_quad.material = this.m_compositeMaterial;\n        this.m_compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n        this.m_compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n        this.m_compositeMaterial.uniforms[\"bloomTintColors\"].value = this.m_bloomTintColors;\n        renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);\n        renderer.clear();\n        renderer.render(this.m_scene, this.m_camera);\n        // Blend it additively over the input texture\n        this.m_quad.material = this.m_materialCopy;\n        this.m_copyUniforms[\"tDiffuse\"].value = this.m_renderTargetsHorizontal[0].texture;\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null);\n            renderer.render(this.m_scene, this.m_camera);\n        }\n        else {\n            renderer.setRenderTarget(readBuffer);\n            renderer.render(this.m_scene, this.m_camera);\n        }\n        // tslint:enable:no-string-literal\n    }\n    getSeperableBlurMaterial(kernelRadius) {\n        return new THREE.ShaderMaterial({\n            defines: {\n                KERNEL_RADIUS: kernelRadius,\n                SIGMA: kernelRadius\n            },\n            uniforms: {\n                colorTexture: { value: null },\n                texSize: { value: new THREE.Vector2(0.5, 0.5) },\n                direction: { value: new THREE.Vector2(0.5, 0.5) }\n            },\n            vertexShader: `varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }`,\n            fragmentShader: `#include <common>\n            varying vec2 vUv;\n            uniform sampler2D colorTexture;\n            uniform vec2 texSize;\n            uniform vec2 direction;\n\n            float gaussianPdf(in float x, in float sigma) {\n                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n            }\n            void main() {\\n\\\n                vec2 invSize = 1.0 / texSize;\n                float fSigma = float(SIGMA);\n                float weightSum = gaussianPdf(0.0, fSigma);\n                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n                    float x = float(i);\n                    float w = gaussianPdf(x, fSigma);\n                    vec2 uvOffset = direction * invSize * x;\n                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n                    diffuseSum += (sample1 + sample2) * w;\n                    weightSum += 2.0 * w;\n                }\n                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n            }`\n        });\n    }\n    getCompositeMaterial(nMips) {\n        return new THREE.ShaderMaterial({\n            defines: {\n                NUM_MIPS: nMips\n            },\n            uniforms: {\n                blurTexture1: { value: null },\n                blurTexture2: { value: null },\n                blurTexture3: { value: null },\n                blurTexture4: { value: null },\n                blurTexture5: { value: null },\n                dirtTexture: { value: null },\n                bloomStrength: { value: 1.0 },\n                bloomFactors: { value: null },\n                bloomTintColors: { value: null },\n                bloomRadius: { value: 0.0 }\n            },\n            vertexShader: `varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }`,\n            fragmentShader: `varying vec2 vUv;\n                uniform sampler2D blurTexture1;\n                uniform sampler2D blurTexture2;\n                uniform sampler2D blurTexture3;\n                uniform sampler2D blurTexture4;\n                uniform sampler2D blurTexture5;\n                uniform sampler2D dirtTexture;\n                uniform float bloomStrength;\n                uniform float bloomRadius;\n                uniform float bloomFactors[NUM_MIPS];\n                uniform vec3 bloomTintColors[NUM_MIPS];\n\n                float lerpBloomFactor(const in float factor) {\n                    float mirrorFactor = 1.2 - factor;\n                    return mix(factor, mirrorFactor, bloomRadius);\n                }\n\n                void main() {\n                    gl_FragColor = bloomStrength * (\nlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\nlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\nlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\nlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\nlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n                }`\n        });\n    }\n}\nexports.BloomPass = BloomPass;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/UnrealBloomPass.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/composing/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/composing/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MapRenderingManager_1 = __webpack_require__(/*! ./MapRenderingManager */ \"./node_modules/@here/harp-mapview/lib/composing/MapRenderingManager.js\");\nexports.MapRenderingManager = MapRenderingManager_1.MapRenderingManager;\nvar Pass_1 = __webpack_require__(/*! ./Pass */ \"./node_modules/@here/harp-mapview/lib/composing/Pass.js\");\nexports.Pass = Pass_1.Pass;\nvar MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ \"./node_modules/@here/harp-mapview/lib/composing/MSAARenderPass.js\");\nexports.MSAARenderPass = MSAARenderPass_1.MSAARenderPass;\nexports.MSAASampling = MSAARenderPass_1.MSAASampling;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/composing/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n// tslint:disable-next-line:no-var-requires\nconst RBush = __webpack_require__(/*! rbush */ \"./node_modules/rbush/rbush.min.js\");\n/**\n * Base class to provide copyrights based on copyright coverage information, defined by geographical\n * bounding boxes and relevant zoom level ranges.\n */\nclass CopyrightCoverageProvider {\n    constructor() {\n        /** Logger instance. */\n        this.logger = harp_utils_1.LoggerManager.instance.create(\"CopyrightCoverageProvider\");\n    }\n    /** @inheritdoc */\n    getTree() {\n        if (this.m_cachedTreePromise !== undefined) {\n            return this.m_cachedTreePromise;\n        }\n        this.m_cachedTreePromise = this.getCopyrightCoverageData()\n            .then(coverageInfo => this.initRBush(coverageInfo))\n            .catch(error => {\n            this.logger.error(error);\n            return new RBush();\n        });\n        return this.m_cachedTreePromise;\n    }\n    /** @inheritdoc */\n    async getCopyrights(geoBox, level) {\n        const tree = await this.getTree();\n        const result = [];\n        const matchingEntries = tree.search({\n            minX: geoBox.west,\n            minY: geoBox.south,\n            maxX: geoBox.east,\n            maxY: geoBox.north\n        });\n        for (const entry of matchingEntries) {\n            const minLevel = harp_utils_1.getOptionValue(entry.minLevel, 0);\n            const maxLevel = harp_utils_1.getOptionValue(entry.maxLevel, Infinity);\n            if (level >= minLevel && level <= maxLevel) {\n                if (result.find(item => item.id === entry.label) === undefined) {\n                    result.push({ id: entry.label });\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Initializes RBush.\n     *\n     * @param entries Entries for tree.\n     * @returns RBush instance.\n     */\n    initRBush(entries) {\n        const tree = new RBush();\n        if (!entries) {\n            this.logger.warn(\"No copyright coverage data provided\");\n            return tree;\n        }\n        for (const entry of entries) {\n            const { minLevel, maxLevel, label, alt } = entry;\n            if (!entry.boxes) {\n                tree.insert({\n                    minX: -180,\n                    minY: -90,\n                    maxX: 180,\n                    maxY: 180,\n                    minLevel,\n                    maxLevel,\n                    label,\n                    alt\n                });\n            }\n            else {\n                for (const box of entry.boxes) {\n                    const [minY, minX, maxY, maxX] = box;\n                    tree.insert({\n                        minX,\n                        minY,\n                        maxX,\n                        maxY,\n                        minLevel,\n                        maxLevel,\n                        label,\n                        alt\n                    });\n                }\n            }\n        }\n        return tree;\n    }\n}\nexports.CopyrightCoverageProvider = CopyrightCoverageProvider;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst MapView_1 = __webpack_require__(/*! ../MapView */ \"./node_modules/@here/harp-mapview/lib/MapView.js\");\nconst CopyrightInfo_1 = __webpack_require__(/*! ./CopyrightInfo */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js\");\n/**\n * Helper class that maintains up-to-date [[MapView]] copyright information in DOM element.\n *\n * @example\n *\n *     // HTML snippet\n *     <div id=\"copyrightNotice\" style=\"position:absolute; right:0; bottom:0; z-index:100\"></div>\n *\n *     // JavaScript\n *     const mapView = new MapView({ ... });\n *     CopyrightElementHandler.install(\"copyrightNotice\", mapView);\n */\nclass CopyrightElementHandler {\n    /**\n     * Creates a new `CopyrightElementHandler` that updates the DOM element with the copyright info\n     * of the given `mapView`.\n     *\n     * Note: Generally, the static [[install]] method can be used to create and attach a new\n     * `CopyrightElementHandler` to a [[MapView]]\n     *\n     * @param element HTML DOM element or a HTML DOM element id\n     * @param mapView optional, [[attach]] to this [[MapView]] instance\n     */\n    constructor(element, mapView) {\n        this.m_defaults = new Map();\n        this.m_mapViews = [];\n        /**\n         * Update copyright info text in controlled HTML element.\n         */\n        this.update = () => {\n            const mergedCopyrightInfo = this.m_mapViews\n                .map(mapView => mapView.copyrightInfo)\n                .reduce(CopyrightInfo_1.CopyrightInfo.mergeArrays, this.staticInfo || []);\n            // Conditionally hiding of element with copyright information.\n            // If nothing to show we schould to avoid empty white rectangle in right bottom corner.\n            if (mergedCopyrightInfo.length === 0) {\n                this.m_element.style.display = \"none\";\n                return;\n            }\n            else {\n                this.m_element.style.display = \"block\";\n            }\n            if (this.m_defaults.size !== 0) {\n                for (const sourceInfo of mergedCopyrightInfo) {\n                    const defaults = this.m_defaults.get(sourceInfo.id);\n                    if (defaults !== undefined) {\n                        sourceInfo.year = harp_utils_1.getOptionValue(sourceInfo.year, defaults.year);\n                        sourceInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, defaults.label);\n                        sourceInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, defaults.link);\n                    }\n                }\n            }\n            const deduped = CopyrightInfo_1.CopyrightInfo.mergeArrays(mergedCopyrightInfo);\n            this.m_element.innerHTML = CopyrightInfo_1.CopyrightInfo.formatAsHtml(deduped);\n        };\n        if (typeof element === \"string\") {\n            const htmlElement = document.getElementById(element);\n            if (!htmlElement) {\n                throw new Error(`CopyrightElementHandler: unable to find DOM element #${element}`);\n            }\n            this.m_element = htmlElement;\n        }\n        else {\n            this.m_element = element;\n        }\n        if (mapView !== undefined) {\n            this.attach(mapView);\n        }\n    }\n    /**\n     * Install [[CopyrightElementHandler]] on DOM element and - optionally - attach to a [[MapView]]\n     * instance.\n     *\n     * @param element HTML DOM element or a HTML DOM element id\n     * @param mapView, optional, [[attach]] to this [[MapView]]\n     */\n    static install(element, mapView) {\n        return new CopyrightElementHandler(element, mapView);\n    }\n    /**\n     * Destroys this object by removing all event listeners from the attached [[MapView]]s.\n     */\n    destroy() {\n        for (const mapView of this.m_mapViews) {\n            mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);\n        }\n    }\n    /**\n     * Attaches this [[CopyrightInfo]] updates from [[MapView]] instance.\n     */\n    attach(mapView) {\n        this.m_mapViews.push(mapView);\n        mapView.addEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);\n        this.update();\n        return this;\n    }\n    /**\n     * Stop following [[CopyrightInfo]] updates from [[MapView]] instance.\n     */\n    detach(mapView) {\n        mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);\n        this.m_mapViews = this.m_mapViews.filter(item => item !== mapView);\n        this.update();\n        return this;\n    }\n    /**\n     * Set [[CopyrightInfo]] defaults to be used in case [[DataSource]] does not provide deatailed\n     * copyright information.\n     *\n     * The defaults will applied to all undefined `year`, `label` and `link` values in the copyright\n     * information retrieved from [[MapView]].\n     */\n    setDefaults(defaults) {\n        this.m_defaults.clear();\n        if (defaults !== undefined) {\n            for (const item of defaults) {\n                this.m_defaults.set(item.id, item);\n            }\n        }\n        return this;\n    }\n    /**\n     * Sets the [[staticInfo]] property.\n     *\n     * A `CopyrightElementHandler` always displays a deduplicated sum of static copyright info and\n     * copyright information obtained from attached [[MapView]]s.\n     *\n     * This information is used when [[DataSource]] instances of given [[MapView]] do not provide\n     * copyright information.\n     */\n    setStaticCopyightInfo(staticInfo) {\n        this.staticInfo = staticInfo;\n        return this;\n    }\n}\nexports.CopyrightElementHandler = CopyrightElementHandler;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/copyrights/CopyrightElementHandler.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nvar CopyrightInfo;\n(function (CopyrightInfo) {\n    /**\n     * Merge [[CopyrightInfo]] arrays, removing duplicates.\n     *\n     * `id` and `label` are considered keys in deduplication algorithm.\n     *\n     * @param sources non-duplicate elements from this array are added to `target`\n     * @returns merge of all copyright infos in `sources`\n     */\n    function mergeArrays(a, b) {\n        const result = [];\n        for (const source of [a, b]) {\n            if (source === undefined) {\n                continue;\n            }\n            for (const sourceInfo of source) {\n                const existingInfo = result.find(findItem => findItem.id === sourceInfo.id ||\n                    (findItem.label !== undefined && findItem.label === sourceInfo.label));\n                if (existingInfo === undefined) {\n                    result.push(Object.assign({}, sourceInfo));\n                }\n                else {\n                    existingInfo.year = harp_utils_1.MathUtils.max2(sourceInfo.year, existingInfo.year);\n                    existingInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, existingInfo.label);\n                    existingInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, existingInfo.link);\n                }\n            }\n        }\n        return result;\n    }\n    CopyrightInfo.mergeArrays = mergeArrays;\n    /**\n     * Format copyright information to a HTML string that can be displayed in the UI.\n     *\n     * * Empty list returns empty string.\n     * * Entries with empty (but defined) labels are skipped.\n     */\n    function formatAsHtml(copyrightInfo) {\n        if (copyrightInfo.length === 0) {\n            return \"\";\n        }\n        const filtered = copyrightInfo.filter(entry => entry.label !== \"\");\n        if (filtered.length === 0) {\n            return \"\";\n        }\n        return (\"© \" +\n            filtered\n                .map(entry => {\n                const label = entry.label !== undefined ? entry.label : entry.id;\n                const text = entry.year !== undefined ? `${entry.year} ${label}` : label;\n                return entry.link ? `<a href=\"${entry.link}\">${text}</a>` : `${text}`;\n            })\n                .join(\", \"));\n    }\n    CopyrightInfo.formatAsHtml = formatAsHtml;\n})(CopyrightInfo = exports.CopyrightInfo || (exports.CopyrightInfo = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/copyrights/CopyrightInfo.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ \"./node_modules/@here/harp-transfer-manager/index.js\");\nconst CopyrightCoverageProvider_1 = __webpack_require__(/*! ./CopyrightCoverageProvider */ \"./node_modules/@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.js\");\n/**\n * Copyright provider which retrieves copyright coverage information from provided URL.\n */\nclass UrlCopyrightProvider extends CopyrightCoverageProvider_1.CopyrightCoverageProvider {\n    /**\n     * Default constructor.\n     *\n     * @param m_fetchURL URL to fetch copyrights data from.\n     * @param m_baseScheme Scheme to get copyrights from.\n     */\n    constructor(m_fetchURL, m_baseScheme) {\n        super();\n        this.m_fetchURL = m_fetchURL;\n        this.m_baseScheme = m_baseScheme;\n    }\n    /**\n     * @inheritdoc\n     * @override\n     */\n    getCopyrightCoverageData() {\n        if (this.m_cachedCopyrightResponse !== undefined) {\n            return this.m_cachedCopyrightResponse;\n        }\n        this.m_cachedCopyrightResponse = new harp_transfer_manager_1.TransferManager()\n            .downloadJson(this.m_fetchURL)\n            .then(json => json[this.m_baseScheme])\n            .catch(error => {\n            this.logger.error(error);\n            return [];\n        });\n        return this.m_cachedCopyrightResponse;\n    }\n}\nexports.UrlCopyrightProvider = UrlCopyrightProvider;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/PhasedTileGeometryLoader.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/PhasedTileGeometryLoader.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Statistics_1 = __webpack_require__(/*! ../Statistics */ \"./node_modules/@here/harp-mapview/lib/Statistics.js\");\nconst TileGeometryCreator_1 = __webpack_require__(/*! ./TileGeometryCreator */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js\");\nconst TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js\");\n/**\n * The `PhasedTileGeometryLoader` loads the geometry of a [[Tile]] using a list of [[Phase]]s.\n *\n */\nclass PhasedTileGeometryLoader {\n    /**\n     * Creates an instance of PhasedTileGeometryLoader of a [[Tile]]. It stores the phases in which\n     * its geometry should be created.\n     *\n     * @param {Tile} m_tile Tile the loader manages.\n     * @param {Phase[]} m_loadPhaseDefinitions The definitions of the loading phases.\n     * @param {GeometryKindSet} m_basicGeometryKinds The set of [[GeometryKind]] s that have to be\n     *      created before the [[Tile]] is made visible.\n     */\n    constructor(m_tile, m_loadPhaseDefinitions, m_basicGeometryKinds) {\n        this.m_tile = m_tile;\n        this.m_loadPhaseDefinitions = m_loadPhaseDefinitions;\n        this.m_basicGeometryKinds = m_basicGeometryKinds;\n        this.m_isFinished = false;\n        this.m_geometryKindsLoaded = new harp_datasource_protocol_1.GeometryKindSet();\n        this.m_currentPhaseIndex = 0;\n    }\n    /**\n     * The [[Tile]] this loader is managing.\n     */\n    get tile() {\n        return this.m_tile;\n    }\n    /**\n     * The index into the array of loading phases.\n     */\n    get currentPhase() {\n        return this.m_currentPhaseIndex;\n    }\n    /**\n     * The number of phases defined.\n     */\n    get numberOfPhases() {\n        return this.m_loadPhaseDefinitions.length;\n    }\n    /**\n     * The set of [[GeometryKind]]s already created in this [[Tile]].\n     */\n    get geometryKindsCreated() {\n        return this.m_geometryKindsLoaded;\n    }\n    /**\n     * The set of [[GeometryKind]]s available in this [[Tile]].\n     */\n    get availableGeometryKinds() {\n        return this.m_availableGeometryKinds;\n    }\n    /**\n     * Returns `true` if all basic [[GeometryKind]]s have been loaded. The set of basic\n     * [[GeometryKind]]s is defined in the constructor of `PhasedTileGeometryLoader`.\n     */\n    get basicGeometryLoaded() {\n        for (const kind of this.m_basicGeometryKinds) {\n            if (!this.m_geometryKindsLoaded.has(kind)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns `true` if all [[GeometryKind]]s have been loaded.\n     */\n    get allGeometryLoaded() {\n        return this.currentPhase >= this.m_loadPhaseDefinitions.length;\n    }\n    /**\n     * Set the [[DecodedTile]] of the tile. Is called after the decoded tile has been loaded, and\n     * prepares its content for later processing in the 'updateXXX' methods.\n     *\n     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to\n     *      this tile.\n     * @returns {DecodedTile} The processed decoded tile.\n     */\n    setDecodedTile(decodedTile) {\n        this.m_decodedTile = decodedTile;\n        this.m_currentPhaseIndex = 0;\n        this.m_geometryKindsLoaded.clear();\n        if (this.m_decodedTile !== undefined) {\n            this.m_availableGeometryKinds = TileGeometryLoader_1.TileGeometryLoader.prepareDecodedTile(this.m_decodedTile);\n        }\n        return this.m_decodedTile;\n    }\n    /**\n     * Update the tile to have all the content in its decoded tile. Load phases will be ignored.\n     *\n     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be\n     *      enabled.\n     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be\n     *      disabled.\n     * @returns {boolean} `true` if actual geometry has been created.\n     */\n    updateCompletely(enabledKinds, disabledKinds) {\n        return this.update(enabledKinds, disabledKinds, true);\n    }\n    /**\n     * Update the tile to the specified phase (index). All intermediate phases between the current\n     * and the specified phase will be processed.\n     *\n     * @param toPhase A value between 0 and `numberOfPhases`.\n     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be\n     *      enabled.\n     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be\n     *      disabled.\n     * @returns {boolean} `true` if `updateToPhase` was successful.\n     */\n    updateToPhase(toPhase, enabledKinds, disabledKinds) {\n        let didUpdate = false;\n        toPhase = Math.min(toPhase, this.numberOfPhases);\n        while (this.currentPhase < toPhase) {\n            if (!this.update(enabledKinds, disabledKinds)) {\n                break;\n            }\n            didUpdate = true;\n        }\n        return didUpdate;\n    }\n    /**\n     * Create all geometries in the current phase, or ignore the phases and create all remaining\n     * geometries if `doFullUpdate` is `true`.\n     *\n     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be\n     *      enabled.\n     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be\n     *      disabled.\n     * @param doFullUpdate If a value of `true` is specified, the current phase is ignored and all\n     *      remaining geometries are created.\n     * @returns {boolean} `true` if `update` was successful. If `currentPhase` is smaller than\n     *      `numberOfPhases`, `update` can be called again. If `false` is returned, another call to\n     *      `update` is not required.\n     */\n    update(enabledKinds, disabledKinds, doFullUpdate = false) {\n        const tile = this.tile;\n        const loadPhaseDefinitions = this.m_loadPhaseDefinitions;\n        if (!tile.dataSource.cacheable) {\n            this.m_currentPhaseIndex = loadPhaseDefinitions.length;\n            return false;\n        }\n        let decodedTile = this.m_decodedTile;\n        const currentPhase = this.currentPhase;\n        // First time this tile is handled:\n        if (decodedTile === undefined && tile.decodedTile !== undefined) {\n            decodedTile = this.setDecodedTile(tile.decodedTile);\n            TileGeometryCreator_1.TileGeometryCreator.instance.processTechniques(decodedTile, enabledKinds, disabledKinds);\n            tile.clear();\n        }\n        if (decodedTile === undefined || currentPhase >= this.numberOfPhases) {\n            return false;\n        }\n        const geometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;\n        const stats = Statistics_1.PerformanceStatistics.instance;\n        let now = 0;\n        if (stats.enabled) {\n            now = harp_utils_1.PerformanceTimer.now();\n        }\n        if (doFullUpdate) {\n            geometryCreator.createAllGeometries(tile, decodedTile);\n            // Mark it as finished.\n            this.m_currentPhaseIndex = loadPhaseDefinitions.length;\n        }\n        else {\n            const currentPhaseDefinition = loadPhaseDefinitions[currentPhase];\n            for (const kind of currentPhaseDefinition) {\n                this.createKind(geometryCreator, kind);\n            }\n        }\n        if (stats.enabled) {\n            stats.currentFrame.addValue(\"geometry.geometryCreationTime\", harp_utils_1.PerformanceTimer.now() - now);\n        }\n        if (this.nextPhase() === undefined) {\n            // All done, update the stats\n            if (stats.enabled) {\n                const currentFrame = stats.currentFrame;\n                currentFrame.addValue(\"geometryCount.numGeometries\", decodedTile.geometries.length);\n                currentFrame.addValue(\"geometryCount.numTechniques\", decodedTile.techniques.length);\n                currentFrame.addValue(\"geometryCount.numPoiGeometries\", decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0);\n                currentFrame.addValue(\"geometryCount.numTextGeometries\", decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0);\n                currentFrame.addValue(\"geometryCount.numTextPathGeometries\", decodedTile.textPathGeometries !== undefined\n                    ? decodedTile.textPathGeometries.length\n                    : 0);\n                currentFrame.addValue(\"geometryCount.numPathGeometries\", decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0);\n                currentFrame.addMessage(`Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} ` +\n                    `col=${tile.tileKey.column} row=${tile.tileKey.row}`);\n            }\n            this.finish();\n        }\n        return true;\n    }\n    get isFinished() {\n        return this.m_isFinished;\n    }\n    dispose() {\n        this.m_decodedTile = undefined;\n    }\n    reset() {\n        this.m_decodedTile = undefined;\n        this.m_isFinished = false;\n        this.m_availableGeometryKinds = undefined;\n        this.m_geometryKindsLoaded.clear();\n        this.m_currentPhaseIndex = 0;\n    }\n    /**\n     * Increment the current phase to activate the next phase of geometries.\n     *\n     * @returns {(number | undefined)} The index into the now active current pase, or `undefined` if\n     *      the last phase has been reached.\n     */\n    nextPhase() {\n        if (this.m_currentPhaseIndex < this.m_loadPhaseDefinitions.length) {\n            this.m_currentPhaseIndex++;\n        }\n        return this.m_currentPhaseIndex < this.m_loadPhaseDefinitions.length\n            ? this.m_currentPhaseIndex\n            : undefined;\n    }\n    /**\n     * Create all geometries of the specified [[GeometryKind]] `kindToCreate`.\n     *\n     * @param {TileGeometryCreator} geometryCreator\n     * @param {GeometryKind} kindToCreate\n     */\n    createKind(geometryCreator, kindToCreate) {\n        if (this.m_geometryKindsLoaded.has(kindToCreate)) {\n            return;\n        }\n        this.m_geometryKindsLoaded.add(kindToCreate);\n        const tile = this.tile;\n        const decodedTile = this.m_decodedTile;\n        if (decodedTile !== undefined) {\n            const filter = (technique) => {\n                if (technique.enabled === false) {\n                    return false;\n                }\n                const techniqueKind = technique.kind;\n                // All kinds are allowed, except those which are explicitly disabled.\n                if (kindToCreate === harp_datasource_protocol_1.GeometryKind.All) {\n                    return true;\n                }\n                if (techniqueKind instanceof Set) {\n                    const techniqueKinds = techniqueKind;\n                    // Check if that technique fits the expected kindToCreate.\n                    return techniqueKinds.has(kindToCreate);\n                }\n                else {\n                    return techniqueKind === kindToCreate;\n                }\n            };\n            geometryCreator.createObjects(tile, decodedTile, filter);\n            const textFilter = (technique) => {\n                if (!harp_datasource_protocol_1.isPoiTechnique(technique) &&\n                    !harp_datasource_protocol_1.isLineMarkerTechnique(technique) &&\n                    !harp_datasource_protocol_1.isTextTechnique(technique)) {\n                    return false;\n                }\n                return filter(technique);\n            };\n            // TextElements do not get their geometry created by Tile, but are managed on a\n            // higher level.\n            geometryCreator.createTextElements(tile, decodedTile, textFilter);\n            geometryCreator.preparePois(tile, decodedTile);\n        }\n    }\n    finish() {\n        this.m_decodedTile = undefined;\n        this.m_tile.loadingFinished();\n        this.m_tile.removeDecodedTile();\n        this.m_isFinished = true;\n    }\n}\nexports.PhasedTileGeometryLoader = PhasedTileGeometryLoader;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/PhasedTileGeometryLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/PhasedTileGeometryManager.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/PhasedTileGeometryManager.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst PhasedTileGeometryLoader_1 = __webpack_require__(/*! ./PhasedTileGeometryLoader */ \"./node_modules/@here/harp-mapview/lib/geometry/PhasedTileGeometryLoader.js\");\nconst TileGeometryManager_1 = __webpack_require__(/*! ./TileGeometryManager */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js\");\n/**\n * The default phases to load geometry.\n */\nconst DefaultPhases = [\n    [harp_datasource_protocol_1.GeometryKind.Background, harp_datasource_protocol_1.GeometryKind.Terrain, harp_datasource_protocol_1.GeometryKind.Area, harp_datasource_protocol_1.GeometryKind.Border],\n    [harp_datasource_protocol_1.GeometryKind.Line],\n    [harp_datasource_protocol_1.GeometryKind.Building],\n    [harp_datasource_protocol_1.GeometryKind.Label],\n    [harp_datasource_protocol_1.GeometryKind.All]\n];\n// FIXME: This should (always) be the first phase, no?\nconst DefaultBasicGeometryKinds = new harp_datasource_protocol_1.GeometryKindSet(DefaultPhases[0]);\n/**\n * Manages the loading of [[Tile]] geometry in phases.\n */\nclass PhasedTileGeometryManager extends TileGeometryManager_1.TileGeometryManagerBase {\n    /**\n     * Creates an instance of PhasedTileGeometryManager. Keeps the reference to the [[MapView]].\n     *\n     * @param {MapView} mapView\n     */\n    constructor(mapView) {\n        super(mapView);\n        this.m_maxUpdatedTilePerFrame = 5;\n        this.m_loadPhaseDefinitions = DefaultPhases;\n        this.m_basicGeometryKinds = DefaultBasicGeometryKinds;\n    }\n    /** @override */\n    initTile(tile) {\n        if (tile.dataSource.useGeometryLoader) {\n            tile.tileGeometryLoader = new PhasedTileGeometryLoader_1.PhasedTileGeometryLoader(tile, this.m_loadPhaseDefinitions, this.m_basicGeometryKinds);\n        }\n    }\n    /** @override */\n    updateTiles(tiles) {\n        let needUpdate = this.mapView.isDynamicFrame\n            ? this.updateSomeTiles(tiles)\n            : this.updateAllTilesTogether(tiles);\n        if (this.m_tileUpdateCallback) {\n            for (const tile of tiles) {\n                this.m_tileUpdateCallback(tile);\n            }\n        }\n        // updateTileObjectVisibility() has always to be called.\n        needUpdate = this.updateTileObjectVisibility(tiles) || needUpdate;\n        if (needUpdate || !this.checkTilesFinished(tiles)) {\n            this.mapView.update();\n        }\n    }\n    checkTilesFinished(tiles) {\n        for (const tile of tiles) {\n            const phasedGeometryLoader = tile.tileGeometryLoader;\n            if (phasedGeometryLoader !== undefined && !phasedGeometryLoader.allGeometryLoaded) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Update the tiles during dynamic frames. Number of tiles to update may be limited.\n     *\n     * @param {Tile[]} tiles\n     */\n    updateSomeTiles(tiles) {\n        let numTilesUpdated = 0;\n        for (const tile of tiles) {\n            const phasedGeometryLoader = tile.tileGeometryLoader;\n            if (phasedGeometryLoader !== undefined) {\n                if (phasedGeometryLoader.update(this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined)) {\n                    numTilesUpdated++;\n                    if (this.m_maxUpdatedTilePerFrame > 0 &&\n                        numTilesUpdated >= this.m_maxUpdatedTilePerFrame) {\n                        break;\n                    }\n                }\n            }\n        }\n        return numTilesUpdated > 0;\n    }\n    /**\n     * Update the tiles during static frames. Before advancing to the next phase, any tiles lagging\n     * behind are allowed to catch up to their next phase. Only then all tiles will advance to the\n     * next phase together.\n     *\n     * @param {Tile[]} tiles\n     */\n    updateAllTilesTogether(tiles) {\n        let lowestPhase;\n        let needUpdate = false;\n        for (const tile of tiles) {\n            const phasedGeometryLoader = tile.tileGeometryLoader;\n            if (phasedGeometryLoader !== undefined &&\n                (lowestPhase === undefined || phasedGeometryLoader.currentPhase < lowestPhase)) {\n                lowestPhase = phasedGeometryLoader.currentPhase;\n            }\n        }\n        if (lowestPhase !== undefined && lowestPhase < this.m_loadPhaseDefinitions.length) {\n            const nextPhase = lowestPhase + 1;\n            needUpdate = this.updateTilesIfNeeded(tiles, nextPhase);\n        }\n        return needUpdate;\n    }\n    /**\n     * Update the tiles during static frames only if their phase is lower than the `toPhase`.\n     *\n     * @param {Tile[]} tiles\n     */\n    updateTilesIfNeeded(tiles, toPhase) {\n        let needUpdate = false;\n        for (const tile of tiles) {\n            const phasedGeometryLoader = tile.tileGeometryLoader;\n            if (phasedGeometryLoader !== undefined) {\n                if (phasedGeometryLoader.updateToPhase(toPhase, this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined)) {\n                    needUpdate = true;\n                }\n            }\n        }\n        return needUpdate;\n    }\n}\nexports.PhasedTileGeometryManager = PhasedTileGeometryManager;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/PhasedTileGeometryManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst TileGeometry_1 = __webpack_require__(/*! ./TileGeometry */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TileDataAccessor\");\n/**\n * An accessor for all geometries in a tile. This class uses a client-provided [[ITileDataVisitor]]\n * to visit all objects, based on filtering options specified by both, the `TileDataAccessor` and\n * the visitor itself.\n */\nclass TileDataAccessor {\n    /**\n     * Constructs a `TileDataAccessor` instance.\n     *\n     * @param tile The tile to access.\n     * @param visitor The visitor.\n     * @param options Options for the tile.\n     */\n    constructor(tile, visitor, options) {\n        this.tile = tile;\n        this.visitor = visitor;\n        this.m_wantsPoints = true;\n        this.m_wantsLines = true;\n        this.m_wantsAreas = true;\n        this.m_wantsObject3D = true;\n        const wantsAll = options.wantsAll === true;\n        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);\n        this.m_wantsLines = wantsAll || !(options.wantsLines === false);\n        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);\n        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);\n    }\n    /**\n     * Calls the visitor on all objects in the tile.\n     */\n    visitAll() {\n        const objects = this.tile.objects;\n        for (const object of objects) {\n            this.visitObject(object);\n        }\n    }\n    /**\n     * Visits a single object. This function should normally be called during visiting.\n     *\n     * @param object The object to visit.\n     */\n    visitObject(object) {\n        const featureData = object.userData !== undefined\n            ? object.userData.feature\n            : undefined;\n        // early opt out if there is no feature data, or if the feature data has only a single id\n        // and the visitor wants to ignore that featureId\n        if (featureData === undefined ||\n            (featureData.objInfos !== undefined &&\n                featureData.objInfos.length === 1 &&\n                !this.visitor.wantsFeature(harp_datasource_protocol_1.getFeatureId(featureData.objInfos[0])))) {\n            return;\n        }\n        const geometryType = featureData.geometryType;\n        if (geometryType === undefined) {\n            logger.warn(\"#visitObject: visiting object failed, no geometryType\", object);\n            return;\n        }\n        harp_utils_1.assert(featureData.objInfos !== undefined, \"featureData.ids missing\");\n        harp_utils_1.assert(featureData.starts !== undefined, \"featureData.starts missing\");\n        harp_utils_1.assert(Array.isArray(featureData.starts), \"featureData.starts is not an array\");\n        if (featureData.objInfos !== undefined && featureData.starts !== undefined) {\n            harp_utils_1.assert(featureData.objInfos.length === featureData.starts.length, \"featureData.ids and featureData.starts have unequal length\");\n        }\n        switch (geometryType) {\n            case harp_datasource_protocol_1.GeometryType.Point:\n            case harp_datasource_protocol_1.GeometryType.Text:\n                if (!this.m_wantsPoints) {\n                    return;\n                }\n                break;\n            case harp_datasource_protocol_1.GeometryType.SolidLine:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:\n            case harp_datasource_protocol_1.GeometryType.TextPath:\n                if (!this.m_wantsLines) {\n                    return;\n                }\n                break;\n            case harp_datasource_protocol_1.GeometryType.Polygon:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:\n                if (!this.m_wantsAreas) {\n                    return;\n                }\n                break;\n            case harp_datasource_protocol_1.GeometryType.Object3D:\n                if (!this.m_wantsObject3D) {\n                    return;\n                }\n                break;\n            default:\n                logger.warn(\"#visitObject: invalid geometryType\");\n        }\n        if (object.type !== \"Mesh\") {\n            logger.warn(\"#visitObject: visiting object failed, not of type 'Mesh'\", object);\n            return;\n        }\n        const mesh = object;\n        this.visitMesh(mesh, featureData);\n    }\n    /**\n     * Gets the `BufferGeometry` from the specified object. This function requires the\n     * attribute `position` in `BufferGeometry` to be set.\n     *\n     * @param object The object from which to get the geometry.\n     * @returns the geometry of the object, or `undefined`.\n     */\n    getBufferGeometry(object) {\n        const geometry = object.geometry;\n        if (geometry.type !== \"BufferGeometry\") {\n            logger.warn(\"#visitObject: object does not have BufferGeometry\");\n            return undefined;\n        }\n        const bufferGeometry = geometry;\n        // we know its a BufferAttribute because it is a BufferGeometry\n        const position = bufferGeometry.getAttribute(\"position\");\n        if (!position) {\n            logger.warn(\"#visitLines: BufferGeometry has no position attribute\");\n            return undefined;\n        }\n        return bufferGeometry;\n    }\n    /**\n     * Obtains an accessor for the nonindexed geometry. This function may return `undefined`\n     * if the accessor is not implemented.\n     *\n     * @param geometryType The type of geometry.\n     * @param object The object for which to access the attributes and geometry.\n     * @param bufferGeometry The object's `BufferGeometry`.\n     * @returns an accessor for a specified object, if available.\n     */\n    getGeometryAccessor(geometryType, object, bufferGeometry) {\n        switch (geometryType) {\n            case harp_datasource_protocol_1.GeometryType.Point:\n            case harp_datasource_protocol_1.GeometryType.Text:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case harp_datasource_protocol_1.GeometryType.SolidLine:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:\n            case harp_datasource_protocol_1.GeometryType.TextPath:\n                return new TileGeometry_1.BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n            case harp_datasource_protocol_1.GeometryType.Polygon:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case harp_datasource_protocol_1.GeometryType.Object3D:\n                return new TileGeometry_1.BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);\n            default:\n                logger.warn(\"#getGeometryAccessor: invalid geometryType\");\n        }\n        return undefined;\n    }\n    /**\n     * Obtains an accessor for the indexed geometry. This function may return `undefined`\n     * if the accessor is not implemented.\n     *\n     * @param geometryType The type of geometry.\n     * @param object The object for which to access the attributes and geometry.\n     * @param bufferGeometry The object's `BufferGeometry`.\n     * @returns an accessor for a specified object, if available.\n     */\n    getIndexedGeometryAccessor(geometryType, object, bufferGeometry) {\n        switch (geometryType) {\n            case harp_datasource_protocol_1.GeometryType.Point:\n            case harp_datasource_protocol_1.GeometryType.Text:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case harp_datasource_protocol_1.GeometryType.SolidLine:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:\n            case harp_datasource_protocol_1.GeometryType.TextPath:\n                return new TileGeometry_1.IndexedBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n            case harp_datasource_protocol_1.GeometryType.Polygon:\n            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case harp_datasource_protocol_1.GeometryType.Object3D:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            default:\n                logger.warn(\"#getIndexedGeometryAccessor: invalid geometryType\");\n        }\n        return undefined;\n    }\n    /**\n     * Visit the object.\n     *\n     * @param meshObject Object of type `Mesh`.\n     * @param featureData Dataset stored along with the object.\n     */\n    visitMesh(meshObject, featureData) {\n        const { objInfos, starts } = featureData;\n        const geometryType = featureData.geometryType;\n        // make linter happy: we already know that these both are valid\n        if (objInfos === undefined || starts === undefined || geometryType === undefined) {\n            return;\n        }\n        let geometryAccessor;\n        for (let featureIndex = 0; featureIndex < objInfos.length; featureIndex++) {\n            const featureId = harp_datasource_protocol_1.getFeatureId(objInfos[featureIndex]);\n            if (!this.visitor.wantsFeature(featureId)) {\n                continue;\n            }\n            const featureStart = starts[featureIndex];\n            let featureEnd = -1;\n            // lazy creation of accessor, in case featureId was not wanted...\n            if (geometryAccessor === undefined) {\n                const bufferGeometry = this.getBufferGeometry(meshObject);\n                if (bufferGeometry === undefined) {\n                    continue;\n                }\n                if (bufferGeometry.index !== null) {\n                    geometryAccessor = this.getIndexedGeometryAccessor(geometryType, meshObject, bufferGeometry);\n                }\n                else {\n                    geometryAccessor = this.getGeometryAccessor(geometryType, meshObject, bufferGeometry);\n                }\n                if (geometryAccessor === undefined) {\n                    logger.warn(\"#visitObject: no accessor geometryType\", geometryType);\n                    continue;\n                }\n            }\n            featureEnd =\n                featureIndex < starts.length - 1\n                    ? starts[featureIndex + 1]\n                    : geometryAccessor.getCount();\n            // setup/update the accessor for the new range of the object\n            geometryAccessor.setRange(featureStart, featureEnd);\n            switch (geometryType) {\n                case harp_datasource_protocol_1.GeometryType.Point:\n                case harp_datasource_protocol_1.GeometryType.Text:\n                    this.visitor.visitPoint(featureId);\n                    break;\n                case harp_datasource_protocol_1.GeometryType.SolidLine:\n                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:\n                case harp_datasource_protocol_1.GeometryType.TextPath:\n                    harp_utils_1.assert(TileGeometry_1.isLineAccessor(geometryAccessor));\n                    this.visitor.visitLine(featureId, geometryAccessor);\n                    break;\n                case harp_datasource_protocol_1.GeometryType.Polygon:\n                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:\n                    this.visitor.visitArea(featureId);\n                    break;\n                case harp_datasource_protocol_1.GeometryType.Object3D:\n                    harp_utils_1.assert(TileGeometry_1.isObject3dAccessor(geometryAccessor));\n                    this.visitor.visitObject3D(featureId, geometryAccessor);\n                    break;\n                default:\n                    logger.warn(\"#visitObject: invalid geometryType\");\n            }\n        }\n    }\n}\nexports.TileDataAccessor = TileDataAccessor;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/TileDataAccessor.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_lines_1 = __webpack_require__(/*! @here/harp-lines */ \"./node_modules/@here/harp-lines/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TileGeometry\");\n/**\n * Helper function to check if an accessor is of type `ILineAccessor`.\n *\n * @param arg `true` if `arg` is `ILineAccessor`.\n */\nfunction isLineAccessor(arg) {\n    /**\n     * Get vertices from the object.\n     *\n     * @param mode Specifies which part of the vertices should be returned.\n     */\n    return typeof arg.isLineAccessor === \"function\" && arg.isLineAccessor() === true;\n}\nexports.isLineAccessor = isLineAccessor;\n/**\n * Helper function to check if an accessor is of type `IObject3dAccessor`.\n *\n * @param arg `true` if `arg` is `IObject3dAccessor`.\n */\nfunction isObject3dAccessor(arg) {\n    return typeof arg.isObject3dAccessor === \"function\" && arg.isObject3dAccessor() === true;\n}\nexports.isObject3dAccessor = isObject3dAccessor;\n/**\n * Geometry accessor for both indexed and nonindexed `BufferedGeometry`.\n */\nclass BufferedGeometryAccessorBase {\n    constructor(object, geometryType, bufferGeometry) {\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n        this.start = -1;\n        this.end = -1;\n        this.startCapSize = 0;\n        this.endCapSize = 0;\n        harp_utils_1.assert(!!object);\n        if (bufferGeometry.type !== \"BufferGeometry\") {\n            logger.error(\"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong \" + \"type\");\n        }\n        harp_utils_1.assert(bufferGeometry.type === \"BufferGeometry\", \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type\");\n        // we know its a BufferAttribute because it is a BufferGeometry\n        this.position = this.bufferGeometry.getAttribute(\"position\");\n        this.itemSize = this.position.itemSize;\n        if (!this.position) {\n            logger.warn(\"BufferedGeometryAccessor#constructor: BufferGeometry has no position \" +\n                \"attribute\");\n        }\n        if (this.position.array.constructor !== Float32Array) {\n            logger.warn(\"BufferedGeometryAccessor#constructor: BufferGeometry.position: \" +\n                \"unsupported ArrayBuffer\");\n        }\n    }\n    /**\n     * Get the number of accessible geometries in this buffer.\n     *\n     * @returns Number of primitives in this geometry.\n     */\n    getCount() {\n        return this.position.count;\n    }\n    /**\n     * Get `renderOrder` of object.\n     *\n     * @returns `renderOrder` of the object.\n     */\n    get renderOrder() {\n        return this.object.renderOrder;\n    }\n    setRange(start, end, startCapSize = 0, endCapSize = 0) {\n        harp_utils_1.assert(start >= 0);\n        harp_utils_1.assert(end >= 0);\n        harp_utils_1.assert(start <= end);\n        this.start = start;\n        this.end = end;\n        this.startCapSize = startCapSize;\n        this.endCapSize = endCapSize;\n    }\n    /**\n     * Get one or more colors from materials.\n     */\n    get color() {\n        /**\n         * TODO: Get color(s) from vertex colors\n         */\n        const getColor = (material) => {\n            const meshMaterial = material;\n            if (meshMaterial.type === \"MeshBasicMaterial\" ||\n                meshMaterial.type === \"MeshStandardMaterial\") {\n                return meshMaterial.color;\n            }\n            else if (meshMaterial.type === \"RawShaderMaterial\") {\n                const rawShaderMaterial = material;\n                if (rawShaderMaterial.name === \"SolidLineMaterial\") {\n                    return rawShaderMaterial.uniforms.diffuse.value;\n                }\n                logger.warn(\"BufferedGeometryAccessor#color: unknown shader material name\", rawShaderMaterial.name);\n            }\n            else {\n                logger.warn(\"BufferedGeometryAccessor#color: unknown material type\", meshMaterial.type);\n            }\n            return undefined;\n        };\n        if (Array.isArray(this.object.material)) {\n            const results = new Array();\n            const materials = this.object.material;\n            for (const material of materials) {\n                results.push(getColor(material));\n            }\n            return results;\n        }\n        else {\n            return getColor(this.object.material);\n        }\n    }\n}\nexports.BufferedGeometryAccessorBase = BufferedGeometryAccessorBase;\n/**\n * Abstract base class of an accessor for nonindexed geometry.\n */\nclass BufferedGeometryAccessor extends BufferedGeometryAccessorBase {\n    /**\n     * Create an object of type `BufferedGeometryAccessor`\n     *\n     * @param object - mesh object\n     * @param geometryType - type of geometry to be used\n     * @param bufferGeometry - which buffer geometry to use\n     * @param stride - geometry stride length\n     */\n    constructor(object, geometryType, bufferGeometry, stride) {\n        super(object, geometryType, bufferGeometry);\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n        this.stride = stride;\n    }\n    clear() {\n        harp_utils_1.assert(this.checkSetUp(), \"BufferedGeometryAccessor not setup\");\n        const positionsArray = this.position.array;\n        const start = this.start * this.itemSize;\n        const end = this.end * this.itemSize;\n        for (let i = start; i < end; i++) {\n            positionsArray[i] = 0;\n        }\n        this.position.needsUpdate = true;\n    }\n    getVertices() {\n        harp_utils_1.assert(this.checkSetUp(), \"BufferedGeometryAccessor not setup\");\n        const start = this.start;\n        const end = this.end;\n        return this.position.array.subarray(start * this.itemSize, end * this.itemSize);\n    }\n    checkSetUp() {\n        return (this.position !== undefined &&\n            this.start !== undefined &&\n            this.end !== undefined &&\n            this.start >= 0 &&\n            this.end <= this.position.count &&\n            this.start <= this.end);\n    }\n}\nexports.BufferedGeometryAccessor = BufferedGeometryAccessor;\n/**\n * Accessor for nonindexed line geometry.\n */\nclass BufferedGeometryLineAccessor extends BufferedGeometryAccessor {\n    constructor(object, geometryType, bufferGeometry) {\n        super(object, geometryType, bufferGeometry, 3);\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n    }\n    isLineAccessor() {\n        return true;\n    }\n    get width() {\n        //TODO: There is no implementation of such a line, yet...\n        harp_utils_1.assert(this.checkSetUp(), \"RoBufferedGeometryLineAccessor not setup\");\n        return undefined;\n    }\n}\nexports.BufferedGeometryLineAccessor = BufferedGeometryLineAccessor;\n/**\n * Accessor for nonindexed unspecified (`Object3D`) geometry.\n */\nclass BufferedGeometryObject3dAccessor extends BufferedGeometryAccessor {\n    constructor(object, geometryType, bufferGeometry) {\n        super(object, geometryType, bufferGeometry, 1);\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n    }\n    isObject3dAccessor() {\n        return true;\n    }\n    /** @override */\n    getVertices() {\n        return super.getVertices();\n    }\n}\nexports.BufferedGeometryObject3dAccessor = BufferedGeometryObject3dAccessor;\n/**\n * Abstract base class of indexed geometry.\n */\nclass IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {\n    /**\n     * Creates an abstract class `IndexedBufferedGeometryAccessor`.\n     *\n     * @param object - mesh to be used\n     * @param geometryType - type of geometry\n     * @param bufferGeometry - geometry used\n     * @param start\n     * @param end\n     */\n    constructor(object, geometryType, bufferGeometry, \n    // tslint:disable-next-line:no-unused-variable\n    start, \n    // tslint:disable-next-line:no-unused-variable\n    end) {\n        super(object, geometryType, bufferGeometry);\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n        this.indices =\n            this.bufferGeometry.index !== null\n                ? this.bufferGeometry.index.array\n                : undefined;\n        if (!this.indices) {\n            logger.warn(\"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no \" + \"index\");\n            harp_utils_1.assert(!!this.indices);\n        }\n        else {\n            if (!(this.indices instanceof Uint32Array)) {\n                logger.warn(\"IndexedBufferedGeometryAccessor#constructor: BufferGeometry index \" +\n                    \"has wrong type\");\n                harp_utils_1.assert(this.indices instanceof Uint32Array);\n            }\n        }\n    }\n    /**\n     * Returns number of primitives, which is not known in this base class, so we return the number\n     * of indices.\n     *\n     * @returns The number of indices in the geometry.\n     * @override\n     */\n    getCount() {\n        return this.indices.length;\n    }\n    checkSetUp() {\n        return (!!this.indices &&\n            this.start !== undefined &&\n            this.end !== undefined &&\n            this.start >= 0 &&\n            this.end <= this.indices.length &&\n            this.start <= this.end);\n    }\n}\nexports.IndexedBufferedGeometryAccessor = IndexedBufferedGeometryAccessor;\n/**\n * Accessor for lines in an indexed geometry.\n */\nclass IndexedBufferedGeometryLineAccessor extends IndexedBufferedGeometryAccessor {\n    constructor(object, geometryType, bufferGeometry) {\n        super(object, geometryType, bufferGeometry, 3);\n        this.object = object;\n        this.geometryType = geometryType;\n        this.bufferGeometry = bufferGeometry;\n    }\n    isLineAccessor() {\n        return true;\n    }\n    /**\n     * Reconstructs line width from triangulated geometry.\n     *\n     * @returns Line width.\n     */\n    get width() {\n        harp_utils_1.assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n        if (this.geometryType === harp_datasource_protocol_1.GeometryType.ExtrudedLine) {\n            const start = this.start + this.startCapSize;\n            const positionArray = this.position.array;\n            return harp_lines_1.reconstructLineWidth(positionArray, start);\n        }\n        return undefined;\n    }\n    clear() {\n        harp_utils_1.assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n        const start = this.start;\n        const end = this.end;\n        for (let i = start; i < end; i++) {\n            this.indices[i] = 0;\n        }\n        if (this.bufferGeometry.index !== null) {\n            this.bufferGeometry.index.needsUpdate = true;\n        }\n    }\n    getVertices() {\n        harp_utils_1.assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n        const itemSize = this.itemSize;\n        const start = this.start;\n        const end = this.end;\n        const result = new Float32Array((end - start) * itemSize);\n        const positionArray = this.position.array;\n        if (itemSize === 2) {\n            for (let i = start, j = 0; i < end; i++, j += itemSize) {\n                const index = this.indices[i];\n                result[j + 0] = positionArray[index * itemSize + 0];\n                result[j + 1] = positionArray[index * itemSize + 1];\n            }\n        }\n        if (itemSize === 3) {\n            for (let i = start, j = 0; i < end; i++, j += itemSize) {\n                const index = this.indices[i];\n                result[j + 0] = positionArray[index * itemSize + 0];\n                result[j + 1] = positionArray[index * itemSize + 1];\n                result[j + 2] = positionArray[index * itemSize + 2];\n            }\n        }\n        else {\n            for (let i = start, j = 0; i < end; i++, j++) {\n                const index = this.indices[i];\n                for (let k = 0; k < itemSize; k++) {\n                    result[j * itemSize + k] = positionArray[index * itemSize + k];\n                }\n            }\n        }\n        return result;\n    }\n}\nexports.IndexedBufferedGeometryLineAccessor = IndexedBufferedGeometryLineAccessor;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/TileGeometry.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\n// tslint:disable:max-line-length\nconst SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst AnimatedExtrusionHandler_1 = __webpack_require__(/*! ../AnimatedExtrusionHandler */ \"./node_modules/@here/harp-mapview/lib/AnimatedExtrusionHandler.js\");\nconst ColorCache_1 = __webpack_require__(/*! ../ColorCache */ \"./node_modules/@here/harp-mapview/lib/ColorCache.js\");\nconst DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\");\nconst DepthPrePass_1 = __webpack_require__(/*! ../DepthPrePass */ \"./node_modules/@here/harp-mapview/lib/DepthPrePass.js\");\nconst MapView_1 = __webpack_require__(/*! ../MapView */ \"./node_modules/@here/harp-mapview/lib/MapView.js\");\nconst PathBlockingElement_1 = __webpack_require__(/*! ../PathBlockingElement */ \"./node_modules/@here/harp-mapview/lib/PathBlockingElement.js\");\nconst TextElement_1 = __webpack_require__(/*! ../text/TextElement */ \"./node_modules/@here/harp-mapview/lib/text/TextElement.js\");\nconst TextElementsRenderer_1 = __webpack_require__(/*! ../text/TextElementsRenderer */ \"./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js\");\nconst TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TileGeometryCreator\");\nconst tmpVector3 = new THREE.Vector3();\nconst tmpVector2 = new THREE.Vector2();\n/**\n * Support class to create geometry for a [[Tile]] from a [[DecodedTile]].\n */\nclass TileGeometryCreator {\n    /**\n     *  Creates an instance of TileGeometryCreator. Access is allowed only through `instance`.\n     */\n    constructor() {\n        //\n    }\n    /**\n     * The `instance` of the `TileGeometryCreator`.\n     *\n     * @returns TileGeometryCreator\n     */\n    static get instance() {\n        return this.m_instance || (this.m_instance = new TileGeometryCreator());\n    }\n    /**\n     * Apply `enabledKinds` and `disabledKinds` to all techniques in the `decodedTile`. If a\n     * technique is identified as disabled, its property `enabled` is set to `false`.\n     *\n     * @param decodedTile The decodedTile containing the actual tile map data.\n     * @param enabledKinds Optional [[GeometryKindSet]] used to specify which object kinds should be\n     *      created.\n     * @param disabledKinds Optional [[GeometryKindSet]] used to filter objects that should not be\n     *      created.\n     */\n    initDecodedTile(decodedTile, enabledKinds, disabledKinds) {\n        for (const technique of decodedTile.techniques) {\n            // Already processed\n            if (technique.enabled !== undefined) {\n                continue;\n            }\n            // Turn technique.kind from the style, which may be a string or an array of strings,\n            // into a GeometryKindSet.\n            if (technique.kind !== undefined) {\n                if (Array.isArray(technique.kind)) {\n                    technique.kind = new harp_datasource_protocol_1.GeometryKindSet(technique.kind);\n                }\n                else if (typeof technique.kind !== \"string\") {\n                    logger.warn(\"Technique has unknown type of kind:\", technique);\n                    technique.kind = undefined;\n                }\n            }\n            // No info about kind, no way to filter it.\n            if (technique.kind === undefined ||\n                (technique.kind instanceof Set && technique.kind.size === 0)) {\n                technique.enabled = true;\n                continue;\n            }\n            technique.enabled =\n                !(disabledKinds !== undefined && disabledKinds.hasOrIntersects(technique.kind)) ||\n                    (enabledKinds !== undefined && enabledKinds.hasOrIntersects(technique.kind));\n        }\n        for (const srcGeometry of decodedTile.geometries) {\n            for (const group of srcGeometry.groups) {\n                group.createdOffsets = [];\n            }\n        }\n        // compile the dynamic expressions.\n        decodedTile.techniques.forEach((technique) => {\n            for (const propertyName in technique) {\n                if (!technique.hasOwnProperty(propertyName)) {\n                    continue;\n                }\n                const value = technique[propertyName];\n                if (harp_datasource_protocol_1.isJsonExpr(value) && propertyName !== \"kind\") {\n                    // \"kind\" is reserved.\n                    try {\n                        technique[propertyName] = harp_datasource_protocol_1.Expr.fromJSON(value);\n                    }\n                    catch (error) {\n                        logger.error(\"#initDecodedTile: Failed to compile expression:\", error);\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Called after the `Tile` has been decoded. It is required to call `initDecodedTile` before\n     * calling this method.\n     *\n     * @see [[TileGeometryCreator#initDecodedTile]]\n     *\n     * @param tile The [[Tile]] to process.\n     * @param decodedTile The decodedTile containing the actual tile map data.\n     */\n    createAllGeometries(tile, decodedTile) {\n        const filter = (technique) => {\n            return technique.enabled !== false;\n        };\n        if (decodedTile.maxGeometryHeight !== undefined) {\n            tile.maxGeometryHeight = decodedTile.maxGeometryHeight;\n        }\n        this.createObjects(tile, decodedTile, filter);\n        this.preparePois(tile, decodedTile);\n        // TextElements do not get their geometry created by Tile, but are managed on a\n        // higher level.\n        const textFilter = (technique) => {\n            if (!harp_datasource_protocol_1.isPoiTechnique(technique) &&\n                !harp_datasource_protocol_1.isLineMarkerTechnique(technique) &&\n                !harp_datasource_protocol_1.isTextTechnique(technique)) {\n                return false;\n            }\n            return filter(technique);\n        };\n        this.createTextElements(tile, decodedTile, textFilter);\n        this.createLabelRejectionElements(tile, decodedTile);\n        // HARP-7899, disable ground plane for globe\n        if (tile.dataSource.addGroundPlane && tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n            // The ground plane is required for when we change the zoom back and we fall back to the\n            // parent, in that case we reduce the renderOrder of the parent tile and this ground\n            // place ensures that parent doesn't come through. This value must be above the\n            // renderOrder of all objects in the fallback tile, otherwise there won't be a proper\n            // covering of the parent tile by the children, hence dividing by 2. To put a bit more\n            // concretely, we assume all objects are rendered with a renderOrder between 0 and\n            // FALLBACK_RENDER_ORDER_OFFSET / 2, i.e. 10000. The ground plane is put at -10000, and\n            // the fallback tiles have their renderOrder set between -20000 and -10000\n            TileGeometryCreator.instance.addGroundPlane(tile, -MapView_1.FALLBACK_RENDER_ORDER_OFFSET / 2);\n        }\n    }\n    createLabelRejectionElements(tile, decodedTile) {\n        if (decodedTile.pathGeometries === undefined) {\n            return;\n        }\n        for (const path of decodedTile.pathGeometries) {\n            tile.addBlockingElement(new PathBlockingElement_1.PathBlockingElement(path.path));\n        }\n    }\n    /**\n     * Apply enabled and disabled kinds as a filter.\n     *\n     * @param {DecodedTile} decodedTile\n     * @param {(GeometryKindSet | undefined)} enabledKinds\n     * @param {(GeometryKindSet | undefined)} disabledKinds\n     */\n    processTechniques(decodedTile, enabledKinds, disabledKinds) {\n        if (decodedTile === undefined) {\n            return;\n        }\n        for (const technique of decodedTile.techniques) {\n            // Make sure that all technique have their geometryKind set, either from the Theme or\n            // their default value.\n            if (technique.kind === undefined) {\n                TileGeometryLoader_1.TileGeometryLoader.setDefaultGeometryKind(technique);\n            }\n        }\n        // Speedup and simplify following code: Test all techniques if they intersect with\n        // enabledKinds and disabledKinds, in which case they are flagged. The disabledKinds can be\n        // ignored hereafter.\n        this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);\n    }\n    /**\n     * Adds a THREE object to the root of the tile. Sets the owning tiles datasource.name and the\n     * tileKey in the `userData` property of the object, such that the tile it belongs to can be\n     * identified during picking.\n     *\n     * @param tile The [[Tile]] to add the object to.\n     * @param object The object to add to the root of the tile.\n     * @param geometryKind The kind of object. Can be used for filtering.\n     */\n    registerTileObject(tile, object, geometryKind) {\n        if (object.userData === undefined) {\n            object.userData = {};\n        }\n        const userData = object.userData;\n        userData.tileKey = tile.tileKey;\n        userData.dataSource = tile.dataSource.name;\n        userData.kind =\n            geometryKind instanceof Set\n                ? Array.from(geometryKind.values())\n                : Array.isArray(geometryKind)\n                    ? geometryKind\n                    : [geometryKind];\n        // Force a visibility check of all objects.\n        tile.resetVisibilityCounter();\n    }\n    /**\n     * Splits the text paths that contain sharp corners.\n     *\n     * @param tile The [[Tile]] to process paths on.\n     * @param textPathGeometries The original path geometries that may have defects.\n     * @param textFilter: Optional filter. Should return true for any text technique that is\n     *      applicable.\n     */\n    prepareTextPaths(textPathGeometries, decodedTile, textFilter) {\n        const processedPaths = new Array();\n        const newPaths = textPathGeometries.slice();\n        while (newPaths.length > 0) {\n            const textPath = newPaths.pop();\n            if (textPath === undefined) {\n                break;\n            }\n            const technique = decodedTile.techniques[textPath.technique];\n            if (!harp_datasource_protocol_1.isTextTechnique(technique) ||\n                (textFilter !== undefined && !textFilter(technique))) {\n                continue;\n            }\n            processedPaths.push(textPath);\n        }\n        return processedPaths;\n    }\n    /**\n     * Creates [[TextElement]] objects from the decoded tile and list of materials specified. The\n     * priorities of the [[TextElement]]s are updated to simplify label placement.\n     *\n     * @param tile The [[Tile]] to create the testElements on.\n     * @param decodedTile The [[DecodedTile]].\n     * @param textFilter: Optional filter. Should return true for any text technique that is\n     *      applicable.\n     */\n    createTextElements(tile, decodedTile, textFilter) {\n        const mapView = tile.mapView;\n        const textElementsRenderer = mapView.textElementsRenderer;\n        const displayZoomLevel = Math.floor(mapView.zoomLevel);\n        const worldOffsetX = tile.computeWorldOffsetX();\n        if (decodedTile.textPathGeometries !== undefined) {\n            const textPathGeometries = this.prepareTextPaths(decodedTile.textPathGeometries, decodedTile, textFilter);\n            for (const textPath of textPathGeometries) {\n                const technique = decodedTile.techniques[textPath.technique];\n                if (technique.enabled === false ||\n                    !harp_datasource_protocol_1.isTextTechnique(technique) ||\n                    (textFilter !== undefined && !textFilter(technique))) {\n                    continue;\n                }\n                const path = [];\n                for (let i = 0; i < textPath.path.length; i += 3) {\n                    path.push(new THREE.Vector3(textPath.path[i] + worldOffsetX, textPath.path[i + 1], textPath.path[i + 2]));\n                }\n                // Make sorting stable.\n                const priority = technique.priority !== undefined\n                    ? harp_datasource_protocol_1.getPropertyValue(technique.priority, displayZoomLevel)\n                    : 0;\n                const fadeNear = technique.fadeNear !== undefined\n                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)\n                    : technique.fadeNear;\n                const fadeFar = technique.fadeFar !== undefined\n                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)\n                    : technique.fadeFar;\n                const userData = textPath.objInfos;\n                const featureId = harp_datasource_protocol_1.getFeatureId(userData);\n                const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(textPath.text), path, textElementsRenderer.styleCache.getRenderStyle(tile, technique), textElementsRenderer.styleCache.getLayoutStyle(tile, technique), priority, technique.xOffset !== undefined ? technique.xOffset : 0.0, technique.yOffset !== undefined ? technique.yOffset : 0.0, featureId, technique.style, fadeNear, fadeFar, tile.offset);\n                textElement.pathLengthSqr = textPath.pathLengthSqr;\n                textElement.minZoomLevel =\n                    technique.minZoomLevel !== undefined\n                        ? technique.minZoomLevel\n                        : mapView.minZoomLevel;\n                textElement.maxZoomLevel =\n                    technique.maxZoomLevel !== undefined\n                        ? technique.maxZoomLevel\n                        : mapView.maxZoomLevel;\n                textElement.distanceScale =\n                    technique.distanceScale !== undefined\n                        ? technique.distanceScale\n                        : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;\n                textElement.mayOverlap = technique.mayOverlap === true;\n                textElement.reserveSpace = technique.reserveSpace !== false;\n                textElement.kind = technique.kind;\n                // Get the userData for text element picking.\n                textElement.userData = textPath.objInfos;\n                tile.addTextElement(textElement);\n            }\n        }\n        if (decodedTile.textGeometries !== undefined) {\n            for (const text of decodedTile.textGeometries) {\n                if (text.technique === undefined || text.stringCatalog === undefined) {\n                    continue;\n                }\n                const technique = decodedTile.techniques[text.technique];\n                if (technique.enabled === false ||\n                    !harp_datasource_protocol_1.isTextTechnique(technique) ||\n                    (textFilter !== undefined && !textFilter(technique))) {\n                    continue;\n                }\n                const positions = new THREE.BufferAttribute(new Float32Array(text.positions.buffer), text.positions.itemCount);\n                const numPositions = positions.count;\n                if (numPositions < 1) {\n                    continue;\n                }\n                const priority = technique.priority !== undefined\n                    ? harp_datasource_protocol_1.getPropertyValue(technique.priority, displayZoomLevel)\n                    : 0;\n                const fadeNear = technique.fadeNear !== undefined\n                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)\n                    : technique.fadeNear;\n                const fadeFar = technique.fadeFar !== undefined\n                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)\n                    : technique.fadeFar;\n                for (let i = 0; i < numPositions; ++i) {\n                    const x = positions.getX(i) + worldOffsetX;\n                    const y = positions.getY(i);\n                    const z = positions.getZ(i);\n                    const label = text.stringCatalog[text.texts[i]];\n                    if (label === undefined) {\n                        // skip missing labels\n                        continue;\n                    }\n                    const userData = text.objInfos !== undefined ? text.objInfos[i] : undefined;\n                    const featureId = harp_datasource_protocol_1.getFeatureId(userData);\n                    const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x, y, z), textElementsRenderer.styleCache.getRenderStyle(tile, technique), textElementsRenderer.styleCache.getLayoutStyle(tile, technique), priority, technique.xOffset || 0.0, technique.yOffset || 0.0, featureId, technique.style, undefined, undefined, tile.offset);\n                    textElement.minZoomLevel =\n                        technique.minZoomLevel !== undefined\n                            ? technique.minZoomLevel\n                            : mapView.minZoomLevel;\n                    textElement.maxZoomLevel =\n                        technique.maxZoomLevel !== undefined\n                            ? technique.maxZoomLevel\n                            : mapView.maxZoomLevel;\n                    textElement.mayOverlap = technique.mayOverlap === true;\n                    textElement.reserveSpace = technique.reserveSpace !== false;\n                    textElement.kind = technique.kind;\n                    textElement.fadeNear = fadeNear;\n                    textElement.fadeFar = fadeFar;\n                    // Get the userData for text element picking.\n                    textElement.userData = userData;\n                    tile.addTextElement(textElement);\n                }\n            }\n        }\n    }\n    /**\n     * Creates `Tile` objects from the decoded tile and list of materials specified.\n     *\n     * @param tile The [[Tile]] to create the geometry on.\n     * @param decodedTile The [[DecodedTile]].\n     * @param techniqueFilter: Optional filter. Should return true for any technique that is\n     *      applicable.\n     */\n    createObjects(tile, decodedTile, techniqueFilter) {\n        const materials = [];\n        const mapView = tile.mapView;\n        const dataSource = tile.dataSource;\n        const displayZoomLevel = Math.floor(mapView.zoomLevel);\n        const objects = tile.objects;\n        const viewRanges = mapView.viewRanges;\n        for (const srcGeometry of decodedTile.geometries) {\n            const groups = srcGeometry.groups;\n            const groupCount = groups.length;\n            for (let groupIndex = 0; groupIndex < groupCount;) {\n                const group = groups[groupIndex++];\n                const start = group.start;\n                const techniqueIndex = group.technique;\n                const technique = decodedTile.techniques[techniqueIndex];\n                if (group.createdOffsets.indexOf(tile.offset) !== -1 ||\n                    technique.enabled === false ||\n                    (techniqueFilter !== undefined && !techniqueFilter(technique))) {\n                    continue;\n                }\n                let count = group.count;\n                group.createdOffsets.push(tile.offset);\n                // compress consecutive groups\n                for (; groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex; ++groupIndex) {\n                    if (start + count !== groups[groupIndex].start) {\n                        break;\n                    }\n                    count += groups[groupIndex].count;\n                    // Mark this group as created, so it does not get processed again.\n                    groups[groupIndex].createdOffsets.push(tile.offset);\n                }\n                const ObjectCtor = DecodedTileHelpers_1.getObjectConstructor(technique);\n                if (ObjectCtor === undefined) {\n                    continue;\n                }\n                let material = materials[techniqueIndex];\n                if (material === undefined) {\n                    const onMaterialUpdated = (texture) => {\n                        dataSource.requestUpdate();\n                        if (texture !== undefined) {\n                            tile.addOwnedTexture(texture);\n                        }\n                    };\n                    material = DecodedTileHelpers_1.createMaterial({\n                        technique,\n                        level: displayZoomLevel,\n                        fog: mapView.scene.fog !== null\n                    }, onMaterialUpdated);\n                    if (material === undefined) {\n                        continue;\n                    }\n                    materials[techniqueIndex] = material;\n                }\n                // Modify the standard textured shader to support height-based coloring.\n                if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {\n                    this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);\n                }\n                const bufferGeometry = new THREE.BufferGeometry();\n                srcGeometry.vertexAttributes.forEach((vertexAttribute) => {\n                    const buffer = DecodedTileHelpers_1.getBufferAttribute(vertexAttribute);\n                    bufferGeometry.setAttribute(vertexAttribute.name, buffer);\n                });\n                if (srcGeometry.interleavedVertexAttributes !== undefined) {\n                    srcGeometry.interleavedVertexAttributes.forEach((attr) => {\n                        const ArrayCtor = harp_datasource_protocol_1.getArrayConstructor(attr.type);\n                        const buffer = new THREE.InterleavedBuffer(new ArrayCtor(attr.buffer), attr.stride);\n                        attr.attributes.forEach((interleavedAttr) => {\n                            const attribute = new THREE.InterleavedBufferAttribute(buffer, interleavedAttr.itemSize, interleavedAttr.offset, false);\n                            bufferGeometry.setAttribute(interleavedAttr.name, attribute);\n                        });\n                    });\n                }\n                if (srcGeometry.index) {\n                    bufferGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.index));\n                }\n                if (!bufferGeometry.getAttribute(\"normal\") && harp_datasource_protocol_1.needsVertexNormals(technique)) {\n                    bufferGeometry.computeVertexNormals();\n                }\n                bufferGeometry.addGroup(start, count);\n                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {\n                    // TODO: Unify access to shader defines via SolidLineMaterial setters\n                    harp_utils_1.assert(!harp_materials_1.isHighPrecisionLineMaterial(material));\n                    const lineMaterial = material;\n                    if (technique.clipping !== false &&\n                        tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {\n                        tile.boundingBox.getSize(tmpVector3);\n                        tmpVector2.set(tmpVector3.x, tmpVector3.y);\n                        lineMaterial.clipTileSize = tmpVector2;\n                    }\n                    if (bufferGeometry.getAttribute(\"color\")) {\n                        harp_materials_1.setShaderMaterialDefine(lineMaterial, \"USE_COLOR\", true);\n                    }\n                }\n                // Add the solid line outlines as a separate object.\n                const hasSolidLinesOutlines = harp_datasource_protocol_1.isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;\n                const object = new ObjectCtor(bufferGeometry, material);\n                object.renderOrder = technique.renderOrder;\n                if (group.renderOrderOffset !== undefined) {\n                    object.renderOrder += group.renderOrderOffset;\n                }\n                if (srcGeometry.uuid !== undefined) {\n                    object.userData.geometryId = srcGeometry.uuid;\n                }\n                if ((harp_datasource_protocol_1.isCirclesTechnique(technique) || harp_datasource_protocol_1.isSquaresTechnique(technique)) &&\n                    technique.enablePicking !== undefined) {\n                    // tslint:disable-next-line:max-line-length\n                    object.enableRayTesting = technique.enablePicking;\n                }\n                if (harp_datasource_protocol_1.isLineTechnique(technique) || harp_datasource_protocol_1.isSegmentsTechnique(technique)) {\n                    const hasDynamicColor = harp_datasource_protocol_1.Expr.isExpr(technique.color) || harp_datasource_protocol_1.Expr.isExpr(technique.opacity);\n                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);\n                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false, hasDynamicColor\n                        ? (renderer, mat) => {\n                            const lineMaterial = mat;\n                            DecodedTileHelpers_1.applyBaseColorToMaterial(lineMaterial, lineMaterial.color, technique, technique.color, mapView.zoomLevel);\n                        }\n                        : undefined);\n                }\n                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {\n                    const hasDynamicColor = harp_datasource_protocol_1.Expr.isExpr(technique.color) || harp_datasource_protocol_1.Expr.isExpr(technique.opacity);\n                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);\n                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false, (renderer, mat) => {\n                        const lineMaterial = mat;\n                        const unitFactor = technique.metricUnit === \"Pixel\" ? mapView.pixelToWorld : 1.0;\n                        if (hasDynamicColor) {\n                            DecodedTileHelpers_1.applyBaseColorToMaterial(lineMaterial, lineMaterial.color, technique, technique.color, mapView.zoomLevel);\n                        }\n                        lineMaterial.lineWidth =\n                            harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, mapView.zoomLevel, mapView.pixelToWorld) *\n                                unitFactor *\n                                0.5;\n                        if (technique.outlineWidth !== undefined) {\n                            lineMaterial.outlineWidth =\n                                harp_datasource_protocol_1.getPropertyValue(technique.outlineWidth, mapView.zoomLevel, mapView.pixelToWorld) * unitFactor;\n                        }\n                        if (technique.dashSize !== undefined) {\n                            lineMaterial.dashSize =\n                                harp_datasource_protocol_1.getPropertyValue(technique.dashSize, mapView.zoomLevel, mapView.pixelToWorld) *\n                                    unitFactor *\n                                    0.5;\n                        }\n                        if (technique.gapSize !== undefined) {\n                            lineMaterial.gapSize =\n                                harp_datasource_protocol_1.getPropertyValue(technique.gapSize, mapView.zoomLevel, mapView.pixelToWorld) *\n                                    unitFactor *\n                                    0.5;\n                        }\n                    });\n                }\n                if (harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {\n                    const hasDynamicColor = harp_datasource_protocol_1.Expr.isExpr(technique.color) || harp_datasource_protocol_1.Expr.isExpr(technique.opacity);\n                    // extruded lines are normal meshes, and need transparency only when fading or\n                    // dynamic properties is defined.\n                    if (technique.fadeFar !== undefined || hasDynamicColor) {\n                        const fadingParams = this.getFadingParams(displayZoomLevel, technique);\n                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true, hasDynamicColor\n                            ? (renderer, mat) => {\n                                const extrudedMaterial = mat;\n                                DecodedTileHelpers_1.applyBaseColorToMaterial(extrudedMaterial, extrudedMaterial.color, technique, technique.color, mapView.zoomLevel);\n                            }\n                            : undefined);\n                    }\n                }\n                this.addFeatureData(srcGeometry, technique, object);\n                this.addGeometryObjInfos(tile, srcGeometry, technique, object);\n                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique)) {\n                    // filled polygons are normal meshes, and need transparency only when fading or\n                    // dynamic properties is defined.\n                    const hasDynamicPrimaryColor = harp_datasource_protocol_1.Expr.isExpr(technique.color) || harp_datasource_protocol_1.Expr.isExpr(technique.opacity);\n                    const hasDynamicSecondaryColor = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && harp_datasource_protocol_1.Expr.isExpr(technique.emissive);\n                    const hasDynamicColor = hasDynamicPrimaryColor || hasDynamicSecondaryColor;\n                    if (technique.fadeFar !== undefined || hasDynamicColor) {\n                        const fadingParams = this.getFadingParams(displayZoomLevel, technique);\n                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true, hasDynamicColor\n                            ? (renderer, mat) => {\n                                const polygonMaterial = mat;\n                                if (hasDynamicPrimaryColor) {\n                                    DecodedTileHelpers_1.applyBaseColorToMaterial(polygonMaterial, polygonMaterial.color, technique, technique.color, mapView.zoomLevel);\n                                }\n                                if (hasDynamicSecondaryColor &&\n                                    // Just to omit compiler warnings\n                                    harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n                                    const standardMat = mat;\n                                    DecodedTileHelpers_1.applySecondaryColorToMaterial(standardMat.emissive, technique.emissive, mapView.zoomLevel);\n                                }\n                            }\n                            : undefined);\n                    }\n                }\n                const extrudedObjects = [];\n                const animatedExtrusionHandler = mapView.animatedExtrusionHandler;\n                let extrusionAnimationEnabled = false;\n                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&\n                    animatedExtrusionHandler !== undefined) {\n                    let animateExtrusionValue = harp_datasource_protocol_1.getPropertyValue(technique.animateExtrusion, displayZoomLevel);\n                    if (animateExtrusionValue !== undefined) {\n                        animateExtrusionValue =\n                            typeof animateExtrusionValue === \"boolean\"\n                                ? animateExtrusionValue\n                                : typeof animateExtrusionValue === \"number\"\n                                    ? animateExtrusionValue !== 0\n                                    : false;\n                    }\n                    extrusionAnimationEnabled =\n                        animateExtrusionValue !== undefined &&\n                            animatedExtrusionHandler.forceEnabled === false\n                            ? animateExtrusionValue\n                            : animatedExtrusionHandler.enabled;\n                }\n                const renderDepthPrePass = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && DepthPrePass_1.isRenderDepthPrePassEnabled(technique);\n                if (renderDepthPrePass) {\n                    const depthPassMesh = DepthPrePass_1.createDepthPrePassMesh(object);\n                    // Set geometry kind for depth pass mesh so that it gets the displacement map\n                    // for elevation overlay.\n                    this.registerTileObject(tile, depthPassMesh, technique.kind);\n                    objects.push(depthPassMesh);\n                    if (extrusionAnimationEnabled) {\n                        extrudedObjects.push({\n                            object: depthPassMesh,\n                            materialFeature: true\n                        });\n                    }\n                    DepthPrePass_1.setDepthPrePassStencil(depthPassMesh, object);\n                }\n                this.registerTileObject(tile, object, technique.kind);\n                objects.push(object);\n                // Add the extruded building edges as a separate geometry.\n                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && srcGeometry.edgeIndex !== undefined) {\n                    const edgeGeometry = new THREE.BufferGeometry();\n                    edgeGeometry.setAttribute(\"position\", bufferGeometry.getAttribute(\"position\"));\n                    const colorAttribute = bufferGeometry.getAttribute(\"color\");\n                    if (colorAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"color\", colorAttribute);\n                    }\n                    const extrusionAttribute = bufferGeometry.getAttribute(\"extrusionAxis\");\n                    if (extrusionAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"extrusionAxis\", extrusionAttribute);\n                    }\n                    const normalAttribute = bufferGeometry.getAttribute(\"normal\");\n                    if (normalAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"normal\", normalAttribute);\n                    }\n                    const uvAttribute = bufferGeometry.getAttribute(\"uv\");\n                    if (uvAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"uv\", uvAttribute);\n                    }\n                    edgeGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.edgeIndex));\n                    // Read the uniforms from the technique values (and apply the default values).\n                    const extrudedPolygonTechnique = technique;\n                    const fadingParams = this.getPolygonFadingParams(displayZoomLevel, extrudedPolygonTechnique);\n                    // Configure the edge material based on the theme values.\n                    const materialParams = {\n                        color: fadingParams.color,\n                        colorMix: fadingParams.colorMix,\n                        fadeNear: fadingParams.lineFadeNear,\n                        fadeFar: fadingParams.lineFadeFar\n                    };\n                    const edgeMaterial = new harp_materials_1.EdgeMaterial(materialParams);\n                    const edgeObj = new THREE.LineSegments(edgeGeometry, edgeMaterial);\n                    // Set the correct render order.\n                    edgeObj.renderOrder = object.renderOrder + 0.1;\n                    harp_materials_1.FadingFeature.addRenderHelper(edgeObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false, extrudedPolygonTechnique.lineColor !== undefined &&\n                        harp_datasource_protocol_1.Expr.isExpr(extrudedPolygonTechnique.lineColor)\n                        ? () => {\n                            DecodedTileHelpers_1.applyBaseColorToMaterial(edgeMaterial, edgeMaterial.color, extrudedPolygonTechnique, extrudedPolygonTechnique.lineColor, mapView.zoomLevel);\n                        }\n                        : undefined);\n                    if (extrusionAnimationEnabled) {\n                        extrudedObjects.push({\n                            object: edgeObj,\n                            materialFeature: false\n                        });\n                    }\n                    this.registerTileObject(tile, edgeObj, technique.kind);\n                    objects.push(edgeObj);\n                }\n                // animate the extrusion of buildings\n                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {\n                    extrudedObjects.push({\n                        object,\n                        materialFeature: true\n                    });\n                    const extrusionAnimationDuration = technique.animateExtrusionDuration !== undefined &&\n                        animatedExtrusionHandler.forceEnabled === false\n                        ? technique.animateExtrusionDuration\n                        : animatedExtrusionHandler.duration;\n                    tile.animatedExtrusionTileHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionTileHandler(tile, extrudedObjects, extrusionAnimationDuration);\n                    mapView.animatedExtrusionHandler.add(tile.animatedExtrusionTileHandler);\n                }\n                // Add the fill area edges as a separate geometry.\n                if (harp_datasource_protocol_1.isFillTechnique(technique) && srcGeometry.edgeIndex !== undefined) {\n                    const outlineGeometry = new THREE.BufferGeometry();\n                    outlineGeometry.setAttribute(\"position\", bufferGeometry.getAttribute(\"position\"));\n                    outlineGeometry.setIndex(DecodedTileHelpers_1.getBufferAttribute(srcGeometry.edgeIndex));\n                    const fillTechnique = technique;\n                    const fadingParams = this.getPolygonFadingParams(displayZoomLevel, fillTechnique);\n                    // Configure the edge material based on the theme values.\n                    const materialParams = {\n                        color: fadingParams.color,\n                        colorMix: fadingParams.colorMix,\n                        fadeNear: fadingParams.lineFadeNear,\n                        fadeFar: fadingParams.lineFadeFar\n                    };\n                    const outlineMaterial = new harp_materials_1.EdgeMaterial(materialParams);\n                    const outlineObj = new THREE.LineSegments(outlineGeometry, outlineMaterial);\n                    outlineObj.renderOrder = object.renderOrder + 0.1;\n                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false, fillTechnique.lineColor !== undefined &&\n                        harp_datasource_protocol_1.Expr.isExpr(fillTechnique.lineColor)\n                        ? (renderer, mat) => {\n                            const edgeMaterial = mat;\n                            DecodedTileHelpers_1.applyBaseColorToMaterial(edgeMaterial, edgeMaterial.color, fillTechnique, fillTechnique.lineColor, mapView.zoomLevel);\n                        }\n                        : undefined);\n                    this.registerTileObject(tile, outlineObj, technique.kind);\n                    objects.push(outlineObj);\n                }\n                // Add the fill area edges as a separate geometry.\n                if (hasSolidLinesOutlines) {\n                    const outlineTechnique = technique;\n                    const outlineMaterial = material.clone();\n                    const outlineColor = ColorCache_1.ColorCache.instance.getColor(outlineTechnique.secondaryColor !== undefined\n                        ? harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryColor, displayZoomLevel)\n                        : 0x000000);\n                    outlineMaterial.uniforms.diffuse.value = outlineColor;\n                    if (outlineTechnique.secondaryCaps !== undefined) {\n                        outlineMaterial.caps = outlineTechnique.secondaryCaps;\n                    }\n                    const outlineObj = new ObjectCtor(bufferGeometry, outlineMaterial);\n                    outlineObj.renderOrder =\n                        outlineTechnique.secondaryRenderOrder !== undefined\n                            ? outlineTechnique.secondaryRenderOrder\n                            : technique.renderOrder - 0.0000001;\n                    if (group.renderOrderOffset !== undefined) {\n                        outlineObj.renderOrder += group.renderOrderOffset;\n                    }\n                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);\n                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false, (renderer, mat) => {\n                        const lineMaterial = mat;\n                        const unitFactor = outlineTechnique.metricUnit === \"Pixel\"\n                            ? mapView.pixelToWorld\n                            : 1.0;\n                        if (outlineTechnique.secondaryColor !== undefined) {\n                            DecodedTileHelpers_1.applyBaseColorToMaterial(lineMaterial, lineMaterial.color, outlineTechnique, outlineTechnique.secondaryColor, mapView.zoomLevel);\n                        }\n                        if (outlineTechnique.secondaryWidth !== undefined) {\n                            const techniqueLineWidth = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.lineWidth, mapView.zoomLevel, mapView.pixelToWorld);\n                            const techniqueSecondaryWidth = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryWidth, mapView.zoomLevel, mapView.pixelToWorld);\n                            const techniqueOpacity = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.opacity, mapView.zoomLevel);\n                            // hide outline when it's equal or smaller then line to avoid subpixel contour\n                            const lineWidth = techniqueSecondaryWidth <= techniqueLineWidth &&\n                                (techniqueOpacity === undefined || techniqueOpacity === 1)\n                                ? 0\n                                : techniqueSecondaryWidth;\n                            lineMaterial.lineWidth = lineWidth * unitFactor * 0.5;\n                        }\n                    });\n                    this.registerTileObject(tile, outlineObj, technique.kind);\n                    objects.push(outlineObj);\n                }\n            }\n        }\n    }\n    /**\n     * Prepare the [[Tile]]s pois. Uses the [[PoiManager]] in [[MapView]].\n     */\n    preparePois(tile, decodedTile) {\n        if (decodedTile.poiGeometries !== undefined) {\n            tile.mapView.poiManager.addPois(tile, decodedTile);\n        }\n    }\n    /**\n     * Creates and add a background plane for the tile.\n     */\n    addGroundPlane(tile, renderOrder) {\n        const mapView = tile.mapView;\n        const dataSource = tile.dataSource;\n        const projection = tile.projection;\n        const color = mapView.clearColor;\n        const tmpV = new THREE.Vector3();\n        if (tile.projection.type === harp_geoutils_1.ProjectionType.Spherical) {\n            const { east, west, north, south } = tile.geoBox;\n            const sourceProjection = dataSource.getTilingScheme().projection;\n            const g = new THREE.BufferGeometry();\n            const posAttr = new THREE.BufferAttribute(new Float32Array([\n                ...sourceProjection\n                    .projectPoint(new harp_geoutils_1.GeoCoordinates(south, west), tmpV)\n                    .toArray(),\n                ...sourceProjection\n                    .projectPoint(new harp_geoutils_1.GeoCoordinates(south, east), tmpV)\n                    .toArray(),\n                ...sourceProjection\n                    .projectPoint(new harp_geoutils_1.GeoCoordinates(north, west), tmpV)\n                    .toArray(),\n                ...sourceProjection\n                    .projectPoint(new harp_geoutils_1.GeoCoordinates(north, east), tmpV)\n                    .toArray()\n            ]), 3);\n            g.setAttribute(\"position\", posAttr);\n            g.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));\n            const modifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.Math.degToRad(10), sourceProjection);\n            modifier.modify(g);\n            for (let i = 0; i < posAttr.array.length; i += 3) {\n                tmpV.set(posAttr.array[i], posAttr.array[i + 1], posAttr.array[i + 2]);\n                projection.reprojectPoint(sourceProjection, tmpV, tmpV);\n                tmpV.sub(tile.center);\n                posAttr.array[i] = tmpV.x;\n                posAttr.array[i + 1] = tmpV.y;\n                posAttr.array[i + 2] = tmpV.z;\n            }\n            posAttr.needsUpdate = true;\n            const material = new harp_materials_1.MapMeshBasicMaterial({\n                color,\n                visible: true,\n                depthWrite: true\n            });\n            const mesh = new THREE.Mesh(g, material);\n            mesh.renderOrder = renderOrder;\n            this.registerTileObject(tile, mesh, harp_datasource_protocol_1.GeometryKind.Background);\n            tile.objects.push(mesh);\n        }\n        else {\n            // Add a ground plane to the tile.\n            tile.boundingBox.getSize(tmpV);\n            const groundPlane = this.createPlane(tmpV.x, tmpV.y, tile.center, color, true, renderOrder);\n            this.registerTileObject(tile, groundPlane, harp_datasource_protocol_1.GeometryKind.Background);\n            tile.objects.push(groundPlane);\n        }\n    }\n    setupTerrainMaterial(technique, material, terrainColor) {\n        if (technique.displacementMap === undefined) {\n            // Render terrain using the given color.\n            const stdMaterial = material;\n            stdMaterial.color.set(terrainColor);\n            return;\n        }\n        // Render terrain using height-based colors.\n        material.onBeforeCompile = (shader) => {\n            shader.fragmentShader = shader.fragmentShader.replace(\"#include <map_pars_fragment>\", `#include <map_pars_fragment>\n    uniform sampler2D displacementMap;\n    uniform float displacementScale;\n    uniform float displacementBias;`);\n            shader.fragmentShader = shader.fragmentShader.replace(\"#include <map_fragment>\", `#ifdef USE_MAP\n    float minElevation = ${harp_geoutils_1.EarthConstants.MIN_ELEVATION.toFixed(1)};\n    float maxElevation = ${harp_geoutils_1.EarthConstants.MAX_ELEVATION.toFixed(1)};\n    float elevationRange = maxElevation - minElevation;\n\n    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;\n    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );\n    texelColor = mapTexelToLinear( texelColor );\n    diffuseColor *= texelColor;\n#endif`);\n            // We remove the displacement map from manipulating the vertices, it is\n            // however still required for the pixel shader, so it can't be directly\n            // removed.\n            shader.vertexShader = shader.vertexShader.replace(\"#include <displacementmap_vertex>\", \"\");\n        };\n        material.displacementMap.needsUpdate = true;\n    }\n    /**\n     * Create a simple flat plane for a [[Tile]].\n     *\n     * @param {number} width Width of plane.\n     * @param {number} height Height of plane.\n     * @param {THREE.Vector3} planeCenter Center of plane.\n     * @param {number} colorHex Color of the plane mesh.\n     * @param {boolean} isVisible `True` to make the mesh visible.\n     * @returns {THREE.Mesh} The created plane.\n     */\n    createPlane(width, height, planeCenter, colorHex, isVisible, renderOrder) {\n        const geometry = new THREE.PlaneGeometry(width, height, 1);\n        // TODO cache the material HARP-4207\n        const material = new harp_materials_1.MapMeshBasicMaterial({\n            color: colorHex,\n            visible: isVisible,\n            depthWrite: false\n        });\n        const plane = new THREE.Mesh(geometry, material);\n        plane.position.copy(planeCenter);\n        // Render before everything else\n        plane.renderOrder = renderOrder;\n        return plane;\n    }\n    /**\n     * Pass the feature data on to the object, so it can be used in picking\n     * `MapView.intersectMapObjects()`. Do not pass the feature data if the technique is a\n     * solid-line, because the line picking functionality for the lines is not object based, but\n     * tile based.\n     *\n     * @param srcGeometry The original [[Geometry]].\n     * @param technique The corresponding [[Technique]].\n     * @param object The object to pass info to.\n     */\n    addFeatureData(srcGeometry, technique, object) {\n        if (((srcGeometry.objInfos !== undefined && srcGeometry.objInfos.length > 0) ||\n            harp_datasource_protocol_1.isCirclesTechnique(technique) ||\n            harp_datasource_protocol_1.isSquaresTechnique(technique)) &&\n            !harp_datasource_protocol_1.isSolidLineTechnique(technique)) {\n            const featureData = {\n                geometryType: srcGeometry.type,\n                starts: srcGeometry.featureStarts,\n                objInfos: srcGeometry.objInfos\n            };\n            object.userData.feature = featureData;\n        }\n    }\n    addGeometryObjInfos(tile, srcGeometry, technique, object) {\n        if (srcGeometry.objInfos === undefined || Object.keys(object.userData).length > 0) {\n            return;\n        }\n        if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {\n            if (typeof srcGeometry.objInfos[0] === \"number\") {\n                harp_utils_1.assert(false, \"Wrong attribute map type for terrain geometry\");\n                return;\n            }\n            const displacementMap = srcGeometry.objInfos[0];\n            const tileDisplacementMap = {\n                tileKey: tile.tileKey,\n                texture: new THREE.DataTexture(displacementMap.buffer, displacementMap.xCountVertices, displacementMap.yCountVertices, THREE.LuminanceFormat, THREE.FloatType),\n                displacementMap\n            };\n            object.userData = tileDisplacementMap;\n        }\n        else {\n            object.userData = srcGeometry.objInfos;\n        }\n    }\n    /**\n     * Gets the fading parameters for several kinds of objects.\n     */\n    getFadingParams(displayZoomLevel, technique) {\n        const fadeNear = technique.fadeNear !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)\n            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;\n        const fadeFar = technique.fadeFar !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)\n            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;\n        return {\n            fadeNear,\n            fadeFar\n        };\n    }\n    /**\n     * Gets the fading parameters for several kinds of objects.\n     */\n    getPolygonFadingParams(displayZoomLevel, technique) {\n        let color;\n        let colorMix = harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;\n        if (technique.lineColor !== undefined) {\n            color = harp_datasource_protocol_1.getPropertyValue(technique.lineColor, displayZoomLevel);\n            if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n                const extrudedPolygonTechnique = technique;\n                colorMix =\n                    extrudedPolygonTechnique.lineColorMix !== undefined\n                        ? extrudedPolygonTechnique.lineColorMix\n                        : harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;\n            }\n        }\n        const fadeNear = technique.fadeNear !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)\n            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;\n        const fadeFar = technique.fadeFar !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)\n            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;\n        const lineFadeNear = technique.lineFadeNear !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeNear, displayZoomLevel)\n            : fadeNear;\n        const lineFadeFar = technique.lineFadeFar !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeFar, displayZoomLevel)\n            : fadeFar;\n        if (color === undefined) {\n            color = harp_materials_1.EdgeMaterial.DEFAULT_COLOR;\n        }\n        return {\n            color,\n            colorMix,\n            fadeNear,\n            fadeFar,\n            lineFadeNear,\n            lineFadeFar\n        };\n    }\n}\nexports.TileGeometryCreator = TileGeometryCreator;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Statistics_1 = __webpack_require__(/*! ../Statistics */ \"./node_modules/@here/harp-mapview/lib/Statistics.js\");\nconst TileGeometryCreator_1 = __webpack_require__(/*! ./TileGeometryCreator */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js\");\nvar TileGeometryLoader;\n(function (TileGeometryLoader) {\n    /**\n     * Make sure that all technique have their geometryKind set, either from the theme or their\n     * default value.\n     *\n     * Also gather set of the [[GeometryKind]]s found in the techniques and return it.\n     *\n     * @param {DecodedTile} decodedTile\n     * @returns {GeometryKindSet} The set of kinds used in the decodeTile.\n     */\n    function prepareDecodedTile(decodedTile) {\n        const foundSet = new harp_datasource_protocol_1.GeometryKindSet();\n        for (const technique of decodedTile.techniques) {\n            let geometryKind = technique.kind;\n            // Set default kind based on technique.\n            if (geometryKind === undefined) {\n                geometryKind = setDefaultGeometryKind(technique);\n            }\n            if (Array.isArray(geometryKind)) {\n                geometryKind = new harp_datasource_protocol_1.GeometryKindSet(geometryKind);\n            }\n            if (geometryKind instanceof Set) {\n                for (const kind of geometryKind) {\n                    foundSet.add(kind);\n                }\n            }\n            else {\n                foundSet.add(geometryKind);\n            }\n        }\n        return foundSet;\n    }\n    TileGeometryLoader.prepareDecodedTile = prepareDecodedTile;\n    /**\n     * Make sure that the technique has its geometryKind set, either from the theme or their default\n     * value.\n     *\n     * @param {Technique} technique\n     */\n    function setDefaultGeometryKind(technique) {\n        let geometryKind = technique.kind;\n        // Set default kind based on technique.\n        if (geometryKind === undefined) {\n            if (harp_datasource_protocol_1.isFillTechnique(technique)) {\n                geometryKind = harp_datasource_protocol_1.GeometryKind.Area;\n            }\n            else if (harp_datasource_protocol_1.isLineTechnique(technique) ||\n                harp_datasource_protocol_1.isSolidLineTechnique(technique) ||\n                harp_datasource_protocol_1.isSegmentsTechnique(technique) ||\n                harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {\n                geometryKind = harp_datasource_protocol_1.GeometryKind.Line;\n            }\n            else if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {\n                geometryKind = harp_datasource_protocol_1.GeometryKind.Building;\n            }\n            else if (harp_datasource_protocol_1.isPoiTechnique(technique) ||\n                harp_datasource_protocol_1.isLineMarkerTechnique(technique) ||\n                harp_datasource_protocol_1.isTextTechnique(technique)) {\n                geometryKind = harp_datasource_protocol_1.GeometryKind.Label;\n            }\n            else {\n                geometryKind = harp_datasource_protocol_1.GeometryKind.All;\n            }\n            technique.kind = geometryKind;\n        }\n        return geometryKind;\n    }\n    TileGeometryLoader.setDefaultGeometryKind = setDefaultGeometryKind;\n})(TileGeometryLoader = exports.TileGeometryLoader || (exports.TileGeometryLoader = {}));\n/**\n * Simplest implementation of a [[TileGeometryLoader]]. It loads all geometry in a single step.\n */\nclass SimpleTileGeometryLoader {\n    constructor(m_tile) {\n        this.m_tile = m_tile;\n        this.m_isFinished = false;\n    }\n    get tile() {\n        return this.m_tile;\n    }\n    get isFinished() {\n        return this.m_isFinished;\n    }\n    get basicGeometryLoaded() {\n        return this.m_tile.hasGeometry;\n    }\n    get allGeometryLoaded() {\n        return this.m_isFinished;\n    }\n    /**\n     * Set the [[DecodedTile]] of the tile. Is called after the decoded tile has been loaded, and\n     * prepares its content for later processing in the 'updateXXX' methods.\n     *\n     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to\n     *      this tile.\n     * @returns {DecodedTile} The processed decoded tile.\n     */\n    setDecodedTile(decodedTile) {\n        this.m_decodedTile = decodedTile;\n        if (this.m_decodedTile !== undefined) {\n            this.m_availableGeometryKinds = TileGeometryLoader.prepareDecodedTile(this.m_decodedTile);\n        }\n        return this.m_decodedTile;\n    }\n    get availableGeometryKinds() {\n        return this.m_availableGeometryKinds;\n    }\n    update(enabledKinds, disabledKinds) {\n        const tile = this.tile;\n        // First time this tile is handled:\n        if (this.m_decodedTile === undefined && tile.decodedTile !== undefined) {\n            TileGeometryCreator_1.TileGeometryCreator.instance.processTechniques(tile.decodedTile, enabledKinds, disabledKinds);\n            this.setDecodedTile(tile.decodedTile);\n            this.prepareForRender(enabledKinds, disabledKinds);\n        }\n    }\n    dispose() {\n        this.m_decodedTile = undefined;\n    }\n    reset() {\n        this.m_decodedTile = undefined;\n        this.m_isFinished = false;\n        if (this.m_availableGeometryKinds !== undefined) {\n            this.m_availableGeometryKinds.clear();\n        }\n        if (this.m_timeout !== undefined) {\n            clearTimeout(this.m_timeout);\n        }\n    }\n    finish() {\n        this.m_tile.loadingFinished();\n        this.m_tile.removeDecodedTile();\n        this.m_isFinished = true;\n        this.m_timeout = undefined;\n    }\n    /**\n     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare geometry.\n     */\n    prepareForRender(enabledKinds, disabledKinds) {\n        // If the tile is not ready for display, or if it has become invisible while being loaded,\n        // for example by moving the camera, the tile is not finished and its geometry is not\n        // created. This is an optimization for fast camera movements and zooms.\n        const tile = this.tile;\n        const decodedTile = this.m_decodedTile;\n        this.m_decodedTile = undefined;\n        if (decodedTile === undefined || tile.disposed || !tile.isVisible) {\n            this.finish();\n            return;\n        }\n        this.m_timeout = setTimeout(() => {\n            const stats = Statistics_1.PerformanceStatistics.instance;\n            // If the tile has become invisible while being loaded, for example by moving the\n            // camera, the tile is not finished and its geometry is not created. This is an\n            // optimization for fast camera movements and zooms.\n            if (!tile.isVisible) {\n                // Dispose the tile from the visible set, so it can be reloaded properly next time\n                // it is needed.\n                tile.mapView.visibleTileSet.disposeTile(tile);\n                if (stats.enabled) {\n                    stats.currentFrame.addMessage(\n                    // tslint:disable-next-line: max-line-length\n                    `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row} DISCARDED - invisible`);\n                }\n                this.finish();\n                return;\n            }\n            let now = 0;\n            if (stats.enabled) {\n                now = harp_utils_1.PerformanceTimer.now();\n            }\n            const geometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;\n            tile.clear();\n            geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);\n            geometryCreator.createAllGeometries(tile, decodedTile);\n            if (stats.enabled) {\n                const geometryCreationTime = harp_utils_1.PerformanceTimer.now() - now;\n                const currentFrame = stats.currentFrame;\n                currentFrame.addValue(\"geometry.geometryCreationTime\", geometryCreationTime);\n                currentFrame.addValue(\"geometryCount.numGeometries\", decodedTile.geometries.length);\n                currentFrame.addValue(\"geometryCount.numTechniques\", decodedTile.techniques.length);\n                currentFrame.addValue(\"geometryCount.numPoiGeometries\", decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0);\n                currentFrame.addValue(\"geometryCount.numTextGeometries\", decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0);\n                currentFrame.addValue(\"geometryCount.numTextPathGeometries\", decodedTile.textPathGeometries !== undefined\n                    ? decodedTile.textPathGeometries.length\n                    : 0);\n                currentFrame.addValue(\"geometryCount.numPathGeometries\", decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0);\n                currentFrame.addMessage(\n                // tslint:disable-next-line: max-line-length\n                `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`);\n            }\n            this.finish();\n            tile.dataSource.requestUpdate();\n        }, 0);\n    }\n}\nexports.SimpleTileGeometryLoader = SimpleTileGeometryLoader;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst TileGeometryLoader_1 = __webpack_require__(/*! ./TileGeometryLoader */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryLoader.js\");\n/**\n * Base class for all [[TileGeometryManager]]s. Handles visibility as well as enabling/disabling of\n * kinds of geometry [[GeometryKind]].\n */\nclass TileGeometryManagerBase {\n    /**\n     * Creates an instance of `TileGeometryManagerBase` with a reference to the [[MapView]].\n     */\n    constructor(mapView) {\n        this.mapView = mapView;\n        this.enableFilterByKind = true;\n        this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet();\n        this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet();\n        this.hiddenKinds = new harp_datasource_protocol_1.GeometryKindSet();\n        /**\n         * Optimization for evaluation in `update()` method. Only if a kind is hidden/unhidden, the\n         * visibility of the kinds is applied to their geometries.\n         */\n        this.m_visibilityCounter = 1;\n    }\n    get enabledGeometryKinds() {\n        return this.enabledKinds;\n    }\n    set enabledGeometryKinds(kinds) {\n        this.enabledKinds = kinds;\n    }\n    get disabledGeometryKinds() {\n        return this.disabledKinds;\n    }\n    set disabledGeometryKinds(kinds) {\n        this.disabledKinds = kinds;\n    }\n    get hiddenGeometryKinds() {\n        return this.hiddenKinds;\n    }\n    set hiddenGeometryKinds(kinds) {\n        this.hiddenKinds = kinds;\n        this.incrementVisibilityCounter();\n    }\n    get visibilityCounter() {\n        return this.m_visibilityCounter;\n    }\n    clear() {\n        this.enabledKinds.clear();\n        this.disabledKinds.clear();\n        this.hiddenKinds.clear();\n    }\n    enableKind(kind, addOrRemoveToEnabledSet = true) {\n        this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);\n    }\n    disableKind(kind, addOrRemoveToDisabledSet = true) {\n        this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);\n    }\n    hideKind(kind, addOrRemoveToHiddenSet = true) {\n        let visibilityHasChanged = false;\n        if (Array.isArray(kind)) {\n            for (const oneKind of kind) {\n                visibilityHasChanged =\n                    visibilityHasChanged ||\n                        this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);\n            }\n        }\n        else if (kind instanceof Set) {\n            const kindSet = kind;\n            for (const oneKind of kindSet) {\n                visibilityHasChanged =\n                    visibilityHasChanged ||\n                        this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);\n            }\n        }\n        else if (kind !== undefined) {\n            visibilityHasChanged =\n                visibilityHasChanged ||\n                    this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);\n        }\n        // Will be evaluated in the next update()\n        if (visibilityHasChanged) {\n            this.incrementVisibilityCounter();\n        }\n    }\n    getAvailableKinds(tiles) {\n        const visibleKinds = new harp_datasource_protocol_1.GeometryKindSet();\n        for (const tile of tiles) {\n            const geometryLoader = tile.tileGeometryLoader;\n            if (geometryLoader !== undefined) {\n                const tileKinds = geometryLoader.availableGeometryKinds;\n                if (tileKinds !== undefined) {\n                    for (const kind of tileKinds) {\n                        visibleKinds.add(kind);\n                    }\n                }\n            }\n        }\n        return visibleKinds;\n    }\n    /**\n     * Apply the visibility status taken from the `hiddenKinds` to all geometries in the specified\n     * tiles.\n     *\n     * @param {Tile[]} tiles List of [[Tiles]] to process the visibility status of.\n     */\n    updateTileObjectVisibility(tiles) {\n        let needUpdate = false;\n        for (const tile of tiles) {\n            if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {\n                continue;\n            }\n            tile.visibilityCounter = this.visibilityCounter;\n            for (const object of tile.objects) {\n                const geometryKind = object.userData !== undefined ? object.userData.kind : undefined;\n                if (geometryKind !== undefined) {\n                    const nowVisible = !geometryKind.some(kind => this.hiddenKinds.has(kind));\n                    needUpdate = needUpdate || object.visible !== nowVisible;\n                    object.visible = nowVisible;\n                }\n            }\n        }\n        return needUpdate;\n    }\n    setTileUpdateCallback(callback) {\n        this.m_tileUpdateCallback = callback;\n    }\n    incrementVisibilityCounter() {\n        return ++this.m_visibilityCounter;\n    }\n    /**\n     * Add or remove a kind|array of kinds|set of kinds from the specified kind set.\n     *\n     * @hidden\n     * @param {GeometryKindSet} set\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind\n     * @param {boolean} addToSet\n     */\n    enableDisableKinds(set, kind, addToSet) {\n        if (Array.isArray(kind)) {\n            for (const oneKind of kind) {\n                this.addRemove(set, oneKind, addToSet);\n            }\n        }\n        else if (kind instanceof Set) {\n            const kindSet = kind;\n            for (const oneKind of kindSet) {\n                this.addRemove(set, oneKind, addToSet);\n            }\n        }\n        else if (kind !== undefined) {\n            this.addRemove(set, kind, addToSet);\n        }\n    }\n    /**\n     * Add or remove a single kind from the specified kind set.\n     *\n     * @hidden\n     * @param {GeometryKindSet} set\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind\n     * @param {boolean} addToSet\n     */\n    addRemove(kindsSet, kind, addToSet) {\n        if (addToSet) {\n            if (!kindsSet.has(kind)) {\n                kindsSet.add(kind);\n                return true;\n            }\n        }\n        else {\n            if (kindsSet.has(kind)) {\n                kindsSet.delete(kind);\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.TileGeometryManagerBase = TileGeometryManagerBase;\n/**\n * Implements the simplest for of [[TileGeometryManager]]. Uses a [[SimpleTileGeometryLoader]] to\n * load the geometries of the [[Tile]].\n */\nclass SimpleTileGeometryManager extends TileGeometryManagerBase {\n    /**\n     * Creates an instance of `SimpleTileGeometryManager` with a reference to the [[MapView]].\n     */\n    constructor(mapView) {\n        super(mapView);\n    }\n    /** @override */\n    initTile(tile) {\n        if (tile.dataSource.useGeometryLoader) {\n            tile.tileGeometryLoader = new TileGeometryLoader_1.SimpleTileGeometryLoader(tile);\n        }\n    }\n    /** @override */\n    updateTiles(tiles) {\n        for (const tile of tiles) {\n            const geometryLoader = tile.tileGeometryLoader;\n            if (geometryLoader !== undefined) {\n                geometryLoader.update(this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined);\n                if (this.m_tileUpdateCallback) {\n                    this.m_tileUpdateCallback(tile);\n                }\n            }\n        }\n        // If the visibility status of the kinds changed since the last update, the new visibility\n        // status is applied (again).\n        if (this.updateTileObjectVisibility(tiles)) {\n            this.mapView.update();\n        }\n    }\n}\nexports.SimpleTileGeometryManager = SimpleTileGeometryManager;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/TileGeometryManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\n/**\n * Overlays the specified object's geometry on the elevation represented by the given displacement\n * map .\n *\n * @param object The object to be overlaid.\n * @param displacementMap Texture representing the elevation data used to overlay the object.\n */\nfunction overlayObject(object, displacementMap) {\n    if (!(\"material\" in object)) {\n        return;\n    }\n    const material = object.material;\n    if (\"displacementMap\" in material) {\n        material.displacementMap = displacementMap;\n    }\n}\n/**\n * Overlays the specified coordinates on top of elevation data if available.\n *\n * @param worldCoords World coordinates to overlay.\n * @param elevationProvider Used to get elevation data.\n * @param tile The tile to which the coordinates are relative.\n */\nfunction overlayPosition(worldCoords, elevationProvider, tile) {\n    const geoCoords = tile.mapView.projection.unprojectPoint(worldCoords);\n    const height = elevationProvider.getHeight(geoCoords);\n    if (height !== undefined) {\n        geoCoords.altitude = height;\n        tile.mapView.projection.projectPoint(geoCoords, worldCoords);\n    }\n}\n/**\n * Overlays a text element on top of elevation data if available.\n *\n * @param textElement The text element whose geometry will be overlaid.\n * @param elevationProvider Used to get elevation data.\n * @param tile The tile the text element belongs to.\n */\nfunction overlayTextElement(textElement, elevationProvider, tile) {\n    // TODO: Move calculation of text element geoCoordinates to decoder.\n    if (textElement.path === undefined) {\n        overlayPosition(textElement.position, elevationProvider, tile);\n        return;\n    }\n    for (const position of textElement.path) {\n        overlayPosition(position, elevationProvider, tile);\n    }\n}\n// Overlay of text elements within a tile is spread through this many frames to minimize the time\n// spent per frame on elevation overlay.\nconst TEXT_OVERLAY_SPREAD_FRAME_COUNT = 60;\n/**\n * Overlays the geometry in the given tile on top of elevation data if available.\n *\n * @param tile The tile whose geometry will be overlaid.\n */\nfunction overlayOnElevation(tile) {\n    const elevationProvider = tile.mapView.elevationProvider;\n    if (elevationProvider === undefined || tile.objects.length === 0) {\n        return;\n    }\n    const displacementMap = elevationProvider.getDisplacementMap(tile.tileKey);\n    if (displacementMap === undefined || tile.objects.length === 0) {\n        return;\n    }\n    const firstObject = tile.objects[0];\n    if (!firstObject.userData ||\n        !firstObject.userData.kind ||\n        !firstObject.userData.kind.find((kind) => {\n            return kind !== harp_datasource_protocol_1.GeometryKind.All && kind !== harp_datasource_protocol_1.GeometryKind.Terrain;\n        })) {\n        return;\n    }\n    for (const object of tile.objects) {\n        overlayObject(object, displacementMap.texture);\n    }\n    // TODO: Start overlaying text elements as soon as there's some text.\n    if (!tile.allGeometryLoaded) {\n        return;\n    }\n    if (tile.allTextElementsOverlaid) {\n        return;\n    }\n    const textElementsPerFrame = Math.ceil(tile.textElementGroups.count() / TEXT_OVERLAY_SPREAD_FRAME_COUNT);\n    const groups = tile.textElementGroups.sortedGroups;\n    let { groupIndex, elementIndex } = tile.nextTextElementToOverlay;\n    let textElementsCount = 0;\n    while (groupIndex < groups.length) {\n        const group = groups[groupIndex];\n        while (textElementsCount < textElementsPerFrame && elementIndex < group.elements.length) {\n            overlayTextElement(group.elements[elementIndex], elevationProvider, tile);\n            elementIndex++;\n            textElementsCount++;\n        }\n        if (elementIndex >= group.elements.length) {\n            ++groupIndex;\n            elementIndex = 0;\n        }\n        else {\n            break;\n        }\n    }\n    tile.nextTextElementToOverlay = { groupIndex, elementIndex };\n    tile.textElementsChanged = true;\n    tile.mapView.update();\n}\nexports.overlayOnElevation = overlayOnElevation;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/geometry/overlayOnElevation.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/Image.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/Image.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ImageItem;\n(function (ImageItem) {\n    /**\n     * Missing Typedoc\n     */\n    function isLoading(imageItem) {\n        return imageItem.loadingPromise !== undefined;\n    }\n    ImageItem.isLoading = isLoading;\n})(ImageItem = exports.ImageItem || (exports.ImageItem = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/image/Image.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/ImageCache.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/ImageCache.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"ImageCache\");\n/**\n * Combines an [[ImageItem]] with a list of [[MapViews]] that reference it.\n */\nclass ImageCacheItem {\n    /**\n     * Instantiates `ImageCacheItem`.\n     *\n     * @param imageItem The [[ImageItem]] referenced by the associated [[MapView]]s instances.\n     * @param mapView An optional first [[MapView]] referencing the [[ImageItem]].\n     */\n    constructor(imageItem, mapView) {\n        this.imageItem = imageItem;\n        /**\n         * The list of [[MapView]]s referencing the [[ImageItem]].\n         */\n        this.mapViews = [];\n        if (mapView !== undefined) {\n            this.mapViews.push(mapView);\n        }\n    }\n}\n/**\n * `ImageCache` is a singleton, so it can be used with multiple MapViews on a single page. This\n * allows to have an image loaded only once for multiple views. THREE is doing something similar,\n * but does not allow to share images that have been loaded from a canvas (which we may need to do\n * if we use SVG images for textures).\n *\n * One application that makes our own cache necessary is the generation of our own textures from\n * data that is not an URL.\n *\n * The `ImageCache` can be improved by adding satistics for memory footprint as well.\n */\nclass ImageCache {\n    constructor() {\n        this.m_images = new Map();\n    }\n    /**\n     * Returns the singleton `instance` of the `ImageCache`.\n     */\n    static get instance() {\n        if (ImageCache.m_instance === undefined) {\n            ImageCache.m_instance = new ImageCache();\n        }\n        return ImageCache.m_instance;\n    }\n    /**\n     * Dispose the singleton object. Not normally implemented for singletons, but good for\n     * debugging.\n     */\n    static dispose() {\n        ImageCache.m_instance = undefined;\n    }\n    /**\n     * Add an image definition to the global cache. Useful when the image data is already loaded.\n     *\n     * @param mapView Specifiy which [[MapView]] requests the image.\n     * @param url URL of image.\n     * @param imageData Optional [ImageData]] containing the image content.\n     */\n    registerImage(mapView, url, imageData) {\n        let imageCacheItem = this.findImageCacheItem(url);\n        if (imageCacheItem !== undefined) {\n            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {\n                imageCacheItem.mapViews.push(mapView);\n            }\n            return imageCacheItem.imageItem;\n        }\n        imageCacheItem = this.findImageCacheItem(url);\n        if (imageCacheItem !== undefined) {\n            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {\n                imageCacheItem.mapViews.push(mapView);\n            }\n            return imageCacheItem.imageItem;\n        }\n        const mapViews = [];\n        if (mapView !== undefined) {\n            mapViews.push(mapView);\n        }\n        imageCacheItem = {\n            imageItem: {\n                url,\n                imageData,\n                loaded: false\n            },\n            mapViews\n        };\n        this.m_images.set(url, imageCacheItem);\n        return imageCacheItem.imageItem;\n    }\n    /**\n     * Add an image definition, and optionally start loading the content.\n     *\n     * @param mapView [[MapView]] requesting the image.\n     * @param url URL of image.\n     * @param startLoading Optional flag. If `true` the image will be loaded in the background.\n     */\n    addImage(mapView, url, startLoading = true) {\n        const imageItem = this.registerImage(mapView, url, undefined);\n        if (imageItem !== undefined && startLoading === true) {\n            return this.loadImage(imageItem);\n        }\n        return imageItem;\n    }\n    /**\n     * Find [[ImageItem]] for the specified URL.\n     *\n     * @param url URL of image.\n     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.\n     */\n    findImage(url) {\n        const imageItem = this.m_images.get(url);\n        if (imageItem !== undefined) {\n            return imageItem.imageItem;\n        }\n        return undefined;\n    }\n    /**\n     * Clear all [[ImageItem]]s belonging to a [[MapView]]. May remove cached items if no\n     * [[MapView]] are registered anymore.\n     *\n     * @param mapView MapView to remove all [[ImageItem]]s from.\n     */\n    clear(mapView) {\n        const itemsToRemove = [];\n        this.m_images.forEach(imageItem => {\n            const mapViewIndex = imageItem.mapViews.indexOf(mapView);\n            if (mapViewIndex >= 0) {\n                imageItem.mapViews.splice(mapViewIndex, 1);\n            }\n            if (imageItem.mapViews.length === 0) {\n                itemsToRemove.push(imageItem.imageItem.url);\n            }\n        });\n        for (const keyToDelete of itemsToRemove) {\n            this.m_images.delete(keyToDelete);\n        }\n    }\n    /**\n     * Clear all [[ImageItem]]s from all [[MapView]]s.\n     */\n    clearAll() {\n        this.m_images = new Map();\n    }\n    /**\n     * Returns the number of all cached [[ImageItem]]s.\n     */\n    get size() {\n        return this.m_images.size;\n    }\n    /**\n     * Load an [[ImageItem]]. If the loading process is already running, it returns the current\n     * promise.\n     *\n     * @param imageItem `ImageItem` containing the URL to load image from.\n     * @returns An [[ImageItem]] if the image has already been loaded, a promise otherwise.\n     */\n    loadImage(imageItem) {\n        if (imageItem.imageData !== undefined) {\n            return imageItem;\n        }\n        if (imageItem.loadingPromise !== undefined) {\n            return imageItem.loadingPromise;\n        }\n        const imageLoader = new THREE.ImageLoader();\n        imageItem.loadingPromise = new Promise(resolve => {\n            logger.debug(`Loading image: ${imageItem.url}`);\n            imageLoader.load(imageItem.url, image => {\n                logger.debug(`... finished loading image: ${imageItem.url}`);\n                this.renderImage(imageItem, image)\n                    .then(() => {\n                    imageItem.loadingPromise = undefined;\n                    resolve(imageItem);\n                })\n                    .catch(ex => {\n                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);\n                    resolve(undefined);\n                });\n            }, \n            // Loading events no longer supported\n            undefined, errorEvent => {\n                logger.error(`... loading image failed: ${imageItem.url} : ${errorEvent}`);\n                imageItem.loadingPromise = undefined;\n                resolve(undefined);\n            });\n        });\n        return imageItem.loadingPromise;\n    }\n    /**\n     * Find the cached [[ImageItem]] by URL.\n     *\n     * @param url URL of image.\n     */\n    findImageCacheItem(url) {\n        return this.m_images.get(url);\n    }\n    /**\n     * Render the `ImageItem` by using `createImageBitmap()` or by rendering the image into a\n     * [[HTMLCanvasElement]].\n     *\n     * @param imageItem [[ImageItem]] to assign image data to.\n     * @param image [[HTMLImageElement]] to\n     */\n    renderImage(imageItem, image) {\n        return new Promise((resolve, reject) => {\n            // use createImageBitmap if it is available. It should be available in webworkers as\n            // well\n            if (typeof createImageBitmap === \"function\") {\n                const options = {\n                    premultiplyAlpha: \"default\",\n                    imageOrientation: \"flipY\"\n                };\n                logger.debug(`Creating bitmap image: ${imageItem.url}`);\n                createImageBitmap(image, 0, 0, image.width, image.height, options)\n                    .then(imageBitmap => {\n                    logger.debug(`... finished creating bitmap image: ${imageItem.url}`);\n                    imageItem.loadingPromise = undefined;\n                    imageItem.imageData = imageBitmap;\n                    imageItem.loaded = true;\n                    resolve(imageBitmap);\n                })\n                    .catch(ex => {\n                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);\n                    resolve(undefined);\n                });\n            }\n            else {\n                try {\n                    if (typeof document === \"undefined\") {\n                        logger.error(\"Error: document is not available, cannot generate image\");\n                        reject(new Error(\"ImageCache#renderImage: document is not available, cannot \" +\n                            \"render image to create texture\"));\n                    }\n                    // TODO: Extract the rendering to the canvas part and make it configurable for\n                    // the client, so it does not rely on the `document`.\n                    // use the image, e.g. draw part of it on a canvas\n                    const canvas = document.createElement(\"canvas\");\n                    canvas.width = image.width;\n                    canvas.height = image.height;\n                    const context = canvas.getContext(\"2d\");\n                    if (context !== null) {\n                        logger.debug(\n                        // tslint:disable-next-line: max-line-length\n                        `... finished creating bitmap image in canvas: ${imageItem.url} ${image}`);\n                        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n                        const imageData = context.getImageData(0, 0, image.width, image.height);\n                        imageItem.imageData = imageData;\n                        imageItem.loaded = true;\n                        resolve(imageData);\n                    }\n                    else {\n                        logger.error(`renderImage: no context found`);\n                        reject(new Error(`ImageCache#renderImage: no context found`));\n                    }\n                }\n                catch (ex) {\n                    logger.error(`renderImage failed: ${ex}`);\n                    imageItem.imageData = undefined;\n                    imageItem.loaded = true;\n                    reject(new Error(`ImageCache#renderImage failed: ${ex}`));\n                }\n            }\n        });\n    }\n}\nexports.ImageCache = ImageCache;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/image/ImageCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ImageCache_1 = __webpack_require__(/*! ./ImageCache */ \"./node_modules/@here/harp-mapview/lib/image/ImageCache.js\");\n/**\n * Cache images wrapped into [[ImageItem]]s for a [[MapView]]. An image may have multiple names in\n * a theme, the `MapViewImageCache` will take care of that. Registering multiple images with the\n * same name is invalid.\n *\n * The `MapViewImageCache` uses a global [[ImageCache]] to actually store (and generate) the\n * image data.\n */\nclass MapViewImageCache {\n    /**\n     * The constructor for `MapViewImageCache`.\n     *\n     * @param mapView a [[MapView]] instance.\n     */\n    constructor(mapView) {\n        this.mapView = mapView;\n        this.m_name2Url = new Map();\n        this.m_url2Name = new Map();\n    }\n    /**\n     * Register an existing image by name.\n     *\n     * @param name Name of the image from [[Theme]].\n     * @param url URL of image.\n     * @param image Optional [[ImageData]] of image.\n     */\n    registerImage(name, url, image) {\n        if (name !== undefined) {\n            if (this.hasName(name)) {\n                throw new Error(\"duplicate name in cache\");\n            }\n            const oldNames = this.m_url2Name.get(url);\n            if (oldNames !== undefined) {\n                if (oldNames.indexOf(name) < 0) {\n                    oldNames.push(name);\n                }\n            }\n            else {\n                this.m_url2Name.set(url, [name]);\n            }\n            this.m_name2Url.set(name, url);\n        }\n        const imageItem = ImageCache_1.ImageCache.instance.findImage(url);\n        if (imageItem === undefined) {\n            return ImageCache_1.ImageCache.instance.registerImage(this.mapView, url, image);\n        }\n        return imageItem;\n    }\n    /**\n     * Add an image and optionally start loading it. Once done, the [[ImageData]] or [[ImageBitmap]]\n     * will be stored in the [[ImageItem]].\n     *\n     * @param name Name of image from [[Theme]].\n     * @param url URL of image.\n     * @param startLoading Optional. Pass `true` to start loading the image in the background.\n     */\n    addImage(name, url, startLoading = true) {\n        const imageItem = this.registerImage(name, url, undefined);\n        if (startLoading === true) {\n            return ImageCache_1.ImageCache.instance.loadImage(imageItem);\n        }\n        return imageItem;\n    }\n    /**\n     * Find [[ImageItem]] by its name.\n     *\n     * @param name Name of image.\n     */\n    findImageByName(name) {\n        const url = this.m_name2Url.get(name);\n        if (url === undefined) {\n            return undefined;\n        }\n        return ImageCache_1.ImageCache.instance.findImage(url);\n    }\n    /**\n     * Find [[ImageItem]] by URL.\n     *\n     * @param url Url of image.\n     */\n    findImageByUrl(url) {\n        return ImageCache_1.ImageCache.instance.findImage(url);\n    }\n    /**\n     * Load an [[ImageItem]]. Returns a promise or a loaded [[ImageItem]].\n     *\n     * @param imageItem ImageItem to load.\n     */\n    loadImage(imageItem) {\n        return ImageCache_1.ImageCache.instance.loadImage(imageItem);\n    }\n    /**\n     * Remove all [[ImageItem]]s from the cache. Also removes all [[ImageItem]]s that belong to this\n     * [[MapView]] from the global [[ImageCache]].\n     */\n    clear() {\n        ImageCache_1.ImageCache.instance.clear(this.mapView);\n        this.m_name2Url = new Map();\n        this.m_url2Name = new Map();\n    }\n    /**\n     * Returns number of image names stored in the cache.\n     */\n    get numberOfNames() {\n        return this.m_name2Url.size;\n    }\n    /**\n     * Returns number of image URLs in the cache.\n     */\n    get numberOfUrls() {\n        return this.m_url2Name.size;\n    }\n    /**\n     * Return `true` if an image with the given name is known.\n     *\n     * @param name Name of the image.\n     */\n    hasName(name) {\n        return this.m_name2Url.get(name) !== undefined;\n    }\n    /**\n     * Return `true` if an image with the given URL is known.\n     * @param url URL of image.\n     */\n    hasUrl(url) {\n        return this.m_url2Name.get(url) !== undefined;\n    }\n    /**\n     * Return the names under which an image with the given URL is saved.\n     */\n    findNames(url) {\n        return this.m_url2Name.get(url);\n    }\n}\nexports.MapViewImageCache = MapViewImageCache;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/image/MapViewImageCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst PixelPicker_1 = __webpack_require__(/*! ./PixelPicker */ \"./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js\");\n/**\n * Initial number of boxes in BoxBuffer.\n */\nconst START_BOX_BUFFER_SIZE = 0;\n/**\n * Maximum number of boxes in BoxBuffer.\n */\nconst MAX_BOX_BUFFER_SIZE = 32 * 1024;\n/**\n * Number of vertices per box/glyph element: 4 corners.\n */\nconst NUM_VERTICES_PER_ELEMENT = 4;\n/**\n * Number of indices added per box/glyph: 2 triangles, 6 indices.\n */\nconst NUM_INDICES_PER_ELEMENT = 6;\n/**\n * Number of values per position.\n */\nconst NUM_POSITION_VALUES_PER_VERTEX = 3;\n/**\n * Number of values per color.\n */\nconst NUM_COLOR_VALUES_PER_VERTEX = 4;\n/**\n * Number of values per UV.\n */\nconst NUM_UV_VALUES_PER_VERTEX = 4;\n/**\n * Number of values per index.\n */\nconst NUM_INDEX_VALUES_PER_VERTEX = 1;\n/**\n * Number of bytes for float in an Float32Array.\n */\nconst NUM_BYTES_PER_FLOAT = 4;\n/**\n * Number of bytes for integer number in an UInt32Array.\n */\nconst NUM_BYTES_PER_INT32 = 4;\n/**\n * SubClass of [[THREE.Mesh]] to identify meshes that have been created by [[BoxBuffer]] and\n * [[TextBuffer]]. Add the isEmpty flag to quickly test for empty meshes.\n */\nclass BoxBufferMesh extends THREE.Mesh {\n    constructor(geometry, material) {\n        super(geometry, material);\n        this.type = \"BoxBufferMesh\";\n    }\n    /**\n     * A mesh that has no positions and indices set is defined to be empty.\n     *\n     * @returns `True` if no indices have been added to the mesh.\n     */\n    get isEmpty() {\n        if (this.geometry === undefined) {\n            return true;\n        }\n        else {\n            const bufferGeometry = this.geometry;\n            return bufferGeometry.index === null || bufferGeometry.index.count === 0;\n        }\n    }\n}\nexports.BoxBufferMesh = BoxBufferMesh;\n/**\n * Buffer for (untransformed) `Box2` objects. Can be used to create a single geometry for screen-\n * aligned boxes, like POIs.\n */\nclass BoxBuffer {\n    /**\n     * Creates a new `BoxBuffer`.\n     *\n     * @param material Material to be used for [[Mesh]] of this `BoxBuffer`.\n     * @param renderOrder Optional renderOrder of this buffer.\n     * @param startElementCount Initial number of elements this `BoxBuffer` can hold.\n     * @param maxElementCount Maximum number of elements this `BoxBuffer` can hold.\n     */\n    constructor(material, renderOrder = 0, startElementCount = START_BOX_BUFFER_SIZE, maxElementCount = MAX_BOX_BUFFER_SIZE) {\n        this.material = material;\n        this.renderOrder = renderOrder;\n        this.startElementCount = startElementCount;\n        this.maxElementCount = maxElementCount;\n        this.m_size = 0;\n        this.resizeBuffer(startElementCount);\n        this.pickInfos = new Array();\n    }\n    /**\n     * Duplicate this `BoxBuffer` with same material and renderOrder.\n     *\n     * @returns A clone of this `BoxBuffer`.\n     */\n    clone() {\n        return new BoxBuffer(this.material, this.renderOrder);\n    }\n    /**\n     * Dispose of the geometry.\n     */\n    dispose() {\n        if (this.geometry !== undefined) {\n            this.geometry.dispose();\n            this.geometry = undefined;\n        }\n        this.internalMesh = undefined;\n    }\n    /**\n     * Return the current number of elements the buffer can hold.\n     */\n    get size() {\n        return this.m_size;\n    }\n    /**\n     * Clear's the `BoxBuffer` attribute buffers.\n     */\n    reset() {\n        if (this.positionAttribute !== undefined) {\n            this.positionAttribute.count = 0;\n            this.colorAttribute.count = 0;\n            this.uvAttribute.count = 0;\n            this.indexAttribute.count = 0;\n            this.pickInfos.length = 0;\n        }\n    }\n    /**\n     * Returns `true` if this `BoxBuffer` can hold the specified amount of glyphs. If the buffer\n     * can only add the glyph by increasing the buffer size, the resize() method is called, which\n     * will then create a new geometry for the mesh.\n     *\n     * @param glyphCount Number of glyphs to be added to the buffer.\n     * @returns `true` if the element (box or glyph) can be added to the buffer, `false` otherwise.\n     */\n    canAddElements(glyphCount = 1) {\n        const indexAttribute = this.indexAttribute;\n        if (indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >=\n            indexAttribute.array.length) {\n            // Too many elements for the current buffer, check if we can resize the buffer.\n            if (indexAttribute.array.length >= this.maxElementCount * NUM_INDICES_PER_ELEMENT) {\n                return false;\n            }\n            const newSize = Math.min(this.maxElementCount, this.size === 0 ? 256 : this.size * 2);\n            this.resize(newSize);\n        }\n        return true;\n    }\n    /**\n     * Returns this `BoxBuffer`'s attribute [[State]].\n     */\n    saveState() {\n        const state = {\n            positionAttributeCount: this.positionAttribute.count,\n            colorAttributeCount: this.colorAttribute.count,\n            uvAttributeCount: this.uvAttribute.count,\n            indexAttributeCount: this.indexAttribute.count,\n            pickInfoCount: this.pickInfos.length\n        };\n        return state;\n    }\n    /**\n     * Store this `BoxBuffer`'s attribute [[State]] to a previously stored one.\n     *\n     * @param state [[State]] struct describing a previous attribute state.\n     */\n    restoreState(state) {\n        this.positionAttribute.count = state.positionAttributeCount;\n        this.colorAttribute.count = state.colorAttributeCount;\n        this.uvAttribute.count = state.uvAttributeCount;\n        this.indexAttribute.count = state.indexAttributeCount;\n        this.pickInfos.length = state.pickInfoCount;\n    }\n    /**\n     * Adds a new box to this `BoxBuffer`.\n     *\n     * @param screenBox [[Math2D.Box]] holding screen coordinates for this box.\n     * @param uvBox [[Math2D.UvBox]] holding uv coordinates for this box.\n     * @param color Box's color.\n     * @param opacity Box's opacity.\n     * @param distance Box's distance to camera.\n     * @param pickInfo Box's picking information.\n     */\n    addBox(screenBox, uvBox, color, opacity, distance, pickInfo) {\n        if (!this.canAddElements()) {\n            return false;\n        }\n        const { s0, t0, s1, t1 } = uvBox;\n        const { x, y, w, h } = screenBox;\n        const r = Math.round(color.r * 255);\n        const g = Math.round(color.g * 255);\n        const b = Math.round(color.b * 255);\n        const a = Math.round(opacity * 255);\n        const positionAttribute = this.positionAttribute;\n        const colorAttribute = this.colorAttribute;\n        const uvAttribute = this.uvAttribute;\n        const indexAttribute = this.indexAttribute;\n        const baseVertex = positionAttribute.count;\n        const baseIndex = indexAttribute.count;\n        positionAttribute.setXYZ(baseVertex, x, y, distance);\n        positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);\n        positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);\n        positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);\n        colorAttribute.setXYZW(baseVertex, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);\n        uvAttribute.setXY(baseVertex, s0, t0);\n        uvAttribute.setXY(baseVertex + 1, s1, t0);\n        uvAttribute.setXY(baseVertex + 2, s0, t1);\n        uvAttribute.setXY(baseVertex + 3, s1, t1);\n        indexAttribute.setX(baseIndex, baseVertex);\n        indexAttribute.setX(baseIndex + 1, baseVertex + 1);\n        indexAttribute.setX(baseIndex + 2, baseVertex + 2);\n        indexAttribute.setX(baseIndex + 3, baseVertex + 2);\n        indexAttribute.setX(baseIndex + 4, baseVertex + 1);\n        indexAttribute.setX(baseIndex + 5, baseVertex + 3);\n        positionAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        colorAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        uvAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        indexAttribute.count += NUM_INDICES_PER_ELEMENT;\n        this.pickInfos.push(pickInfo);\n        return true;\n    }\n    /**\n     * Updates a [[BufferGeometry]] object to reflect the changes in this `TextBuffer`'s attribute\n     * data.\n     */\n    updateBufferGeometry() {\n        const positionAttribute = this.positionAttribute;\n        const colorAttribute = this.colorAttribute;\n        const uvAttribute = this.uvAttribute;\n        const indexAttribute = this.indexAttribute;\n        if (positionAttribute.count > 0) {\n            positionAttribute.needsUpdate = true;\n            positionAttribute.updateRange.offset = 0;\n            positionAttribute.updateRange.count =\n                positionAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n        if (colorAttribute.count > 0) {\n            colorAttribute.needsUpdate = true;\n            colorAttribute.updateRange.offset = 0;\n            colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n        if (uvAttribute.count > 0) {\n            uvAttribute.needsUpdate = true;\n            uvAttribute.updateRange.offset = 0;\n            uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n        if (indexAttribute.count > 0) {\n            indexAttribute.needsUpdate = true;\n            indexAttribute.updateRange.offset = 0;\n            indexAttribute.updateRange.count = indexAttribute.count;\n        }\n        if (this.geometry !== undefined) {\n            this.geometry.clearGroups();\n            this.geometry.addGroup(0, this.indexAttribute.count);\n        }\n    }\n    /**\n     * Check if the buffer is empty. If it is empty, the memory usage is minimized to reduce\n     * footprint.\n     */\n    cleanUp() {\n        // If there is nothing in this buffer, resize it, it may never be used again.\n        if (this.indexAttribute.count === 0 && this.size > START_BOX_BUFFER_SIZE) {\n            this.clearAttributes();\n        }\n    }\n    /**\n     * Determine if the mesh is empty.\n     */\n    get isEmpty() {\n        return this.internalMesh.isEmpty;\n    }\n    /**\n     * Get the [[Mesh]] object. The geometry instance of the mesh may change if the buffers are\n     * resized. The mesh, once created, will not change, so it can always be added to the scene.\n     */\n    get mesh() {\n        if (this.internalMesh === undefined) {\n            this.resize();\n        }\n        return this.internalMesh;\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * boxes are found, the order of the results is unspecified.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickCallback Callback to be called for every picked element.\n     * @param imageData Image data to test if the pixel is transparent\n     */\n    pickBoxes(screenPosition, pickCallback, imageData) {\n        const n = this.pickInfos.length;\n        const pickInfos = this.pickInfos;\n        const positions = this.positionAttribute;\n        const screenX = screenPosition.x;\n        const screenY = screenPosition.y;\n        const canvas = document.createElement(\"canvas\");\n        for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {\n            const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;\n            const minX = positions.getX(positionIndex);\n            if (screenX < minX) {\n                continue;\n            }\n            const maxX = positions.getX(positionIndex + 1);\n            if (screenX > maxX) {\n                continue;\n            }\n            const minY = positions.getY(positionIndex);\n            if (screenY < minY) {\n                continue;\n            }\n            const maxY = positions.getY(positionIndex + 2);\n            if (screenY > maxY) {\n                continue;\n            }\n            const box = new harp_utils_1.Math2D.Box(minX, minY, maxX - minX, maxY - minY);\n            if (imageData !== undefined &&\n                pickInfos[pickInfoIndex].poiInfo !== undefined &&\n                pickInfos[pickInfoIndex].poiInfo.uvBox !== undefined &&\n                this.isPixelTransparent(imageData, screenX, screenY, box, pickInfos[pickInfoIndex].poiInfo.uvBox, canvas)) {\n                continue;\n            }\n            if (pickInfos[pickInfoIndex] !== undefined) {\n                pickCallback(pickInfos[pickInfoIndex]);\n            }\n        }\n    }\n    /**\n     * Creates a new [[Geometry]] object from all the attribute data stored in this `BoxBuffer`.\n     * The [[Mesh]] object may be created if it is not initialized already.\n     *\n     * @param newSize Optional number of elements to resize the buffer to.\n     * @param forceResize Optional flag to force a resize even if new size is smaller than before.\n     */\n    resize(newSize, forceResize) {\n        if (this.geometry !== undefined) {\n            this.geometry.dispose();\n        }\n        this.geometry = new THREE.BufferGeometry();\n        if (newSize !== undefined && (forceResize === true || newSize > this.size)) {\n            this.resizeBuffer(newSize);\n        }\n        this.geometry.setAttribute(\"position\", this.positionAttribute);\n        this.geometry.setAttribute(\"color\", this.colorAttribute);\n        this.geometry.setAttribute(\"uv\", this.uvAttribute);\n        this.geometry.setIndex(this.indexAttribute);\n        this.geometry.addGroup(0, this.indexAttribute.count);\n        if (this.internalMesh === undefined) {\n            this.internalMesh = new BoxBufferMesh(this.geometry, this.material);\n            this.internalMesh.renderOrder = this.renderOrder;\n        }\n        else {\n            this.internalMesh.geometry = this.geometry;\n        }\n        return this.internalMesh;\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `BoxBuffer`.\n     *\n     * @param info The info object to increment with the values from this `BoxBuffer`.\n     */\n    updateMemoryUsage(info) {\n        const numBytes = this.positionAttribute.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +\n            this.colorAttribute.count * NUM_COLOR_VALUES_PER_VERTEX +\n            this.uvAttribute.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +\n            this.indexAttribute.count * NUM_BYTES_PER_INT32; // May be UInt16, so we overestimate\n        info.heapSize += numBytes;\n        info.gpuSize += numBytes;\n    }\n    /**\n     * Check if a pixel is transparent or not.\n     *\n     * @param imageData Data containing the pixels.\n     * @param xScreenPos X position of the pixel.\n     * @param yScreenPos Y position of the pixel.\n     * @param box Bounding box of the image in screen coordinates.\n     * @param uvBox Uv box referred to the given bounding box.\n     * @param canvas Canvas element that will be used to draw the image, in case the imageData is an\n     *      ImageBitmap\n     */\n    isPixelTransparent(imageData, xScreenPos, yScreenPos, box, uvBox, canvas) {\n        let pixelIsTransparent = false;\n        const { u, v } = PixelPicker_1.screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);\n        const imageWidth = imageData.width;\n        const x = imageWidth * u;\n        const imageHeight = imageData.height;\n        const y = imageHeight * v;\n        const pixel = PixelPicker_1.getPixelFromImage(x, y, imageData, canvas);\n        if (pixel !== undefined && pixel[3] === 0) {\n            pixelIsTransparent = true;\n        }\n        return pixelIsTransparent;\n    }\n    /**\n     * Remove current attributes and arrays. Minimizes memory footprint.\n     */\n    clearAttributes() {\n        this.positionAttribute = undefined;\n        this.colorAttribute = undefined;\n        this.uvAttribute = undefined;\n        this.indexAttribute = undefined;\n        this.resize(START_BOX_BUFFER_SIZE, true);\n    }\n    /**\n     * Resize the attribute buffers. New value must be larger than the previous one.\n     *\n     * @param newSize New number of elements in the buffer. Number has to be larger than the\n     *      previous size.\n     */\n    resizeBuffer(newSize) {\n        const newPositionArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX);\n        if (this.positionAttribute !== undefined && this.positionAttribute.array.length > 0) {\n            const positionAttributeCount = this.positionAttribute.count;\n            newPositionArray.set(this.positionAttribute.array);\n            this.positionAttribute.array = newPositionArray;\n            this.positionAttribute.count = positionAttributeCount;\n        }\n        else {\n            this.positionAttribute = new THREE.BufferAttribute(newPositionArray, NUM_POSITION_VALUES_PER_VERTEX);\n            this.positionAttribute.count = 0;\n            this.positionAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n        const newColorArray = new Uint8Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX);\n        if (this.colorAttribute !== undefined) {\n            const colorAttributeCount = this.colorAttribute.count;\n            newColorArray.set(this.colorAttribute.array);\n            this.colorAttribute.array = newColorArray;\n            this.colorAttribute.count = colorAttributeCount;\n        }\n        else {\n            this.colorAttribute = new THREE.BufferAttribute(newColorArray, NUM_COLOR_VALUES_PER_VERTEX, true);\n            this.colorAttribute.count = 0;\n            this.colorAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n        const newUvArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX);\n        if (this.uvAttribute !== undefined) {\n            const uvAttributeCount = this.uvAttribute.count;\n            newUvArray.set(this.uvAttribute.array);\n            this.uvAttribute.array = newUvArray;\n            this.uvAttribute.count = uvAttributeCount;\n        }\n        else {\n            this.uvAttribute = new THREE.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);\n            this.uvAttribute.count = 0;\n            this.uvAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n        const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;\n        const newIndexArray = numIndexValues > 65535\n            ? new Uint32Array(numIndexValues)\n            : new Uint16Array(numIndexValues);\n        if (this.indexAttribute !== undefined) {\n            const indexAttributeCount = this.indexAttribute.count;\n            newIndexArray.set(this.indexAttribute.array);\n            this.indexAttribute.array = newIndexArray;\n            this.indexAttribute.count = indexAttributeCount;\n        }\n        else {\n            this.indexAttribute = new THREE.BufferAttribute(newIndexArray, NUM_INDEX_VALUES_PER_VERTEX);\n            this.indexAttribute.count = 0;\n            this.indexAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n        this.m_size = newSize;\n    }\n}\nexports.BoxBuffer = BoxBuffer;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/**\n * It returns an array containing the channel colors for the pixel at the given coordinates.\n *\n * @param xPos X value of the pixel.\n * @param yPos Y value of the pixel.\n * @param imageData Data containing the pixels.\n * @param canvas Canvas element that will be used to draw the image, in case the imageData is an\n * ImageBitmap\n */\nfunction getPixelFromImage(xPos, yPos, imageData, canvas) {\n    let pickedColor;\n    const isImageBitmap = (imgData) => {\n        return imgData.close !== undefined;\n    };\n    if (isImageBitmap(imageData)) {\n        if (canvas === undefined) {\n            canvas = document.createElement(\"canvas\");\n        }\n        pickedColor = getPixelFromImageBitmap(imageData, xPos, yPos, canvas);\n    }\n    else {\n        const pixelsData = imageData;\n        const stride = pixelsData.data.length / (pixelsData.height * pixelsData.width);\n        pickedColor = getPixelFromImageData(pixelsData, xPos, yPos, stride);\n    }\n    return pickedColor;\n}\nexports.getPixelFromImage = getPixelFromImage;\n/**\n * Given the x and y position in screen coordinates inside the target box, it map them to the UV\n * coordinates.\n * @param screenX X value in screen coordinates.\n * @param screenY Y value in screen coordinates.\n * @param box Bounding box in screen coordinates.\n * @param uvBox Uv box referred to the given bounding box.\n */\nfunction screenToUvCoordinates(screenX, screenY, box, uvBox) {\n    const minX = box.x;\n    const maxX = box.x + box.w;\n    const minY = box.y;\n    const maxY = box.y + box.h;\n    const u = harp_utils_1.MathUtils.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);\n    const v = harp_utils_1.MathUtils.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);\n    return { u, v };\n}\nexports.screenToUvCoordinates = screenToUvCoordinates;\n/**\n * It returns an Uint8ClampedArray containing the color channel values for the given pixel\n * coordinates. It returns undefined if the given coordinates are out of range.\n *\n * @param image Bitmap image in which the pixels are stored.\n * @param xPos X value of the pixel.\n * @param yPos Y value of the pixel.\n * @param canvas HTML Canvas element on which the image is drawn.\n */\nfunction getPixelFromImageBitmap(image, xPos, yPos, canvas) {\n    if (xPos > image.width || xPos < 0 || yPos > image.height || yPos < 0) {\n        return undefined;\n    }\n    let pixelData;\n    canvas.width = image.width;\n    canvas.height = image.height;\n    const context = canvas.getContext(\"2d\");\n    if (context !== null) {\n        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n        pixelData = context.getImageData(xPos, yPos, 1, 1).data;\n    }\n    return pixelData;\n}\nexports.getPixelFromImageBitmap = getPixelFromImageBitmap;\n/**\n * It returns an Uint8ClampedArray containing the color channel values for the given pixel\n * coordinates. It returns undefined if the given coordinates are out of range.\n *\n * @param image Image data in which the pixels are stored.\n * @param xPos X value of the pixel.\n * @param yPos Y value of the pixel.\n * @param stride The stride value of the image data.\n */\nfunction getPixelFromImageData(imgData, xPos, yPos, stride) {\n    const getPixel = (imageData, index, strd) => {\n        const i = index * strd;\n        const d = imageData.data;\n        const pixel = new Uint8ClampedArray(strd);\n        for (let s = 0; s < strd; s++) {\n            pixel[0] = d[i + s];\n        }\n        return pixel;\n    };\n    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {\n        return undefined;\n    }\n    return getPixel(imgData, yPos * imgData.width + xPos, stride);\n}\nexports.getPixelFromImageData = getPixelFromImageData;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/PixelPicker.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/Poi.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/Poi.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This enum defines the possible origin points for an image.\n */\nvar ImageOrigin;\n(function (ImageOrigin) {\n    ImageOrigin[ImageOrigin[\"TopLeft\"] = 0] = \"TopLeft\";\n    ImageOrigin[ImageOrigin[\"BottomLeft\"] = 1] = \"BottomLeft\";\n})(ImageOrigin = exports.ImageOrigin || (exports.ImageOrigin = {}));\n/**\n * Defines a part (or all) of an image as a texture.\n */\nclass IconTexture {\n    /**\n     * The constructor of an `IconTexture`.\n     *\n     * @param image An [[ImageItem]] instance.\n     * @param options The rendering parameters.\n     */\n    constructor(image) {\n        this.image = image;\n    }\n}\nexports.IconTexture = IconTexture;\n// export enum TextAlign {\n//     Center,\n//     Left,\n//     Right,\n//     // ??? expands lines to have same length.\n//     Justify\n// }\n// export interface LayoutOptions {\n//     paddingH?: number;\n//     paddingV: number;\n//     transFormCenterX?: number;\n//     transFormCenterY?: number;\n//     rotation?: number;\n//     /** Set to `true` to enlarge the box after rotation to include all rotated corners. */\n//     rotationEnlargesBox: boolean;\n// }\n// export interface TextOptions {\n//     bgColor?: THREE.Color;\n//     wrapWords?: boolean;\n//     maxNumLines?: number;\n//     maxWidth?: number;\n//     /** Replace with ellipsis if wider than maxWidth. */\n//     addEllipsis?: boolean;\n//     /** Handle right-to-left texts */\n//     isRightToLeft?: boolean;\n//     textAlignH?: AlignH; // = AlignH.Center;\n//     textAlignV?: AlignV; // = AlignV.Center;\n// }\n// export class IconLabel {\n//     constructor(text: string, options: LayoutOptions | TextOptions) {}\n//     /**\n//      * Setup a box with size and padding.\n//      *\n//      * @param box Target box to set up.\n//      */\n//     getBox(box: THREE.Box2) {}\n//     /**\n//      * Compute width and height from text and font.\n//      */\n//     computeBox() {}\n//     /**\n//      * Generate the glyphs and keep them in a buffer. Generates a fixed layout.\n//      */\n//     prepareRendering() {}\n// }\n// export enum AlignH {\n//     Center,\n//     Left,\n//     Right\n// }\n// export enum AlignV {\n//     Center,\n//     Top,\n//     Bottom\n// }\n// export enum AnchorTarget {\n//     /** Anchor point relative to Icon */\n//     Icon,\n//     /** Anchor point is transform center of icon */\n//     IconCenter,\n//     /** Anchor point relative to Icon including padding */\n//     IconBox,\n//     /** Anchor point relative to Label */\n//     Label,\n//     /** Anchor point relative to combination of Icon and Label */\n//     Box\n// }\n// export class AnchorPosition {\n//     targetH: AnchorTarget = AnchorTarget.Icon;\n//     targetV: AnchorTarget = AnchorTarget.Icon;\n//     alignH: AlignH = AlignH.Center;\n//     alignV: AlignV = AlignV.Center;\n// }\n// export enum IconPinMode {\n//     /** Pinned down, anchor point is the same at all angles. */\n//     PinDown,\n//     /**\n//      * Icon stands up. \"StreetLevel\"-style. The anchor point moves to the bottom of the icon when\n//      * the view direction gets parallel to the ground.\n//      */\n//     StandUp\n// }\n// export interface IconScaleOptions {\n//     depthScale?: boolean;\n//     minimumScale?: number;\n// }\n// export interface IconOptions {\n//     useScreenSpace?: boolean; // = true\n//     priority?: number;\n//     scaleOptions?: IconScaleOptions;\n//     /** Optional offset in screen space */\n//     screenOffsetX?: number;\n//     screenOffsetY?: number;\n//     /** Optional 3D height above terrain. */\n//     heightAboveGround?: number;\n// }\n// export class SimplePoiIcon {\n//     constructor(\n//         readonly pos: THREE.Vector3,\n//         readonly image ?: IconTexture,\n//         options ?: IconOptions\n//     ) { }\n// }\n// export class PoiIcon {\n//     constructor(\n//         readonly pos: THREE.Vector3,\n//         readonly image?: IconTexture,\n//         readonly label?: IconLabel,\n//         options?: IconOptions\n//     ) {}\n// }\n// export interface PoiOptions {\n//     featureId?: number;\n//     minZoomLevel?: number;\n// }\n// export class SimplePoi {\n//     private m_featureId?: number;\n//     private m_minZoomLevel: number = 0;\n//     constructor(readonly icon: SimplePoiIcon, options?: PoiOptions) {\n//         if (options !== undefined) {\n//             this.m_featureId = options.featureId;\n//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;\n//         }\n//     }\n// }\n// export class Poi {\n//     /** store multiple icons, one for every LOD */\n//     private m_icons: PoiIcon[] = [];\n//     private m_lod = 0;\n//     private m_featureId?: number;\n//     private m_minZoomLevel: number = 0;\n//     constructor(icon: PoiIcon, options?: PoiOptions) {\n//         this.m_icons.push(icon);\n//         if (options !== undefined) {\n//             this.m_featureId = options.featureId;\n//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;\n//         }\n//     }\n//     icon(): PoiIcon | undefined {\n//         return this.m_icons[this.m_lod];\n//     }\n//     /**\n//      * Select the level of detail that should be used.\n//      *\n//      * @param levelOfDetail Level of detail to render.\n//      */\n//     selectIcon(levelOfDetail: number) {}\n// }\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/Poi.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiManager.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiManager.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextElement_1 = __webpack_require__(/*! ../text/TextElement */ \"./node_modules/@here/harp-mapview/lib/text/TextElement.js\");\nconst TextElementsRenderer_1 = __webpack_require__(/*! ../text/TextElementsRenderer */ \"./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"PoiManager\");\n/**\n * POI manager class, responsible for loading the [[PoiGeometry]] objects from the [[DecodedTile]],\n * and preparing them for rendering. Also loads and manages the texture atlases for the icons.\n */\nclass PoiManager {\n    /**\n     * The constructor of the `PoiManager`.\n     *\n     * @param mapView The [[MapView]] instance that should display the POIs.\n     */\n    constructor(mapView) {\n        this.mapView = mapView;\n        this.m_imageTextures = new Map();\n        this.m_poiShieldGroups = new Map();\n    }\n    /**\n     * Warn about a missing POI table name, but only once.\n     * @param poiTableName POI mapping table name.\n     * @param poiTable POI table instance.\n     */\n    static notifyMissingPoiTable(poiTableName, poiTable) {\n        if (poiTableName === undefined) {\n            poiTableName = \"undefined\";\n        }\n        if (PoiManager.m_missingPoiTableName.get(poiTableName) === undefined) {\n            PoiManager.m_missingPoiTableName.set(poiTableName, true);\n            if (poiTable !== undefined && !poiTable.loadedOk) {\n                logger.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);\n            }\n            else {\n                logger.error(`updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`);\n            }\n        }\n    }\n    /**\n     * Warn about a missing POI name, but only once.\n     * @param poiName name of POI.\n     * @param poiTableName POI mapping table name.\n     */\n    static notifyMissingPoi(poiName, poiTableName) {\n        if (poiName === undefined) {\n            poiName = \"undefined\";\n        }\n        const key = `${poiTableName}[${poiName}]`;\n        if (PoiManager.m_missingPoiName.get(key) === undefined) {\n            PoiManager.m_missingPoiName.set(key, true);\n            logger.warn(`updatePoiFromPoiTable: ` +\n                `Cannot find POI info for '${poiName}' in table '${poiTableName}'.`);\n        }\n    }\n    /**\n     * Add all POIs from a decoded tile and store them as [[TextElement]]s in the [[Tile]].\n     *\n     * Also handles LineMarkers, which is a recurring marker along a line (road).\n     *\n     * @param tile Tile to add POIs to.\n     * @param decodedTile DecodedTile containing the raw [[PoiGeometry]] objects describing the\n     *  POIs.\n     */\n    addPois(tile, decodedTile) {\n        const poiGeometries = harp_utils_1.assertExists(decodedTile.poiGeometries);\n        const worldOffsetX = tile.computeWorldOffsetX();\n        for (const poiGeometry of poiGeometries) {\n            harp_utils_1.assert(poiGeometry.technique !== undefined);\n            const techniqueIndex = harp_utils_1.assertExists(poiGeometry.technique);\n            const technique = decodedTile.techniques[techniqueIndex];\n            if (technique.enabled === false ||\n                (!harp_datasource_protocol_1.isLineMarkerTechnique(technique) && !harp_datasource_protocol_1.isPoiTechnique(technique))) {\n                continue;\n            }\n            // The POI may be in the data, and there may be a Technique, but the technique may\n            // specify to not show it.\n            if (technique.showOnMap === false) {\n                continue;\n            }\n            const positions = new THREE.BufferAttribute(new Float32Array(poiGeometry.positions.buffer), poiGeometry.positions.itemCount);\n            if (harp_datasource_protocol_1.isLineMarkerTechnique(technique) && positions.count > 0) {\n                this.addLineMarker(tile, poiGeometry, technique, positions, worldOffsetX);\n            }\n            else if (harp_datasource_protocol_1.isPoiTechnique(technique)) {\n                this.addPoi(tile, poiGeometry, technique, positions, worldOffsetX);\n            }\n        }\n    }\n    /**\n     * Load the texture atlas that defines the segments of the texture that should be used for\n     * specific icons. Creates an [[ImageTexture]] for every element in the atlas, such that it can\n     * be addressed in the theme file.\n     *\n     * @param imageName Name of the image from the theme (NOT the url!).\n     * @param atlas URL of the JSON file defining the texture atlas.\n     */\n    addTextureAtlas(imageName, atlas) {\n        fetch(atlas)\n            .then(response => {\n            if (!response.ok) {\n                throw new Error(`addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`);\n            }\n            return response.json();\n        })\n            .then((jsonAtlas) => {\n            if (jsonAtlas === undefined) {\n                logger.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);\n                return;\n            }\n            try {\n                logger.debug(`addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`);\n                for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {\n                    const imageTextureDef = jsonAtlas[textureName];\n                    const imageTexture = {\n                        name: textureName,\n                        image: imageName,\n                        xOffset: imageTextureDef.x,\n                        yOffset: imageTextureDef.y,\n                        width: imageTextureDef.width,\n                        height: imageTextureDef.height\n                    };\n                    this.addImageTexture(imageTexture);\n                }\n            }\n            catch (ex) {\n                logger.error(`addTextureAtlas: Failed to load textureAtlas ` + `'${atlas}' : ${ex}`);\n            }\n            this.mapView.update();\n        })\n            .catch((reason) => {\n            logger.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${reason}`);\n        });\n    }\n    /**\n     * Add an [[ImageTexture]] such that it is available as a named entity for techniques in theme\n     * files.\n     *\n     * @param imageTexture [[ImageTexture]] that should be available for POIs.\n     */\n    addImageTexture(imageTexture) {\n        if (imageTexture.name === undefined) {\n            logger.error(\"addImageTexture: Name required\", imageTexture);\n            return;\n        }\n        if (this.m_imageTextures.get(imageTexture.name) !== undefined) {\n            logger.warn(`addImageTexture: Name already used: ${imageTexture.name}` + ` (overriding it)`);\n        }\n        this.m_imageTextures.set(imageTexture.name, imageTexture);\n    }\n    /**\n     * Return the [[ImageTexture]] registered under the specified name.\n     *\n     * @param name Name of the [[ImageTexture]].\n     */\n    getImageTexture(name) {\n        return this.m_imageTextures.get(name);\n    }\n    /**\n     * Update the [[TextElement]] with the information taken from the [[PoiTable]] which is\n     * referenced in the [[PoiInfo]] of the pointLabel.\n     *\n     * If the requested [[PoiTable]] is not available yet, the function returns `false`.\n     * If the [[PoiTable]] is not defined, or if the references POI has no entry in\n     * the [[PoiTable]], no action is taken, and the function returns `false`.\n     *\n     * If the [[PoiTable]] has been processed, it returns `true`, indicating that this function\n     * doesn't have to be called again.\n     *\n     * @param pointLabel The [[TextElement]] to update.\n     *\n     * @returns `true` if the [[PoiTable]] has been processed, and the function does not have to be\n     *          called again.\n     */\n    updatePoiFromPoiTable(pointLabel) {\n        const poiInfo = pointLabel.poiInfo;\n        // PoiTable requires poiName to be defined otherwise mapping via PoiTable is\n        // not possible, such as table key is not defined.\n        if (poiInfo === undefined ||\n            poiInfo.poiTableName === undefined ||\n            poiInfo.poiName === undefined) {\n            return true;\n        }\n        // Try to acquire PoiTable\n        const poiTableName = poiInfo.poiTableName;\n        const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);\n        // Check if PoiTable is found, but its still loading.\n        if (poiTable !== undefined && poiTable.isLoading) {\n            // The PoiTable is still loading, we have to try again.\n            return false;\n        }\n        // Remove poiTableName to mark this POI as processed.\n        poiInfo.poiTableName = undefined;\n        // PoiTable not found or can not be loaded.\n        if (poiTable === undefined || !poiTable.loadedOk) {\n            PoiManager.notifyMissingPoiTable(poiTableName, poiTable);\n            return true;\n        }\n        // Try to acquire PoiTableEntry.\n        const poiName = poiInfo.poiName;\n        const poiTableEntry = poiTable.getEntry(poiName);\n        if (poiTableEntry === undefined) {\n            PoiManager.notifyMissingPoi(poiName, poiTableName);\n            return true;\n        }\n        if (poiTableEntry.iconName !== undefined && poiTableEntry.iconName.length > 0) {\n            poiInfo.imageTextureName = harp_datasource_protocol_1.composeTechniqueTextureName(poiTableEntry.iconName, poiInfo.technique);\n        }\n        pointLabel.visible =\n            poiTableEntry.visible !== undefined ? poiTableEntry.visible : pointLabel.visible;\n        pointLabel.priority =\n            poiTableEntry.priority !== undefined ? poiTableEntry.priority : pointLabel.priority;\n        poiInfo.iconMinZoomLevel =\n            poiTableEntry.iconMinLevel !== undefined\n                ? poiTableEntry.iconMinLevel\n                : poiInfo.iconMinZoomLevel;\n        poiInfo.iconMaxZoomLevel =\n            poiTableEntry.iconMaxLevel !== undefined\n                ? poiTableEntry.iconMaxLevel\n                : poiInfo.iconMaxZoomLevel;\n        poiInfo.textMinZoomLevel =\n            poiTableEntry.textMinLevel !== undefined\n                ? poiTableEntry.textMinLevel\n                : poiInfo.textMinZoomLevel;\n        poiInfo.textMaxZoomLevel =\n            poiTableEntry.textMaxLevel !== undefined\n                ? poiTableEntry.textMaxLevel\n                : poiInfo.textMaxZoomLevel;\n        pointLabel.updateMinMaxZoomLevelsFromPoiInfo();\n        return true;\n    }\n    /**\n     * Clear internal state. Applicable when switching themes.\n     */\n    clear() {\n        this.m_imageTextures.clear();\n        this.m_poiShieldGroups.clear();\n    }\n    /**\n     * Add the LineMarker as a POI with a series of positions. Make sure that the LineMarkers\n     * having the same visual all get their `shieldGroupIndex` set appropriately, so it can be taken\n     * care of later that not too many of them are rendered (obey `minDistance` attribute).\n     */\n    addLineMarker(tile, poiGeometry, technique, positions, worldOffsetX) {\n        let imageTextureName = technique.imageTexture !== undefined\n            ? harp_datasource_protocol_1.composeTechniqueTextureName(technique.imageTexture, technique)\n            : undefined;\n        let text = \"\";\n        let userData;\n        let featureId;\n        if (poiGeometry.stringCatalog !== undefined) {\n            harp_utils_1.assert(poiGeometry.texts.length > 0);\n            text = poiGeometry.stringCatalog[poiGeometry.texts[0]] || \"\";\n            if (poiGeometry.objInfos !== undefined) {\n                userData = poiGeometry.objInfos[0];\n                featureId = harp_datasource_protocol_1.getFeatureId(userData);\n            }\n            if (poiGeometry.imageTextures !== undefined) {\n                harp_utils_1.assert(poiGeometry.imageTextures.length > 0);\n                imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[0]];\n            }\n        }\n        // let the combined image texture name (name of image in atlas, not the URL) and\n        // text of the shield be the group key, at worst scenario it may be:\n        // \"undefined-\"\n        const groupKey = String(imageTextureName) + \"-\" + text;\n        let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);\n        if (shieldGroupIndex === undefined) {\n            shieldGroupIndex = this.m_poiShieldGroups.size;\n            this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);\n        }\n        // Debugging help to identify the group of a shield :\n        // text = groupKey + \": \" + text;\n        const positionArray = [];\n        for (let i = 0; i < positions.count; i += 3) {\n            const x = positions.getX(i) + worldOffsetX;\n            const y = positions.getY(i);\n            const z = positions.getZ(i);\n            positionArray.push(new THREE.Vector3(x, y, z));\n        }\n        const textElement = this.checkCreateTextElement(tile, text, technique, imageTextureName, undefined, // TBD for road shields\n        undefined, shieldGroupIndex, featureId, positionArray, undefined, undefined, userData);\n        // If the poi icon is rendered, the label that shows text should also be rendered.\n        // The distance rule of the icon should apply, not the one for text (only) labels.\n        textElement.ignoreDistance = false;\n        tile.addTextElement(textElement);\n    }\n    /**\n     * Create and add POI [[TextElement]]s to tile with a series of positions.\n     */\n    addPoi(tile, poiGeometry, technique, positions, worldOffsetX) {\n        if (poiGeometry.stringCatalog === undefined) {\n            return;\n        }\n        const techniqueTextureName = technique.imageTexture !== undefined\n            ? harp_datasource_protocol_1.composeTechniqueTextureName(technique.imageTexture, technique)\n            : undefined;\n        const poiTechnique = technique;\n        const poiTableName = poiTechnique.poiTable;\n        let poiName = poiTechnique.poiName;\n        for (let i = 0; i < positions.count; ++i) {\n            const x = positions.getX(i) + worldOffsetX;\n            const y = positions.getY(i);\n            const z = positions.getZ(i);\n            harp_utils_1.assert(poiGeometry.texts.length > i);\n            let imageTextureName = techniqueTextureName;\n            const text = poiGeometry.stringCatalog[poiGeometry.texts[i]] || \"\";\n            const userData = poiGeometry.objInfos !== undefined ? poiGeometry.objInfos[i] : undefined;\n            const featureId = harp_datasource_protocol_1.getFeatureId(userData);\n            if (poiGeometry.imageTextures !== undefined && poiGeometry.imageTextures[i] >= 0) {\n                harp_utils_1.assert(poiGeometry.imageTextures.length > i);\n                imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[i]];\n            }\n            if (poiTableName !== undefined) {\n                // The POI name to be used is taken from the data, since it will\n                // specify the name of the texture to use.\n                // The POI name in the technique may override the POI name from the\n                // data.\n                poiName =\n                    poiTechnique.poiName === undefined ? imageTextureName : poiTechnique.poiName;\n                imageTextureName = undefined;\n            }\n            const textElement = this.checkCreateTextElement(tile, text, technique, imageTextureName, poiTableName, poiName, 0, featureId, x, y, z, userData);\n            tile.addTextElement(textElement);\n        }\n    }\n    /**\n     * Create the [[TextElement]] for a POI. Even if the POI has no text, it is required that there\n     * is a [[TextElement]], since POIs are hooked onto [[TextElement]]s for sorting.(Sorted by\n     * priority attribute).\n     */\n    checkCreateTextElement(tile, text, technique, imageTextureName, poiTableName, poiName, shieldGroupIndex, featureId, x, y, z, userData) {\n        const textElementsRenderer = this.mapView.textElementsRenderer;\n        const priority = technique.priority !== undefined ? technique.priority : 0;\n        const positions = Array.isArray(x) ? x : new THREE.Vector3(x, y, z);\n        // The current zoomlevel of mapview. Since this method is called for all tiles in the\n        // VisibleTileSet we can be sure that the current zoomlevel matches the zoomlevel where\n        // the tile should be shown.\n        const displayZoomLevel = this.mapView.zoomLevel;\n        const fadeNear = technique.fadeNear !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, displayZoomLevel)\n            : technique.fadeNear;\n        const fadeFar = technique.fadeFar !== undefined\n            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, displayZoomLevel)\n            : technique.fadeFar;\n        const xOffset = harp_datasource_protocol_1.getPropertyValue(technique.xOffset, displayZoomLevel);\n        const yOffset = harp_datasource_protocol_1.getPropertyValue(technique.yOffset, displayZoomLevel);\n        const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), positions, textElementsRenderer.styleCache.getRenderStyle(tile, technique), textElementsRenderer.styleCache.getLayoutStyle(tile, technique), harp_datasource_protocol_1.getPropertyValue(priority, displayZoomLevel), xOffset !== undefined ? xOffset : 0.0, yOffset !== undefined ? yOffset : 0.0, featureId, technique.style, fadeNear, fadeFar, tile.offset);\n        textElement.mayOverlap = technique.textMayOverlap === true;\n        textElement.reserveSpace = technique.textReserveSpace !== false;\n        textElement.alwaysOnTop = technique.alwaysOnTop === true;\n        textElement.userData = userData;\n        // imageTextureName may be undefined if a poiTable is used.\n        if (imageTextureName === undefined && poiTableName !== undefined) {\n            imageTextureName = \"\";\n        }\n        else if (imageTextureName !== undefined && poiTableName !== undefined) {\n            logger.warn(\"Possible duplicate POI icon definition via imageTextureName and poiTable!\");\n        }\n        if (imageTextureName !== undefined) {\n            const textIsOptional = technique.textIsOptional === true;\n            const iconIsOptional = technique.iconIsOptional !== false;\n            const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);\n            const iconMayOverlap = technique.iconMayOverlap === undefined\n                ? textElement.textMayOverlap\n                : technique.iconMayOverlap === true;\n            const iconReserveSpace = technique.iconReserveSpace === undefined\n                ? textElement.textReservesSpace\n                : technique.iconReserveSpace !== false;\n            textElement.poiInfo = {\n                technique,\n                imageTextureName,\n                poiTableName,\n                poiName,\n                shieldGroupIndex,\n                textElement,\n                textIsOptional,\n                iconIsOptional,\n                renderTextDuringMovements,\n                mayOverlap: iconMayOverlap,\n                reserveSpace: iconReserveSpace,\n                featureId,\n                iconMinZoomLevel: technique.iconMinZoomLevel,\n                iconMaxZoomLevel: technique.iconMaxZoomLevel,\n                textMinZoomLevel: technique.textMinZoomLevel,\n                textMaxZoomLevel: technique.textMaxZoomLevel\n            };\n            textElement.updateMinMaxZoomLevelsFromPoiInfo();\n        }\n        else {\n            // Select the smaller/larger one of the two min/max values, because the TextElement\n            // is a container for both.\n            if (textElement.minZoomLevel === undefined) {\n                textElement.minZoomLevel = technique.textMinZoomLevel;\n            }\n            if (textElement.maxZoomLevel === undefined) {\n                textElement.maxZoomLevel = technique.textMaxZoomLevel;\n            }\n        }\n        textElement.distanceScale =\n            technique.distanceScale !== undefined\n                ? technique.distanceScale\n                : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;\n        return textElement;\n    }\n}\nexports.PoiManager = PoiManager;\n// Keep track of the missing POI table names, but only warn once.\nPoiManager.m_missingPoiTableName = new Map();\nPoiManager.m_missingPoiName = new Map();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/PoiManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ \"./node_modules/@here/harp-materials/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst ColorCache_1 = __webpack_require__(/*! ../ColorCache */ \"./node_modules/@here/harp-mapview/lib/ColorCache.js\");\nconst BoxBuffer_1 = __webpack_require__(/*! ./BoxBuffer */ \"./node_modules/@here/harp-mapview/lib/poi/BoxBuffer.js\");\nconst Poi_1 = __webpack_require__(/*! ./Poi */ \"./node_modules/@here/harp-mapview/lib/poi/Poi.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"PoiRenderer\");\nconst INVALID_RENDER_BATCH = -1;\nconst tempPos = new THREE.Vector3(0);\n/**\n * The `PoiRenderBufferBatch` contains the geometry and the material for all POIs that share the\n * same icon image ([[ImageTexture]]). If the image is the same, all the objects in this batch can\n * share the same material, which makes them renderable in the same draw call, whatever the number\n * of actual objects (WebGL limits apply!).\n *\n * There is a `PoiRenderBufferBatch` for every icon in a texture atlas, since the size of the icon\n * in the atlas as well as the texture coordinates are specified in the `PoiRenderBufferBatch`.\n */\nclass PoiRenderBufferBatch {\n    /**\n     * Create the `PoiRenderBufferBatch`.\n     *\n     * @param mapView The [[MapView]] instance.\n     * @param scene The three.js scene to add the POIs to.\n     * @param imageItem The icon that will have his material shared.\n     * @param renderOrder RenderOrder of the batch geometry's [[Mesh]].\n     */\n    constructor(mapView, scene, imageItem, renderOrder) {\n        this.mapView = mapView;\n        this.scene = scene;\n        this.imageItem = imageItem;\n        this.renderOrder = renderOrder;\n        this.color = ColorCache_1.ColorCache.instance.getColor(\"#000000\");\n    }\n    /**\n     * Initialize with the [[ImageTexture]]. Loads the image and sets up the icon size, the texture\n     * coordinates and material of the batch. Since image loading is done asynchronously, this\n     * batch cannot be rendered right away. MapView#update is being triggered if it loaded\n     * successfully.\n     */\n    init() {\n        if (this.boxBuffer === undefined) {\n            this.setup();\n        }\n    }\n    /**\n     * Clean the `PoiRenderBufferBatch`, remove all icon boxes. Called before starting a new frame.\n     */\n    reset() {\n        if (this.boxBuffer === undefined) {\n            this.init();\n        }\n        this.boxBuffer.reset();\n    }\n    /**\n     * Update the geometry with all the added boxes during the frame.\n     */\n    update() {\n        if (this.boxBuffer === undefined) {\n            this.init();\n        }\n        this.boxBuffer.updateBufferGeometry();\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the\n     * `PoiRenderBufferBatch`.\n     *\n     * @param info The info object to increment with the values from this `PoiRenderBufferBatch`.\n     */\n    updateMemoryUsage(info) {\n        if (this.boxBuffer !== undefined) {\n            this.boxBuffer.updateMemoryUsage(info);\n        }\n    }\n    /**\n     * Setup texture and material for the batch.\n     */\n    setup() {\n        const bilinear = true;\n        // Texture images should be generated with premultiplied alpha\n        const premultipliedAlpha = true;\n        const iconTexture = new Poi_1.IconTexture(this.imageItem);\n        const texture = new THREE.Texture(iconTexture.image.imageData, THREE.UVMapping, undefined, undefined, bilinear ? THREE.LinearFilter : THREE.NearestFilter, bilinear ? THREE.LinearFilter : THREE.NearestFilter, THREE.RGBAFormat);\n        texture.needsUpdate = true;\n        texture.premultiplyAlpha = premultipliedAlpha;\n        texture.generateMipmaps = false; // not needed, always rendered in full size\n        this.m_material = new harp_materials_1.IconMaterial({\n            map: texture\n        });\n        this.boxBuffer = new BoxBuffer_1.BoxBuffer(this.m_material, this.renderOrder);\n        const mesh = this.boxBuffer.mesh;\n        mesh.frustumCulled = false;\n        this.scene.add(mesh);\n        this.mapView.update();\n    }\n}\n/**\n * Contains all [[PoiRenderBufferBatch]]es. Selects (and initializes) the correct batch for a POI.\n */\nclass PoiRenderBuffer {\n    /**\n     * Create the `PoiRenderBuffer`.\n     *\n     * @param mapView The [[MapView]] to be rendered to.\n     * @param textCanvas The [[TextCanvas]] to which scenes this `PoiRenderBuffer` adds geometry to.\n     * The actual scene a [[TextElement]] is added to is specified by the renderOrder of the\n     * [[TextElement]].\n     */\n    constructor(mapView, textCanvas) {\n        this.mapView = mapView;\n        this.textCanvas = textCanvas;\n        this.batches = [];\n        this.m_batchMap = new Map();\n    }\n    /**\n     * Register the POI and prepare the [[PoiRenderBufferBatch]] for the POI at first usage.\n     *\n     * @param poiInfo Describes the POI icon.\n     */\n    registerPoi(poiInfo) {\n        const { imageItem, imageTexture, imageTextureName } = poiInfo;\n        if (imageItem === undefined ||\n            imageTextureName === undefined ||\n            imageTexture === undefined) {\n            // No image -> invisible -> ignore\n            return INVALID_RENDER_BATCH;\n        }\n        const renderOrder = poiInfo.renderOrder;\n        // There is a batch for every ImageDefinition, which could be a texture atlas with many\n        // ImageTextures in it.\n        const batchKey = imageTexture.image;\n        let batchSet = this.m_batchMap.get(batchKey);\n        let mappedIndex;\n        let bufferBatch;\n        if (batchSet === undefined) {\n            batchSet = new Map();\n            this.m_batchMap.set(batchKey, batchSet);\n        }\n        mappedIndex = batchSet.get(renderOrder);\n        if (mappedIndex !== undefined) {\n            return mappedIndex;\n        }\n        mappedIndex = this.batches.length;\n        let layer = this.textCanvas.getLayer(renderOrder);\n        if (layer === undefined) {\n            this.textCanvas.addText(\"\", tempPos, { layer: renderOrder });\n            layer = this.textCanvas.getLayer(renderOrder);\n        }\n        bufferBatch = new PoiRenderBufferBatch(this.mapView, layer.storage.scene, imageItem, renderOrder);\n        bufferBatch.init();\n        batchSet.set(renderOrder, mappedIndex);\n        this.batches.push(bufferBatch);\n        return mappedIndex;\n    }\n    /**\n     * Render a POI image at the specified location.\n     *\n     * @param poiInfo PoiInfo containing information for rendering the POI icon.\n     * @param screenBox Box to render icon into in 2D coordinates.\n     * @param viewDistance Box's distance to camera.\n     * @param opacity Opacity of icon to allow fade in/out.\n     */\n    addPoi(poiInfo, screenBox, viewDistance, opacity) {\n        const poiRegistered = poiInfo.poiRenderBatch !== undefined && poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH;\n        const batchIndex = poiRegistered ? poiInfo.poiRenderBatch : this.registerPoi(poiInfo);\n        if (batchIndex === INVALID_RENDER_BATCH) {\n            return INVALID_RENDER_BATCH;\n        }\n        harp_utils_1.assert(batchIndex >= 0);\n        harp_utils_1.assert(batchIndex < this.batches.length);\n        harp_utils_1.assert(poiInfo.uvBox !== undefined);\n        if (this.batches[batchIndex].boxBuffer === undefined) {\n            this.batches[batchIndex].init();\n        }\n        this.batches[batchIndex].boxBuffer.addBox(screenBox, poiInfo.uvBox, this.batches[batchIndex].color, opacity, viewDistance, poiInfo.textElement);\n        return batchIndex;\n    }\n    /**\n     * Retrieve the [[PoiRenderBufferBatch]] from the array at the specified index. May be invalid\n     * if the imageTexture could not be found\n     *\n     * @param index Index into batch array.\n     */\n    getBatch(index) {\n        if (index >= 0) {\n            harp_utils_1.assert(index < this.batches.length);\n            return this.batches[index];\n        }\n        // may be invalid if the imageTexture could not be found\n        return undefined;\n    }\n    /**\n     * Reset all batches, removing all content from the [[PoiRenderBufferBatch]]es. Called at the\n     * beginning of a frame before the POIs are placed.\n     */\n    reset() {\n        for (const batch of this.batches) {\n            batch.reset();\n        }\n    }\n    /**\n     * Update the geometry of all [[PoiRenderBufferBatch]]es. Called before rendering.\n     */\n    update() {\n        for (const batch of this.batches) {\n            batch.update();\n        }\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * [[PoiInfo]]s are found, the order of the results is unspecified.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickCallback Callback to be called for every picked element.\n     */\n    pickTextElements(screenPosition, pickCallback) {\n        for (const batch of this.batches) {\n            if (batch.boxBuffer === undefined) {\n                batch.init();\n            }\n            batch.boxBuffer.pickBoxes(screenPosition, pickCallback, batch.imageItem.imageData);\n        }\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiRenderBuffer`.\n     *\n     * @param info The info object to increment with the values from this `PoiRenderBuffer`.\n     */\n    updateMemoryUsage(info) {\n        for (const batch of this.batches) {\n            if (batch.imageItem.imageData !== undefined) {\n                const imageBytes = batch.imageItem.imageData.width * batch.imageItem.imageData.height * 4;\n                info.heapSize += imageBytes;\n                info.gpuSize += imageBytes;\n            }\n            if (batch.boxBuffer !== undefined) {\n                batch.boxBuffer.updateMemoryUsage(info);\n            }\n        }\n    }\n}\n/**\n * Manage POI rendering. Uses a [[PoiRenderBuffer]] to actually create the geometry that is being\n * rendered.\n */\nclass PoiRenderer {\n    /**\n     * Create the `PoiRenderer` for the specified [[MapView]].\n     *\n     * @param mapView The MapView to be rendered to.\n     * @param textCanvas The [[TextCanvas]] this `PoiRenderer` is associated to. POIs are added to\n     * the different layers of this [[TextCanvas]] based on renderOrder.\n     */\n    constructor(mapView, textCanvas) {\n        this.mapView = mapView;\n        this.textCanvas = textCanvas;\n        // temporary variable to save allocations\n        this.m_tempScreenBox = new harp_utils_1.Math2D.Box();\n        this.m_renderBuffer = new PoiRenderBuffer(mapView, textCanvas);\n    }\n    /**\n     * Compute screen box for icon. It is required that `prepareRender` has been successfully called\n     * before `computeScreenBox` may be called.\n     *\n     * @param poiInfo PoiInfo containing information for rendering the POI icon.\n     * @param screenPosition Position on screen (2D).\n     * @param scale Scale to apply to icon.\n     * @param zoomLevel Current zoom level.\n     * @param screenBox Box that will be used to store the result.\n     * @returns The computed screen box for the icon.\n     */\n    static computeIconScreenBox(poiInfo, screenPosition, scale, zoomLevel, \n    /* out */ screenBox = new harp_utils_1.Math2D.Box()) {\n        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);\n        harp_utils_1.assert(poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH);\n        const width = poiInfo.computedWidth * scale;\n        const height = poiInfo.computedHeight * scale;\n        const technique = poiInfo.technique;\n        const iconXOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconXOffset, zoomLevel);\n        const iconYOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconYOffset, zoomLevel);\n        const centerX = screenPosition.x + (typeof iconXOffset === \"number\" ? iconXOffset : 0);\n        const centerY = screenPosition.y + (typeof iconYOffset === \"number\" ? iconYOffset : 0);\n        screenBox.x = centerX - width / 2;\n        screenBox.y = centerY - height / 2;\n        screenBox.w = width;\n        screenBox.h = height;\n        return screenBox;\n    }\n    /**\n     * Prepare the POI for rendering, and determine which `poiRenderBatch` should be used. If a\n     * `poiRenderBatch` is assigned, the POI is ready to be rendered.\n     *\n     * @param pointLabel TextElement with PoiInfo for rendering the POI icon.\n     * @param zoomLevel The current zoom level of [[MapView]]\n     *\n     * @returns `True` if the space is not already allocated by another object (text label or POI)\n     */\n    prepareRender(pointLabel, zoomLevel) {\n        const poiInfo = pointLabel.poiInfo;\n        if (poiInfo === undefined) {\n            return false;\n        }\n        if (poiInfo.poiRenderBatch === undefined) {\n            this.preparePoi(pointLabel, zoomLevel);\n        }\n        return poiInfo.poiRenderBatch !== undefined;\n    }\n    /**\n     * Reset all batches, removing all content from the [[PoiRenderBuffer]]es. Called at the\n     * beginning of a frame before the POIs are placed.\n     */\n    reset() {\n        this.m_renderBuffer.reset();\n    }\n    /**\n     * Render the icon.\n     *\n     * @param poiInfo PoiInfo containing information for rendering the POI icon.\n     * @param screenPosition Position on screen (2D):\n     * @param screenCollisions Object handling the collision checks for screen-aligned 2D boxes.\n     * @param viewDistance Box's distance to camera.\n     * @param scale Scaling factor to apply to text and icon.\n     * @param allocateScreenSpace If `true` screen space will be allocated for the icon.\n     * @param opacity Opacity of icon to allow fade in/out.\n     */\n    renderPoi(poiInfo, screenPosition, screenCollisions, viewDistance, scale, allocateScreenSpace, opacity, zoomLevel) {\n        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);\n        PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scale, zoomLevel, this.m_tempScreenBox);\n        if (allocateScreenSpace) {\n            screenCollisions.allocate(this.m_tempScreenBox);\n        }\n        this.m_renderBuffer.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);\n    }\n    /**\n     * Update the geometry of all [[PoiRenderBuffer]]es. Called before rendering.\n     */\n    update() {\n        this.m_renderBuffer.update();\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * [[PoiInfo]]s are found, the order of the results is unspecified.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickCallback Callback to be called for every picked element.\n     */\n    pickTextElements(screenPosition, pickCallback) {\n        this.m_renderBuffer.pickTextElements(screenPosition, pickCallback);\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.\n     *\n     * @param info The info object to increment with the values from this `PoiRenderer`.\n     */\n    getMemoryUsage(info) {\n        this.m_renderBuffer.updateMemoryUsage(info);\n    }\n    /**\n     * Register the POI at the [[PoiRenderBuffer]] which may require some setup, for example loading\n     * of the actual image.\n     */\n    preparePoi(pointLabel, zoomLevel) {\n        const poiInfo = pointLabel.poiInfo;\n        if (poiInfo === undefined || !pointLabel.visible) {\n            return;\n        }\n        if (poiInfo.poiRenderBatch !== undefined || poiInfo.isValid === false) {\n            // Already set up, nothing to be done here.\n            return;\n        }\n        if (poiInfo.poiTableName !== undefined) {\n            if (this.mapView.poiManager.updatePoiFromPoiTable(pointLabel)) {\n                if (!pointLabel.visible) {\n                    // PoiTable set this POI to not visible.\n                    return;\n                }\n            }\n            else {\n                // PoiTable has not been loaded, but is required to determine visibility.\n                return;\n            }\n        }\n        const imageTextureName = poiInfo.imageTextureName;\n        const imageTexture = this.mapView.poiManager.getImageTexture(imageTextureName);\n        if (imageTexture === undefined) {\n            // Warn about a missing texture, but only once.\n            if (PoiRenderer.m_missingTextureName.get(imageTextureName) === undefined) {\n                PoiRenderer.m_missingTextureName.set(imageTextureName, true);\n                logger.error(`preparePoi: No imageTexture with name '${imageTextureName}' found`);\n            }\n            poiInfo.isValid = false;\n            return;\n        }\n        const imageDefinition = imageTexture.image;\n        let imageItem = this.mapView.imageCache.findImageByName(imageDefinition);\n        if (imageItem === undefined) {\n            logger.error(`init: No imageItem found with name '${imageDefinition}'`);\n            poiInfo.isValid = false;\n            return;\n        }\n        if (!imageItem.loaded) {\n            if (imageItem.loadingPromise !== undefined) {\n                // already being loaded, will be rendered once available\n                return;\n            }\n            const imageUrl = imageItem.url;\n            const loading = this.mapView.imageCache.loadImage(imageItem);\n            if (loading instanceof Promise) {\n                loading\n                    .then(loadedImageItem => {\n                    if (loadedImageItem === undefined) {\n                        logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`);\n                        return;\n                    }\n                    this.setupPoiInfo(poiInfo, imageTexture, loadedImageItem, zoomLevel);\n                })\n                    .catch(error => {\n                    logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`, error);\n                    poiInfo.isValid = false;\n                });\n                return;\n            }\n            else {\n                imageItem = loading;\n            }\n        }\n        this.setupPoiInfo(poiInfo, imageTexture, imageItem, zoomLevel);\n    }\n    /**\n     * Setup texture and material for the batch.\n     *\n     * @param poiInfo [[PoiInfo]] to initialize.\n     * @param imageTexture Shared [[ImageTexture]], defines used area in atlas.\n     * @param imageItem Shared [[ImageItem]], contains cached image for texture.\n     * @param zoomLevel The current zoom level of [[MapView]]\n     */\n    setupPoiInfo(poiInfo, imageTexture, imageItem, zoomLevel) {\n        harp_utils_1.assert(poiInfo.uvBox === undefined);\n        if (imageItem === undefined || imageItem.imageData === undefined) {\n            logger.error(\"setupPoiInfo: No imageItem/imageData found\");\n            // invalid render batch number\n            poiInfo.poiRenderBatch = INVALID_RENDER_BATCH;\n            poiInfo.isValid = false;\n            return;\n        }\n        const technique = poiInfo.technique;\n        const imageWidth = imageItem.imageData.width;\n        const imageHeight = imageItem.imageData.height;\n        const iconWidth = imageTexture.width !== undefined ? imageTexture.width : imageWidth;\n        const iconHeight = imageTexture.height !== undefined ? imageTexture.height : imageHeight;\n        let minS = 0;\n        let maxS = 1;\n        let minT = 0;\n        let maxT = 1;\n        let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;\n        let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;\n        const width = imageTexture.width !== undefined ? imageTexture.width : imageWidth;\n        const height = imageTexture.height !== undefined ? imageTexture.height : imageHeight;\n        const xOffset = imageTexture.xOffset !== undefined ? imageTexture.xOffset : 0;\n        const yOffset = imageTexture.yOffset !== undefined ? imageTexture.yOffset : 0;\n        minS = xOffset / imageWidth;\n        maxS = (xOffset + width) / imageWidth;\n        const flipY = true;\n        if (flipY) {\n            minT = (imageHeight - yOffset) / imageHeight;\n            maxT = (imageHeight - yOffset - height) / imageHeight;\n        }\n        else {\n            minT = yOffset / imageHeight;\n            maxT = (yOffset + height) / imageHeight;\n        }\n        // minS += 0.5 / imageWidth;\n        // maxS += 0.5 / imageWidth;\n        // minT += 0.5 / imageHeight;\n        // maxT += 0.5 / imageHeight;\n        // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.\n        const screenWidth = harp_datasource_protocol_1.getPropertyValue(technique.screenWidth, zoomLevel);\n        if (screenWidth !== undefined) {\n            iconScaleV = iconScaleH = screenWidth / iconWidth;\n        }\n        const screenHeight = harp_datasource_protocol_1.getPropertyValue(technique.screenHeight, zoomLevel);\n        if (screenHeight !== undefined) {\n            iconScaleV = screenHeight / iconHeight;\n            if (screenWidth !== undefined) {\n                iconScaleH = iconScaleV;\n            }\n        }\n        // compute stored values in imageTexture\n        poiInfo.computedWidth = iconWidth * iconScaleH;\n        poiInfo.computedHeight = iconHeight * iconScaleV;\n        poiInfo.uvBox = {\n            s0: minS,\n            t0: maxT,\n            s1: maxS,\n            t1: minT\n        };\n        poiInfo.imageItem = imageItem;\n        poiInfo.imageTexture = imageTexture;\n        poiInfo.poiRenderBatch = this.m_renderBuffer.registerPoi(poiInfo);\n        poiInfo.isValid = true;\n        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);\n    }\n}\nexports.PoiRenderer = PoiRenderer;\n// keep track of the missing textures, but only warn once\nPoiRenderer.m_missingTextureName = new Map();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiRendererFactory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiRendererFactory.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PoiRenderer_1 = __webpack_require__(/*! ./PoiRenderer */ \"./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js\");\nclass PoiRendererFactory {\n    /**\n     * Creates an instance of poi renderer factory.\n     * @param m_mapView\n     */\n    constructor(m_mapView) {\n        this.m_mapView = m_mapView;\n    }\n    /**\n     * Creates poi renderer\n     * @param textCanvas\n     * @returns\n     */\n    createPoiRenderer(textCanvas) {\n        return new PoiRenderer_1.PoiRenderer(this.m_mapView, textCanvas);\n    }\n}\nexports.PoiRendererFactory = PoiRendererFactory;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/PoiRendererFactory.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"PoiTable\");\n/**\n * Class to store and maintain individual POI information for the [[PoiTable]].\n */\nclass PoiTableEntry {\n    /**\n     * Verify that the JSON description of the POI table entry is valid.\n     *\n     * @param jsonEntry JSON description of the POI table entry.\n     *\n     * @returns `true` if the `jsonEntry` is valid.\n     */\n    static verifyJSON(jsonEntry) {\n        let isOK = typeof jsonEntry.name === \"string\" &&\n            jsonEntry.name.length > 0 &&\n            (jsonEntry.altNames === undefined || Array.isArray(jsonEntry.altNames)) &&\n            (jsonEntry.stackMode === undefined ||\n                jsonEntry.stackMode === \"yes\" ||\n                jsonEntry.stackMode === \"no\" ||\n                jsonEntry.stackMode === \"parent\") &&\n            (jsonEntry.visible === undefined || typeof jsonEntry.visible === \"boolean\") &&\n            (jsonEntry.priority === undefined || typeof jsonEntry.priority === \"number\") &&\n            (jsonEntry.iconMinLevel === undefined || typeof jsonEntry.iconMinLevel === \"number\") &&\n            (jsonEntry.iconMaxLevel === undefined || typeof jsonEntry.iconMaxLevel === \"number\") &&\n            (jsonEntry.textMinLevel === undefined || typeof jsonEntry.textMinLevel === \"number\") &&\n            (jsonEntry.textMaxLevel === undefined || typeof jsonEntry.textMaxLevel === \"number\");\n        if (isOK && jsonEntry.altNames !== undefined) {\n            const altNames = jsonEntry.altNames;\n            for (const str in altNames) {\n                if (typeof str !== \"string\") {\n                    isOK = false;\n                    break;\n                }\n            }\n        }\n        return isOK;\n    }\n    /**\n     * Setup the [[PoiTableEntry]] from the JSON description. It is assumed that the jsonEntry has\n     * been verified with [[PoiTableEntry#verifyJSON]].\n     *\n     * @param jsonEntry JSON description of the POI table entry. Expected to have been verified with\n     *          [[PoiTableEntry#verifyJSON]].\n     */\n    setup(jsonEntry) {\n        this.name = jsonEntry.name;\n        this.altNames = jsonEntry.altNames;\n        this.iconName = jsonEntry.iconName;\n        this.visible = jsonEntry.visible;\n        this.priority = jsonEntry.priority;\n        this.iconMinLevel = jsonEntry.iconMinLevel;\n        this.iconMaxLevel = jsonEntry.iconMaxLevel;\n        this.textMinLevel = jsonEntry.textMinLevel;\n        this.textMaxLevel = jsonEntry.textMaxLevel;\n        switch (jsonEntry.stackMode) {\n            case \"yes\":\n                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Show;\n                break;\n            case \"no\":\n                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Hide;\n                break;\n            case \"parent\":\n                this.stackMode = harp_datasource_protocol_1.PoiStackMode.ShowParent;\n                break;\n            default:\n        }\n    }\n}\n/**\n * The `PoiTable` stores individual information for each POI type. If a [[TextElement]] has a\n * reference to a PoiTable (if TextElement.poiInfo.poiTableName is set), information for the\n * TextElement and its icon are read from the PoiTable.\n *\n * The key to look up the POI is taken from the data, in case of OSM data with TileZen data, the\n * `poiNameField` is set to `kind`, which makes the content of the field `kind` in the data the key\n * to look up the POIs in the [[PoiTable]].\n *\n * On the side of the [[PoiTable]], the key to look up the PoiTableEntry is either the property\n * \"name\" of the [[PoiTableEntry]] (which should be unique), or the alternative list of names\n * `altNames`, where each value should also be unique. If the property `useAltNamesForKey` is set to\n * `true`, the `altNames` will be used.\n */\nclass PoiTable {\n    /**\n     * Creates an instance of PoiTable.\n     *\n     * @param {string} name Name of the `PoiTable`. Must be unique.\n     * @param {boolean} useAltNamesForKey Pass `true` to use the contents of the property `altNames`\n     *          to find a [[PoiTableEntry]] in the table.\n     */\n    constructor(name, useAltNamesForKey) {\n        this.name = name;\n        this.useAltNamesForKey = useAltNamesForKey;\n        /**\n         * Stores the list of [[PoiTableEntry]]s.\n         */\n        this.poiList = new Array();\n        /**\n         * Dictionary to look up for [[PoiTableEntry]] quickly. The dictionary is either created for\n         * the `name` property of the [[PoiTableEntry]], which will identify POI, or for all of\n         * alternative the names defined in `altNames` of [[PoiTableEntry]] JSON object.\n         * Value assigned to key it is the index to [[poiList]] array which contain actual\n         * [[PoiTabelEntry]] objects.\n         */\n        this.poiDict = new Map();\n        this.m_isLoading = false;\n        this.m_loadedOk = undefined;\n    }\n    /**\n     * Returns `true` if the table is currently being loaded, `false` otherwise.\n     *\n     * @readonly\n     */\n    get isLoading() {\n        return this.m_isLoading;\n    }\n    /**\n     * Returns `true` if the table has been loaded correctly, `false` otherwise.\n     *\n     * @readonly\n     */\n    get loadedOk() {\n        return this.m_loadedOk === true;\n    }\n    /**\n     * Gets [[PoiTableEntry]] for poi name specified.\n     *\n     * @param poiName poi name or one of its alternative names if [[useAltNamesForKey]] is\n     * set to `true`.\n     * @returns [[PoiTableEntry]] object or undefined if name was not found in dictionary.\n     */\n    getEntry(poiName) {\n        const entryIdx = this.poiDict.get(poiName);\n        if (entryIdx !== undefined) {\n            if (entryIdx < this.poiList.length) {\n                return this.poiList[entryIdx];\n            }\n            else {\n                throw new Error(\"Poi table entry index out of stored list!\");\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Start to load the PoiTable from the specified URL. Can only be called once per table.\n     *\n     * @param {string} poiTableUrl URL that points to the JSON file.\n     *\n     * @returns {Promise<boolean>} Promise is being resolved once the JSON file has been fetched and\n     *          the `PoiTable` has been set up.\n     */\n    async load(poiTableUrl) {\n        if (this.m_loadedOk !== undefined) {\n            // Only load once.\n            return true;\n        }\n        this.m_loadedOk = false;\n        const response = await fetch(poiTableUrl);\n        if (!response.ok) {\n            throw new Error(`load: Cannot load POI table at ${poiTableUrl}:` + ` ${response.statusText}`);\n        }\n        const jsonPoiTable = (await response.json());\n        if (jsonPoiTable === undefined) {\n            logger.info(`load: TextureAtlas empty: ${poiTableUrl}`);\n            return true;\n        }\n        this.startLoading();\n        try {\n            logger.debug(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);\n            if (jsonPoiTable.poiList !== undefined && Array.isArray(jsonPoiTable.poiList)) {\n                for (const tableEntry of jsonPoiTable.poiList) {\n                    if (PoiTableEntry.verifyJSON(tableEntry)) {\n                        const newPoiEntry = new PoiTableEntry();\n                        newPoiEntry.setup(tableEntry);\n                        const entryIdx = this.poiList.push(newPoiEntry) - 1;\n                        if (!this.useAltNamesForKey) {\n                            // Use actual name of entry as the key\n                            if (newPoiEntry.name === undefined) {\n                                logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +\n                                    `. No name set in entry: ${tableEntry}.`);\n                            }\n                            else {\n                                this.poiDict.set(newPoiEntry.name, entryIdx);\n                            }\n                        }\n                        else {\n                            if (newPoiEntry.altNames !== undefined &&\n                                newPoiEntry.altNames.length > 0) {\n                                // Use the list of alternative names as keys.\n                                for (const altName of newPoiEntry.altNames) {\n                                    this.poiDict.set(altName, entryIdx);\n                                }\n                            }\n                            else {\n                                logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +\n                                    `No alternative names set in entry: ${JSON.stringify(tableEntry)}.`);\n                            }\n                        }\n                    }\n                    else {\n                        logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(tableEntry)}`);\n                    }\n                }\n            }\n            this.m_loadedOk = true;\n            this.finishedLoading();\n        }\n        catch (ex) {\n            logger.error(`load: Failed to load POI table ` + `'${poiTableUrl}' : ${ex}`);\n            this.m_loadedOk = false;\n            this.finishedLoading();\n            return false;\n        }\n        return true;\n    }\n    startLoading() {\n        this.m_isLoading = true;\n    }\n    finishedLoading() {\n        this.m_isLoading = false;\n    }\n}\nexports.PoiTable = PoiTable;\n/**\n * The `PoiTableManager` manages the list of [[PoiTables]] that can be defined in the [[Theme]]\n * file.\n */\nclass PoiTableManager {\n    /**\n     * Creates an instance of PoiTableManager.\n     * @param {MapView} mapView Owning [[MapView]].\n     */\n    constructor(mapView) {\n        this.mapView = mapView;\n        this.m_isLoading = false;\n        this.m_poiTables = new Map();\n    }\n    /**\n     * Load the [[PoiTable]]s that are stored in the [[MapView]]s [[Theme]]. Note that duplicate\n     * names of [[PoiTable]]s in the [[Theme]] will lead to inaccessible [[PoiTable]]s.\n     *\n     * @param {Theme} theme [[Theme]] containing all [[PoiTable]]s to load.\n     *\n     * @returns {Promise<void>} Resolved once all the [[PoiTable]]s in the [[Theme]] have been\n     *          loaded.\n     */\n    async loadPoiTables(theme) {\n        const finished = new Promise(resolve => {\n            this.clear();\n            // Add the POI tables defined in the theme.\n            if (theme.poiTables !== undefined) {\n                this.startLoading();\n                // Gather promises to signal the success of having loaded them all\n                const loadPromises = new Array();\n                theme.poiTables.forEach((poiTableRef) => {\n                    if (poiTableRef !== undefined &&\n                        poiTableRef.name !== undefined &&\n                        typeof poiTableRef.name === \"string\") {\n                        const poiTable = new PoiTable(poiTableRef.name, poiTableRef.useAltNamesForKey !== false);\n                        if (poiTableRef.url !== undefined && typeof poiTableRef.url === \"string\") {\n                            this.addTable(poiTable);\n                            loadPromises.push(poiTable.load(poiTableRef.url));\n                        }\n                        else {\n                            logger.error(`POI table definition has no valid url: ${poiTableRef}`);\n                        }\n                    }\n                    else {\n                        logger.error(`POI table definition has no valid name: ${poiTableRef}`);\n                    }\n                });\n                if (loadPromises.length > 0) {\n                    Promise.all(loadPromises).finally(() => {\n                        this.finishLoading();\n                        resolve();\n                    });\n                }\n                else {\n                    this.finishLoading();\n                    resolve();\n                }\n            }\n            else {\n                this.finishLoading();\n                resolve();\n            }\n        });\n        return finished;\n    }\n    /**\n     * Clear the list of [[PoiTable]]s.\n     */\n    clear() {\n        this.m_poiTables = new Map();\n    }\n    /**\n     * Return the map of [[PoiTable]]s.\n     */\n    get poiTables() {\n        return this.m_poiTables;\n    }\n    /**\n     * Manually add a [[PoiTable]]. Normally, the [[PoiTables]]s are specified in the [[Theme]].\n     * Ensure that the name is unique.\n     */\n    addTable(poiTable) {\n        this.m_poiTables.set(poiTable.name, poiTable);\n    }\n    /**\n     * Retrieve a [[PoiTable]] by name.\n     *\n     * @param {(string | undefined)} poiTableName Name of the [[PoiTable]].\n     *\n     * @returns {(PoiTable | undefined)} The found [[poiTable]] if it could be found, `undefined`\n     *          otherwise.\n     */\n    getPoiTable(poiTableName) {\n        return poiTableName === undefined ? undefined : this.m_poiTables.get(poiTableName);\n    }\n    /**\n     * Return `true` if the [[PoiTable]]s have finished loading.\n     *\n     * @readonly\n     */\n    get finishedLoading() {\n        return !this.m_isLoading;\n    }\n    startLoading() {\n        this.m_isLoading = true;\n    }\n    finishLoading() {\n        this.m_isLoading = false;\n    }\n}\nexports.PoiTableManager = PoiTableManager;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/poi/PoiTableManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nexports.DEFAULT_FONT_CATALOG_NAME = \"default\";\nconst logger = harp_utils_1.LoggerManager.instance.create(\"FontCatalogLoader\");\nclass FontCatalogLoader {\n    constructor(m_theme) {\n        this.m_theme = m_theme;\n        this.m_catalogsLoading = 0;\n    }\n    /**\n     * Initializes font catalog loader.\n     * @param defaultFontCatalogUrl Url of the font catalog that will be used by default if the\n     * theme doesn't define any font catalog.\n     * @returns Name of the default font catalog.\n     */\n    initialize(defaultFontCatalogUrl) {\n        if (this.m_theme.fontCatalogs === undefined || this.m_theme.fontCatalogs.length === 0) {\n            this.m_theme.fontCatalogs = [\n                {\n                    name: exports.DEFAULT_FONT_CATALOG_NAME,\n                    url: defaultFontCatalogUrl\n                }\n            ];\n            return exports.DEFAULT_FONT_CATALOG_NAME;\n        }\n        const defaultFontCatalogName = this.m_theme.fontCatalogs[0].name;\n        return defaultFontCatalogName;\n    }\n    async loadCatalogs(catalogCallback) {\n        harp_utils_1.assert(this.m_theme.fontCatalogs !== undefined);\n        harp_utils_1.assert(this.m_theme.fontCatalogs.length > 0);\n        const promises = [];\n        this.m_theme.fontCatalogs.forEach(fontCatalogConfig => {\n            this.m_catalogsLoading += 1;\n            const fontCatalogPromise = harp_text_canvas_1.FontCatalog.load(fontCatalogConfig.url, 1024)\n                .then(catalogCallback.bind(undefined, fontCatalogConfig.name))\n                .catch((error) => {\n                logger.error(\"Failed to load FontCatalog: \", error);\n            })\n                .finally(() => {\n                this.m_catalogsLoading -= 1;\n            });\n            promises.push(fontCatalogPromise);\n        });\n        return Promise.all(promises);\n    }\n    get loading() {\n        return this.m_catalogsLoading > 0;\n    }\n}\nexports.FontCatalogLoader = FontCatalogLoader;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/FontCatalogLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/MapViewState.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/MapViewState.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * View state obtained from a MapView instance.\n */\nclass MapViewState {\n    constructor(m_mapView, m_renderedTilesChangeCheck) {\n        this.m_mapView = m_mapView;\n        this.m_renderedTilesChangeCheck = m_renderedTilesChangeCheck;\n    }\n    get worldCenter() {\n        return this.m_mapView.worldCenter;\n    }\n    get cameraIsMoving() {\n        return this.m_mapView.cameraIsMoving;\n    }\n    get maxVisibilityDist() {\n        return this.m_mapView.viewRanges.maximum;\n    }\n    get zoomLevel() {\n        return this.m_mapView.zoomLevel;\n    }\n    get frameNumber() {\n        return this.m_mapView.frameNumber;\n    }\n    get lookAtDistance() {\n        return this.m_mapView.lookAtDistance;\n    }\n    get isDynamic() {\n        return this.m_mapView.isDynamicFrame;\n    }\n    get hiddenGeometryKinds() {\n        return this.m_mapView.tileGeometryManager === undefined\n            ? undefined\n            : this.m_mapView.tileGeometryManager.hiddenGeometryKinds;\n    }\n    get renderedTilesChanged() {\n        return this.m_renderedTilesChangeCheck();\n    }\n}\nexports.MapViewState = MapViewState;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/MapViewState.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/Placement.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/Placement.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst PoiRenderer_1 = __webpack_require__(/*! ../poi/PoiRenderer */ \"./node_modules/@here/harp-mapview/lib/poi/PoiRenderer.js\");\nconst ScreenCollisions_1 = __webpack_require__(/*! ../ScreenCollisions */ \"./node_modules/@here/harp-mapview/lib/ScreenCollisions.js\");\nconst TextElement_1 = __webpack_require__(/*! ./TextElement */ \"./node_modules/@here/harp-mapview/lib/text/TextElement.js\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\n/**\n * Minimum number of pixels per character. Used during estimation if there is enough screen space\n * available to render a text.\n */\nconst MIN_AVERAGE_CHAR_WIDTH = 5;\n/**\n * Functions related to text element placement.\n */\nconst tmpPosition = new THREE.Vector3(0, 0, 0);\nconst tmpCameraDir = new THREE.Vector3(0, 0, 0);\nconst COS_TEXT_ELEMENT_FALLOFF_ANGLE = 0.5877852522924731; // Math.cos(0.3 * Math.PI)\n/**\n * Checks whether the distance of the specified text element to the center of the given view is\n * lower than a maximum threshold.\n * @param textElement The textElement of which the view distance will be checked, with coordinates\n * in world space.\n * @param mapView The view that will be used as reference to calculate the distance.\n * @param maxViewDistance The maximum distance value.\n * @returns The text element view distance if it's lower than the maximum value, otherwise\n * `undefined`.\n */\nfunction checkViewDistance(worldCenter, textElement, projectionType, camera, maxViewDistance) {\n    const textDistance = computeViewDistance(worldCenter, textElement);\n    if (projectionType !== harp_geoutils_1.ProjectionType.Spherical) {\n        return textDistance <= maxViewDistance ? textDistance : undefined;\n    }\n    // For sphere projection: Filter labels that are close to the horizon\n    tmpPosition.copy(textElement.position).normalize();\n    camera.getWorldPosition(tmpCameraDir).normalize();\n    const cosAlpha = tmpPosition.dot(tmpCameraDir);\n    const viewDistance = cosAlpha > COS_TEXT_ELEMENT_FALLOFF_ANGLE && textDistance <= maxViewDistance\n        ? textDistance\n        : undefined;\n    return viewDistance;\n}\n/**\n * Computes the distance of the specified text element to the given position.\n * @param refPosition The world coordinates used a reference position to calculate the distance.\n * @param textElement The textElement of which the view distance will be checked. It must have\n * coordinates in world space.\n * @returns The text element view distance.\n * `undefined`.\n */\nfunction computeViewDistance(refPosition, textElement) {\n    let viewDistance;\n    if (Array.isArray(textElement.points) && textElement.points.length > 1) {\n        const viewDistance0 = refPosition.distanceTo(textElement.points[0]);\n        const viewDistance1 = refPosition.distanceTo(textElement.points[textElement.points.length - 1]);\n        viewDistance = Math.min(viewDistance0, viewDistance1);\n    }\n    else {\n        viewDistance = refPosition.distanceTo(textElement.points);\n    }\n    return viewDistance;\n}\nexports.computeViewDistance = computeViewDistance;\n/**\n * Computes the maximum view distance for text elements as a ratio of the given view's maximum far\n * plane distance.\n * @param viewState The view for which the maximum view distance will be calculated.\n * @param farDistanceLimitRatio The ratio to apply to the maximum far plane distance.\n * @returns Maximum view distance.\n */\nfunction getMaxViewDistance(viewState, farDistanceLimitRatio) {\n    return viewState.maxVisibilityDist * farDistanceLimitRatio;\n}\nexports.getMaxViewDistance = getMaxViewDistance;\n/**\n * State of fading.\n */\nvar PrePlacementResult;\n(function (PrePlacementResult) {\n    PrePlacementResult[PrePlacementResult[\"Ok\"] = 0] = \"Ok\";\n    PrePlacementResult[PrePlacementResult[\"NotReady\"] = 1] = \"NotReady\";\n    PrePlacementResult[PrePlacementResult[\"Invisible\"] = 2] = \"Invisible\";\n    PrePlacementResult[PrePlacementResult[\"TooFar\"] = 3] = \"TooFar\";\n    PrePlacementResult[PrePlacementResult[\"Duplicate\"] = 4] = \"Duplicate\";\n    PrePlacementResult[PrePlacementResult[\"Count\"] = 5] = \"Count\";\n})(PrePlacementResult = exports.PrePlacementResult || (exports.PrePlacementResult = {}));\n/**\n * Applies early rejection tests for a given text element meant to avoid trying to place labels\n * that are not visible, not ready, duplicates etc...\n * @param textElement The Text element to check.\n * @param viewState The view for which the text element will be placed.\n * @param viewCamera The view's camera.\n * @param m_poiManager To prepare pois for rendering.\n * @param projectionType The projection type currently used from geo to world space.\n * @param [maxViewDistance] If specified, text elements farther than this max distance will be\n * rejected.\n * @returns An object with the result code and the text element view distance\n * ( or `undefined` of the checks failed) as second.\n */\nfunction checkReadyForPlacement(textElement, viewState, viewCamera, poiManager, projectionType, maxViewDistance) {\n    let viewDistance;\n    if (!textElement.visible) {\n        return { result: PrePlacementResult.Invisible, viewDistance };\n    }\n    // If a PoiTable is specified in the technique, the table is required to be\n    // loaded before the POI can be rendered.\n    if (!poiManager.updatePoiFromPoiTable(textElement)) {\n        // PoiTable has not been loaded, but is required to determine\n        // visibility.\n        return { result: PrePlacementResult.NotReady, viewDistance };\n    }\n    // Text element visibility and zoom level ranges must be checked after calling\n    // updatePoiFromPoiTable, since that function may change those values.\n    if (!textElement.visible ||\n        !harp_utils_1.MathUtils.isClamped(viewState.zoomLevel, textElement.minZoomLevel, textElement.maxZoomLevel)) {\n        return { result: PrePlacementResult.Invisible, viewDistance };\n    }\n    viewDistance =\n        maxViewDistance === undefined\n            ? computeViewDistance(viewState.worldCenter, textElement)\n            : checkViewDistance(viewState.worldCenter, textElement, projectionType, viewCamera, maxViewDistance);\n    if (viewDistance === undefined) {\n        return { result: PrePlacementResult.TooFar, viewDistance };\n    }\n    return { result: PrePlacementResult.Ok, viewDistance };\n}\nexports.checkReadyForPlacement = checkReadyForPlacement;\n/**\n * Computes the offset for a point text accordingly to text alignment (and icon, if any).\n * @param textElement The text element of which the offset will computed. It must be a point\n * label with [[layoutStyle]] and [[bounds]] already computed.\n * @param offset The offset result.\n */\nfunction computePointTextOffset(textElement, offset = new THREE.Vector2()) {\n    harp_utils_1.assert(textElement.type === TextElementType_1.TextElementType.PoiLabel);\n    harp_utils_1.assert(textElement.layoutStyle !== undefined);\n    harp_utils_1.assert(textElement.bounds !== undefined);\n    const hAlign = textElement.layoutStyle.horizontalAlignment;\n    const vAlign = textElement.layoutStyle.verticalAlignment;\n    switch (hAlign) {\n        case harp_text_canvas_1.HorizontalAlignment.Right:\n            offset.x = -textElement.xOffset;\n            break;\n        default:\n            offset.x = textElement.xOffset;\n            break;\n    }\n    switch (vAlign) {\n        case harp_text_canvas_1.VerticalAlignment.Below:\n            offset.y = -textElement.yOffset;\n            break;\n        case harp_text_canvas_1.VerticalAlignment.Above:\n            offset.y = textElement.yOffset - textElement.bounds.min.y;\n            break;\n        default:\n            offset.y = textElement.yOffset;\n            break;\n    }\n    if (textElement.poiInfo !== undefined && TextElement_1.poiIsRenderable(textElement.poiInfo)) {\n        harp_utils_1.assert(textElement.poiInfo.computedWidth !== undefined);\n        harp_utils_1.assert(textElement.poiInfo.computedHeight !== undefined);\n        offset.x += textElement.poiInfo.computedWidth * (0.5 + hAlign);\n        offset.y += textElement.poiInfo.computedHeight * (0.5 + vAlign);\n    }\n    return offset;\n}\nconst tmpBox = new THREE.Box2();\nconst tmpBoxes = [];\nconst tmpMeasurementParams = {};\nconst tmpCollisionBoxes = [];\nconst tmpCollisionBox = new ScreenCollisions_1.CollisionBox();\nconst tmpScreenPosition = new THREE.Vector2();\nconst tmpTextOffset = new THREE.Vector2();\nconst tmp2DBox = new harp_utils_1.Math2D.Box();\nconst pointLabelMargin = new THREE.Vector2(4, 2);\nvar PlacementResult;\n(function (PlacementResult) {\n    PlacementResult[PlacementResult[\"Ok\"] = 0] = \"Ok\";\n    PlacementResult[PlacementResult[\"Rejected\"] = 1] = \"Rejected\";\n    PlacementResult[PlacementResult[\"Invisible\"] = 2] = \"Invisible\";\n})(PlacementResult = exports.PlacementResult || (exports.PlacementResult = {}));\n/**\n * Places an icon on screen.\n * @param iconRenderState The icon state.\n * @param poiInfo Icon information necessary to compute its dimensions.\n * @param screenPosition Screen position of the icon.\n * @param scaleFactor Scaling factor to apply to the icon dimensions.\n * @param screenCollisions Used to check the icon visibility and collisions.\n * @param zoomLevel Current zoom level.\n * @returns `PlacementResult.Ok` if icon can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n */\nfunction placeIcon(iconRenderState, poiInfo, screenPosition, scaleFactor, zoomLevel, screenCollisions) {\n    PoiRenderer_1.PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scaleFactor, zoomLevel, tmp2DBox);\n    if (!screenCollisions.isVisible(tmp2DBox)) {\n        return PlacementResult.Invisible;\n    }\n    const iconSpaceAvailable = poiInfo.mayOverlap === true || !screenCollisions.isAllocated(tmp2DBox);\n    if (!iconSpaceAvailable) {\n        return iconRenderState.isVisible() ? PlacementResult.Rejected : PlacementResult.Invisible;\n    }\n    return PlacementResult.Ok;\n}\nexports.placeIcon = placeIcon;\n/**\n * Places a point label on a specified text canvas.\n * @param labelState State of the point label to place.\n * @param screenPosition Position of the label in screen coordinates.\n * @param scale Scale factor to be applied to label dimensions.\n * @param isRejected Whether the label is already rejected (e.g. because its icon was rejected). If\n * `true`, text won't be checked for collision, result will be either `PlacementResult.Invisible` or\n * `PlacementResult.Rejected`.\n * @param textCanvas The text canvas where the label will be placed.\n * @param screenCollisions Used to check collisions with other labels.\n * @param outScreenPosition The final label screen position after applying any offsets.\n * @returns `PlacementResult.Ok` if path label can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n */\nfunction placePointLabel(labelState, screenPosition, scale, textCanvas, screenCollisions, isRejected, outScreenPosition) {\n    const label = labelState.element;\n    if (label.bounds === undefined) {\n        label.bounds = new THREE.Box2();\n        tmpMeasurementParams.outputCharacterBounds = undefined;\n        tmpMeasurementParams.path = undefined;\n        tmpMeasurementParams.pathOverflow = false;\n        tmpMeasurementParams.letterCaseArray = label.glyphCaseArray;\n        textCanvas.measureText(label.glyphs, label.bounds, tmpMeasurementParams);\n    }\n    screenPosition.add(computePointTextOffset(label, tmpTextOffset));\n    outScreenPosition.set(screenPosition.x, screenPosition.y, labelState.renderDistance);\n    // TODO: Make the margin configurable\n    tmpBox.copy(label.bounds).expandByVector(pointLabelMargin);\n    tmpBox.min.multiplyScalar(scale);\n    tmpBox.max.multiplyScalar(scale);\n    tmpBox.translate(screenPosition);\n    tmp2DBox.set(tmpBox.min.x, tmpBox.min.y, tmpBox.max.x - tmpBox.min.x, tmpBox.max.y - tmpBox.min.y);\n    // Check the text visibility.\n    if (!screenCollisions.isVisible(tmp2DBox)) {\n        return PlacementResult.Invisible;\n    }\n    if (isRejected || (!label.textMayOverlap && screenCollisions.isAllocated(tmp2DBox))) {\n        return labelState.visible ? PlacementResult.Rejected : PlacementResult.Invisible;\n    }\n    // Don't allocate space for rejected text. When zooming, this allows placement of a\n    // lower priority text element that was displaced by a higher priority one (not\n    // present in the new zoom level) before an even lower priority one takes the space.\n    // Otherwise the lowest priority text will fade in and back out.\n    // TODO: Add a unit test for this scenario.\n    if (label.textReservesSpace) {\n        screenCollisions.allocate(tmp2DBox);\n    }\n    return PlacementResult.Ok;\n}\nexports.placePointLabel = placePointLabel;\n/**\n * Places a path label along a given path on a specified text canvas.\n * @param labelState The state of the path label to place.\n * @param textPath The text path along which the label will be placed.\n * @param screenPosition Position of the label in screen coordinates.\n * @param textCanvas The text canvas where the label will be placed.\n * @param screenCollisions Used to check collisions with other labels.\n * @returns `PlacementResult.Ok` if path label can be placed, `PlacementResult.Rejected` if there's\n * a collision or text doesn't fit into path, `PlacementResult.Invisible` if it's not visible.\n */\nfunction placePathLabel(labelState, textPath, screenPosition, textCanvas, screenCollisions) {\n    // Recalculate the text bounds for this path label. If measurement fails, the whole\n    // label doesn't fit the path and should be discarded.\n    tmpMeasurementParams.path = textPath;\n    tmpMeasurementParams.outputCharacterBounds = tmpBoxes;\n    tmpMeasurementParams.letterCaseArray = labelState.element.glyphCaseArray;\n    // TODO: HARP-7648. TextCanvas.measureText does the placement as in TextCanvas.addText but\n    // without storing the result. If the measurement succeeds, the placement work is done\n    // twice.\n    // This could be done in one step (e.g measureAndAddText). Collision test could be injected\n    // in the middle as a function.\n    if (!textCanvas.measureText(labelState.element.glyphs, tmpBox, tmpMeasurementParams)) {\n        return PlacementResult.Rejected;\n    }\n    // Coarse collision check.\n    tmpCollisionBox.copy(tmpBox.translate(screenPosition));\n    if (!screenCollisions.isVisible(tmpCollisionBox)) {\n        return PlacementResult.Invisible;\n    }\n    let checkGlyphCollision = false;\n    let candidateBoxes;\n    if (!labelState.element.textMayOverlap) {\n        candidateBoxes = screenCollisions.search(tmpCollisionBox);\n        checkGlyphCollision = candidateBoxes.length > 0;\n    }\n    const checkGlyphVisible = !screenCollisions.isFullyVisible(tmpCollisionBox);\n    // Perform per-character collision checks.\n    tmpCollisionBoxes.length = tmpBoxes.length;\n    for (let i = 0; i < tmpBoxes.length; ++i) {\n        const glyphBox = tmpBoxes[i].translate(screenPosition);\n        let collisionBox = tmpCollisionBoxes[i];\n        if (collisionBox === undefined) {\n            collisionBox = new ScreenCollisions_1.CollisionBox(glyphBox);\n            tmpCollisionBoxes[i] = collisionBox;\n        }\n        else {\n            collisionBox.copy(glyphBox);\n        }\n        if (checkGlyphVisible && !screenCollisions.isVisible(collisionBox)) {\n            return PlacementResult.Invisible;\n        }\n        if (checkGlyphCollision &&\n            screenCollisions.intersectsDetails(collisionBox, candidateBoxes)) {\n            return PlacementResult.Rejected;\n        }\n    }\n    // Allocate collision info if needed.\n    if (labelState.element.textReservesSpace) {\n        const collisionBox = new ScreenCollisions_1.DetailedCollisionBox(tmpCollisionBox, tmpCollisionBoxes.slice());\n        tmpCollisionBoxes.length = 0;\n        screenCollisions.allocate(collisionBox);\n    }\n    return PlacementResult.Ok;\n}\nexports.placePathLabel = placePathLabel;\n/**\n * Check if a given path label is too small to be rendered.\n * @param textElement The text element to check.\n * @param screenProjector Used to project coordinates from world to screen space.\n * @param outScreenPoints Label path projected to screen space.\n * @returns `true` if label is too small, `false` otherwise.\n */\nfunction isPathLabelTooSmall(textElement, screenProjector, outScreenPoints) {\n    harp_utils_1.assert(textElement.type === TextElementType_1.TextElementType.PathLabel);\n    // Get the screen points that define the label's segments and create a path with\n    // them.\n    outScreenPoints.length = 0;\n    let anyPointVisible = false;\n    for (const pt of textElement.points) {\n        // Skip invisible points at the beginning of the path.\n        const screenPoint = anyPointVisible\n            ? screenProjector.project(pt, tmpScreenPosition)\n            : screenProjector.projectOnScreen(pt, tmpScreenPosition);\n        if (screenPoint === undefined) {\n            continue;\n        }\n        anyPointVisible = true;\n        outScreenPoints.push(tmpScreenPosition.clone());\n    }\n    // TODO: (HARP-3515)\n    //      The rendering of a path label that contains just a single point that is not\n    //      visible is impossible, which is problematic with long paths.\n    //      Fix: Skip/clip the invisible points at beginning and end of the path to get\n    //      the visible part of the path.\n    // If not a single point is visible, skip the path\n    if (!anyPointVisible) {\n        return true;\n    }\n    // Check/guess if the screen box can hold a string of that length. It is important\n    // to guess that value without measuring the font first to save time.\n    const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;\n    tmpBox.setFromPoints(outScreenPoints);\n    const boxDiagonalSq = tmpBox.max.sub(tmpBox.min).lengthSq();\n    if (boxDiagonalSq < minScreenSpace * minScreenSpace) {\n        textElement.dbgPathTooSmall = true;\n        return true;\n    }\n    return false;\n}\nexports.isPathLabelTooSmall = isPathLabelTooSmall;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/Placement.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/PlacementStats.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/PlacementStats.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass PlacementStats {\n    constructor(m_logger) {\n        this.m_logger = m_logger;\n        this.totalGroups = 0;\n        this.resortedGroups = 0;\n        this.total = 0;\n        this.uninitialized = 0;\n        this.tooFar = 0;\n        this.numNotVisible = 0;\n        this.numPathTooSmall = 0;\n        this.numCannotAdd = 0;\n        this.numRenderedPoiIcons = 0;\n        this.numRenderedPoiTexts = 0;\n        this.numPoiTextsInvisible = 0;\n        this.numRenderedTextElements = 0;\n    }\n    clear() {\n        this.totalGroups = 0;\n        this.resortedGroups = 0;\n        this.total = 0;\n        this.uninitialized = 0;\n        this.tooFar = 0;\n        this.numNotVisible = 0;\n        this.numPathTooSmall = 0;\n        this.numCannotAdd = 0;\n        this.numRenderedPoiIcons = 0;\n        this.numRenderedPoiTexts = 0;\n        this.numPoiTextsInvisible = 0;\n        this.numRenderedTextElements = 0;\n    }\n    log() {\n        const numNotRendered = this.uninitialized +\n            this.numPoiTextsInvisible +\n            this.tooFar +\n            this.numNotVisible +\n            this.numCannotAdd;\n        this.m_logger.debug(\"Total groups\", this.totalGroups);\n        this.m_logger.debug(\"Resorted groups\", this.resortedGroups);\n        this.m_logger.debug(\"Total labels\", this.total);\n        this.m_logger.debug(\"Rendered labels\", this.numRenderedTextElements);\n        this.m_logger.debug(\"Rejected labels\", numNotRendered);\n        this.m_logger.debug(\"Unitialized labels\", this.uninitialized);\n        this.m_logger.debug(\"Rendered poi icons\", this.numRenderedPoiIcons);\n        this.m_logger.debug(\"Rendered poi texts\", this.numRenderedPoiTexts);\n        this.m_logger.debug(\"Poi text invisible\", this.numPoiTextsInvisible);\n        this.m_logger.debug(\"Too far\", this.tooFar);\n        this.m_logger.debug(\"Not visible\", this.numNotVisible);\n        this.m_logger.debug(\"Path too small\", this.numPathTooSmall);\n        this.m_logger.debug(\"Rejected, max glyphs reached\", this.numCannotAdd);\n    }\n}\nexports.PlacementStats = PlacementStats;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/PlacementStats.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/RenderState.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/RenderState.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * State of fading.\n */\nvar FadingState;\n(function (FadingState) {\n    FadingState[FadingState[\"Undefined\"] = 0] = \"Undefined\";\n    FadingState[FadingState[\"FadingIn\"] = 1] = \"FadingIn\";\n    FadingState[FadingState[\"FadedIn\"] = 2] = \"FadedIn\";\n    FadingState[FadingState[\"FadingOut\"] = -1] = \"FadingOut\";\n    FadingState[FadingState[\"FadedOut\"] = -2] = \"FadedOut\";\n})(FadingState = exports.FadingState || (exports.FadingState = {}));\n/**\n * Time to fade in/fade out the labels in milliseconds.\n */\nexports.DEFAULT_FADE_TIME = 800;\n/**\n * State of rendering of the icon and text part of the `TextElement`. Mainly for fading the elements\n * in and out, to compute the opacity.\n *\n * @hidden\n */\nclass RenderState {\n    /**\n     * Create a `RenderState`.\n     *\n     * @param value Current fading value [0..1].\n     * @param startTime Time stamp the fading started.\n     * @param opacity Computed opacity depending on value.\n     */\n    constructor(value = 0.0, startTime = 0, opacity = 1.0) {\n        this.value = value;\n        this.startTime = startTime;\n        this.opacity = opacity;\n        this.m_state = FadingState.Undefined;\n    }\n    /**\n     * Reset existing `RenderState` to appear like a fresh state.\n     */\n    reset() {\n        this.m_state = FadingState.Undefined;\n        this.value = 0.0;\n        this.startTime = 0.0;\n        this.opacity = 1.0;\n    }\n    /**\n     * @returns `true` if element state is `FadingState.Undefined`.\n     */\n    isUndefined() {\n        return this.m_state === FadingState.Undefined;\n    }\n    /**\n     * @returns `true` if element is either fading in or fading out.\n     */\n    isFading() {\n        const fading = this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadingOut;\n        return fading;\n    }\n    /**\n     * @returns `true` if element is fading in.\n     */\n    isFadingIn() {\n        const fadingIn = this.m_state === FadingState.FadingIn;\n        return fadingIn;\n    }\n    /**\n     * @returns `true` if element is fading out.\n     */\n    isFadingOut() {\n        const fadingOut = this.m_state === FadingState.FadingOut;\n        return fadingOut;\n    }\n    /**\n     * @returns `true` if element is done with fading in.\n     */\n    isFadedIn() {\n        const fadedIn = this.m_state === FadingState.FadedIn;\n        return fadedIn;\n    }\n    /**\n     * @returns `true` if element is done with fading out.\n     */\n    isFadedOut() {\n        const fadedOut = this.m_state === FadingState.FadedOut;\n        return fadedOut;\n    }\n    /**\n     * @returns `true` if state is neither faded out nor undefined.\n     */\n    isVisible() {\n        return this.m_state !== FadingState.FadedOut && this.m_state !== FadingState.Undefined;\n    }\n    /**\n     * Updates the state to [[FadingState.FadingIn]].\n     * If previous state is [[FadingState.FadingIn]] or [[FadingState.FadedIn]] it remains\n     * unchanged.\n     *\n     * @param time Current time.\n     */\n    startFadeIn(time) {\n        if (this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadedIn) {\n            return;\n        }\n        if (this.m_state === FadingState.FadingOut) {\n            // The fadeout is not complete: compute the virtual fadingStartTime in the past, to get\n            // a correct end time:\n            this.value = 1.0 - this.value;\n            this.startTime = time - this.value * exports.DEFAULT_FADE_TIME;\n        }\n        else {\n            this.startTime = time;\n            this.value = 0.0;\n            this.opacity = 0;\n        }\n        this.m_state = FadingState.FadingIn;\n    }\n    /**\n     * Updates the state to [[FadingState.FadingOut]].\n     * If previous state is [[FadingState.FadingOut]] or [[FadingState.FadedOut]] it remains\n     * unchanged.\n     *\n     * @param time Current time.\n     */\n    startFadeOut(time) {\n        if (this.m_state === FadingState.FadingOut || this.m_state === FadingState.FadedOut) {\n            return;\n        }\n        if (this.m_state === FadingState.FadingIn) {\n            // The fade-in is not complete: compute the virtual fadingStartTime in the past, to get\n            // a correct end time:\n            this.startTime = time - this.value * exports.DEFAULT_FADE_TIME;\n            this.value = 1.0 - this.value;\n        }\n        else {\n            this.startTime = time;\n            this.value = 0.0;\n            this.opacity = 1;\n        }\n        this.m_state = FadingState.FadingOut;\n    }\n    /**\n     * Updates opacity to current time, changing the state to [[FadingState.FadedOut]] or\n     * [[FadingState.FadedIn]] when the opacity becomes 0 or 1 respectively.\n     * It does nothing if [[isFading]] !== `true`.\n     *\n     * @param time Current time.\n     * @param disableFading `true` if fading is disabled, `false` otherwise.\n     */\n    updateFading(time, disableFading) {\n        if (this.m_state !== FadingState.FadingIn && this.m_state !== FadingState.FadingOut) {\n            return;\n        }\n        if (this.startTime === 0) {\n            this.startTime = time;\n        }\n        const fadingTime = time - this.startTime;\n        const startValue = this.m_state === FadingState.FadingIn ? 0 : 1;\n        const endValue = this.m_state === FadingState.FadingIn ? 1 : 0;\n        if (disableFading || fadingTime >= exports.DEFAULT_FADE_TIME) {\n            this.value = 1.0;\n            this.opacity = endValue;\n            this.m_state =\n                this.m_state === FadingState.FadingIn ? FadingState.FadedIn : FadingState.FadedOut;\n        }\n        else {\n            // TODO: HARP-7648. Do this once for all labels (calculate the last frame value\n            // increment).\n            this.value = fadingTime / exports.DEFAULT_FADE_TIME;\n            this.opacity = THREE.Math.clamp(harp_utils_1.MathUtils.smootherStep(startValue, endValue, this.value), 0, 1);\n            harp_utils_1.assert(this.isFading());\n        }\n    }\n}\nexports.RenderState = RenderState;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/RenderState.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/SimplePath.js":
/*!****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/SimplePath.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * @hidden\n */\nclass SimpleLineCurve extends THREE.LineCurve {\n    constructor(v1, v2) {\n        super(v1, v2);\n    }\n    getLengths() {\n        if (this.m_lengths === undefined) {\n            this.m_lengths = [0, this.v2.distanceTo(this.v1)];\n        }\n        return this.m_lengths;\n    }\n}\nexports.SimpleLineCurve = SimpleLineCurve;\n/**\n * @hidden\n */\nclass PathParam {\n    constructor(path, index, t) {\n        this.path = path;\n        this.index = index;\n        this.t = t;\n    }\n    get curve() {\n        return this.path.curves[this.index];\n    }\n    get point() {\n        if (this.m_point === undefined) {\n            this.m_point = this.curve.getPoint(this.t);\n        }\n        return this.m_point;\n    }\n}\nexports.PathParam = PathParam;\n/**\n * @hidden\n */\nclass SimplePath extends THREE.Path {\n    constructor() {\n        super();\n    }\n    getLengths() {\n        if (this.m_cache) {\n            return this.m_cache;\n        }\n        let sum = 0;\n        const lengths = new Array();\n        lengths.push(0);\n        this.curves.forEach(curve => {\n            const lineCurve = curve;\n            sum += lineCurve.v1.distanceTo(lineCurve.v2);\n            lengths.push(sum);\n        });\n        this.m_cache = lengths;\n        return lengths;\n    }\n    getParamAt(t) {\n        const distance = t * this.getLength();\n        const curveLengths = this.getCurveLengths();\n        for (let index = 0; index < curveLengths.length; ++index) {\n            if (curveLengths[index] < distance) {\n                continue;\n            }\n            const diff = curveLengths[index] - distance;\n            const curve = this.curves[index];\n            const segmentLength = curve.getLength();\n            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n            return new PathParam(this, index, u);\n        }\n        return null;\n    }\n}\nexports.SimplePath = SimplePath;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/SimplePath.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nclass TextCanvasFactory {\n    /**\n     * Creates an instance of text canvas factory.\n     * @param m_renderer\n     */\n    constructor(m_renderer) {\n        this.m_renderer = m_renderer;\n        this.m_minGlyphCount = 0; //Min amount of glyphs each [[TextCanvas]] layer can store.\n        this.m_maxGlyphCount = 0; //Max amount of glyphs each [[TextCanvas]] layer can store.\n    }\n    setGlyphCountLimits(min, max) {\n        this.m_minGlyphCount = min;\n        this.m_maxGlyphCount = max;\n    }\n    /**\n     * Creates text canvas\n     * @param fontCatalog Initial [[FontCatalog]].\n     */\n    createTextCanvas(fontCatalog) {\n        harp_utils_1.assert(this.m_maxGlyphCount > 0);\n        return new harp_text_canvas_1.TextCanvas({\n            renderer: this.m_renderer,\n            fontCatalog,\n            minGlyphCount: this.m_minGlyphCount,\n            maxGlyphCount: this.m_maxGlyphCount\n        });\n    }\n}\nexports.TextCanvasFactory = TextCanvasFactory;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextCanvasFactory.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElement.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElement.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\n/**\n * Return 'true' if the POI has been successfully prepared for rendering.\n *\n * @param poiInfo PoiInfo containing information for rendering the POI icon.\n */\nfunction poiIsRenderable(poiInfo) {\n    return poiInfo.poiRenderBatch !== undefined;\n}\nexports.poiIsRenderable = poiIsRenderable;\n/**\n * State of loading.\n */\nvar LoadingState;\n(function (LoadingState) {\n    LoadingState[LoadingState[\"Requested\"] = 0] = \"Requested\";\n    LoadingState[LoadingState[\"Loaded\"] = 1] = \"Loaded\";\n    LoadingState[LoadingState[\"Initialized\"] = 2] = \"Initialized\";\n})(LoadingState = exports.LoadingState || (exports.LoadingState = {}));\n/**\n * `TextElement` is used to create 2D text elements (for example, labels).\n */\nclass TextElement {\n    /**\n     * Creates a new `TextElement`.\n     *\n     * @param text The text to display.\n     * @param points The position or a list of points for a curved text, both in local tile space.\n     * @param renderParams `TextElement` text rendering parameters.\n     * @param layoutParams `TextElement` text layout parameters.\n     * @param priority The priority of the `TextElement. Elements with the highest priority get\n     *              placed first, elements with priority of `0` are placed last, elements with a\n     *              negative value are always rendered, ignoring priorities and allowing\n     *              overrides.\n     * @param xOffset Optional X offset of this `TextElement` in screen coordinates.\n     * @param yOffset Optional Y offset of this `TextElement` in screen coordinates.\n     * @param featureId Optional number to identify feature (originated from `OmvDataSource`).\n     * @param fadeNear Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the\n     *              label starts fading out (opacity decreases).\n     * @param fadeFar Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the\n     *              label becomes transparent. A value of <= 0.0 disables fading.\n     */\n    constructor(text, points, renderParams, layoutParams, priority = 0, xOffset = 0, yOffset = 0, featureId, style, fadeNear, fadeFar, tileOffset) {\n        this.text = text;\n        this.points = points;\n        this.renderParams = renderParams;\n        this.layoutParams = layoutParams;\n        this.priority = priority;\n        this.xOffset = xOffset;\n        this.yOffset = yOffset;\n        this.featureId = featureId;\n        this.style = style;\n        this.fadeNear = fadeNear;\n        this.fadeFar = fadeFar;\n        this.tileOffset = tileOffset;\n        /**\n         * Determines visibility. If set to `false`, it will not be rendered.\n         */\n        this.visible = true;\n        /**\n         * Scaling factor of text. Defaults to 0.5, reducing the size ot 50% in the distance.\n         */\n        this.distanceScale = 0.5;\n        /**\n         * If specified, determines the render order between `TextElement`s. The number different\n         * renderOrders should be as small as possible, because every specific `renderOrder` may result\n         * in one or more draw calls.\n         *\n         * TextElements with the same integer `renderOrder` will be rendered in the same batch.\n         *\n         * The `renderOrder` of `TextElement`s are only relative to other `TextElement`s, and not other\n         * map elements.\n         *\n         * A `TextElement` with a higher `renderOrder` will be rendered after a `TextElement` with a\n         * lower `renderOrder`.\n         */\n        this.renderOrder = 0;\n        if (renderParams instanceof harp_text_canvas_1.TextRenderStyle) {\n            this.renderStyle = renderParams;\n        }\n        if (layoutParams instanceof harp_text_canvas_1.TextLayoutStyle) {\n            this.layoutStyle = layoutParams;\n        }\n        this.type =\n            points instanceof THREE.Vector3 ? TextElementType_1.TextElementType.PoiLabel : TextElementType_1.TextElementType.PathLabel;\n    }\n    /**\n     * The text element position or the first point of the path used to render a curved text, both\n     * in local tile space.\n     */\n    get position() {\n        if (this.points instanceof Array) {\n            const p = this.points[0];\n            return p;\n        }\n        return this.points;\n    }\n    /**\n     * The list of points in local tile space used to render the text along a path or `undefined`.\n     */\n    get path() {\n        if (this.points instanceof Array) {\n            return this.points;\n        }\n        return undefined;\n    }\n    /**\n     * If `true`, `TextElement` is allowed to overlap other labels or icons of lower priority.\n     *\n     * @default `false`\n     */\n    get textMayOverlap() {\n        return this.mayOverlap === true;\n    }\n    set textMayOverlap(mayOverlap) {\n        this.mayOverlap = mayOverlap;\n    }\n    /**\n     * If `true`, `TextElement` will reserve screen space, other markers of lower priority will not\n     * be able to overlap.\n     *\n     * @default `true`\n     */\n    get textReservesSpace() {\n        return this.reserveSpace !== false;\n    }\n    set textReservesSpace(reserveSpace) {\n        this.reserveSpace = reserveSpace;\n    }\n    /**\n     * Contains additional information about icon to be rendered along with text.\n     */\n    get poiInfo() {\n        return this.m_poiInfo;\n    }\n    set poiInfo(poiInfo) {\n        this.m_poiInfo = poiInfo;\n        if (poiInfo !== undefined) {\n            if (this.path !== undefined) {\n                this.type = TextElementType_1.TextElementType.LineMarker;\n            }\n            const poiRenderOrder = this.renderOrder !== undefined ? this.renderOrder : 0;\n            poiInfo.renderOrder = poiRenderOrder;\n        }\n    }\n    /**\n     * @returns The style used to render this text element, undefined if not set yet.\n     */\n    get renderStyle() {\n        return this.m_renderStyle;\n    }\n    /**\n     * Sets style used for text rendering.\n     * @param style The style to use.\n     */\n    set renderStyle(style) {\n        this.m_renderStyle = style;\n    }\n    /**\n     * @returns The style used to layout this text element, undefined if not set yet.\n     */\n    get layoutStyle() {\n        return this.m_layoutStyle;\n    }\n    /**\n     * Sets the style used for text layout.\n     * @param style The style to use.\n     */\n    set layoutStyle(style) {\n        this.m_layoutStyle = style;\n    }\n    hasFeatureId() {\n        return this.featureId !== undefined && this.featureId !== 0;\n    }\n    /**\n     * Update the minZoomLevel and maxZoomLevel from the values set in [[PoiInfo]].\n     * Selects the smaller/larger one of the two min/max values for icon and text, because the\n     * TextElement is a container for both.\n     */\n    updateMinMaxZoomLevelsFromPoiInfo() {\n        if (this.poiInfo !== undefined) {\n            if (this.minZoomLevel === undefined) {\n                this.minZoomLevel = harp_utils_1.MathUtils.min2(this.poiInfo.iconMinZoomLevel, this.poiInfo.textMinZoomLevel);\n            }\n            if (this.maxZoomLevel === undefined) {\n                this.maxZoomLevel = harp_utils_1.MathUtils.max2(this.poiInfo.iconMaxZoomLevel, this.poiInfo.textMaxZoomLevel);\n            }\n        }\n    }\n}\nexports.TextElement = TextElement;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElement.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/**\n * Group of [[TextElement]] sharing same priority.\n */\nclass TextElementGroup extends harp_utils_1.PriorityListGroup {\n}\nexports.TextElementGroup = TextElementGroup;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementGroup.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\n/**\n * List of [[TextElement]] groups sorted by priority.\n */\nclass TextElementGroupPriorityList extends harp_utils_1.GroupedPriorityList {\n}\nexports.TextElementGroupPriorityList = TextElementGroupPriorityList;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementGroupPriorityList.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst TextElementState_1 = __webpack_require__(/*! ./TextElementState */ \"./node_modules/@here/harp-mapview/lib/text/TextElementState.js\");\n/**\n * `TextElementGroupState` keeps the state of a text element group and each element in it while\n * they're being rendered.\n */\nclass TextElementGroupState {\n    /**\n     * Creates the state for specified group.\n     * @param group The group of which the state will be created.\n     * @param filter Function used to do early rejection. @see [[TextElementFilter]].\n     */\n    constructor(group, filter) {\n        this.group = group;\n        this.m_visited = false;\n        harp_utils_1.assert(group.elements.length > 0);\n        const length = group.elements.length;\n        this.m_textElementStates = new Array(length);\n        this.m_visited = true;\n        // TODO: HARP-7648. Reduce number of allocations here:\n        // a) Avoid creating the state for labels that don't pass early placement checks and make\n        //    this checks more strict.\n        // b) Break label state objects into a set of arrays held at group level, one for each\n        //    primitive field in the label state.\n        for (let i = 0; i < length; ++i) {\n            const textElement = group.elements[i];\n            const state = new TextElementState_1.TextElementState(textElement);\n            const textDistance = filter(state);\n            state.update(textDistance);\n            this.m_textElementStates[i] = state;\n        }\n    }\n    /**\n     * Indicates whether the group has been submitted to the [[TextElementsRenderer]] in the current\n     * frame.\n     */\n    get visited() {\n        return this.m_visited;\n    }\n    set visited(visited) {\n        this.m_visited = visited;\n    }\n    /**\n     * @returns the priority of the text elements in the group.\n     */\n    get priority() {\n        return this.group.priority;\n    }\n    /**\n     * Updates the fading state of all text elements within the group to the specified time.\n     * @param time The time to which the fading state will be updated.\n     * @param disableFading `true` if fading is disabled, `false` otherwise.\n     */\n    updateFading(time, disableFading) {\n        for (const elementState of this.m_textElementStates) {\n            if (elementState !== undefined) {\n                elementState.updateFading(time, disableFading);\n            }\n        }\n    }\n    /**\n     * Calls the specified callback for every visible text elements in the group.\n     * @param visibleElementsCallback Functions that will be called for every visible text element\n     * in the group.\n     */\n    traverseVisibleElements(visibleElementsCallback) {\n        for (const elementState of this.m_textElementStates) {\n            if (elementState !== undefined && elementState.visible) {\n                visibleElementsCallback(elementState);\n            }\n        }\n    }\n    /**\n     * Updates the states of elements within the group.\n     * @param filter Function used to do early rejection. @see [[TextElementFilter]].\n     */\n    updateElements(filter) {\n        for (const elementState of this.m_textElementStates) {\n            const textDistance = filter(elementState);\n            elementState.update(textDistance);\n        }\n    }\n    get size() {\n        return this.m_textElementStates.length;\n    }\n    /**\n     * Returns text element states.\n     * @returns Array of element states.\n     */\n    get textElementStates() {\n        return this.m_textElementStates;\n    }\n}\nexports.TextElementGroupState = TextElementGroupState;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementState.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementState.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst RenderState_1 = __webpack_require__(/*! ./RenderState */ \"./node_modules/@here/harp-mapview/lib/text/RenderState.js\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\n/**\n * `TextElementState` keeps the current state of a text element while it's being rendered.\n */\nclass TextElementState {\n    constructor(element) {\n        this.element = element;\n    }\n    get initialized() {\n        return this.m_textRenderState !== undefined || this.m_iconRenderStates !== undefined;\n    }\n    /**\n     * @returns `true` if any component of the element is visible, `false` otherwise.\n     */\n    get visible() {\n        if (this.m_textRenderState !== undefined && this.m_textRenderState.isVisible()) {\n            return true;\n        }\n        const iconRenderState = this.iconRenderState;\n        if (iconRenderState !== undefined && iconRenderState.isVisible()) {\n            return true;\n        }\n        const iconRenderStates = this.iconRenderStates;\n        if (iconRenderStates === undefined) {\n            return false;\n        }\n        for (const state of iconRenderStates) {\n            if (state.isVisible()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Resets the element to an initialized state.\n     */\n    reset() {\n        if (this.m_textRenderState !== undefined) {\n            this.m_textRenderState.reset();\n        }\n        if (this.iconRenderState) {\n            this.m_iconRenderStates.reset();\n        }\n        else if (this.m_iconRenderStates !== undefined) {\n            for (const renderState of this.m_iconRenderStates) {\n                renderState.reset();\n            }\n        }\n        this.m_viewDistance = undefined;\n    }\n    /**\n     * Replaces given text element, inheriting its current state.\n     * The predecessor text element state is erased.\n     * @param predecessor Text element state to be replaced.\n     */\n    replace(predecessor) {\n        this.m_textRenderState = predecessor.m_textRenderState;\n        this.m_iconRenderStates = predecessor.m_iconRenderStates;\n        predecessor.m_textRenderState = undefined;\n        predecessor.m_iconRenderStates = undefined;\n        if (this.element.glyphs === undefined) {\n            // Use the predecessor glyphs, bounds and case array until proper ones are computed.\n            this.element.glyphs = predecessor.element.glyphs;\n            this.element.bounds = predecessor.element.bounds;\n            this.element.glyphCaseArray = predecessor.element.glyphCaseArray;\n        }\n    }\n    /**\n     * Returns the last computed distance of the text element to the camera.\n     * @returns Distance to camera.\n     */\n    get viewDistance() {\n        return this.m_viewDistance;\n    }\n    /**\n     * Updates the text element state.\n     * @param viewDistance The new view distance to set. If `undefined`, element is considered to\n     * be out of view.\n     */\n    update(viewDistance) {\n        if (this.initialized) {\n            this.setViewDistance(viewDistance);\n        }\n        else if (viewDistance !== undefined) {\n            this.initialize(viewDistance);\n        }\n    }\n    /**\n     * Sets the distance of the element to the current view center.\n     * @param viewDistance The new view distance to set. If `undefined`, element is considered to\n     * be out of view.\n     */\n    setViewDistance(viewDistance) {\n        if (viewDistance === this.m_viewDistance) {\n            return;\n        }\n        this.m_viewDistance = viewDistance;\n    }\n    /**\n     * Return the last distance that has been computed for sorting during placement. This may not be\n     * the actual distance if the camera is moving, as the distance is computed only during\n     * placement. If the property `alwaysOnTop` is true, the value returned is always `0`.\n     *\n     * @returns 0 or negative distance to camera.\n     */\n    get renderDistance() {\n        return this.element.alwaysOnTop === true\n            ? 0\n            : this.m_viewDistance !== undefined\n                ? -this.m_viewDistance\n                : 0;\n    }\n    /**\n     * @returns The text render state.\n     */\n    get textRenderState() {\n        return this.m_textRenderState;\n    }\n    /**\n     * Returns the icon render state for the case where the text element has only one icon.\n     * @returns The icon render state if the text element has a single icon, otherwise undefined.\n     */\n    get iconRenderState() {\n        if (this.m_iconRenderStates === undefined) {\n            return undefined;\n        }\n        return this.m_iconRenderStates instanceof RenderState_1.RenderState ? this.m_iconRenderStates : undefined;\n    }\n    /**\n     * Returns the icon render states for text elements with multiple icons.\n     * @returns The icon render states if the text element has multiple icons, otherwise undefined.\n     */\n    get iconRenderStates() {\n        if (this.m_iconRenderStates === undefined) {\n            return undefined;\n        }\n        return this.m_iconRenderStates instanceof RenderState_1.RenderState\n            ? undefined\n            : this.m_iconRenderStates;\n    }\n    /**\n     * Updates the fading state to the specified time.\n     * @param time The current time.\n     * @param disableFading If `True` there will be no fading transitions, i.e., state will go\n     * directly from FadedIn to FadedOut and viceversa.\n     */\n    updateFading(time, disableFading) {\n        if (this.m_textRenderState !== undefined) {\n            this.m_textRenderState.updateFading(time, disableFading);\n        }\n        if (this.iconRenderState !== undefined) {\n            const iconRenderState = this.m_iconRenderStates;\n            iconRenderState.updateFading(time, disableFading);\n        }\n        else if (this.iconRenderStates !== undefined) {\n            for (const renderState of this.m_iconRenderStates) {\n                renderState.updateFading(time, disableFading);\n            }\n        }\n    }\n    /**\n     * @param viewDistance Current distance of the element to the view center.\n     */\n    initialize(viewDistance) {\n        harp_utils_1.assert(this.m_textRenderState === undefined);\n        harp_utils_1.assert(this.m_iconRenderStates === undefined);\n        this.setViewDistance(viewDistance);\n        if (this.element.type === TextElementType_1.TextElementType.LineMarker) {\n            this.m_iconRenderStates = new Array();\n            for (const _point of this.element.points) {\n                const iconRenderStates = this.m_iconRenderStates;\n                const renderState = new RenderState_1.RenderState();\n                iconRenderStates.push(renderState);\n            }\n            return;\n        }\n        this.m_textRenderState = new RenderState_1.RenderState();\n        if (this.element.type === TextElementType_1.TextElementType.PoiLabel) {\n            this.m_iconRenderStates = new RenderState_1.RenderState();\n        }\n    }\n}\nexports.TextElementState = TextElementState;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementState.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst TextElementGroupState_1 = __webpack_require__(/*! ./TextElementGroupState */ \"./node_modules/@here/harp-mapview/lib/text/TextElementGroupState.js\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TextElementsStateCache\", { level: harp_utils_1.LogLevel.Log });\n/**\n * Label distance tolerance squared in meters. Point labels with the same name that are closer in\n * world space than this value are treated as the same label. Used to identify duplicate labels in\n * overlapping tiles and label replacements at different storage levels.\n */\nfunction getDedupSqDistTolerance(zoomLevel) {\n    // Defining here a minimum tolerance of 10m at zoom level 13 or higher.\n    const minSqTol = 100;\n    const minSqTolLevel = 13;\n    const maxLevelDelta = 4;\n    const levelDelta = Math.min(maxLevelDelta, minSqTolLevel - Math.min(minSqTolLevel, Math.floor(zoomLevel)));\n    // Distance tolerance computed applying a factor over an arbitrary minimum tolerance for a\n    // chosen zoom level. The factor is an exponential function on zoom level delta wrt minimum\n    // tolerance zoom level.\n    // error = sqrt(sqError) = sqrt(minSqError* 2^(4d)) = minError*2^(2d)\n    //tslint:disable-next-line: no-bitwise\n    return minSqTol << (levelDelta << 2);\n}\nconst tmpCachedDuplicate = {\n    entries: [],\n    index: -1\n};\nfunction getCacheKey(element) {\n    return element.hasFeatureId() ? element.featureId : element.text;\n}\n/**\n * Finds a duplicate for a text element among a list of candidates using their feature ids.\n * @param elementState The state of the text element for which the duplicate will be found.\n * @param candidates The list of candidates to check.\n * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.\n */\nfunction findDuplicateById(elementState, candidates) {\n    // Cached entries with same feature id found, find the entry with the same tile offset.\n    const element = elementState.element;\n    const duplicateIndex = candidates.findIndex(entry => entry.element.tileOffset === element.tileOffset);\n    if (duplicateIndex === -1) {\n        return -1;\n    }\n    const candidate = candidates[duplicateIndex].element;\n    harp_utils_1.assert(element.featureId === candidate.featureId);\n    if (candidate.text !== element.text) {\n        // Labels with different text shouldn't share the same feature id. This points to\n        // an issue on the map data side. Submit a ticket to the corresponding map backend\n        // issue tracking system if available (e.g. OLPRPS project in JIRA for OMV),\n        // indicating affected labels including tile keys, texts and feature id.\n        logger.warn(`Text feature id ${element.featureId} collision between \"${element.text} and \\\n             ${candidate.text}`);\n        return undefined;\n    }\n    return duplicateIndex;\n}\n// Duplicate criteria for path labels. Candidates are better the longer their paths are.\nfunction isBetterPathDuplicate(newCandidate, _newDistance, oldCandidate, _oldDistance) {\n    if (newCandidate.pathLengthSqr === undefined) {\n        return false;\n    }\n    if (oldCandidate.pathLengthSqr === undefined) {\n        return false;\n    }\n    return newCandidate.pathLengthSqr > oldCandidate.pathLengthSqr;\n}\n// Duplicate criteria for point labels. Candidates are better the nearer they are to the label being\n// tested for duplicates.\nfunction isBetterPointDuplicate(_newCandidate, newDistance, _oldCandidate, oldDistance) {\n    return newDistance < oldDistance;\n}\n/**\n * Finds a duplicate for a text element among a list of candidates using their text and distances.\n * @param elementState The state of the text element for which the duplicate will be found.\n * @param candidates The list of candidates to check.\n * @param zoomLevel Current zoom level.\n * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.\n */\nfunction findDuplicateByText(elementState, candidates, zoomLevel) {\n    const element = elementState.element;\n    const maxSqDistError = getDedupSqDistTolerance(zoomLevel);\n    const entryCount = candidates.length;\n    const elementPosition = element.position;\n    const elementVisible = elementState.visible;\n    let dupIndex = -1;\n    let duplicate;\n    let dupDistSquared = Infinity;\n    const isBetterDuplicate = element.type === TextElementType_1.TextElementType.PoiLabel ? isBetterPointDuplicate : isBetterPathDuplicate;\n    for (let i = 0; i < entryCount; ++i) {\n        const candidateEntry = candidates[i];\n        const cachedElement = candidateEntry.element;\n        const areDiffType = element.type !== cachedElement.type;\n        const areBothVisible = elementVisible && candidateEntry.visible;\n        if (areDiffType || areBothVisible) {\n            // Two text elements with different type or visible at the same time are always\n            // considered distinct.\n            continue;\n        }\n        const distSquared = elementPosition.distanceToSquared(cachedElement.position);\n        if (distSquared > maxSqDistError) {\n            // Cached text element is too far away to be a duplicate.\n            continue;\n        }\n        if (duplicate === undefined ||\n            isBetterDuplicate(cachedElement, distSquared, duplicate, dupDistSquared)) {\n            dupIndex = i;\n            duplicate = cachedElement;\n            dupDistSquared = distSquared;\n        }\n    }\n    return dupIndex;\n}\n/**\n * Caches the state of text element groups currently rendered as well as the text element states\n * belonging to them, including their fading state and text deduplication information.\n */\nclass TextElementStateCache {\n    constructor() {\n        this.m_referenceMap = new Map();\n        // Cache for point labels which may have duplicates in same tile or in neighboring tiles.\n        this.m_textMap = new Map();\n    }\n    /**\n     * Gets the state corresponding to a given text element group or sets a newly created state if\n     * not found. It updates the states of the text elements belonging to the group using the\n     * specified parameters.\n     * @param textElementGroup The group of which the state will be obtained.\n     * @param textElementFilter Filter used to decide if a text element must be initialized,\n     * @see [[TextElementGroupState]] construction.\n     * @returns Tuple with the group state as first element and a boolean indicating whether the\n     * state was found in cache (`true`) or newly created (`false`) as second element.\n     */\n    getOrSet(textElementGroup, textElementFilter) {\n        let groupState = this.get(textElementGroup);\n        if (groupState !== undefined) {\n            harp_utils_1.assert(groupState.size === textElementGroup.elements.length);\n            groupState.updateElements(textElementFilter);\n            return [groupState, true];\n        }\n        groupState = new TextElementGroupState_1.TextElementGroupState(textElementGroup, textElementFilter);\n        this.set(textElementGroup, groupState);\n        return [groupState, false];\n    }\n    get size() {\n        return this.m_referenceMap.size;\n    }\n    /**\n     * @returns All text element group states in the cache by group priority.\n     */\n    get sortedGroupStates() {\n        if (this.m_sortedGroupStates === undefined) {\n            this.m_sortedGroupStates = Array.from(this.m_referenceMap.values());\n            this.m_sortedGroupStates.sort((a, b) => {\n                return b.group.priority - a.group.priority;\n            });\n        }\n        harp_utils_1.assert(this.m_referenceMap.size === this.m_sortedGroupStates.length);\n        return this.m_sortedGroupStates;\n    }\n    /**\n     * Updates state of all cached groups, discarding those that are not needed anymore.\n     * @param time The current time.\n     * @param disableFading `True` if fading is currently disabled, `false` otherwise.\n     * @param findReplacements `True` to replace each visible unvisited text element with a\n     * visited duplicate.\n     * @param zoomLevel Current zoom level.\n     * @returns `True` if any textElementGroup was evicted from cache, false otherwise.\n     */\n    update(time, disableFading, findReplacements, zoomLevel) {\n        const replaceCallback = findReplacements\n            ? this.replaceElement.bind(this, zoomLevel)\n            : undefined;\n        let anyEviction = false;\n        for (const [key, groupState] of this.m_referenceMap.entries()) {\n            if (groupState.visited) {\n                groupState.updateFading(time, disableFading);\n            }\n            else {\n                if (findReplacements) {\n                    groupState.traverseVisibleElements(replaceCallback);\n                }\n                this.m_referenceMap.delete(key);\n                this.m_sortedGroupStates = undefined;\n                anyEviction = true;\n            }\n        }\n        return anyEviction;\n    }\n    /**\n     * Clears visited state for all text element groups in cache.\n     */\n    clearVisited() {\n        for (const groupState of this.m_referenceMap.values()) {\n            groupState.visited = false;\n        }\n    }\n    clearTextCache() {\n        this.m_textMap.clear();\n    }\n    /**\n     * Clears the whole cache contents.\n     */\n    clear() {\n        this.m_referenceMap.clear();\n        this.m_sortedGroupStates = undefined;\n        this.m_textMap.clear();\n    }\n    /**\n     * Removes duplicates for a given text element.\n     *\n     * @param zoomLevel Current zoom level.\n     * @param elementState State of the text element to deduplicate.\n     * @returns True if it's the remaining element after deduplication, false if it's been marked\n     * as duplicate.\n     */\n    deduplicateElement(zoomLevel, elementState) {\n        const cacheResult = this.findDuplicate(elementState, zoomLevel);\n        if (cacheResult === undefined) {\n            // Text not found so far, add this element to cache.\n            this.m_textMap.set(getCacheKey(elementState.element), [elementState]);\n            return true;\n        }\n        if (cacheResult.index === -1) {\n            // No duplicate found among elements with same text,add this one to cache.\n            cacheResult.entries.push(elementState);\n            return true;\n        }\n        // Duplicate found, check whether there's a label already visible and keep that one.\n        const cachedDuplicate = cacheResult.entries[cacheResult.index];\n        if (!cachedDuplicate.visible && elementState.visible) {\n            // New label is visible, substitute the cached label.\n            cacheResult.entries[cacheResult.index] = elementState;\n            cachedDuplicate.reset();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Replaces a visible unvisited text element with a visited duplicate.\n     * @param zoomLevel Current zoom level.\n     * @param elementState State of the text element to deduplicate.\n     */\n    replaceElement(zoomLevel, elementState) {\n        harp_utils_1.assert(elementState.visible);\n        const cacheResult = this.findDuplicate(elementState, zoomLevel);\n        if (cacheResult === undefined || cacheResult.index === -1) {\n            // No replacement found;\n            return;\n        }\n        const replacement = cacheResult.entries[cacheResult.index];\n        harp_utils_1.assert(!replacement.visible);\n        replacement.replace(elementState);\n    }\n    /**\n     * Gets the state corresponding to a given text element group.\n     * @param textElementGroup The group of which the state will be obtained.\n     * @returns The group state if cached, otherwise `undefined`.\n     */\n    get(textElementGroup) {\n        const groupState = this.m_referenceMap.get(textElementGroup);\n        if (groupState !== undefined) {\n            groupState.visited = true;\n        }\n        return groupState;\n    }\n    /**\n     * Sets a specified state for a given text element group.\n     * @param textElementGroup  The group of which the state will be set.\n     * @param textElementGroupState The state to set for the group.\n     */\n    set(textElementGroup, textElementGroupState) {\n        harp_utils_1.assert(textElementGroup.elements.length > 0);\n        this.m_referenceMap.set(textElementGroup, textElementGroupState);\n        this.m_sortedGroupStates = undefined;\n    }\n    findDuplicate(elementState, zoomLevel) {\n        // Point labels may have duplicates (as can path labels), Identify them\n        // and keep the one we already display.\n        const element = elementState.element;\n        const cachedEntries = this.m_textMap.get(getCacheKey(element));\n        if (cachedEntries === undefined) {\n            // No labels found with the same key.\n            return undefined;\n        }\n        tmpCachedDuplicate.entries = cachedEntries;\n        const index = element.hasFeatureId()\n            ? findDuplicateById(elementState, cachedEntries)\n            : findDuplicateByText(elementState, cachedEntries, zoomLevel);\n        if (index === undefined) {\n            // Feature id collision, try finding duplicates using text as key.\n            element.featureId = undefined;\n            return this.findDuplicate(elementState, zoomLevel);\n        }\n        tmpCachedDuplicate.index = index;\n        return tmpCachedDuplicate;\n    }\n}\nexports.TextElementStateCache = TextElementStateCache;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementType.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementType.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Types of text elements.\n */\nvar TextElementType;\n(function (TextElementType) {\n    TextElementType[TextElementType[\"PoiLabel\"] = 0] = \"PoiLabel\";\n    TextElementType[TextElementType[\"PathLabel\"] = 1] = \"PathLabel\";\n    TextElementType[TextElementType[\"LineMarker\"] = 2] = \"LineMarker\";\n})(TextElementType = exports.TextElementType || (exports.TextElementType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementType.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst DebugContext_1 = __webpack_require__(/*! ../DebugContext */ \"./node_modules/@here/harp-mapview/lib/DebugContext.js\");\nconst PickHandler_1 = __webpack_require__(/*! ../PickHandler */ \"./node_modules/@here/harp-mapview/lib/PickHandler.js\");\nconst Placement_1 = __webpack_require__(/*! ./Placement */ \"./node_modules/@here/harp-mapview/lib/text/Placement.js\");\nconst PlacementStats_1 = __webpack_require__(/*! ./PlacementStats */ \"./node_modules/@here/harp-mapview/lib/text/PlacementStats.js\");\nconst SimplePath_1 = __webpack_require__(/*! ./SimplePath */ \"./node_modules/@here/harp-mapview/lib/text/SimplePath.js\");\nconst TextElement_1 = __webpack_require__(/*! ./TextElement */ \"./node_modules/@here/harp-mapview/lib/text/TextElement.js\");\nconst TextElementsRendererOptions_1 = __webpack_require__(/*! ./TextElementsRendererOptions */ \"./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js\");\nconst TextElementStateCache_1 = __webpack_require__(/*! ./TextElementStateCache */ \"./node_modules/@here/harp-mapview/lib/text/TextElementStateCache.js\");\nconst TextElementType_1 = __webpack_require__(/*! ./TextElementType */ \"./node_modules/@here/harp-mapview/lib/text/TextElementType.js\");\nconst TextStyleCache_1 = __webpack_require__(/*! ./TextStyleCache */ \"./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js\");\nconst UpdateStats_1 = __webpack_require__(/*! ./UpdateStats */ \"./node_modules/@here/harp-mapview/lib/text/UpdateStats.js\");\nvar Pass;\n(function (Pass) {\n    Pass[Pass[\"PersistentLabels\"] = 0] = \"PersistentLabels\";\n    Pass[Pass[\"NewLabels\"] = 1] = \"NewLabels\";\n})(Pass || (Pass = {}));\n/**\n * Default distance scale. Will be applied if distanceScale is not defined in the technique.\n * Defines the scale that will be applied to labeled icons (icon and text) in the distance.\n */\nexports.DEFAULT_TEXT_DISTANCE_SCALE = 0.5;\n/**\n * Maximum number of recommended labels. If more labels are encountered, the \"overloaded\" mode is\n * set, which modifies the behavior of label placement and rendering, trying to keep delivering an\n * interactive performance. The overloaded mode should not be activated if the [[MapView]] is\n * rendering a static image (camera not moving and no animation running).\n */\nconst OVERLOAD_LABEL_LIMIT = 20000;\n/**\n * If \"overloaded\" is `true`:\n *\n * Default number of labels/POIs updated in a frame. They are rendered only if they fit. If the\n * camera is not moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_UPDATED_LABEL_LIMIT = 100;\n/**\n * If \"overloaded\" is `true`:\n *\n * Maximum time in milliseconds available for placement. If value is <= 0, or if the camera is not\n * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_UPDATE_TIME_LIMIT = 5;\n/**\n * If \"overloaded\" is `true`:\n *\n * Maximum time in milliseconds available for rendering. If value is <= 0, or if the camera is not\n * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_PLACE_TIME_LIMIT = 10;\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TextElementsRenderer\", { level: harp_utils_1.LogLevel.Log });\n// Development flag: Enable debug print.\nconst PRINT_LABEL_DEBUG_INFO = false;\nconst updateStats = PRINT_LABEL_DEBUG_INFO ? new UpdateStats_1.UpdateStats(logger) : undefined;\nconst placementStats = PRINT_LABEL_DEBUG_INFO ? new PlacementStats_1.PlacementStats(logger) : undefined;\nconst tempPosition = new THREE.Vector3();\nconst tempScreenPosition = new THREE.Vector2();\nconst tempScreenPoints = [];\nconst tempPoiScreenPosition = new THREE.Vector2();\nconst tmpTextBufferCreationParams = {};\nconst tmpAdditionParams = {};\nconst tmpBufferAdditionParams = {};\nclass TileTextElements {\n    constructor(tile, group) {\n        this.tile = tile;\n        this.group = group;\n    }\n}\nclass TextElementLists {\n    constructor(lists) {\n        this.lists = lists;\n    }\n    get priority() {\n        harp_utils_1.assert(this.lists.length > 0);\n        // All text element lists here have the same priority.\n        return this.lists[0].group.priority;\n    }\n    /**\n     * Sum up the number of elements in all lists.\n     */\n    count() {\n        let n = 0;\n        for (const list of this.lists) {\n            n += list.group.elements.length;\n        }\n        return n;\n    }\n}\nfunction checkIfTextElementsChanged(dataSourceTileList) {\n    let textElementsChanged = false;\n    dataSourceTileList.forEach(({ renderedTiles }) => {\n        renderedTiles.forEach(tile => {\n            if (tile.textElementsChanged) {\n                tile.textElementsChanged = false;\n                textElementsChanged = true;\n            }\n        });\n    });\n    return textElementsChanged;\n}\nfunction addTextToCanvas(textElement, canvas, screenPosition, path, pathOverflow) {\n    tmpAdditionParams.path = path;\n    tmpAdditionParams.pathOverflow = pathOverflow;\n    tmpAdditionParams.layer = textElement.renderOrder;\n    tmpAdditionParams.letterCaseArray = textElement.glyphCaseArray;\n    tmpAdditionParams.pickingData = textElement.userData ? textElement : undefined;\n    canvas.addText(textElement.glyphs, screenPosition, tmpAdditionParams);\n}\nfunction addTextBufferToCanvas(textElementState, canvas, screenPosition, fadeFactor, scaleFactor) {\n    const textElement = textElementState.element;\n    const textRenderState = textElementState.textRenderState;\n    const opacity = textRenderState.opacity * fadeFactor * textElement.renderStyle.opacity;\n    if (opacity === 0) {\n        return false;\n    }\n    // Compute the TextBufferObject when we know we're gonna render this label.\n    tmpTextBufferCreationParams.letterCaseArray = textElement.glyphCaseArray;\n    if (textElement.textBufferObject === undefined) {\n        textElement.textBufferObject = canvas.createTextBufferObject(textElement.glyphs, tmpTextBufferCreationParams);\n    }\n    const backgroundIsVisible = textElement.renderStyle.backgroundOpacity > 0 &&\n        canvas.textRenderStyle.fontSize.backgroundSize > 0;\n    tmpBufferAdditionParams.layer = textElement.renderOrder;\n    tmpBufferAdditionParams.position = screenPosition;\n    tmpBufferAdditionParams.scale = scaleFactor;\n    tmpBufferAdditionParams.opacity = opacity;\n    tmpBufferAdditionParams.backgroundOpacity = backgroundIsVisible\n        ? tmpBufferAdditionParams.opacity * textElement.renderStyle.backgroundOpacity\n        : 0.0;\n    tmpBufferAdditionParams.pickingData = textElement.userData ? textElement : undefined;\n    canvas.addTextBufferObject(textElement.textBufferObject, tmpBufferAdditionParams);\n    return true;\n}\nfunction shouldRenderPointText(labelState, viewState, options) {\n    const textRenderState = labelState.textRenderState;\n    const label = labelState.element;\n    const poiInfo = label.poiInfo;\n    harp_utils_1.assert(label.type !== TextElementType_1.TextElementType.PathLabel);\n    const hasText = textRenderState !== undefined && label.text !== \"\";\n    if (!hasText) {\n        return false;\n    }\n    const visibleInZoomLevel = poiInfo === undefined ||\n        viewState.zoomLevel === undefined ||\n        harp_utils_1.MathUtils.isClamped(viewState.zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel);\n    if (!visibleInZoomLevel) {\n        return false;\n    }\n    const poiTextMaxDistance = Placement_1.getMaxViewDistance(viewState, options.maxDistanceRatioForPoiLabels);\n    const visibleAtDistance = label.ignoreDistance === true ||\n        labelState.viewDistance === undefined ||\n        labelState.viewDistance < poiTextMaxDistance;\n    if (!visibleAtDistance) {\n        return false;\n    }\n    // Do not render text if POI cannot be rendered and is not optional.\n    return poiInfo === undefined || poiInfo.isValid === true || poiInfo.iconIsOptional !== false;\n}\nfunction shouldRenderPoiText(labelState, viewState) {\n    // Do not actually render (just allocate space) if camera is moving and\n    // renderTextDuringMovements is not true.\n    const poiInfo = labelState.element.poiInfo;\n    return (!viewState.cameraIsMoving ||\n        poiInfo === undefined ||\n        poiInfo.renderTextDuringMovements === true);\n}\nfunction isPlacementTimeExceeded(startTime) {\n    // startTime is set in overload mode.\n    if (startTime === undefined || OVERLOAD_PLACE_TIME_LIMIT <= 0) {\n        return false;\n    }\n    const endTime = harp_utils_1.PerformanceTimer.now();\n    const elapsedTime = endTime - startTime;\n    if (elapsedTime > OVERLOAD_PLACE_TIME_LIMIT) {\n        logger.debug(\"Placement time limit exceeded.\");\n        return true;\n    }\n    return false;\n}\n/**\n * @hidden\n *\n * Internal class to manage all text rendering.\n */\nclass TextElementsRenderer {\n    /**\n     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as\n     * a preprocessing step, which is not done every frame, and also renders the placed\n     * [[TextElement]]s every frame.\n     *\n     * @param m_viewState State of the view for which this renderer will draw text.\n     * @param m_viewCamera Camera used by the view for which this renderer will draw text.\n     * @param m_viewUpdateCallback To be called whenever the view needs to be updated.\n     * @param m_screenCollisions General 2D screen occlusion management, may be shared between\n     *     instances.\n     * @param m_screenProjector Projects 3D coordinates into screen space.\n     * @param m_textCanvasFactory To create TextCanvas instances.\n     * @param m_poiRendererFactory To create PoiRenderer instances.\n     * @param m_poiManager To prepare pois for rendering.\n     * @param m_fontCatalogLoader To load font catalogs.\n     * @param m_theme Theme defining  text styles.\n     * @param options Configuration options for the text renderer. See\n     * [[TextElementsRendererOptions]].\n     */\n    constructor(m_viewState, m_viewCamera, m_viewUpdateCallback, m_screenCollisions, m_screenProjector, m_textCanvasFactory, m_poiManager, m_poiRendererFactory, m_fontCatalogLoader, m_theme, options) {\n        this.m_viewState = m_viewState;\n        this.m_viewCamera = m_viewCamera;\n        this.m_viewUpdateCallback = m_viewUpdateCallback;\n        this.m_screenCollisions = m_screenCollisions;\n        this.m_screenProjector = m_screenProjector;\n        this.m_textCanvasFactory = m_textCanvasFactory;\n        this.m_poiManager = m_poiManager;\n        this.m_poiRendererFactory = m_poiRendererFactory;\n        this.m_fontCatalogLoader = m_fontCatalogLoader;\n        this.m_theme = m_theme;\n        this.m_initialized = false;\n        this.m_glyphLoadingCount = 0;\n        this.m_textRenderers = [];\n        this.m_tmpVector = new THREE.Vector2();\n        this.m_overloaded = false;\n        this.m_cacheInvalidated = false;\n        this.m_forceNewLabelsPass = false;\n        this.m_textElementStateCache = new TextElementStateCache_1.TextElementStateCache();\n        this.m_textStyleCache = new TextStyleCache_1.TextStyleCache(this.m_theme);\n        this.m_options = Object.assign({}, options);\n        TextElementsRendererOptions_1.initializeDefaultOptions(this.m_options);\n        this.m_textCanvasFactory.setGlyphCountLimits(this.m_options.minNumGlyphs, this.m_options.maxNumGlyphs);\n    }\n    /**\n     * Disable all fading animations (for debugging and performance measurement). Defaults to\n     * `false`.\n     */\n    set disableFading(disable) {\n        this.m_options.disableFading = disable;\n    }\n    get disableFading() {\n        return this.m_options.disableFading === true;\n    }\n    get styleCache() {\n        return this.m_textStyleCache;\n    }\n    /**\n     * Render the text using the specified camera into the current canvas.\n     *\n     * @param camera Orthographic camera to use.\n     */\n    renderText(camera) {\n        if (!this.initialized) {\n            return;\n        }\n        this.updateGlyphDebugMesh();\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.textCanvas.render(camera);\n        }\n    }\n    /**\n     * Forces update of text elements in the next call to [[placeText]].\n     */\n    invalidateCache() {\n        this.m_cacheInvalidated = true;\n    }\n    /**\n     * Notify `TextElementsRenderer` that the camera has started a movement.\n     */\n    movementStarted() {\n        // Nothing to do (yet)\n    }\n    /**\n     * Notify `TextElementsRenderer` that the camera has finished its movement.\n     */\n    movementFinished() {\n        this.invalidateCache();\n    }\n    /**\n     * Is `true` if number of [[TextElement]]s in visible tiles is larger than the recommended\n     * number `OVERLOAD_LABEL_LIMIT`.\n     */\n    get overloaded() {\n        return this.m_overloaded;\n    }\n    /**\n     * Places text elements for the current frame.\n     * @param dataSourceTileList List of tiles to be rendered for each data source.\n     * @param projection The view's projection.\n     * @param time Current frame time.\n     */\n    placeText(dataSourceTileList, projection, time) {\n        const tileTextElementsChanged = checkIfTextElementsChanged(dataSourceTileList);\n        const textElementsAvailable = this.hasOverlayText() || tileTextElementsChanged;\n        if (!this.initialize(textElementsAvailable)) {\n            return;\n        }\n        const updateTextElements = this.m_cacheInvalidated ||\n            tileTextElementsChanged ||\n            this.m_viewState.renderedTilesChanged;\n        logger.debug(`FRAME: ${this.m_viewState.frameNumber}, ZOOM LEVEL: ${this.m_viewState.zoomLevel}`);\n        if (updateTextElements) {\n            this.m_textElementStateCache.clearVisited();\n            this.updateTextElements(dataSourceTileList, projection);\n        }\n        const findReplacements = updateTextElements;\n        const anyTextGroupEvicted = this.m_textElementStateCache.update(time, this.m_options.disableFading, findReplacements, this.m_viewState.zoomLevel);\n        this.reset();\n        this.prepopulateScreenWithBlockingElements(dataSourceTileList);\n        // New text elements must be placed either if text elements were updated in this frame\n        // or if any text element group was evicted. The second case happens when the group is not\n        // visited anymore and all it's elements just became invisible, which means there's newly\n        // available screen space where new text elements could be placed. A common scenario where\n        // this happens is zooming in/out: text groups from the old level may still be fading out\n        // after all groups in the new level were updated.\n        const placeNewTextElements = updateTextElements || anyTextGroupEvicted;\n        this.placeTextElements(time, placeNewTextElements);\n        this.placeOverlayTextElements();\n        this.updateTextRenderers();\n    }\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements Array of [[TextElement]] to be added.\n     */\n    addOverlayText(textElements) {\n        if (textElements.length === 0) {\n            return;\n        }\n        this.m_overlayTextElements =\n            this.m_overlayTextElements === undefined\n                ? textElements.slice()\n                : this.m_overlayTextElements.concat(textElements);\n    }\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements Array of [[TextElement]] to be added.\n     */\n    clearOverlayText() {\n        this.m_overlayTextElements = [];\n    }\n    /**\n     * @returns Whether there's overlay text to be rendered.\n     */\n    hasOverlayText() {\n        return this.m_overlayTextElements !== undefined && this.m_overlayTextElements.length > 0;\n    }\n    get overlayText() {\n        return this.m_overlayTextElements;\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * [[TextElement]]s are found, the order of the results is unspecified.\n     *\n     * Note: [[TextElement]]s with identical `featureId` or identical `userData` will only appear\n     * once in the list `pickResults`.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickResults Array filled with pick results.\n     */\n    pickTextElements(screenPosition, pickResults) {\n        const pickHandler = (pickData, pickObjectType) => {\n            const textElement = pickData;\n            if (textElement === undefined) {\n                return;\n            }\n            let isDuplicate = false;\n            if (textElement.featureId !== undefined) {\n                isDuplicate = pickResults.some(pickResult => {\n                    return (pickResult !== undefined &&\n                        pickObjectType === pickResult.type &&\n                        ((pickResult.featureId !== undefined &&\n                            pickResult.featureId === textElement.featureId) ||\n                            (pickResult.userData !== undefined &&\n                                pickResult.userData === textElement.userData)));\n                });\n                if (!isDuplicate) {\n                    const pickResult = {\n                        type: pickObjectType,\n                        point: screenPosition,\n                        distance: 0,\n                        featureId: textElement.featureId,\n                        userData: textElement.userData,\n                        text: textElement.text\n                    };\n                    pickResults.push(pickResult);\n                }\n            }\n        };\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.textCanvas.pickText(screenPosition, (pickData) => {\n                pickHandler(pickData, PickHandler_1.PickObjectType.Text);\n            });\n            textRenderer.poiRenderer.pickTextElements(screenPosition, (pickData) => {\n                pickHandler(pickData, PickHandler_1.PickObjectType.Icon);\n            });\n        }\n    }\n    /**\n     * `true` if any resource used by any `FontCatalog` is still loading.\n     */\n    get loading() {\n        return this.m_fontCatalogLoader.loading || this.m_glyphLoadingCount > 0;\n    }\n    /**\n     * Waits till all pending resources from any `FontCatalog` are loaded.\n     */\n    async waitLoaded() {\n        const initialized = await this.waitInitialized();\n        if (!initialized) {\n            return false;\n        }\n        if (this.m_loadPromise === undefined) {\n            return false;\n        }\n        await this.m_loadPromise;\n        return true;\n    }\n    /**\n     * Reset the current text render states of all visible tiles. All [[TextElement]]s will fade in\n     * after that as if they have just been added.\n     */\n    clearRenderStates() {\n        this.m_textElementStateCache.clear();\n    }\n    /**\n     * Return memory used by all objects managed by `TextElementsRenderer`.\n     *\n     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.\n     */\n    getMemoryUsage() {\n        const memoryUsage = {\n            heapSize: 0,\n            gpuSize: 0\n        };\n        for (const renderer of this.m_textRenderers) {\n            renderer.textCanvas.getMemoryUsage(memoryUsage);\n            renderer.poiRenderer.getMemoryUsage(memoryUsage);\n        }\n        return memoryUsage;\n    }\n    get initialized() {\n        return this.m_initialized;\n    }\n    get initializing() {\n        return this.m_initPromise !== undefined;\n    }\n    /**\n     * Waits until initialization is done.\n     * @returns Promise resolved to true if initialization was done, false otherwise.\n     */\n    async waitInitialized() {\n        if (this.initialized) {\n            return true;\n        }\n        if (!this.initializing) {\n            return false;\n        }\n        await this.m_initPromise;\n        return true;\n    }\n    /**\n     * Initializes the text renderer once there's any text element available for rendering.\n     * @param textElementsAvailable Indicates whether there's any text element to be rendered.\n     * @returns Whether the text renderer is initialized.\n     */\n    initialize(textElementsAvailable) {\n        if (!this.initialized && !this.initializing && textElementsAvailable) {\n            this.initializeDefaultAssets();\n            this.m_initPromise = this.initializeTextCanvases().then(() => {\n                this.m_initialized = true;\n                this.m_initPromise = undefined;\n                this.invalidateCache(); // Force cache update after initialization.\n                this.m_viewUpdateCallback();\n            });\n        }\n        return this.initialized;\n    }\n    /**\n     * Reset internal state at the beginning of a frame.\n     */\n    reset() {\n        this.m_screenCollisions.reset();\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.textCanvas.clear();\n            textRenderer.poiRenderer.reset();\n        }\n    }\n    /**\n     * Update state at the end of a frame.\n     */\n    updateTextRenderers() {\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.poiRenderer.update();\n        }\n    }\n    /**\n     * Fills the screen with lines projected from world space, see [[Tile.blockingElements]].\n     * @note These boxes have highest priority, so will block all other labels.\n     * @param dataSourceTileList List of tiles to be rendered for each data source.\n     */\n    prepopulateScreenWithBlockingElements(dataSourceTileList) {\n        const boxes = [];\n        dataSourceTileList.forEach(renderListEntry => {\n            const startLinePointProj = new THREE.Vector3();\n            const endLinePointProj = new THREE.Vector3();\n            for (const tile of renderListEntry.renderedTiles.values()) {\n                for (const pathBlockingElement of tile.blockingElements) {\n                    if (pathBlockingElement.points.length < 2) {\n                        continue;\n                    }\n                    this.m_screenProjector.project3(pathBlockingElement.points[0], startLinePointProj);\n                    for (let i = 1; i < pathBlockingElement.points.length; i++) {\n                        this.m_screenProjector.project3(pathBlockingElement.points[i], endLinePointProj);\n                        const line = pathBlockingElement.screenSpaceLines[i - 1];\n                        line.start.copy(startLinePointProj);\n                        line.end.copy(endLinePointProj);\n                        const lineWithBound = {\n                            minX: Math.min(startLinePointProj.x, endLinePointProj.x),\n                            maxX: Math.max(startLinePointProj.x, endLinePointProj.x),\n                            minY: Math.min(startLinePointProj.y, endLinePointProj.y),\n                            maxY: Math.max(startLinePointProj.y, endLinePointProj.y),\n                            line\n                        };\n                        boxes.push(lineWithBound);\n                        startLinePointProj.copy(endLinePointProj);\n                    }\n                }\n            }\n        });\n        this.m_screenCollisions.allocateIBoxes(boxes);\n    }\n    /**\n     * @returns True if whole group was processed for placement,\n     * false otherwise (e.g. placement limit reached).\n     */\n    placeTextElementGroup(groupState, renderParams, maxNumPlacedLabels, pass) {\n        // Unvisited text elements are never placed.\n        harp_utils_1.assert(groupState.visited);\n        if (this.m_textRenderers.length === 0) {\n            logger.warn(\"No text renderers initialized.\");\n            return false;\n        }\n        const shieldGroups = [];\n        const hiddenKinds = this.m_viewState.hiddenGeometryKinds;\n        for (const textElementState of groupState.textElementStates) {\n            if (pass === Pass.PersistentLabels) {\n                if (placementStats) {\n                    ++placementStats.total;\n                }\n            }\n            if (maxNumPlacedLabels >= 0 &&\n                renderParams.numRenderedTextElements >= maxNumPlacedLabels) {\n                logger.debug(\"Placement label limit exceeded.\");\n                return false;\n            }\n            // Skip all labels that are not initialized (didn't pass early placement tests)\n            // or don't belong to this pass.\n            if (!textElementState.initialized) {\n                if (placementStats) {\n                    ++placementStats.uninitialized;\n                }\n                continue;\n            }\n            if (textElementState.viewDistance === undefined) {\n                if (placementStats) {\n                    ++placementStats.tooFar;\n                }\n                continue;\n            }\n            const elementVisible = textElementState.visible;\n            if ((pass === Pass.PersistentLabels && !elementVisible) ||\n                (pass === Pass.NewLabels && elementVisible)) {\n                continue;\n            }\n            const textElement = textElementState.element;\n            // Get the TextElementStyle.\n            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);\n            const textCanvas = textElementStyle.textCanvas;\n            const poiRenderer = textElementStyle.poiRenderer;\n            if (textCanvas === undefined || poiRenderer === undefined) {\n                logger.warn(\"Text canvas or poi renderer not ready.\");\n                continue;\n            }\n            // TODO: HARP-7648. Discard hidden kinds sooner, before placement.\n            // Check if the label should be hidden.\n            if (hiddenKinds !== undefined &&\n                textElement.kind !== undefined &&\n                hiddenKinds.hasOrIntersects(textElement.kind)) {\n                continue;\n            }\n            const elementType = textElement.type;\n            const isPathLabel = elementType === TextElementType_1.TextElementType.PathLabel;\n            // For paths, check if the label may fit.\n            if (isPathLabel) {\n                if (Placement_1.isPathLabelTooSmall(textElement, this.m_screenProjector, tempScreenPoints)) {\n                    if (placementStats) {\n                        placementStats.numNotVisible++;\n                    }\n                    if (textElement.dbgPathTooSmall === true) {\n                        if (placementStats) {\n                            placementStats.numPathTooSmall++;\n                        }\n                    }\n                    textElementState.textRenderState.reset();\n                    continue;\n                }\n            }\n            const forceNewPassOnLoaded = true;\n            if (!this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded)) {\n                continue;\n            }\n            const layer = textCanvas.getLayer(textElement.renderOrder || harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);\n            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.\n            if (layer !== undefined) {\n                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {\n                    if (placementStats) {\n                        ++placementStats.numCannotAdd;\n                    }\n                    logger.warn(\"layer glyph storage capacity exceeded.\");\n                    continue;\n                }\n            }\n            // Set the current style for the canvas.\n            textCanvas.textRenderStyle = textElement.renderStyle;\n            textCanvas.textLayoutStyle = textElement.layoutStyle;\n            switch (elementType) {\n                case TextElementType_1.TextElementType.PoiLabel:\n                    this.addPoiLabel(textElementState, poiRenderer, textCanvas, renderParams);\n                    break;\n                case TextElementType_1.TextElementType.LineMarker:\n                    this.addLineMarkerLabel(textElementState, poiRenderer, shieldGroups, textCanvas, renderParams);\n                    break;\n                case TextElementType_1.TextElementType.PathLabel:\n                    this.addPathLabel(textElementState, tempScreenPoints, textCanvas, renderParams);\n            }\n        }\n        return true;\n    }\n    initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded) {\n        // Trigger the glyph load if needed.\n        if (textElement.loadingState === TextElement_1.LoadingState.Initialized) {\n            return true;\n        }\n        harp_utils_1.assert(textElementStyle.textCanvas !== undefined);\n        const textCanvas = textElementStyle.textCanvas;\n        if (textElement.loadingState === undefined) {\n            textElement.loadingState = TextElement_1.LoadingState.Requested;\n            if (textElement.renderStyle === undefined) {\n                textElement.renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign(Object.assign({}, textElementStyle.renderParams), textElement.renderParams));\n            }\n            if (textElement.layoutStyle === undefined) {\n                textElement.layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign(Object.assign({}, textElementStyle.layoutParams), textElement.layoutParams));\n            }\n            if (textElement.text === \"\") {\n                textElement.loadingState = TextElement_1.LoadingState.Loaded;\n            }\n            else {\n                const newLoadPromise = textCanvas.fontCatalog\n                    .loadCharset(textElement.text, textElement.renderStyle)\n                    .then(() => {\n                    --this.m_glyphLoadingCount;\n                    textElement.loadingState = TextElement_1.LoadingState.Loaded;\n                    // Ensure that text elements still loading glyphs get a chance to\n                    // be rendered if there's no text element updates in the next frames.\n                    this.m_forceNewLabelsPass =\n                        this.m_forceNewLabelsPass || forceNewPassOnLoaded;\n                    this.m_viewUpdateCallback();\n                });\n                if (this.m_glyphLoadingCount === 0) {\n                    this.m_loadPromise = undefined;\n                }\n                ++this.m_glyphLoadingCount;\n                this.m_loadPromise =\n                    this.m_loadPromise === undefined\n                        ? newLoadPromise\n                        : Promise.all([this.m_loadPromise, newLoadPromise]);\n            }\n        }\n        if (textElement.loadingState === TextElement_1.LoadingState.Loaded) {\n            textCanvas.textRenderStyle = textElement.renderStyle;\n            textCanvas.textLayoutStyle = textElement.layoutStyle;\n            textElement.glyphCaseArray = [];\n            textElement.bounds = undefined;\n            textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);\n            textElement.loadingState = TextElement_1.LoadingState.Initialized;\n        }\n        // Return true as soon as a text element has some glyphs assigned so that it's rendered.\n        // The glyphs may be either the final ones or some temporal glyphs inherited from a\n        // predecessor as part of the text element replacement process.\n        // See TextElementState.replace().\n        return textElement.glyphs !== undefined;\n    }\n    initializeDefaultAssets() {\n        const defaultFontCatalogName = this.m_fontCatalogLoader.initialize(this.m_options.fontCatalog);\n        this.m_textStyleCache.initializeDefaultTextElementStyle(defaultFontCatalogName);\n    }\n    async initializeTextCanvases() {\n        const catalogCallback = (name, catalog) => {\n            const loadedTextCanvas = this.m_textCanvasFactory.createTextCanvas(catalog);\n            this.m_textRenderers.push({\n                fontCatalog: name,\n                textCanvas: loadedTextCanvas,\n                poiRenderer: this.m_poiRendererFactory.createPoiRenderer(loadedTextCanvas)\n            });\n        };\n        return this.m_fontCatalogLoader.loadCatalogs(catalogCallback).then(() => {\n            // Find the default TextCanvas and PoiRenderer.\n            let defaultTextCanvas;\n            this.m_textRenderers.forEach(textRenderer => {\n                if (defaultTextCanvas === undefined) {\n                    defaultTextCanvas = textRenderer.textCanvas;\n                }\n            });\n            const defaultPoiRenderer = this.m_poiRendererFactory.createPoiRenderer(defaultTextCanvas);\n            this.m_textStyleCache.initializeTextElementStyles(defaultPoiRenderer, defaultTextCanvas, this.m_textRenderers);\n        });\n    }\n    updateGlyphDebugMesh() {\n        const debugGlyphs = DebugContext_1.debugContext.getValue(\"DEBUG_GLYPHS\");\n        if (debugGlyphs === undefined) {\n            return;\n        }\n        if (debugGlyphs && this.m_debugGlyphTextureCacheMesh === undefined) {\n            this.initializeGlyphDebugMesh();\n        }\n        harp_utils_1.assert(this.m_debugGlyphTextureCacheMesh !== undefined);\n        harp_utils_1.assert(this.m_debugGlyphTextureCacheWireMesh !== undefined);\n        this.m_debugGlyphTextureCacheMesh.visible = debugGlyphs;\n        this.m_debugGlyphTextureCacheWireMesh.visible = debugGlyphs;\n    }\n    initializeGlyphDebugMesh() {\n        const defaultFontCatalog = this.m_textRenderers[0].textCanvas.fontCatalog;\n        // Initialize glyph-debugging mesh.\n        const planeGeometry = new THREE.PlaneGeometry(defaultFontCatalog.textureSize.width / 2.5, defaultFontCatalog.textureSize.height / 2.5, defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth, defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight);\n        const material = new THREE.MeshBasicMaterial({\n            transparent: true,\n            depthWrite: false,\n            depthTest: false,\n            map: defaultFontCatalog.texture\n        });\n        this.m_debugGlyphTextureCacheMesh = new THREE.Mesh(planeGeometry, material);\n        this.m_debugGlyphTextureCacheMesh.renderOrder = 10000;\n        this.m_debugGlyphTextureCacheMesh.visible = false;\n        this.m_debugGlyphTextureCacheMesh.name = \"glyphDebug\";\n        const wireframe = new THREE.WireframeGeometry(planeGeometry);\n        const wireframeMaterial = new THREE.LineBasicMaterial({\n            transparent: true,\n            color: 0x999999,\n            depthWrite: false,\n            depthTest: false\n        });\n        this.m_debugGlyphTextureCacheWireMesh = new THREE.LineSegments(wireframe, wireframeMaterial);\n        this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;\n        this.m_debugGlyphTextureCacheWireMesh.visible = false;\n        this.m_debugGlyphTextureCacheWireMesh.name = \"glyphDebug\";\n        this.m_textRenderers[0].textCanvas\n            .getLayer(harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER)\n            .storage.scene.add(this.m_debugGlyphTextureCacheMesh, this.m_debugGlyphTextureCacheWireMesh);\n    }\n    /**\n     * Visit all visible tiles and add/ their text elements to cache. The update of\n     * [[TextElement]]s is a time consuming process, and cannot be done every frame, but should only\n     * be done when the camera moved (a lot) of whenever the set of visible tiles change.\n     *\n     * The actually rendered [[TextElement]]s are stored internally until the next update is done\n     * to speed up rendering when no camera movement was detected.\n     * @param dataSourceTileList List of tiles to be rendered for each data source.\n     * @param projection The view's projection.\n     */\n    updateTextElements(dataSourceTileList, projection) {\n        logger.debug(\"updateTextElements\");\n        if (updateStats) {\n            updateStats.clear();\n        }\n        this.m_textElementStateCache.clearTextCache();\n        this.m_cacheInvalidated = false;\n        this.checkIfOverloaded(dataSourceTileList);\n        // Used with tile offset to compute the x coordinate offset for tiles.\n        const updateStartTime = this.overloaded && this.m_viewState.isDynamic ? harp_utils_1.PerformanceTimer.now() : undefined;\n        // TODO: HARP-7648. Skip all data sources that won't contain text.\n        // TODO: HARP-7651. Higher priority labels should be updated before lower priority ones\n        // across all data sources.\n        // TODO: HARP-7373. Use rendered tiles (tiles currently rendered to cover the view,\n        // including fallbacks if necessary) instead of visible tiles (target tiles that might not\n        // be decoded yet).\n        // Otherwise labels persistent when crossing a zoom level boundary will flicker (fade out\n        // and back in) due to the delay in decoding the visible tiles.\n        dataSourceTileList.forEach(tileList => {\n            this.updateTextElementsFromSource(tileList.dataSource, tileList.storageLevel, Array.from(tileList.renderedTiles.values()), projection, updateStartTime);\n        });\n        if (updateStats) {\n            updateStats.log();\n        }\n    }\n    updateTextElementsFromSource(tileDataSource, storageLevel, visibleTiles, projection, updateStartTime) {\n        if (updateStats) {\n            updateStats.tiles += visibleTiles.length;\n        }\n        const sortedTiles = visibleTiles;\n        // TODO: HARP-7648. Really needed? Should it be done here or in VisibleTileSet?\n        sortedTiles.sort((a, b) => {\n            return a.tileKey.mortonCode() - b.tileKey.mortonCode();\n        });\n        // Prepare user text elements.\n        for (const tile of sortedTiles) {\n            this.prepareTextElementGroup(tile.userTextElements, projection);\n        }\n        const sortedGroups = [];\n        this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);\n        let numTextElementsUpdated = 0;\n        for (const textElementLists of sortedGroups) {\n            this.selectTextElementsToUpdateByDistance(textElementLists, projection);\n            // The value of updateStartTime is set if this.overloaded is true.\n            if (updateStartTime !== undefined) {\n                // If overloaded and all time is used up, exit early.\n                if (OVERLOAD_UPDATE_TIME_LIMIT > 0) {\n                    const endTime = harp_utils_1.PerformanceTimer.now();\n                    const elapsedTime = endTime - updateStartTime;\n                    if (elapsedTime > OVERLOAD_UPDATE_TIME_LIMIT) {\n                        logger.debug(\"Update time limit exceeded.\");\n                        break;\n                    }\n                }\n                // Try not to update too many elements. They will be checked for visibility each\n                // frame.\n                numTextElementsUpdated += textElementLists.count();\n                if (numTextElementsUpdated >= OVERLOAD_UPDATED_LABEL_LIMIT) {\n                    logger.debug(\"Update label limit exceeded.\");\n                    break;\n                }\n            }\n        }\n    }\n    prepareTextElementGroup(textElementGroup, projection, maxViewDistance) {\n        if (textElementGroup.elements.length === 0) {\n            return;\n        }\n        const textElementSelection = (textElementState) => {\n            let { result, viewDistance } = Placement_1.checkReadyForPlacement(textElementState.element, this.m_viewState, this.m_viewCamera, this.m_poiManager, projection.type, maxViewDistance);\n            if (result === Placement_1.PrePlacementResult.Ok &&\n                !this.m_textElementStateCache.deduplicateElement(this.m_viewState.zoomLevel, textElementState)) {\n                result = Placement_1.PrePlacementResult.Duplicate;\n                viewDistance = undefined;\n            }\n            if (updateStats) {\n                updateStats.totalLabels++;\n                updateStats.results[result]++;\n            }\n            return viewDistance;\n        };\n        const [, found] = this.m_textElementStateCache.getOrSet(textElementGroup, textElementSelection);\n        if (updateStats) {\n            ++updateStats.totalGroups;\n            if (!found) {\n                ++updateStats.newGroups;\n            }\n        }\n    }\n    createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups) {\n        if (sortedTiles.length === 0) {\n            return;\n        }\n        const tilesToRender = [];\n        for (const tile of sortedTiles) {\n            if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {\n                tilesToRender.push(tile);\n            }\n        }\n        const groupedPriorityLists = new Map();\n        for (const tile of tilesToRender) {\n            for (const group of tile.textElementGroups.groups.values()) {\n                if (group.elements.length === 0) {\n                    continue;\n                }\n                const foundGroup = groupedPriorityLists.get(group.priority);\n                if (foundGroup === undefined) {\n                    groupedPriorityLists.set(group.priority, new TextElementLists([new TileTextElements(tile, group)]));\n                }\n                else {\n                    foundGroup.lists.push(new TileTextElements(tile, group));\n                }\n            }\n        }\n        if (groupedPriorityLists.size === 0) {\n            return;\n        }\n        for (const g of groupedPriorityLists) {\n            const lists = g[1];\n            sortedGroups.push(lists);\n        }\n        sortedGroups.sort((a, b) => {\n            return b.priority - a.priority;\n        });\n        const printTextInfo = false;\n        if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {\n            let outString = \"\";\n            for (const textElementLists of sortedGroups) {\n                let size = 0;\n                for (const tileTextElements of textElementLists.lists) {\n                    size += tileTextElements.group.elements.length;\n                }\n                outString += `priority ${textElementLists.priority} size: ${size}\\n`;\n            }\n            logger.log(outString);\n        }\n    }\n    selectTextElementsToUpdateByDistance(textElementLists, projection) {\n        const farDistanceLimitRatio = Math.max(this.m_options.maxDistanceRatioForTextLabels, this.m_options.maxDistanceRatioForPoiLabels);\n        const maxViewDistance = Placement_1.getMaxViewDistance(this.m_viewState, farDistanceLimitRatio);\n        for (const tileTextElements of textElementLists.lists) {\n            this.prepareTextElementGroup(tileTextElements.group, projection, maxViewDistance);\n        }\n    }\n    placeTextElements(time, placeNewTextElements) {\n        const renderParams = {\n            numRenderedTextElements: 0,\n            fadeAnimationRunning: false,\n            time\n        };\n        const placeStartTime = this.overloaded && this.m_viewState.isDynamic ? harp_utils_1.PerformanceTimer.now() : undefined;\n        if (placementStats) {\n            placementStats.clear();\n        }\n        if (this.m_textElementStateCache.size === 0) {\n            logger.debug(\"Text element cache empty.\");\n            return;\n        }\n        const placeNew = this.m_forceNewLabelsPass || placeNewTextElements;\n        if (this.m_forceNewLabelsPass) {\n            if (!placeNewTextElements) {\n                logger.debug(\"Force new label pass\");\n            }\n            this.m_forceNewLabelsPass = false;\n        }\n        const maxNumPlacedTextElements = this.m_options.maxNumVisibleLabels;\n        // TODO: HARP-7648. Potential performance improvement. Place persistent labels + rejected\n        // candidates from previous frame if there's been no placement in this one.\n        const groupStates = this.m_textElementStateCache.sortedGroupStates;\n        let currentPriority = groupStates[0].priority;\n        let currentPriorityBegin = 0;\n        for (let i = 0; i < groupStates.length; ++i) {\n            const textElementGroupState = groupStates[i];\n            if (placementStats) {\n                ++placementStats.totalGroups;\n            }\n            const newPriority = textElementGroupState.priority;\n            if (placeNew && currentPriority !== newPriority) {\n                // Place all new labels of the previous priority before placing the persistent\n                // labels of this priority.\n                this.placeNewTextElements(currentPriorityBegin, i, renderParams);\n                if (isPlacementTimeExceeded(placeStartTime)) {\n                    break;\n                }\n                currentPriority = newPriority;\n                currentPriorityBegin = i;\n            }\n            if (!this.placeTextElementGroup(textElementGroupState, renderParams, maxNumPlacedTextElements, Pass.PersistentLabels)) {\n                break;\n            }\n            if (isPlacementTimeExceeded(placeStartTime)) {\n                break;\n            }\n        }\n        if (placeNew) {\n            // Place new text elements of the last priority.\n            this.placeNewTextElements(currentPriorityBegin, groupStates.length, renderParams);\n        }\n        if (placementStats) {\n            placementStats.numRenderedTextElements = renderParams.numRenderedTextElements;\n            placementStats.log();\n        }\n        if (!this.m_options.disableFading && renderParams.fadeAnimationRunning) {\n            this.m_viewUpdateCallback();\n        }\n    }\n    placeNewTextElements(beginGroupIndex, endGroupIndex, renderParams) {\n        const groupStates = this.m_textElementStateCache.sortedGroupStates;\n        for (let i = beginGroupIndex; i < endGroupIndex; ++i) {\n            if (!this.placeTextElementGroup(groupStates[i], renderParams, this.m_options.maxNumVisibleLabels, Pass.NewLabels)) {\n                break;\n            }\n        }\n    }\n    placeOverlayTextElements() {\n        if (this.m_overlayTextElements === undefined || this.m_overlayTextElements.length === 0) {\n            return;\n        }\n        const screenSize = this.m_tmpVector.set(this.m_screenProjector.width, this.m_screenProjector.height);\n        const screenXOrigin = -screenSize.width / 2.0;\n        const screenYOrigin = screenSize.height / 2.0;\n        // Place text elements one by one.\n        for (const textElement of this.m_overlayTextElements) {\n            // Get the TextElementStyle.\n            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);\n            const textCanvas = textElementStyle.textCanvas;\n            if (textCanvas === undefined) {\n                continue;\n            }\n            const forceNewPassOnLoaded = false;\n            this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded);\n            if (textElement.loadingState !== TextElement_1.LoadingState.Initialized) {\n                continue;\n            }\n            const layer = textCanvas.getLayer(textElement.renderOrder || harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);\n            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.\n            if (layer !== undefined) {\n                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {\n                    continue;\n                }\n            }\n            // Set the current style for the canvas.\n            textCanvas.textRenderStyle = textElement.renderStyle;\n            textCanvas.textLayoutStyle = textElement.layoutStyle;\n            // Place text.\n            let textPath;\n            if (!(textElement.type === TextElementType_1.TextElementType.PathLabel)) {\n                // Adjust the label positioning.\n                tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;\n                tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;\n                if (textElement.xOffset !== undefined) {\n                    tempScreenPosition.x += textElement.xOffset;\n                }\n                if (textElement.yOffset !== undefined) {\n                    tempScreenPosition.y -= textElement.yOffset;\n                }\n                tempPosition.x = tempScreenPosition.x;\n                tempPosition.y = tempScreenPosition.y;\n                tempPosition.z = 0.0;\n                addTextToCanvas(textElement, textCanvas, tempPosition);\n            }\n            else {\n                // Adjust the label positioning.\n                tempScreenPosition.x = screenXOrigin;\n                tempScreenPosition.y = screenYOrigin;\n                if (textElement.xOffset !== undefined) {\n                    tempScreenPosition.x += textElement.xOffset;\n                }\n                if (textElement.yOffset !== undefined) {\n                    tempScreenPosition.y -= textElement.yOffset;\n                }\n                // Get the screen points that define the label's segments and create a path with\n                // them.\n                // TODO: HARP-7648. Optimize array allocations.\n                const screenPoints = [];\n                for (const pt of textElement.path) {\n                    const pX = tempScreenPosition.x + pt.x * screenSize.width;\n                    const pY = tempScreenPosition.y - pt.y * screenSize.height;\n                    screenPoints.push(new THREE.Vector2(pX, pY));\n                }\n                textPath = new SimplePath_1.SimplePath();\n                for (let i = 0; i < screenPoints.length - 1; ++i) {\n                    textPath.add(new THREE.LineCurve(screenPoints[i], screenPoints[i + 1]));\n                }\n                addTextToCanvas(textElement, textCanvas, tempPosition, textPath, true);\n            }\n        }\n    }\n    getDistanceScalingFactor(label, distance, lookAtDistance) {\n        // Distance scale is based on relation between camera focus point distance and\n        // the actual label distance. For labels close to camera look at point the scale\n        // remains unchanged, the farther is label from that point the smaller size it is\n        // rendered in screen space. This method is unaffected by near and far clipping planes\n        // distances, but may be improved by taking FOV into equation or customizing the\n        // focus point screen position based on horizont, actual ground, tilt ets.\n        let factor = lookAtDistance / distance;\n        // The label.distanceScale property defines the influence ratio at which\n        // distance affects the final scaling of label.\n        factor = 1.0 + (factor - 1.0) * label.distanceScale;\n        // Preserve the constraints\n        factor = Math.max(factor, this.m_options.labelDistanceScaleMin);\n        factor = Math.min(factor, this.m_options.labelDistanceScaleMax);\n        return factor;\n    }\n    getDistanceFadingFactor(label, state, maxVisibilityDist) {\n        let distanceFadeValue = 1.0;\n        const textDistance = state.viewDistance;\n        if (textDistance !== undefined && label.fadeFar !== undefined && label.fadeFar > 0.0) {\n            const fadeNear = label.fadeNear === undefined ? 0.0 : label.fadeNear;\n            const fadeFar = label.fadeFar;\n            if (fadeFar > fadeNear) {\n                distanceFadeValue =\n                    1.0 -\n                        THREE.Math.clamp((textDistance / maxVisibilityDist - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);\n            }\n        }\n        return distanceFadeValue;\n    }\n    addPointLabel(labelState, position, screenPosition, poiRenderer, textCanvas, renderParams, iconIndex) {\n        const pointLabel = labelState.element;\n        const textRenderState = labelState.textRenderState;\n        harp_utils_1.assert(iconIndex === undefined || labelState.iconRenderStates !== undefined);\n        const iconRenderState = iconIndex !== undefined\n            ? labelState.iconRenderStates[iconIndex]\n            : labelState.iconRenderState;\n        harp_utils_1.assert(iconRenderState !== undefined);\n        // Find the label's original position.\n        tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;\n        tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;\n        // Scale the text depending on the label's distance to the camera.\n        const textDistance = this.m_viewState.worldCenter.distanceTo(position);\n        if (pointLabel.fadeFar !== undefined &&\n            (pointLabel.fadeFar <= 0.0 ||\n                pointLabel.fadeFar * this.m_viewState.maxVisibilityDist < textDistance)) {\n            // The label is farther away than fadeFar value, which means it is totally\n            // transparent.\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            return false;\n        }\n        labelState.setViewDistance(textDistance);\n        // Check if there is need to check for screen space for the label's icon.\n        const poiInfo = pointLabel.poiInfo;\n        let iconRejected = false;\n        // Check if icon should be rendered at this zoomLevel\n        const renderIcon = poiInfo !== undefined &&\n            harp_utils_1.MathUtils.isClamped(this.m_viewState.zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel) &&\n            poiInfo.isValid !== false;\n        const distanceScaleFactor = this.getDistanceScalingFactor(pointLabel, textDistance, this.m_viewState.lookAtDistance);\n        const iconReady = renderIcon && poiRenderer.prepareRender(pointLabel, this.m_viewState.zoomLevel);\n        if (iconReady) {\n            const result = Placement_1.placeIcon(iconRenderState, poiInfo, tempPoiScreenPosition, distanceScaleFactor, this.m_viewState.zoomLevel, this.m_screenCollisions);\n            if (result === Placement_1.PlacementResult.Invisible) {\n                iconRenderState.reset();\n                if (placementStats) {\n                    ++placementStats.numNotVisible;\n                }\n                return false;\n            }\n            iconRejected = result === Placement_1.PlacementResult.Rejected;\n        }\n        else if (renderIcon && poiInfo.isValid !== false) {\n            // Ensure that text elements still loading icons get a chance to be rendered if\n            // there's no text element updates in the next frames.\n            this.m_forceNewLabelsPass = true;\n        }\n        const distanceFadeFactor = this.getDistanceFadingFactor(pointLabel, labelState, this.m_viewState.maxVisibilityDist);\n        const renderText = shouldRenderPointText(labelState, this.m_viewState, this.m_options);\n        // Render the label's text...\n        // textRenderState is always defined at this point.\n        if (renderText) {\n            const placeResult = Placement_1.placePointLabel(labelState, tempScreenPosition, distanceScaleFactor, textCanvas, this.m_screenCollisions, iconRejected, tempPosition);\n            if (placeResult === Placement_1.PlacementResult.Invisible) {\n                if (placementStats) {\n                    placementStats.numPoiTextsInvisible++;\n                }\n                labelState.reset();\n                return false;\n            }\n            const textRejected = placeResult === Placement_1.PlacementResult.Rejected;\n            if (!iconRejected) {\n                const textIsOptional = pointLabel.poiInfo !== undefined && pointLabel.poiInfo.textIsOptional === true;\n                iconRejected = textRejected && !textIsOptional;\n            }\n            if (textRejected) {\n                textRenderState.startFadeOut(renderParams.time);\n            }\n            const textNeedsDraw = (!textRejected && shouldRenderPoiText(labelState, this.m_viewState)) ||\n                textRenderState.isFading();\n            if (textNeedsDraw) {\n                if (!textRejected) {\n                    textRenderState.startFadeIn(renderParams.time);\n                }\n                renderParams.fadeAnimationRunning =\n                    renderParams.fadeAnimationRunning || textRenderState.isFading();\n                if (addTextBufferToCanvas(labelState, textCanvas, tempPosition, distanceFadeFactor, distanceScaleFactor) &&\n                    placementStats) {\n                    placementStats.numRenderedPoiTexts++;\n                }\n            }\n        }\n        // ... and render the icon (if any).\n        if (iconReady) {\n            if (iconRejected) {\n                iconRenderState.startFadeOut(renderParams.time);\n            }\n            else {\n                iconRenderState.startFadeIn(renderParams.time);\n            }\n            renderParams.fadeAnimationRunning =\n                renderParams.fadeAnimationRunning || iconRenderState.isFading();\n            const opacity = iconRenderState.opacity * distanceFadeFactor;\n            if (opacity > 0) {\n                // Same as for text, don't allocate screen space for an icon that's fading out so\n                // that any label blocked by it gets a chance to be placed as soon as any other\n                // surrounding new labels.\n                const allocateSpace = poiInfo.reserveSpace !== false && !iconRejected;\n                poiRenderer.renderPoi(poiInfo, tempPoiScreenPosition, this.m_screenCollisions, labelState.renderDistance, distanceScaleFactor, allocateSpace, opacity, this.m_viewState.zoomLevel);\n                if (placementStats) {\n                    placementStats.numRenderedPoiIcons++;\n                }\n            }\n        }\n        renderParams.numRenderedTextElements++;\n        return true;\n    }\n    addPoiLabel(labelState, poiRenderer, textCanvas, renderParams) {\n        const poiLabel = labelState.element;\n        const worldPosition = poiLabel.points;\n        // Only process labels frustum-clipped labels\n        if (this.m_screenProjector.project(worldPosition, tempScreenPosition) === undefined) {\n            return false;\n        }\n        // Add this POI as a point label.\n        return this.addPointLabel(labelState, worldPosition, tempScreenPosition, poiRenderer, textCanvas, renderParams);\n    }\n    addLineMarkerLabel(labelState, poiRenderer, shieldGroups, textCanvas, renderParams) {\n        const lineMarkerLabel = labelState.element;\n        const path = lineMarkerLabel.points;\n        // Early exit if the line marker doesn't have the necessary data.\n        const poiInfo = lineMarkerLabel.poiInfo;\n        if (path.length === 0 ||\n            !poiRenderer.prepareRender(lineMarkerLabel, this.m_viewState.zoomLevel)) {\n            return;\n        }\n        // Initialize the shield group for this lineMarker.\n        let shieldGroup;\n        if (poiInfo.shieldGroupIndex !== undefined) {\n            shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];\n            if (shieldGroup === undefined) {\n                shieldGroup = [];\n                shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;\n            }\n        }\n        const lineTechnique = poiInfo.technique;\n        const minDistanceSqr = lineTechnique.minDistance !== undefined\n            ? lineTechnique.minDistance * lineTechnique.minDistance\n            : 0;\n        // Process markers (with shield groups).\n        if (minDistanceSqr > 0 && shieldGroup !== undefined) {\n            for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) {\n                const point = path[pointIndex];\n                // Only process labels frustum-clipped labels\n                if (this.m_screenProjector.project(point, tempScreenPosition) !== undefined) {\n                    // Find a suitable location for the lineMarker to be placed at.\n                    let tooClose = false;\n                    for (let j = 0; j < shieldGroup.length; j += 2) {\n                        const distanceSqr = harp_utils_1.Math2D.distSquared(shieldGroup[j], shieldGroup[j + 1], tempScreenPosition.x, tempScreenPosition.y);\n                        tooClose = distanceSqr < minDistanceSqr;\n                        if (tooClose) {\n                            break;\n                        }\n                    }\n                    // Place it as a point label if it's not to close to other marker in the\n                    // same shield group.\n                    if (!tooClose) {\n                        if (this.addPointLabel(labelState, point, tempScreenPosition, poiRenderer, textCanvas, renderParams, pointIndex)) {\n                            shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);\n                        }\n                    }\n                }\n            }\n        }\n        // Process markers (without shield groups).\n        else {\n            for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) {\n                const point = path[pointIndex];\n                // Only process labels frustum-clipped labels\n                if (this.m_screenProjector.project(point, tempScreenPosition) !== undefined) {\n                    this.addPointLabel(labelState, point, tempScreenPosition, poiRenderer, textCanvas, renderParams, pointIndex);\n                }\n            }\n        }\n    }\n    addPathLabel(labelState, screenPoints, textCanvas, renderParams) {\n        // TODO: HARP-7649. Add fade out transitions for path labels.\n        const textMaxDistance = Placement_1.getMaxViewDistance(this.m_viewState, this.m_options.maxDistanceRatioForTextLabels);\n        const pathLabel = labelState.element;\n        // Limit the text rendering of path labels in the far distance.\n        if (!(pathLabel.ignoreDistance === true ||\n            labelState.viewDistance === undefined ||\n            labelState.viewDistance < textMaxDistance)) {\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            labelState.textRenderState.reset();\n            return false;\n        }\n        if (pathLabel.fadeFar !== undefined &&\n            (pathLabel.fadeFar <= 0.0 ||\n                pathLabel.fadeFar * this.m_viewState.maxVisibilityDist < labelState.renderDistance)) {\n            // The label is farther away than fadeFar value, which means it is totally\n            // transparent\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            labelState.textRenderState.reset();\n            return false;\n        }\n        // Get the screen points that define the label's segments and create a path with\n        // them.\n        let textPath = new THREE.Path();\n        tempScreenPosition.copy(screenPoints[0]);\n        for (let i = 0; i < screenPoints.length - 1; ++i) {\n            textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));\n        }\n        // Flip the path if the label is gonna be rendered downwards.\n        if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {\n            tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);\n            textPath = new THREE.Path();\n            for (let i = screenPoints.length - 1; i > 0; --i) {\n                textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));\n            }\n        }\n        // Update the real rendering distance to have smooth fading and scaling\n        labelState.setViewDistance(Placement_1.computeViewDistance(this.m_viewState.worldCenter, pathLabel));\n        const textRenderDistance = -labelState.renderDistance;\n        // Scale the text depending on the label's distance to the camera.\n        const distanceScaleFactor = this.getDistanceScalingFactor(pathLabel, textRenderDistance, this.m_viewState.lookAtDistance);\n        const prevSize = textCanvas.textRenderStyle.fontSize.size;\n        textCanvas.textRenderStyle.fontSize.size *= distanceScaleFactor;\n        if (Placement_1.placePathLabel(labelState, textPath, tempScreenPosition, textCanvas, this.m_screenCollisions) !== Placement_1.PlacementResult.Ok) {\n            textCanvas.textRenderStyle.fontSize.size = prevSize;\n            if (placementStats) {\n                ++placementStats.numNotVisible;\n            }\n            labelState.textRenderState.reset();\n            return false;\n        }\n        labelState.textRenderState.startFadeIn(renderParams.time);\n        let opacity = pathLabel.renderStyle.opacity;\n        if (labelState.textRenderState.isFading()) {\n            opacity *= labelState.textRenderState.opacity;\n            renderParams.fadeAnimationRunning = true;\n        }\n        if (labelState.textRenderState.opacity === 0) {\n            textCanvas.textRenderStyle.fontSize.size = prevSize;\n            return false;\n        }\n        const prevOpacity = textCanvas.textRenderStyle.opacity;\n        const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;\n        const distanceFadeFactor = this.getDistanceFadingFactor(pathLabel, labelState, this.m_viewState.maxVisibilityDist);\n        textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;\n        textCanvas.textRenderStyle.backgroundOpacity =\n            textCanvas.textRenderStyle.opacity * pathLabel.renderStyle.backgroundOpacity;\n        tempPosition.z = labelState.renderDistance;\n        addTextToCanvas(pathLabel, textCanvas, tempPosition, textPath);\n        renderParams.numRenderedTextElements++;\n        // Restore previous style values for text elements using the same style.\n        textCanvas.textRenderStyle.fontSize.size = prevSize;\n        textCanvas.textRenderStyle.opacity = prevOpacity;\n        textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;\n        return true;\n    }\n    checkIfOverloaded(dataSourceTileList) {\n        // Count the number of TextElements in the scene to see if we have to switch to\n        // \"overloadMode\".\n        let numTextElementsInScene = 0;\n        dataSourceTileList.forEach(renderListEntry => {\n            for (const tile of renderListEntry.renderedTiles.values()) {\n                numTextElementsInScene += tile.textElementGroups.count();\n                numTextElementsInScene += tile.userTextElements.elements.length;\n            }\n        });\n        const newOverloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;\n        if (newOverloaded && !this.m_overloaded) {\n            logger.debug(\"Overloaded Mode enabled.\");\n        }\n        this.m_overloaded = newOverloaded;\n        return this.m_overloaded;\n    }\n}\nexports.TextElementsRenderer = TextElementsRenderer;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementsRenderer.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DEFAULT_FONT_CATALOG = \"./resources/fonts/Default_FontCatalog.json\";\n/**\n * Default number of labels/POIs rendered in the scene\n */\nconst DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS = 500;\n/**\n * Number of elements that are put into second queue. This second chance queue is used to render\n * TextElements that have not been on screen before. This is a quick source for elements that can\n * appear when the camera moves a bit, before new elements are placed.\n */\nconst DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS = 300;\n/**\n * Maximum distance for text labels expressed as a ratio of distance to from the camera (0) to the\n * far plane (1.0). May be synchronized with fog value ?\n */\nconst DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;\n/**\n * Minimum scaling factor that may be applied to labels when their are distant from focus point.\n */\nconst DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;\n/**\n * Maximum scaling factor that may be applied to labels due to their distance from focus point.\n */\nconst DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;\nconst MIN_GLYPH_COUNT = 1024;\nconst MAX_GLYPH_COUNT = 32768;\n/**\n * Initializes undefined text renderer options to default values.\n * @param options The options to be initialized.\n */\nfunction initializeDefaultOptions(options) {\n    if (options.fontCatalog === undefined) {\n        options.fontCatalog = DEFAULT_FONT_CATALOG;\n    }\n    if (options.minNumGlyphs === undefined) {\n        options.minNumGlyphs = MIN_GLYPH_COUNT;\n    }\n    if (options.maxNumGlyphs === undefined) {\n        options.maxNumGlyphs = MAX_GLYPH_COUNT;\n    }\n    if (options.maxNumVisibleLabels === undefined) {\n        options.maxNumVisibleLabels = DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS;\n    }\n    // TODO: Unused so far.\n    if (options.numSecondChanceLabels === undefined) {\n        options.numSecondChanceLabels = DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS;\n    }\n    if (options.labelDistanceScaleMin === undefined) {\n        options.labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;\n    }\n    if (options.labelDistanceScaleMax === undefined) {\n        options.labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;\n    }\n    if (options.maxDistanceRatioForTextLabels === undefined) {\n        options.maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;\n    }\n    if (options.maxDistanceRatioForPoiLabels === undefined) {\n        options.maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;\n    }\n    if (options.disableFading === undefined) {\n        options.disableFading = false;\n    }\n}\nexports.initializeDefaultOptions = initializeDefaultOptions;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextElementsRendererOptions.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst ColorCache_1 = __webpack_require__(/*! ../ColorCache */ \"./node_modules/@here/harp-mapview/lib/ColorCache.js\");\nconst DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ \"./node_modules/@here/harp-mapview/lib/DecodedTileHelpers.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"TextStyleCache\");\n/**\n * [[TextStyle]] id for the default value inside a [[TextRenderStyleCache]] or a\n * [[TextLayoutStyleCache]].\n */\nexports.DEFAULT_TEXT_STYLE_CACHE_ID = \"Default\";\n/**\n * Calculates the [[TextStyle]] id that identifies either a [[TextRenderStyle]] or a\n * [[TextLayoutStyle]] inside a [[TextRenderStyleCache]] or a [[TextLayoutStyleCache]],\n * respectively.\n *\n * @param technique Technique defining the [[TextStyle]].\n * @param zoomLevel Zoom level for which to interpret the technique.\n *\n * @returns [[TextStyle]] id.\n */\nfunction computeStyleCacheId(datasourceName, technique, zoomLevel) {\n    return `${datasourceName}_${technique._key}_${zoomLevel}`;\n}\nexports.computeStyleCacheId = computeStyleCacheId;\n/**\n * Cache storing [[MapView]]'s [[TextRenderStyle]]s.\n */\nclass TextRenderStyleCache {\n    constructor() {\n        this.m_map = new Map();\n        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextRenderStyle({\n            fontSize: {\n                unit: harp_text_canvas_1.FontUnit.Pixel,\n                size: 32,\n                backgroundSize: 8\n            },\n            color: ColorCache_1.ColorCache.instance.getColor(\"#6d7477\"),\n            opacity: 1.0,\n            backgroundColor: ColorCache_1.ColorCache.instance.getColor(\"#f7fbfd\"),\n            backgroundOpacity: 0.5\n        }));\n    }\n    get size() {\n        return this.m_map.size;\n    }\n    get(id) {\n        return this.m_map.get(id);\n    }\n    set(id, value) {\n        this.m_map.set(id, value);\n    }\n    clear() {\n        this.m_map.clear();\n        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextRenderStyle({\n            fontSize: {\n                unit: harp_text_canvas_1.FontUnit.Pixel,\n                size: 32,\n                backgroundSize: 8\n            },\n            color: ColorCache_1.ColorCache.instance.getColor(\"#6d7477\"),\n            opacity: 1.0,\n            backgroundColor: ColorCache_1.ColorCache.instance.getColor(\"#f7fbfd\"),\n            backgroundOpacity: 0.5\n        }));\n    }\n}\nexports.TextRenderStyleCache = TextRenderStyleCache;\n/**\n * Cache storing [[MapView]]'s [[TextLayoutStyle]]s.\n */\nclass TextLayoutStyleCache {\n    constructor() {\n        this.m_map = new Map();\n        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextLayoutStyle({\n            verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,\n            horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center\n        }));\n    }\n    get size() {\n        return this.m_map.size;\n    }\n    get(id) {\n        return this.m_map.get(id);\n    }\n    set(id, value) {\n        this.m_map.set(id, value);\n    }\n    clear() {\n        this.m_map.clear();\n        this.m_map.set(exports.DEFAULT_TEXT_STYLE_CACHE_ID, new harp_text_canvas_1.TextLayoutStyle({\n            verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,\n            horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center\n        }));\n    }\n}\nexports.TextLayoutStyleCache = TextLayoutStyleCache;\nconst DEFAULT_STYLE_NAME = \"default\";\nclass TextStyleCache {\n    constructor(m_theme) {\n        this.m_theme = m_theme;\n        this.m_textRenderStyleCache = new TextRenderStyleCache();\n        this.m_textLayoutStyleCache = new TextLayoutStyleCache();\n        /**\n         * Cache for named colors.\n         */\n        this.m_colorMap = new Map();\n        this.m_textStyles = new Map();\n        this.m_defaultStyle = {\n            name: DEFAULT_STYLE_NAME,\n            fontCatalog: \"\",\n            renderParams: this.m_textRenderStyleCache.get(exports.DEFAULT_TEXT_STYLE_CACHE_ID).params,\n            layoutParams: this.m_textLayoutStyleCache.get(exports.DEFAULT_TEXT_STYLE_CACHE_ID).params\n        };\n    }\n    initializeDefaultTextElementStyle(defaultFontCatalogName) {\n        if (this.m_theme.textStyles === undefined) {\n            this.m_theme.textStyles = [];\n        }\n        const styles = this.m_theme.textStyles;\n        const themedDefaultStyle = styles.find(style => style.name === DEFAULT_STYLE_NAME);\n        if (themedDefaultStyle !== undefined) {\n            this.m_defaultStyle = this.createTextElementStyle(themedDefaultStyle, DEFAULT_STYLE_NAME);\n        }\n        else if (this.m_theme.defaultTextStyle !== undefined) {\n            this.m_defaultStyle = this.createTextElementStyle(this.m_theme.defaultTextStyle, DEFAULT_STYLE_NAME);\n        }\n        else if (styles.length > 0) {\n            this.m_defaultStyle = this.createTextElementStyle(styles[0], DEFAULT_STYLE_NAME);\n        }\n        this.m_defaultStyle.fontCatalog = defaultFontCatalogName;\n    }\n    initializeTextElementStyles(defaultPoiRenderer, defaultTextCanvas, textRenderers) {\n        // Initialize default text style.\n        if (this.m_defaultStyle.fontCatalog !== undefined) {\n            const styledTextRenderer = textRenderers.find(textRenderer => textRenderer.fontCatalog === this.m_defaultStyle.fontCatalog);\n            this.m_defaultStyle.textCanvas =\n                styledTextRenderer !== undefined ? styledTextRenderer.textCanvas : undefined;\n            this.m_defaultStyle.poiRenderer =\n                styledTextRenderer !== undefined ? styledTextRenderer.poiRenderer : undefined;\n        }\n        if (this.m_defaultStyle.textCanvas === undefined) {\n            if (this.m_defaultStyle.fontCatalog !== undefined) {\n                logger.warn(`FontCatalog '${this.m_defaultStyle.fontCatalog}' set in TextStyle '${this.m_defaultStyle.name}' not found, using default fontCatalog(${defaultTextCanvas.fontCatalog.name}).`);\n            }\n            this.m_defaultStyle.textCanvas = defaultTextCanvas;\n            this.m_defaultStyle.poiRenderer = defaultPoiRenderer;\n        }\n        // Initialize theme text styles.\n        this.m_theme.textStyles.forEach(element => {\n            this.m_textStyles.set(element.name, this.createTextElementStyle(element, element.name));\n        });\n        // tslint:disable-next-line:no-unused-variable\n        for (const [, style] of this.m_textStyles) {\n            if (style.textCanvas === undefined) {\n                if (style.fontCatalog !== undefined) {\n                    const styledTextRenderer = textRenderers.find(textRenderer => textRenderer.fontCatalog === style.fontCatalog);\n                    style.textCanvas =\n                        styledTextRenderer !== undefined\n                            ? styledTextRenderer.textCanvas\n                            : undefined;\n                    style.poiRenderer =\n                        styledTextRenderer !== undefined\n                            ? styledTextRenderer.poiRenderer\n                            : undefined;\n                }\n                if (style.textCanvas === undefined) {\n                    if (style.fontCatalog !== undefined) {\n                        logger.warn(`FontCatalog '${style.fontCatalog}' set in TextStyle '${style.name}' not found, using default fontCatalog(${defaultTextCanvas.fontCatalog.name}).`);\n                    }\n                    style.textCanvas = defaultTextCanvas;\n                    style.poiRenderer = defaultPoiRenderer;\n                }\n            }\n        }\n    }\n    /**\n     * Retrieves a [[TextElementStyle]] for [[Theme]]'s [[TextStyle]] id.\n     */\n    getTextElementStyle(styleId) {\n        let result;\n        if (styleId === undefined) {\n            result = this.m_defaultStyle;\n        }\n        else {\n            result = this.m_textStyles.get(styleId);\n            if (result === undefined) {\n                result = this.m_defaultStyle;\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets the appropriate [[TextRenderStyle]] to use for a label. Depends heavily on the label's\n     * [[Technique]] and the current zoomLevel.\n     *\n     * @param technique Label's technique.\n     * @param techniqueIdx Label's technique index.\n     */\n    getRenderStyle(tile, technique) {\n        const mapView = tile.mapView;\n        const dataSource = tile.dataSource;\n        const zoomLevel = mapView.zoomLevel;\n        const zoomLevelInt = Math.floor(zoomLevel);\n        const cacheId = computeStyleCacheId(dataSource.name, technique, zoomLevelInt);\n        let renderStyle = this.m_textRenderStyleCache.get(cacheId);\n        if (renderStyle === undefined) {\n            const defaultRenderParams = this.m_defaultStyle.renderParams;\n            // Sets opacity to 1.0 if default and technique attribute are undefined.\n            const defaultOpacity = harp_utils_1.getOptionValue(defaultRenderParams.opacity, 1.0);\n            // Interpolate opacity but only on discreet zoom levels (step interpolation).\n            let opacity = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.opacity, defaultOpacity), zoomLevelInt);\n            // Store color (RGB) in cache and multiply opacity value with the color alpha channel.\n            if (technique.color !== undefined) {\n                let hexColor = DecodedTileHelpers_1.evaluateColorProperty(technique.color, zoomLevelInt);\n                if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(hexColor)) {\n                    const alpha = harp_datasource_protocol_1.ColorUtils.getAlphaFromHex(hexColor);\n                    opacity = opacity * alpha;\n                    hexColor = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(hexColor);\n                }\n                this.m_colorMap.set(cacheId, ColorCache_1.ColorCache.instance.getColor(hexColor));\n            }\n            // Sets background size to 0.0 if default and technique attribute is undefined.\n            const defaultBackgroundSize = harp_utils_1.getOptionValue(defaultRenderParams.fontSize.backgroundSize, 0);\n            const backgroundSize = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.backgroundSize, defaultBackgroundSize), zoomLevelInt);\n            const hasBackgroundDefined = technique.backgroundColor !== undefined &&\n                technique.backgroundSize !== undefined &&\n                backgroundSize > 0;\n            // Sets background opacity to 1.0 if default and technique value is undefined while\n            // background size and color is specified, otherwise set value in default render\n            // params or 0.0 if neither set. Makes label opaque when backgroundColor and\n            // backgroundSize are set.\n            const defaultBackgroundOpacity = harp_utils_1.getOptionValue(defaultRenderParams.backgroundOpacity, 0.0);\n            let backgroundOpacity = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.backgroundOpacity, hasBackgroundDefined ? 1.0 : defaultBackgroundOpacity), zoomLevelInt);\n            // Store background color (RGB) in cache and multiply backgroundOpacity by its alpha.\n            if (technique.backgroundColor !== undefined) {\n                let hexBgColor = DecodedTileHelpers_1.evaluateColorProperty(technique.backgroundColor, zoomLevelInt);\n                if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(hexBgColor)) {\n                    const alpha = harp_datasource_protocol_1.ColorUtils.getAlphaFromHex(hexBgColor);\n                    backgroundOpacity = backgroundOpacity * alpha;\n                    hexBgColor = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(hexBgColor);\n                }\n                this.m_colorMap.set(cacheId + \"_bg\", ColorCache_1.ColorCache.instance.getColor(hexBgColor));\n            }\n            const renderParams = {\n                fontName: harp_utils_1.getOptionValue(technique.fontName, defaultRenderParams.fontName),\n                fontSize: {\n                    unit: harp_text_canvas_1.FontUnit.Pixel,\n                    size: harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.size, defaultRenderParams.fontSize.size), zoomLevelInt),\n                    backgroundSize\n                },\n                fontStyle: technique.fontStyle === \"Regular\" ||\n                    technique.fontStyle === \"Bold\" ||\n                    technique.fontStyle === \"Italic\" ||\n                    technique.fontStyle === \"BoldItalic\"\n                    ? harp_text_canvas_1.FontStyle[technique.fontStyle]\n                    : defaultRenderParams.fontStyle,\n                fontVariant: technique.fontVariant === \"Regular\" ||\n                    technique.fontVariant === \"AllCaps\" ||\n                    technique.fontVariant === \"SmallCaps\"\n                    ? harp_text_canvas_1.FontVariant[technique.fontVariant]\n                    : defaultRenderParams.fontVariant,\n                rotation: harp_utils_1.getOptionValue(technique.rotation, defaultRenderParams.rotation),\n                color: harp_utils_1.getOptionValue(this.m_colorMap.get(cacheId), harp_utils_1.getOptionValue(defaultRenderParams.color, harp_text_canvas_1.DefaultTextStyle.DEFAULT_COLOR)),\n                backgroundColor: harp_utils_1.getOptionValue(this.m_colorMap.get(cacheId + \"_bg\"), harp_utils_1.getOptionValue(defaultRenderParams.backgroundColor, harp_text_canvas_1.DefaultTextStyle.DEFAULT_BACKGROUND_COLOR)),\n                opacity,\n                backgroundOpacity\n            };\n            const themeRenderParams = this.getTextElementStyle(technique.style).renderParams;\n            renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign(Object.assign({}, themeRenderParams), renderParams));\n            this.m_textRenderStyleCache.set(cacheId, renderStyle);\n        }\n        return renderStyle;\n    }\n    /**\n     * Gets the appropriate [[TextRenderStyle]] to use for a label. Depends heavily on the label's\n     * [[Technique]] and the current zoomLevel.\n     *\n     * @param tile The [[Tile]] to process.\n     * @param technique Label's technique.\n     */\n    getLayoutStyle(tile, technique) {\n        var _a, _b, _c, _d, _e, _f;\n        const floorZoomLevel = Math.floor(tile.mapView.zoomLevel);\n        const cacheId = computeStyleCacheId(tile.dataSource.name, technique, floorZoomLevel);\n        let layoutStyle = this.m_textLayoutStyleCache.get(cacheId);\n        if (layoutStyle === undefined) {\n            const defaultLayoutParams = this.m_defaultStyle.layoutParams;\n            const hAlignment = harp_datasource_protocol_1.getPropertyValue(technique.hAlignment, floorZoomLevel);\n            const vAlignment = harp_datasource_protocol_1.getPropertyValue(technique.vAlignment, floorZoomLevel);\n            const wrapping = harp_datasource_protocol_1.getPropertyValue(technique.wrappingMode, floorZoomLevel);\n            const horizontalAlignment = hAlignment === \"Left\" || hAlignment === \"Center\" || hAlignment === \"Right\"\n                ? harp_text_canvas_1.HorizontalAlignment[hAlignment]\n                : defaultLayoutParams.horizontalAlignment;\n            const verticalAlignment = vAlignment === \"Above\" || vAlignment === \"Center\" || vAlignment === \"Below\"\n                ? harp_text_canvas_1.VerticalAlignment[vAlignment]\n                : defaultLayoutParams.verticalAlignment;\n            const layoutParams = {\n                tracking: (_a = harp_datasource_protocol_1.getPropertyValue(technique.tracking, floorZoomLevel), (_a !== null && _a !== void 0 ? _a : defaultLayoutParams.tracking)),\n                leading: (_b = harp_datasource_protocol_1.getPropertyValue(technique.leading, floorZoomLevel), (_b !== null && _b !== void 0 ? _b : defaultLayoutParams.leading)),\n                maxLines: (_c = harp_datasource_protocol_1.getPropertyValue(technique.maxLines, floorZoomLevel), (_c !== null && _c !== void 0 ? _c : defaultLayoutParams.maxLines)),\n                lineWidth: (_d = harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, floorZoomLevel), (_d !== null && _d !== void 0 ? _d : defaultLayoutParams.lineWidth)),\n                canvasRotation: (_e = harp_datasource_protocol_1.getPropertyValue(technique.canvasRotation, floorZoomLevel), (_e !== null && _e !== void 0 ? _e : defaultLayoutParams.canvasRotation)),\n                lineRotation: (_f = harp_datasource_protocol_1.getPropertyValue(technique.lineRotation, floorZoomLevel), (_f !== null && _f !== void 0 ? _f : defaultLayoutParams.lineRotation)),\n                wrappingMode: wrapping === \"None\" || wrapping === \"Character\" || wrapping === \"Word\"\n                    ? harp_text_canvas_1.WrappingMode[wrapping]\n                    : defaultLayoutParams.wrappingMode,\n                horizontalAlignment,\n                verticalAlignment\n            };\n            const themeLayoutParams = this.getTextElementStyle(technique.style);\n            layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign(Object.assign({}, themeLayoutParams), layoutParams));\n            this.m_textLayoutStyleCache.set(cacheId, layoutStyle);\n        }\n        return layoutStyle;\n    }\n    createTextElementStyle(style, styleName) {\n        return {\n            name: styleName,\n            fontCatalog: harp_utils_1.getOptionValue(style.fontCatalogName, this.m_defaultStyle.fontCatalog),\n            renderParams: {\n                fontName: style.fontName,\n                fontSize: {\n                    unit: harp_text_canvas_1.FontUnit.Pixel,\n                    size: 32,\n                    backgroundSize: style.backgroundSize || 8\n                },\n                fontStyle: style.fontStyle === \"Regular\" ||\n                    style.fontStyle === \"Bold\" ||\n                    style.fontStyle === \"Italic\" ||\n                    style.fontStyle === \"BoldItalic\"\n                    ? harp_text_canvas_1.FontStyle[style.fontStyle]\n                    : undefined,\n                fontVariant: style.fontVariant === \"Regular\" ||\n                    style.fontVariant === \"AllCaps\" ||\n                    style.fontVariant === \"SmallCaps\"\n                    ? harp_text_canvas_1.FontVariant[style.fontVariant]\n                    : undefined,\n                rotation: style.rotation,\n                color: style.color !== undefined\n                    ? ColorCache_1.ColorCache.instance.getColor(style.color)\n                    : undefined,\n                backgroundColor: style.backgroundColor !== undefined\n                    ? ColorCache_1.ColorCache.instance.getColor(style.backgroundColor)\n                    : undefined,\n                opacity: style.opacity,\n                backgroundOpacity: style.backgroundOpacity\n            },\n            layoutParams: {\n                tracking: style.tracking,\n                leading: style.leading,\n                maxLines: style.maxLines,\n                lineWidth: style.lineWidth,\n                canvasRotation: style.canvasRotation,\n                lineRotation: style.lineRotation,\n                wrappingMode: style.wrappingMode === \"None\" ||\n                    style.wrappingMode === \"Character\" ||\n                    style.wrappingMode === \"Word\"\n                    ? harp_text_canvas_1.WrappingMode[style.wrappingMode]\n                    : harp_text_canvas_1.WrappingMode.Word,\n                verticalAlignment: style.vAlignment === \"Above\" ||\n                    style.vAlignment === \"Center\" ||\n                    style.vAlignment === \"Below\"\n                    ? harp_text_canvas_1.VerticalAlignment[style.vAlignment]\n                    : harp_text_canvas_1.VerticalAlignment.Center,\n                horizontalAlignment: style.hAlignment === \"Left\" ||\n                    style.hAlignment === \"Center\" ||\n                    style.hAlignment === \"Right\"\n                    ? harp_text_canvas_1.HorizontalAlignment[style.hAlignment]\n                    : harp_text_canvas_1.HorizontalAlignment.Center\n            }\n        };\n    }\n}\nexports.TextStyleCache = TextStyleCache;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/TextStyleCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/text/UpdateStats.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/text/UpdateStats.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Placement_1 = __webpack_require__(/*! ./Placement */ \"./node_modules/@here/harp-mapview/lib/text/Placement.js\");\nclass UpdateStats {\n    constructor(m_logger) {\n        this.m_logger = m_logger;\n        this.tiles = 0;\n        this.totalGroups = 0;\n        this.newGroups = 0;\n        this.totalLabels = 0;\n        this.results = new Array(Placement_1.PrePlacementResult.Count);\n        this.results.fill(0);\n    }\n    clear() {\n        this.tiles = 0;\n        this.totalGroups = 0;\n        this.newGroups = 0;\n        this.totalLabels = 0;\n        this.results.fill(0);\n    }\n    log() {\n        this.m_logger.debug(\"Tiles\", this.tiles);\n        this.m_logger.debug(\"Total groups\", this.totalGroups);\n        this.m_logger.debug(\"New groups\", this.newGroups);\n        this.m_logger.debug(\"Total labels\", this.totalLabels);\n        this.m_logger.debug(\"Placed labels\", this.results[Placement_1.PrePlacementResult.Ok]);\n        this.m_logger.debug(\"Invisible\", this.results[Placement_1.PrePlacementResult.Invisible]);\n        this.m_logger.debug(\"Poi not ready\", this.results[Placement_1.PrePlacementResult.NotReady]);\n        this.m_logger.debug(\"Too far\", this.results[Placement_1.PrePlacementResult.TooFar]);\n        this.m_logger.debug(\"Duplicate\", this.results[Placement_1.PrePlacementResult.Duplicate]);\n    }\n}\nexports.UpdateStats = UpdateStats;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/text/UpdateStats.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isWorkerBootstrapRequest(message) {\n    return (message &&\n        message.type === \"worker-bootstrap-request\" &&\n        Array.isArray(message.dependencies));\n}\nexports.isWorkerBootstrapRequest = isWorkerBootstrapRequest;\nfunction isWorkerBootstrapResponse(message) {\n    return (message &&\n        message.type === \"worker-bootstrap-response\" &&\n        Array.isArray(message.resolvedDependencies));\n}\nexports.isWorkerBootstrapResponse = isWorkerBootstrapResponse;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst WorkerBootstrapDefs_1 = __webpack_require__(/*! ./WorkerBootstrapDefs */ \"./node_modules/@here/harp-mapview/lib/workers/WorkerBootstrapDefs.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"WorkerLoader\");\n/**\n * Set of `Worker` loading and initialization helpers:\n *  - starting Worker from URL with fallback to XHR+blob [[WorkerLoader.startWorker]]\n *  - waiting for proper worker initialization, see [[WorkerLoader.waitWorkerInitialized]]\n */\nclass WorkerLoader {\n    /**\n     * Starts worker by first attempting load from `scriptUrl` using native `Worker` constructor.\n     * Then waits (using [[waitWorkerInitialized]]) for first message that indicates successful\n     * initialization.\n     * If `scriptUrl`'s origin is different than `baseUrl`, then in case of error falls back to\n     * [[startWorkerBlob]].\n     *\n     * We must resolve/reject promise at some time, so it is expected that any sane application will\n     * be able to load worker code in some amount of time.\n     * By default, this method timeouts after 10 seconds (configurable using `timeout` argument).\n     *\n     * This method is needed as browsers in general forbid to load worker if it's not on 'same\n     * origin' regardless of Content-Security-Policy.\n     *\n     * For blob-based fallback work, one need to ensure that Content Security Policy (CSP) allows\n     * loading web worker code from `Blob`s. By default browsers, allow 'blob:' for workers, but\n     * this may change.\n     *\n     * Following snippet setups CSP, so workers can be started from blob urls:\n     *\n     *     <head>\n     *         <meta http-equiv=\"Content-Security-Policy\" content=\"child-src blob:\">\n     *     </head>\n     *\n     * Tested on:\n     *   * Chrome 67 / Linux, Window, OSX, Android\n     *   * Firefox 60 / Linux, Windows, OSX\n     *   * Edge 41 / Windows\n     *   * Safari 11 / OSX\n     *   * Samsung Internet 7.2\n     *\n     * See\n     *  * https://benohead.com/cross-domain-cross-browser-web-workers/\n     *  * MapBox\n     *    * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/2658\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/559\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/6058\n     *\n     * Findings:\n     *\n     * * Chrome reports CSP by exception when constructing [[Worker]] instance.\n     * * Firefox reports CSP errors when loading in first event:\n     *   https://bugzilla.mozilla.org/show_bug.cgi?id=1241888\n     * * Firefox 62, Chrome 67 obeys `<meta http-equiv=\"Content-Security-Policy\">` with\n     *   `worker-src blob:` but doesn't obey `worker-src URL` when used\n     * * Chrome 67 doesn't obey CSP `worker-src URL` despite it's documented as supported\n     *   (https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)\n     *\n     * @param scriptUrl web worker script URL\n     * @param timeout timeout in milliseconds, in which worker should set initial message\n     *    (default 10 seconds)\n     */\n    static startWorker(scriptUrl, timeout = 10000) {\n        if (scriptUrl.startsWith(\"blob:\")) {\n            return this.startWorkerImmediately(scriptUrl, timeout);\n        }\n        if (this.directlyFallbackToBlobBasedLoading) {\n            return this.startWorkerBlob(scriptUrl, timeout);\n        }\n        return this.startWorkerImmediately(scriptUrl, timeout).catch(error => {\n            if (typeof window !== \"undefined\") {\n                const pageUrl = window.location.href;\n                const fullScriptUrl = new URL(scriptUrl, pageUrl).href;\n                if (harp_utils_1.getUrlOrigin(fullScriptUrl) === harp_utils_1.getUrlOrigin(pageUrl)) {\n                    throw error;\n                }\n                logger.log(\"#startWorker: cross-origin worker construction failed, trying load with blob\");\n                this.directlyFallbackToBlobBasedLoading = true;\n                return WorkerLoader.startWorkerBlob(scriptUrl, timeout);\n            }\n            else {\n                throw error;\n            }\n        });\n    }\n    /**\n     * Start worker, loading it immediately from `scriptUrl`. Waits (using\n     * [[waitWorkerInitialized]]) for successful worker start.\n     *\n     * @param scriptUrl web worker script URL\n     */\n    static startWorkerImmediately(scriptUrl, timeout) {\n        try {\n            const worker = new Worker(scriptUrl);\n            return this.waitWorkerInitialized(worker, timeout);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    /**\n     * Start worker \"via blob\" by first loading worker script code with [[fetch]], creating `Blob`\n     * and attempting to start worker from blob url. Waits (using [[waitWorkerInitialized]]) for\n     * successful worker start.\n     *\n     * @param scriptUrl web worker script URL\n     */\n    static startWorkerBlob(scriptUrl, timeout) {\n        return this.fetchScriptSourceToBlobUrl(scriptUrl).then(blobUrl => {\n            return this.startWorkerImmediately(blobUrl, timeout);\n        });\n    }\n    /**\n     * Fetch script source as `Blob` url.\n     *\n     * Reuses results, if there are many simultaneous requests.\n     *\n     * @param scriptUrl web worker script URL\n     * @return promise that resolves to url of a `Blob` with script source code\n     */\n    static fetchScriptSourceToBlobUrl(scriptUrl) {\n        let loadingPromise = this.sourceLoaderCache.get(scriptUrl);\n        if (loadingPromise !== undefined) {\n            return loadingPromise;\n        }\n        loadingPromise = fetch(scriptUrl)\n            .then(response => response.text())\n            .catch(error => {\n            throw new Error(`WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`);\n        })\n            .then(scriptSource => {\n            this.sourceLoaderCache.delete(scriptUrl);\n            const blob = new Blob([scriptSource], { type: \"application/javascript\" });\n            return URL.createObjectURL(blob);\n        });\n        this.sourceLoaderCache.set(scriptUrl, loadingPromise);\n        return loadingPromise;\n    }\n    /**\n     * Waits for successful Web Worker start.\n     *\n     * Expects that worker script sends initial message.\n     *\n     * If first event is `message` then assumes that worker has been loaded sussesfully and promise\n     * resolves to `worker` object passed as argument.\n     *\n     * If first event is 'error', then it is assumed that worker failed to load and promise is\n     * rejected.\n     *\n     * (NOTE: The initial 'message' - if received - is immediately replayed using worker's\n     * `dispatchEvent`, so application code can also consume it as confirmation of successful\n     * worker initialization.\n     *\n     * We must resolve/reject promise at some time, so it is expected that any sane application will\n     * be able to load worker code in some amount of time.\n     *\n     * @param worker [[Worker]] instance to be checked\n     * @param timeout timeout in milliseconds, in which worker should set initial message\n     * @returns `Promise` that resolves to `worker` on success\n     */\n    static waitWorkerInitialized(worker, timeout) {\n        return new Promise((resolve, reject) => {\n            const firstMessageCallback = (event) => {\n                const message = event.data;\n                if (WorkerBootstrapDefs_1.isWorkerBootstrapRequest(message)) {\n                    const dependencies = message.dependencies;\n                    const resolvedDependencies = [];\n                    for (const dependency of dependencies) {\n                        const resolved = this.dependencyUrlMapping[dependency];\n                        if (!resolved) {\n                            cleanup();\n                            reject(new Error(`#waitWorkerInitialized: Unable to resolve '${dependency}'` +\n                                ` as needed by worker script.`));\n                            return;\n                        }\n                        resolvedDependencies.push(resolved);\n                    }\n                    const response = {\n                        type: \"worker-bootstrap-response\",\n                        resolvedDependencies\n                    };\n                    worker.postMessage(response);\n                    return;\n                }\n                cleanup();\n                resolve(worker);\n                // We've just consumed first message from worker before client has any chance to\n                // even call `addEventListener` on it, so here after resolve, we wait next tick and\n                // replay message so user has chance to intercept it in its own handler.\n                setTimeout(() => {\n                    worker.dispatchEvent(event);\n                }, 0);\n            };\n            const errorCallback = (error) => {\n                cleanup();\n                // Error events do not carry any useful information on tested browsers, so we assume\n                // that any error before 'firstMessageCallback' as failed Worker initialization.\n                let message = \"Error during worker initialization\";\n                if (error.message) {\n                    message = message + `: ${error.message}`;\n                }\n                if (typeof error.filename === \"string\" && typeof error.lineno === \"number\") {\n                    message = message + ` in ${error.filename}:${error.lineno}`;\n                }\n                reject(new Error(message));\n            };\n            const cleanup = () => {\n                clearTimeout(timerId);\n                worker.removeEventListener(\"message\", firstMessageCallback);\n                worker.removeEventListener(\"error\", errorCallback);\n            };\n            worker.addEventListener(\"error\", errorCallback);\n            worker.addEventListener(\"message\", firstMessageCallback);\n            const timerId = setTimeout(() => {\n                cleanup();\n                reject(new Error(\"Timeout exceeded when waiting for first message from worker.\"));\n            }, timeout);\n        });\n    }\n}\nexports.WorkerLoader = WorkerLoader;\nWorkerLoader.directlyFallbackToBlobBasedLoading = false;\nWorkerLoader.sourceLoaderCache = new Map();\nWorkerLoader.dependencyUrlMapping = {};\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-mapview/lib/workers/WorkerLoader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-materials/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/CirclePointsMaterial */ \"./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js\"));\n__export(__webpack_require__(/*! ./lib/CopyMaterial */ \"./node_modules/@here/harp-materials/lib/CopyMaterial.js\"));\n__export(__webpack_require__(/*! ./lib/EdgeMaterial */ \"./node_modules/@here/harp-materials/lib/EdgeMaterial.js\"));\n__export(__webpack_require__(/*! ./lib/HighPrecisionLineMaterial */ \"./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js\"));\n__export(__webpack_require__(/*! ./lib/HighPrecisionPointMaterial */ \"./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js\"));\n__export(__webpack_require__(/*! ./lib/IconMaterial */ \"./node_modules/@here/harp-materials/lib/IconMaterial.js\"));\n__export(__webpack_require__(/*! ./lib/LuminosityHighPassShader */ \"./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js\"));\n__export(__webpack_require__(/*! ./lib/MapMeshMaterialsDefs */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js\"));\n__export(__webpack_require__(/*! ./lib/MapMeshMaterials */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterials.js\"));\n__export(__webpack_require__(/*! ./lib/MSAAMaterial */ \"./node_modules/@here/harp-materials/lib/MSAAMaterial.js\"));\n__export(__webpack_require__(/*! ./lib/SepiaShader */ \"./node_modules/@here/harp-materials/lib/SepiaShader.js\"));\n__export(__webpack_require__(/*! ./lib/SolidLineMaterial */ \"./node_modules/@here/harp-materials/lib/SolidLineMaterial.js\"));\n__export(__webpack_require__(/*! ./lib/Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\"));\n__export(__webpack_require__(/*! ./lib/VignetteShader */ \"./node_modules/@here/harp-materials/lib/VignetteShader.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\nconst vertexShader = `\nuniform float size;\n\nvoid main() {\n    vec3 transformed = vec3(position);\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\n    gl_Position = projectionMatrix * mvPosition;\n    gl_PointSize = size;\n}\n`;\nconst fragmentShader = `\nuniform vec3 diffuse;\n\nvoid main() {\n    float alpha = 1.0;\n\n    float radius = 0.5;\n    vec2 coords = gl_PointCoord.xy - vec2(0.5);\n    float len = length(coords);\n    float falloff = fwidth(len);\n    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);\n    alpha *= threshold;\n\n    gl_FragColor = vec4(diffuse, alpha);\n}`;\nconst DEFAULT_CIRCLE_SIZE = 1;\n/**\n * Material designed to render circle points. Note that it is always transparent since the circle\n * shape is created with an alpha channel to benefit an antialising that a mere `discard` could\n * not bring.\n */\nclass CirclePointsMaterial extends THREE.ShaderMaterial {\n    /**\n     * Constructs a new `CirclePointsMaterial`.\n     *\n     * @param parameters The constructor's parameters.\n     */\n    constructor(parameters = {}) {\n        parameters.depthTest = false;\n        super(parameters);\n        Utils_1.enforceBlending(this);\n        this.isCirclePointsMaterial = true;\n        this.type = \"CirclePointsMaterial\";\n        this.vertexShader = vertexShader;\n        this.fragmentShader = fragmentShader;\n        this.m_size = parameters.size || DEFAULT_CIRCLE_SIZE;\n        this.m_color = new THREE.Color();\n        this.uniforms = {\n            diffuse: new THREE.Uniform(this.m_color),\n            size: new THREE.Uniform(this.m_size)\n        };\n        this.extensions.derivatives = true;\n    }\n    /**\n     * Gets the circle screen size.\n     */\n    get size() {\n        return this.m_size;\n    }\n    /**\n     * Sets the circle screen size.\n     */\n    set size(size) {\n        this.m_size = size;\n        this.uniforms.size.value = size;\n    }\n    /**\n     * Gets the diffuse.\n     */\n    get color() {\n        return \"#\" + this.m_color.getHexString();\n    }\n    /**\n     * Sets the diffuse.\n     */\n    set color(color) {\n        this.m_color.set(color);\n        this.uniforms.diffuse.value.set(this.m_color);\n    }\n}\nexports.CirclePointsMaterial = CirclePointsMaterial;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/CirclePointsMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/CopyMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/CopyMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * The base shader to use for [[MapView]]'s composing passes, like [[MSAAMaterial]].\n */\nexports.CopyShader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        opacity: { value: 1.0 }\n    },\n    vertexShader: `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform float opacity;\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        gl_FragColor = opacity * texel;\n    }`\n};\n/**\n * The material is used for composing.\n */\nclass CopyMaterial extends THREE.ShaderMaterial {\n    /**\n     * The constructor of `CopyMaterial`.\n     *\n     * @param uniforms The [[CopyShader]]'s uniforms.\n     */\n    constructor(uniforms) {\n        super({\n            name: \"CopyMaterial\",\n            uniforms,\n            vertexShader: exports.CopyShader.vertexShader,\n            fragmentShader: exports.CopyShader.fragmentShader,\n            premultipliedAlpha: true,\n            transparent: false,\n            blending: THREE.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n    }\n}\nexports.CopyMaterial = CopyMaterial;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/CopyMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/EdgeMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/EdgeMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterials.js\");\nconst MapMeshMaterialsDefs_1 = __webpack_require__(/*! ./MapMeshMaterialsDefs */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\nconst vertexSource = `\n#define EDGE_DEPTH_OFFSET 0.0001\n\nattribute vec3 position;\nattribute vec4 color;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 edgeColor;\nuniform float edgeColorMix;\n\n#ifdef USE_DISPLACEMENTMAP\nattribute vec3 normal;\nattribute vec2 uv;\nuniform sampler2D displacementMap;\n#endif\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_vertex>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\nvoid main() {\n\n    #ifdef USE_COLOR\n    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);\n    #else\n    vColor = edgeColor.rgb;\n    #endif\n\n    vec3 transformed = vec3( position );\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_vertex>\n    #endif\n\n    #ifdef USE_DISPLACEMENTMAP\n    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n\n    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n    gl_Position = projectionMatrix * mvPosition;\n    // After projection gl_Position contains clip space coordinates of each vertex\n    // before perspective division (1 / w), thus only vertexes with -w < z < w should\n    // be displayed and offset. We offset only those edges which z coordinate in NDC\n    // space is between: -inf < z < 1\n    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;\n    gl_Position.z -= depthOffset;\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n}`;\nconst fragmentSource = `\nprecision highp float;\nprecision highp int;\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_fragment>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\nvoid main() {\n    float alphaValue = 1.0;\n    gl_FragColor = vec4(vColor, alphaValue);\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_fragment>\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n}`;\n/**\n * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid\n * colors, vertex colors, color mixing and distance fading.\n */\nclass EdgeMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Constructs a new `EdgeMaterial`.\n     *\n     * @param params `EdgeMaterial` parameters.\n     */\n    constructor(params) {\n        const defines = {};\n        const hasDisplacementMap = params !== undefined && params.displacementMap !== undefined;\n        const hasExtrusion = params !== undefined &&\n            params.extrusionRatio !== undefined &&\n            params.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN &&\n            params.extrusionRatio < MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n        if (hasDisplacementMap) {\n            Utils_1.setShaderDefine(defines, \"USE_DISPLACEMENTMAP\", true);\n        }\n        if (hasExtrusion) {\n            Utils_1.setShaderDefine(defines, \"USE_EXTRUSION\", true);\n        }\n        const shaderParams = {\n            name: \"EdgeMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: {\n                edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),\n                edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),\n                fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),\n                fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),\n                extrusionRatio: new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX),\n                displacementMap: new THREE.Uniform(hasDisplacementMap ? params.displacementMap : new THREE.Texture())\n            },\n            depthWrite: false,\n            defines\n        };\n        super(shaderParams);\n        Utils_1.enforceBlending(this);\n        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();\n        MapMeshMaterials_1.ExtrusionFeature.patchGlobalShaderChunks();\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                // Color may be set directly on object (omitting class setter), because we already\n                // know that is does no require any special handling nor material update\n                // (see: set color()).\n                this.color.set(params.color);\n            }\n            if (params.colorMix !== undefined) {\n                this.colorMix = params.colorMix;\n            }\n            if (params.fadeNear !== undefined) {\n                this.fadeNear = params.fadeNear;\n            }\n            if (params.fadeFar !== undefined) {\n                this.fadeFar = params.fadeFar;\n            }\n            if (params.displacementMap !== undefined) {\n                this.displacementMap = params.displacementMap;\n            }\n            if (params.extrusionRatio !== undefined) {\n                this.extrusionRatio = params.extrusionRatio;\n            }\n        }\n    }\n    /**\n     * Edge color.\n     */\n    get color() {\n        return this.uniforms.edgeColor.value;\n    }\n    set color(value) {\n        this.uniforms.edgeColor.value.copy(value);\n    }\n    /**\n     * Color mix value. Mixes between vertexColors and edgeColor.\n     */\n    get colorMix() {\n        return this.uniforms.edgeColorMix.value;\n    }\n    set colorMix(value) {\n        if (this.uniforms.edgeColorMix.value === value) {\n            return;\n        }\n        this.uniforms.edgeColorMix.value = value;\n        Utils_1.setShaderMaterialDefine(this, \"USE_COLOR\", value > 0.0);\n    }\n    get fadeNear() {\n        return this.uniforms.fadeNear.value;\n    }\n    set fadeNear(value) {\n        this.uniforms.fadeNear.value = value;\n    }\n    get fadeFar() {\n        return this.uniforms.fadeFar.value;\n    }\n    set fadeFar(value) {\n        if (this.uniforms.fadeFar.value === value) {\n            return;\n        }\n        this.uniforms.fadeFar.value = value;\n        Utils_1.setShaderMaterialDefine(this, \"USE_FADING\", value > 0.0);\n    }\n    get extrusionRatio() {\n        return this.uniforms.extrusionRatio.value;\n    }\n    set extrusionRatio(value) {\n        if (this.uniforms.extrusionRatio.value === value) {\n            return;\n        }\n        this.uniforms.extrusionRatio.value = value;\n        // NOTE: We could also disable shader extrusion chunks when it hits\n        // ExtrusionFeatureDefs.DEFAULT_RATIO_MAX value, but this would cause shader re-compile.\n        const useExtrusion = value >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;\n        Utils_1.setShaderMaterialDefine(this, \"USE_EXTRUSION\", useExtrusion);\n    }\n    get displacementMap() {\n        return this.uniforms.displacementMap.value;\n    }\n    set displacementMap(map) {\n        if (this.uniforms.displacementMap.value === map) {\n            return;\n        }\n        this.uniforms.displacementMap.value = map;\n        const useDisplacementMap = map !== undefined;\n        if (useDisplacementMap) {\n            this.uniforms.displacementMap.value.needsUpdate = true;\n        }\n        Utils_1.setShaderMaterialDefine(this, \"USE_DISPLACEMENTMAP\", useDisplacementMap);\n    }\n}\nexports.EdgeMaterial = EdgeMaterial;\nEdgeMaterial.DEFAULT_COLOR = 0x000000;\nEdgeMaterial.DEFAULT_COLOR_MIX = 0.0;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/EdgeMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js\");\nconst vertexSource = `\n#ifdef USE_COLOR\nattribute vec4 color;\nvarying vec3 vColor;\n#endif\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 position;        // high part\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n}`;\nconst fragmentSource = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifdef USE_COLOR\nvarying vec3 color;\n#endif\n\nvoid main() {\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( diffuse * vColor, opacity );\n    #else\n    gl_FragColor = vec4( diffuse, opacity );\n    #endif\n}`;\n/**\n * Material designed to render high precision lines (ideal for position-sensible data).\n */\nclass HighPrecisionLineMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Constructs a new `HighPrecisionLineMaterial`.\n     *\n     * @param params `HighPrecisionLineMaterial` parameters.\n     */\n    constructor(params) {\n        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);\n        const shaderParams = {\n            name: \"HighPrecisionLineMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: {\n                diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionLineMaterial.DEFAULT_COLOR)),\n                opacity: new THREE.Uniform(HighPrecisionLineMaterial.DEFAULT_OPACITY),\n                u_mvp: new THREE.Uniform(new THREE.Matrix4()),\n                u_eyepos: new THREE.Uniform(new THREE.Vector3()),\n                u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())\n            }\n        };\n        Object.assign(shaderParams, params);\n        super(shaderParams);\n        this.type = \"HighPrecisionLineMaterial\";\n        this.isHighPrecisionLineMaterial = true;\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                this.color.set(params.color);\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n        }\n        this.updateTransparencyFeature();\n    }\n    /**\n     * Line color.\n     */\n    get color() {\n        return this.uniforms.diffuse.value;\n    }\n    set color(value) {\n        this.uniforms.diffuse.value.copy(value);\n    }\n    updateTransparencyFeature() {\n        this.transparent = this.opacity < 1.0 ? true : false;\n    }\n}\nexports.HighPrecisionLineMaterial = HighPrecisionLineMaterial;\nHighPrecisionLineMaterial.DEFAULT_COLOR = 0x000050;\nHighPrecisionLineMaterial.DEFAULT_OPACITY = 1.0;\nfunction isHighPrecisionLineMaterial(material) {\n    return (material !== undefined &&\n        material.isHighPrecisionLineMaterial === true);\n}\nexports.isHighPrecisionLineMaterial = isHighPrecisionLineMaterial;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/HighPrecisionLineMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js\");\nconst vertexSource = `\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\nuniform float size;\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n\n    // ignore sizeAttenuation for now!\n    gl_PointSize = size;\n}`;\n/**\n * Material designed to render high precision points (ideal for position-sensible data).\n */\nclass HighPrecisionPointMaterial extends THREE.PointsMaterial {\n    /**\n     * Constructs a new `HighPrecisionPointMaterial`.\n     *\n     * @param params `HighPrecisionPointMaterial` parameters.\n     */\n    constructor(params) {\n        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);\n        const shaderParams = params;\n        super(shaderParams);\n        this.type = \"HighPrecisionPointMaterial\";\n        this.vertexShader = vertexSource;\n        this.fragmentShader = THREE.ShaderChunk.points_frag;\n        this.fog = false;\n        this.uniforms = {\n            diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionPointMaterial.DEFAULT_COLOR)),\n            opacity: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_OPACITY),\n            size: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SIZE),\n            scale: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SCALE),\n            map: new THREE.Uniform(new THREE.Texture()),\n            uvTransform: new THREE.Uniform(new THREE.Matrix3()),\n            u_mvp: new THREE.Uniform(new THREE.Matrix4()),\n            u_eyepos: new THREE.Uniform(new THREE.Vector3()),\n            u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())\n        };\n        this.isHighPrecisionPointMaterial = true;\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                this.color.set(params.color);\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n            if (params.size !== undefined) {\n                this.size = params.size;\n            }\n            if (params.scale !== undefined) {\n                this.scale = params.scale;\n            }\n            if (params.uvTransform !== undefined) {\n                this.uvTransform = params.uvTransform;\n            }\n            if (params.map !== undefined) {\n                this.map = params.map;\n            }\n        }\n    }\n    /**\n     *  Point scale.\n     */\n    get scale() {\n        return this.uniforms.scale.value;\n    }\n    set scale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n     * UV transformation matrix.\n     */\n    get uvTransform() {\n        return this.uniforms.uvTransform.value;\n    }\n    set uvTransform(value) {\n        this.uniforms.uvTransform.value = value;\n    }\n}\nexports.HighPrecisionPointMaterial = HighPrecisionPointMaterial;\nHighPrecisionPointMaterial.DEFAULT_COLOR = 0x000050;\nHighPrecisionPointMaterial.DEFAULT_OPACITY = 1.0;\nHighPrecisionPointMaterial.DEFAULT_SIZE = 1.0;\nHighPrecisionPointMaterial.DEFAULT_SCALE = 1.0;\nfunction isHighPrecisionPointMaterial(material) {\n    return (material !== undefined &&\n        material.isHighPrecisionPointMaterial === true);\n}\nexports.isHighPrecisionPointMaterial = isHighPrecisionPointMaterial;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/HighPrecisionPointMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/IconMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/IconMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst vertexSource = `\nattribute vec4 position;\nattribute vec4 color;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vColor = color;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n}`;\nconst fragmentSource = `\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D map;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n\n    vec4 color = texture2D(map, vUv.xy);\n    color *= vColor.a;\n    if (color.a < 0.05) {\n        discard;\n    }\n    gl_FragColor = color;\n}`;\n/**\n * 2D material for icons, similar to [[TextMaterial]]. Uses component in texture coordinates to\n * apply opacity.\n */\nclass IconMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Constructs a new `IconMaterial`.\n     *\n     * @param params `IconMaterial` parameters.\n     */\n    constructor(params) {\n        const shaderParams = {\n            name: \"IconMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: {\n                map: new THREE.Uniform(params.map)\n            },\n            depthTest: true,\n            depthWrite: true,\n            transparent: true,\n            vertexColors: THREE.VertexColors,\n            premultipliedAlpha: true,\n            blending: THREE.NormalBlending\n        };\n        super(shaderParams);\n    }\n    /**\n     * Icon texture map/atlas.\n     */\n    get map() {\n        return this.uniforms.map.value;\n    }\n}\nexports.IconMaterial = IconMaterial;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/IconMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * The shader used in the [[UnrealBloomPass]] for the bloom/glow effect.\n */\nexports.LuminosityHighPassShader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        luminosityThreshold: { value: 1.0 },\n        smoothWidth: { value: 1.0 },\n        defaultColor: { value: new THREE.Color(0x000000) },\n        defaultOpacity: { value: 0.0 }\n    },\n    vertexShader: `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform sampler2D tDiffuse;\n    uniform vec3 defaultColor;\n    uniform float defaultOpacity;\n    uniform float luminosityThreshold;\n    uniform float smoothWidth;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        vec3 luma = vec3( 0.299, 0.587, 0.114 );\n        float v = dot( texel.xyz, luma );\n        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n        gl_FragColor = mix( outputColor, texel, alpha );\n    }`\n};\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/LuminosityHighPassShader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MSAAMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MSAAMaterial.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst CopyMaterial_1 = __webpack_require__(/*! ./CopyMaterial */ \"./node_modules/@here/harp-materials/lib/CopyMaterial.js\");\n/**\n * The material to use for the quad of the [[MSAARenderPass]] in the composing.\n */\nclass MSAAMaterial extends THREE.ShaderMaterial {\n    /**\n     * The constructor of `MSAAMaterial`.\n     *\n     * @param uniforms The [[CopyShader]]'s uniforms.\n     */\n    constructor(uniforms) {\n        super({\n            uniforms,\n            vertexShader: CopyMaterial_1.CopyShader.vertexShader,\n            fragmentShader: CopyMaterial_1.CopyShader.fragmentShader,\n            premultipliedAlpha: true,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n    }\n}\nexports.MSAAMaterial = MSAAMaterial;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/MSAAMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MapMeshMaterials.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MapMeshMaterials.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapMeshMaterialsDefs_1 = __webpack_require__(/*! ./MapMeshMaterialsDefs */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js\");\nconst ExtrusionChunks_1 = __webpack_require__(/*! ./ShaderChunks/ExtrusionChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js\");\nconst FadingChunks_1 = __webpack_require__(/*! ./ShaderChunks/FadingChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js\");\n/**\n * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into\n * [0..maxVisibilityRange].\n *\n * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.\n *\n * @param distance Distance from the camera (range: [0, 1]).\n * @param visibilityRange object describiing maximum and minimum visibility range - distances\n * from camera at which objects won't be rendered anymore.\n */\nfunction cameraToWorldDistance(distance, visibilityRange) {\n    return distance * visibilityRange.maximum;\n}\nvar DisplacementFeature;\n(function (DisplacementFeature) {\n    /**\n     * Update the internals of the `DisplacementFeature` depending on the value of\n     * [[displacementMap]].\n     *\n     * @param displacementMaterial DisplacementFeature\n     */\n    function updateDisplacementFeature(displacementMaterial) {\n        displacementMaterial.needsUpdate = true;\n        if (displacementMaterial.defines === undefined) {\n            displacementMaterial.defines = {};\n        }\n        if (displacementMaterial.displacementMap !== undefined) {\n            displacementMaterial.displacementMap.needsUpdate = true;\n            // Add this define to differentiate it internally from other MeshBasicMaterial\n            displacementMaterial.defines.USE_DISPLACEMENTMAP = \"\";\n        }\n    }\n    DisplacementFeature.updateDisplacementFeature = updateDisplacementFeature;\n    /**\n     * This function should be called on implementors of DisplacementFeature in the\n     * `onBeforeCompile` callback of that material. It adds the required code to the shaders to\n     * apply displacement maps.\n     *\n     * @param displacementMaterial Material to add uniforms to.\n     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    function onBeforeCompile(displacementMaterial, shader) {\n        if (displacementMaterial.displacementMap === undefined) {\n            return;\n        }\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        //\n        // The object \"defines\" are not available for this material, so the fading shader chunks\n        // have the #ifdefs commented out.\n        // Create the uniforms for the shader (if not already existing), and add the new uniforms\n        // to it:\n        const uniforms = shader.uniforms;\n        uniforms.displacementMap = { value: displacementMaterial.displacementMap };\n        uniforms.displacementScale = { value: 1 };\n        uniforms.displacementBias = { value: 0 };\n        // Append the displacement map chunk to the vertex shader.\n        shader.vertexShader = shader.vertexShader.replace(\"#include <skinbase_vertex>\", `#include <skinbase_vertex>\n#ifndef USE_ENVMAP\n    vec3 objectNormal = vec3( normal );\n#endif`);\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"uv2_pars_vertex\", \"displacementmap_pars_vertex\");\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"skinning_vertex\", \"displacementmap_vertex\", true);\n    }\n    DisplacementFeature.onBeforeCompile = onBeforeCompile;\n})(DisplacementFeature = exports.DisplacementFeature || (exports.DisplacementFeature = {}));\nclass DisplacementFeatureMixin {\n    getDisplacementMap() {\n        return this.m_displacementMap;\n    }\n    setDisplacementMap(map) {\n        this.needsUpdate = this.needsUpdate || map !== this.m_displacementMap;\n        this.m_displacementMap = map;\n        if (this.needsUpdate) {\n            DisplacementFeature.updateDisplacementFeature(this);\n        }\n    }\n    /**\n     * The mixin class should call this method to register the property [[displacementMap]]\n     */\n    addDisplacementProperties() {\n        Object.defineProperty(this, \"displacementMap\", {\n            get: () => {\n                return this.getDisplacementMap();\n            },\n            set: val => {\n                this.setDisplacementMap(val);\n            }\n        });\n    }\n    /**\n     * Apply the displacementMap value from the parameters to the respective properties.\n     */\n    applyDisplacementParameters(params) {\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.displacementMap !== undefined) {\n                this.setDisplacementMap(params.displacementMap);\n            }\n        }\n        this.onBeforeCompile = (shader) => {\n            DisplacementFeature.onBeforeCompile(this, shader);\n        };\n    }\n    /**\n     * Copy displacementMap from other DisplacementFeature.\n     *\n     * @param source The material to copy property values from.\n     */\n    copyDisplacementParameters(source) {\n        this.setDisplacementMap(source.displacementMap);\n        return this;\n    }\n}\nexports.DisplacementFeatureMixin = DisplacementFeatureMixin;\n/**\n * Namespace with support functions for implementors of `FadingFeature`.\n */\nvar FadingFeature;\n(function (FadingFeature) {\n    FadingFeature.DEFAULT_FADE_NEAR = -1.0;\n    FadingFeature.DEFAULT_FADE_FAR = -1.0;\n    /**\n     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.\n     */\n    function patchGlobalShaderChunks() {\n        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {\n            Object.assign(THREE.ShaderChunk, FadingChunks_1.default);\n        }\n    }\n    FadingFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;\n    /**\n     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The\n     * fading feature will be disabled if fadeFar <= 0.0.\n     *\n     * @param fadingMaterial FadingFeature\n     */\n    function updateDistanceFadeFeature(fadingMaterial) {\n        fadingMaterial.needsUpdate = true;\n        if (fadingMaterial.defines === undefined) {\n            fadingMaterial.defines = {};\n        }\n        if (fadingMaterial.fadeFar !== undefined && fadingMaterial.fadeFar > 0.0) {\n            // Add this define to differentiate it internally from other MeshBasicMaterial\n            fadingMaterial.defines.FADING_MATERIAL = \"\";\n        }\n    }\n    FadingFeature.updateDistanceFadeFeature = updateDistanceFadeFeature;\n    /**\n     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`\n     * callback of that material. It adds the required code to the shaders and declares the new\n     * uniforms that control fading based on view distance.\n     *\n     * @param fadingMaterial Material to add uniforms to.\n     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    function onBeforeCompile(fadingMaterial, shader) {\n        if (fadingMaterial.fadeFar === undefined || fadingMaterial.fadeFar <= 0.0) {\n            return;\n        }\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        //\n        // The object \"defines\" are not available for this material, so the fading shader chunks\n        // have the #ifdefs commented out.\n        // Create the uniforms for the shader (if not already existing), and add the new uniforms\n        // to it:\n        const uniforms = shader.uniforms;\n        uniforms.fadeNear = { value: fadingMaterial.fadeNear };\n        uniforms.fadeFar = { value: fadingMaterial.fadeFar };\n        // Append the new fading shader cod directly after the fog code. This is done by adding an\n        // include directive for the fading code.\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"fog_pars_vertex\", \"fading_pars_vertex\");\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"fog_vertex\", \"fading_vertex\", true);\n        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, \"fog_pars_fragment\", \"fading_pars_fragment\");\n        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, \"fog_fragment\", \"fading_fragment\", true);\n    }\n    FadingFeature.onBeforeCompile = onBeforeCompile;\n    /**\n     * As threejs is rendering the transparent objects last (internally), regardless of their\n     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In\n     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the\n     * fade distance value is less than 1.\n     *\n     * @param object [[THREE.Object3D]] to prepare for rendering.\n     * @param viewRanges The visibility ranges (clip planes and maxiumum visible distance) for\n     * actual camera setup.\n     * @param fadeNear The fadeNear value to set in the material.\n     * @param fadeFar The fadeFar value to set in the material.\n     * @param updateUniforms If `true`, the fading uniforms are set. Not rquired if material is\n     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].\n     * @param additionalCallback If defined, this function will be called before the function will\n     *          return.\n     */\n    function addRenderHelper(object, viewRanges, fadeNear, fadeFar, updateUniforms, additionalCallback) {\n        // tslint:disable-next-line:no-unused-variable\n        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {\n            const fadingMaterial = material;\n            fadingMaterial.fadeNear =\n                fadeNear === undefined\n                    ? FadingFeature.DEFAULT_FADE_NEAR\n                    : cameraToWorldDistance(fadeNear, viewRanges);\n            fadingMaterial.fadeFar =\n                fadeFar === undefined\n                    ? FadingFeature.DEFAULT_FADE_FAR\n                    : cameraToWorldDistance(fadeFar, viewRanges);\n            if (updateUniforms) {\n                const properties = renderer.properties.get(material);\n                if (properties.shader !== undefined &&\n                    properties.shader.uniforms.fadeNear !== undefined) {\n                    properties.shader.uniforms.fadeNear.value = fadingMaterial.fadeNear;\n                    properties.shader.uniforms.fadeFar.value = fadingMaterial.fadeFar;\n                    fadingMaterial.uniformsNeedUpdate = true;\n                }\n            }\n            if (additionalCallback !== undefined) {\n                additionalCallback(renderer, material);\n            }\n        });\n    }\n    FadingFeature.addRenderHelper = addRenderHelper;\n})(FadingFeature = exports.FadingFeature || (exports.FadingFeature = {}));\n/**\n * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and\n * `fadeFar`. Thre is some special handling for the fadeNear/fadeFar properties, which get some\n * setters and getters in a way that works well with the mixin.\n *\n * @see [[Tile#addRenderHelper]]\n */\nclass FadingFeatureMixin {\n    constructor() {\n        this.m_fadeNear = FadingFeature.DEFAULT_FADE_NEAR;\n        this.m_fadeFar = FadingFeature.DEFAULT_FADE_FAR;\n    }\n    /**\n     * @see [[FadingFeature#fadeNear]]\n     */\n    getFadeNear() {\n        return this.m_fadeNear;\n    }\n    /**\n     * @see [[FadingFeature#fadeNear]]\n     */\n    setFadeNear(value) {\n        this.needsUpdate = this.needsUpdate || value !== this.m_fadeNear;\n        this.m_fadeNear = value;\n        if (this.needsUpdate) {\n            FadingFeature.updateDistanceFadeFeature(this);\n        }\n    }\n    /**\n     * @see [[FadingFeature#fadeFar]]\n     */\n    getFadeFar() {\n        return this.m_fadeFar;\n    }\n    /**\n     * @see [[FadingFeature#fadeFar]]\n     */\n    setFadeFar(value) {\n        this.needsUpdate = this.needsUpdate || value !== this.m_fadeFar;\n        this.m_fadeFar = value;\n        if (this.needsUpdate) {\n            FadingFeature.updateDistanceFadeFeature(this);\n        }\n    }\n    /**\n     * The mixin classes should call this method to register the properties [[fadeNear]] and\n     * [[fadeFar]].\n     */\n    addFadingProperties() {\n        Object.defineProperty(this, \"fadeNear\", {\n            get: () => {\n                return this.getFadeNear();\n            },\n            set: val => {\n                this.setFadeNear(val);\n            }\n        });\n        Object.defineProperty(this, \"fadeFar\", {\n            get: () => {\n                return this.getFadeFar();\n            },\n            set: val => {\n                this.setFadeFar(val);\n            }\n        });\n    }\n    /**\n     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.\n     *\n     * @param params `FadingMeshBasicMaterial` parameters.\n     */\n    applyFadingParameters(params) {\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.fadeNear !== undefined) {\n                this.setFadeNear(params.fadeNear);\n            }\n            if (params.fadeFar !== undefined) {\n                this.setFadeFar(params.fadeFar);\n            }\n        }\n        this.onBeforeCompile = (shader) => {\n            FadingFeature.onBeforeCompile(this, shader);\n        };\n    }\n    /**\n     * Copy fadeNear/fadeFar values from other FadingFeature.\n     *\n     * @param source The material to copy property values from.\n     */\n    copyFadingParameters(source) {\n        this.setFadeNear(source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear);\n        this.setFadeFar(source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar);\n        return this;\n    }\n}\nexports.FadingFeatureMixin = FadingFeatureMixin;\nvar ExtrusionFeature;\n(function (ExtrusionFeature) {\n    /**\n     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.\n     */\n    function patchGlobalShaderChunks() {\n        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {\n            Object.assign(THREE.ShaderChunk, ExtrusionChunks_1.default);\n        }\n    }\n    ExtrusionFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;\n    /**\n     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].\n     *\n     * @param ExtrusionMaterial ExtrusionFeature\n     */\n    function updateExtrusionFeature(extrusionMaterial) {\n        extrusionMaterial.needsUpdate = true;\n        if (extrusionMaterial.defines === undefined) {\n            extrusionMaterial.defines = {};\n        }\n        if (extrusionMaterial.extrusionRatio !== undefined &&\n            extrusionMaterial.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN) {\n            // Add this define to differentiate it internally from other MeshBasicMaterial\n            extrusionMaterial.defines.EXTRUSION_MATERIAL = \"\";\n        }\n    }\n    ExtrusionFeature.updateExtrusionFeature = updateExtrusionFeature;\n    /**\n     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`\n     * callback of that material. It adds the required code to the shaders and declares the new\n     * uniforms that control extrusion.\n     *\n     * @param extrusionMaterial Material to add uniforms to.\n     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    function onBeforeCompile(extrusionMaterial, shader) {\n        if (extrusionMaterial.extrusionRatio === undefined) {\n            return;\n        }\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        // Create the uniforms for the shader (if not already existing), and add the new uniforms\n        // to it:\n        const uniforms = shader.uniforms;\n        uniforms.extrusionRatio = { value: extrusionMaterial.extrusionRatio };\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"common\", \"extrusion_pars_vertex\");\n        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, \"begin_vertex\", \"extrusion_vertex\", true);\n        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, \"fog_pars_fragment\", \"extrusion_pars_fragment\");\n        shader.fragmentShader = shader.fragmentShader.replace(\"#include <normal_fragment_begin>\", \"#include <extrusion_normal_fragment_begin>\");\n        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, \"fog_fragment\", \"extrusion_fragment\", true);\n    }\n    ExtrusionFeature.onBeforeCompile = onBeforeCompile;\n    /**\n     * Handles animated extrusion on each frame. Should be installed as respective\n     * Object3D.onBeforeRender of meshes which use animated extusion feature.\n     */\n    function addRenderHelper(object) {\n        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, ExtrusionFeature.onBeforeRender);\n    }\n    ExtrusionFeature.addRenderHelper = addRenderHelper;\n    function onBeforeRender(renderer, scene, camera, geometry, material, group) {\n        const extrusionMaterial = material;\n        const properties = renderer.properties.get(material);\n        if (properties.shader !== undefined &&\n            properties.shader.uniforms.extrusionRatio !== undefined) {\n            properties.shader.uniforms.extrusionRatio.value =\n                extrusionMaterial.extrusionRatio || MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n            extrusionMaterial.uniformsNeedUpdate = true;\n        }\n    }\n    ExtrusionFeature.onBeforeRender = onBeforeRender;\n})(ExtrusionFeature = exports.ExtrusionFeature || (exports.ExtrusionFeature = {}));\n/**\n * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.\n * Thre is some special handling for the extrusionRatio property, which get some setters and\n * getters in a way that works well with the mixin.\n *\n * @see [[Tile#addRenderHelper]]\n */\nclass ExtrusionFeatureMixin {\n    constructor() {\n        this.m_extrusion = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n    /**\n     * @see [[ExtrusionFeature#extrusion]]\n     */\n    getExtrusionRatio() {\n        return this.m_extrusion;\n    }\n    /**\n     * @see [[ExtrusionFeature#extrusion]]\n     */\n    setExtrusionRatio(value) {\n        this.needsUpdate = this.needsUpdate || value !== this.m_extrusion;\n        this.m_extrusion = value;\n        if (this.needsUpdate) {\n            ExtrusionFeature.updateExtrusionFeature(this);\n        }\n    }\n    /**\n     * The mixin class should call this method to register the property [[extrusionRatio]]\n     */\n    addExtrusionProperties() {\n        Object.defineProperty(this, \"extrusionRatio\", {\n            get: () => {\n                return this.getExtrusionRatio();\n            },\n            set: val => {\n                this.setExtrusionRatio(val);\n            }\n        });\n    }\n    /**\n     * Apply the extrusionRatio value from the parameters to the respective properties.\n     */\n    applyExtrusionParameters(params) {\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.extrusionRatio !== undefined) {\n                this.setExtrusionRatio(params.extrusionRatio);\n            }\n        }\n        this.onBeforeCompile = (shader) => {\n            ExtrusionFeature.onBeforeCompile(this, shader);\n        };\n    }\n    /**\n     * Copy extrusionRatio values from other ExtrusionFeature.\n     *\n     * @param source The material to copy property values from.\n     */\n    copyExtrusionParameters(source) {\n        if (source.extrusionRatio !== undefined) {\n            this.setExtrusionRatio(source.extrusionRatio);\n        }\n        return this;\n    }\n}\nexports.ExtrusionFeatureMixin = ExtrusionFeatureMixin;\n/**\n * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and\n * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is\n * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]\n * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are\n * updated to world space distances.\n *\n * @see [[Tile#addRenderHelper]]\n */\nclass MapMeshBasicMaterial extends THREE.MeshBasicMaterial {\n    /**\n     * Constructs a new `FadingMeshBasicMaterial`.\n     *\n     * @param params `FadingMeshBasicMaterial` parameters.\n     */\n    constructor(params) {\n        super(params);\n        FadingFeature.patchGlobalShaderChunks();\n        this.addFadingProperties();\n        this.applyFadingParameters(params);\n        ExtrusionFeature.patchGlobalShaderChunks();\n        this.addExtrusionProperties();\n        this.applyExtrusionParameters(params);\n        this.addDisplacementProperties();\n        this.applyDisplacementParameters(params);\n    }\n    clone() {\n        return new MapMeshBasicMaterial().copy(this);\n    }\n    copy(source) {\n        super.copy(source);\n        this.copyFadingParameters(source);\n        this.copyExtrusionParameters(source);\n        this.copyDisplacementParameters(source);\n        return this;\n    }\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in [[FadingFeatureMixin]] and [[ExtrusionFeatureMixin]], see below:\n    //\n    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);\n    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n    get fadeNear() {\n        return FadingFeature.DEFAULT_FADE_NEAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeNear(value) {\n        // to be overridden\n    }\n    get fadeFar() {\n        return FadingFeature.DEFAULT_FADE_FAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeFar(value) {\n        // to be overridden\n    }\n    get extrusionRatio() {\n        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set extrusionRatio(value) {\n        // to be overridden\n    }\n    get displacementMap() {\n        return undefined;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set displacementMap(value) {\n        // to be overridden\n    }\n    addFadingProperties() {\n        // to be overridden\n    }\n    // tslint:disable-next-line:no-unused-variable\n    applyFadingParameters(params) {\n        // to be overridden\n    }\n    // tslint:disable-next-line:no-unused-variable\n    copyFadingParameters(source) {\n        // to be overridden\n    }\n    addExtrusionProperties() {\n        // to be overridden\n    }\n    // tslint:disable-next-line:no-unused-variable\n    applyExtrusionParameters(params) {\n        // to be overridden\n    }\n    // tslint:disable-next-line:no-unused-variable\n    copyExtrusionParameters(source) {\n        // to be overridden\n    }\n    addDisplacementProperties() {\n        // to be overridden\n    }\n    // tslint:disable-next-line:no-unused-variable\n    applyDisplacementParameters(params) {\n        // to be overridden\n    }\n    // tslint:disable-next-line:no-unused-variable\n    copyDisplacementParameters(source) {\n        // to be overridden\n    }\n}\nexports.MapMeshBasicMaterial = MapMeshBasicMaterial;\n/**\n * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and\n * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also\n * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,\n * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to\n * world space distances.\n *\n * @see [[Tile#addRenderHelper]]\n */\nclass MapMeshStandardMaterial extends THREE.MeshStandardMaterial {\n    /**\n     * Constructs a new `FadingMeshStandardMaterial`.\n     *\n     * @param params `FadingMeshStandardMaterial` parameters.\n     */\n    constructor(params) {\n        super(params);\n        FadingFeature.patchGlobalShaderChunks();\n        this.addFadingProperties();\n        this.applyFadingParameters(params);\n        ExtrusionFeature.patchGlobalShaderChunks();\n        this.addExtrusionProperties();\n        this.applyExtrusionParameters(params);\n    }\n    clone() {\n        return new MapMeshStandardMaterial().copy(this);\n    }\n    copy(source) {\n        super.copy(source);\n        this.copyFadingParameters(source);\n        this.copyExtrusionParameters(source);\n        return this;\n    }\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in [[FadingFeatureMixin]] and [[ExtrusionFeatureMixin]], see below:\n    //\n    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);\n    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n    get fadeNear() {\n        return FadingFeature.DEFAULT_FADE_NEAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeNear(value) {\n        // to be overridden\n    }\n    get fadeFar() {\n        return FadingFeature.DEFAULT_FADE_FAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeFar(value) {\n        // to be overridden\n    }\n    get extrusionRatio() {\n        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set extrusionRatio(value) {\n        // to be overridden\n    }\n    addFadingProperties() {\n        // to be overridden\n    }\n    // tslint:disable-next-line:no-unused-variable\n    applyFadingParameters(params) {\n        // to be overridden\n    }\n    // tslint:disable-next-line:no-unused-variable\n    copyFadingParameters(source) {\n        // to be overridden\n    }\n    addExtrusionProperties() {\n        // to be overridden\n    }\n    // tslint:disable-next-line:no-unused-variable\n    applyExtrusionParameters(params) {\n        // to be overridden\n    }\n    // tslint:disable-next-line:no-unused-variable\n    copyExtrusionParameters(source) {\n        // to be overridden\n    }\n}\nexports.MapMeshStandardMaterial = MapMeshStandardMaterial;\n/**\n * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual\n * implementations of the mixed in functions.\n */\nharp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);\nharp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);\nharp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);\nharp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);\nharp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/MapMeshMaterials.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ExtrusionFeatureDefs;\n(function (ExtrusionFeatureDefs) {\n    /**\n     * Minimum ratio value for extrusion effect\n     */\n    ExtrusionFeatureDefs.DEFAULT_RATIO_MIN = 0.0;\n    /**\n     * Maximum ratio value for extrusion effect\n     */\n    ExtrusionFeatureDefs.DEFAULT_RATIO_MAX = 1;\n    /**\n     * Buildings height used whenever no height-data is present or height is very small.\n     *\n     * Used to avoid z-fighting between ground plane and building.\n     */\n    ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT = 0.01;\n})(ExtrusionFeatureDefs = exports.ExtrusionFeatureDefs || (exports.ExtrusionFeatureDefs = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/SepiaShader.js":
/*!**************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/SepiaShader.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * `SepiaShader`.\n */\nexports.SepiaShader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        amount: { value: 1.0 }\n    },\n    vertexShader: `\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }`,\n    fragmentShader: `\n        uniform float amount;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 color = texture2D( tDiffuse, vUv );\n            vec3 c = color.rgb;\n            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\n            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\n            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\n            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\n        }`\n};\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/SepiaShader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MapMeshMaterialsDefs_1 = __webpack_require__(/*! ../MapMeshMaterialsDefs */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterialsDefs.js\");\nconst MIN_BUILDING_HEIGHT_SQUARED = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT * MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT;\nexports.default = {\n    extrusion_pars_vertex: `\n// Extrusion axis (xyz: vector, w: factor).\nattribute vec4 extrusionAxis;\nuniform float extrusionRatio;\nvarying vec4 vExtrusionAxis;\nvarying float vExtrusionRatio;\n\n`,\n    extrusion_vertex: `\n// Cancel extrusionRatio (meaning, force to 1) if extrusionAxisLen < MIN_BUILDING_HEIGHT.\nconst float MIN_BUILDING_HEIGHT_SQUARED = ${MIN_BUILDING_HEIGHT_SQUARED};\nfloat extrusionAxisLenSquared = dot(extrusionAxis.xyz, extrusionAxis.xyz);\nvExtrusionRatio = (extrusionAxisLenSquared < MIN_BUILDING_HEIGHT_SQUARED) ? 1.0 : extrusionRatio;\n\ntransformed = transformed + extrusionAxis.xyz * (vExtrusionRatio - 1.0);\nvExtrusionAxis = vec4(normalMatrix * extrusionAxis.xyz, extrusionAxis.w);\n`,\n    // Modified version of THREE <normal_fragment_begin> shader chunk which, for flat shaded\n    // geometries, computes the normal either with the extrusion axis or fragment derivatives based\n    // on the extrusion factor (1.0 = ceiling, 0.0 = footprint).\n    extrusion_normal_fragment_begin: `\n#ifdef FLAT_SHADED\n    // Flattened this divergent path to prevent undefined behaviour in the following derivatives\n    // functions. For more info:\n    // http://www.aclockworkberry.com/shader-derivative-functions/#Derivatives_and_branches\n\n    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n    vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));\n    vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));\n    vec3 normal = cross( fdx, fdy );\n    if (vExtrusionAxis.w > 0.999999) {\n        normal = vExtrusionAxis.xyz;\n    }\n    normal = normalize(normal);\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t\tbitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t#endif\n\t#endif\n#endif\n// non perturbed normal for clearcoat among others\nvec3 geometryNormal = normal;\n`,\n    extrusion_pars_fragment: `\nvarying float vExtrusionRatio;\nvarying vec4 vExtrusionAxis;\n`,\n    extrusion_fragment: `\ngl_FragColor.a *= smoothstep( 0.0, 0.25, vExtrusionRatio );\n`\n};\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The shader chunks have their lines \"#ifdef USE_FADING\" commented out, because currently the\n * mesh materials use individually created shader strings based on the materials settings.\n * @see [[FadingMeshBasicMaterial]]\n **/\nexports.default = {\n    fading_pars_vertex: `\nvarying float fadingDepth;\n`,\n    fading_vertex: `\nfadingDepth = -mvPosition.z;\n`,\n    fading_pars_fragment: `\nvarying float fadingDepth;\nuniform float fadeNear;\nuniform float fadeFar;\n`,\n    fading_fragment: `\n\n// lerp with \"hard\" edges\n//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);\n\n// smooth transitions\nfloat fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );\n\ngl_FragColor.a *= 1.0 - fadingFactor;\n\n// debugging color:\n// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);\n`\n};\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/ShaderChunks/FadingChunks.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Lists supported line caps types/modes.\n */\nvar LineCapsModes;\n(function (LineCapsModes) {\n    LineCapsModes[LineCapsModes[\"CAPS_NONE\"] = 0] = \"CAPS_NONE\";\n    LineCapsModes[LineCapsModes[\"CAPS_SQUARE\"] = 1] = \"CAPS_SQUARE\";\n    LineCapsModes[LineCapsModes[\"CAPS_ROUND\"] = 2] = \"CAPS_ROUND\";\n    LineCapsModes[LineCapsModes[\"CAPS_TRIANGLE_IN\"] = 3] = \"CAPS_TRIANGLE_IN\";\n    LineCapsModes[LineCapsModes[\"CAPS_TRIANGLE_OUT\"] = 4] = \"CAPS_TRIANGLE_OUT\";\n})(LineCapsModes = exports.LineCapsModes || (exports.LineCapsModes = {}));\nexports.default = {\n    extrude_line_vert_func: `\nvec3 extrudeLine(\n        in vec3 vertexPosition,\n        in float linePosition,\n        in float lineWidth,\n        in vec4 bitangent,\n        in vec3 tangent,\n        inout vec2 uv\n    ) {\n    vec3 result = vertexPosition;\n    // Retrieve the angle between this segment and the previous one (stored in the bitangent w\n    // component).\n    float angle = bitangent.w;\n    // Extrude according to the angle between segments to properly render narrow joints...\n    if (angle != 0.0) {\n        result += uv.y * lineWidth * bitangent.xyz / cos(angle / 2.0);\n        uv.x = linePosition + uv.x * lineWidth * uv.y * tan(angle / 2.0);\n    }\n    // ... or extrude in a simple manner for segments that keep the same direction.\n    else {\n        result += uv.y * lineWidth * bitangent.xyz + uv.x * lineWidth * tangent;\n        uv.x = linePosition + uv.x * lineWidth;\n    }\n    uv.y *= lineWidth;\n    return result;\n}\n`,\n    round_edges_and_add_caps: `\n#define CAPS_NONE ${LineCapsModes.CAPS_NONE}\n#define CAPS_SQUARE ${LineCapsModes.CAPS_SQUARE}\n#define CAPS_ROUND ${LineCapsModes.CAPS_ROUND}\n#define CAPS_TRIANGLE_IN ${LineCapsModes.CAPS_TRIANGLE_IN}\n#define CAPS_TRIANGLE_OUT ${LineCapsModes.CAPS_TRIANGLE_OUT}\n\nfloat roundEdgesAndAddCaps(in vec4 coords, in vec3 range) {\n    // Compute the line's width to length ratio.\n    float widthRatio = range.y / range.x;\n\n    // Compute the inner segment distance (same for all cap mode).\n    float dist = abs(coords.y);\n    float segmentBeginMask = clamp(ceil(coords.z - coords.x), 0.0, 1.0);\n    float segmentEndMask = clamp(ceil(coords.x - coords.w), 0.0, 1.0);\n    dist = max(dist, segmentBeginMask * length(vec2((coords.x - coords.z) / widthRatio, coords.y)));\n    dist = max(dist, segmentEndMask * length(vec2((coords.x - coords.w) / widthRatio, coords.y)));\n\n    #if CAPS_MODE != CAPS_ROUND\n    // Compute the caps mask.\n    float capRangeMask = clamp(1.0 - ceil(range.z - drawRange.y), 0.0, 1.0);\n    float beginCapMask = clamp(ceil(drawRange.x - coords.x), 0.0, 1.0);\n    float endCapMask = clamp(ceil(coords.x - drawRange.y), 0.0, 1.0);\n    float capMask = capRangeMask * max(beginCapMask, endCapMask);\n\n    // Compute the outer segment distance (specific for each cap mode).\n    float capDist = max(coords.x - drawRange.y, drawRange.x - coords.x) / widthRatio;\n    #if CAPS_MODE == CAPS_NONE\n    dist = mix(dist, max(abs(coords.y), (capDist + 0.1) / 0.1), capMask);\n    #elif CAPS_MODE == CAPS_SQUARE\n    dist = mix(dist, max(abs(coords.y), capDist), capMask);\n    #elif CAPS_MODE == CAPS_TRIANGLE_OUT\n    dist = mix(dist, abs(coords.y) + capDist, capMask);\n    #elif CAPS_MODE == CAPS_TRIANGLE_IN\n    dist = mix(dist, max(abs(coords.y), (capDist - abs(coords.y)) + capDist), capMask);\n    #endif\n    #endif // CAPS_MODE != CAPS_ROUND\n\n    return dist;\n}\n`,\n    tile_clip_func: `\nvoid tileClip(vec2 tilePos, vec2 tileSize) {\n    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))\n        discard;\n    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))\n        discard;\n}\n`,\n    high_precision_vert_func: `\nvec3 subtractDblEyePos( const in vec3 pos ) {\n    vec3 t1 = positionLow - u_eyepos_lowpart;\n    vec3 e = t1 - positionLow;\n    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;\n    vec3 high_delta = t1 + t2;\n    vec3 low_delta = t2 - (high_delta - t1);\n    return (high_delta + low_delta);\n}\n`\n};\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/SolidLineMaterial.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/SolidLineMaterial.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ \"./node_modules/@here/harp-materials/lib/MapMeshMaterials.js\");\nconst LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ \"./node_modules/@here/harp-materials/lib/ShaderChunks/LinesChunks.js\");\nconst Utils_1 = __webpack_require__(/*! ./Utils */ \"./node_modules/@here/harp-materials/lib/Utils.js\");\nconst LineCapsDefinesMapping = {\n    None: LinesChunks_1.LineCapsModes.CAPS_NONE,\n    Square: LinesChunks_1.LineCapsModes.CAPS_SQUARE,\n    Round: LinesChunks_1.LineCapsModes.CAPS_ROUND,\n    TriangleIn: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_IN,\n    TriangleOut: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_OUT\n};\nconst DefinesLineCapsMapping = Object.keys(LineCapsDefinesMapping).reduce((r, lineCapsName) => {\n    const defineKey = lineCapsName;\n    const defineValue = LineCapsDefinesMapping[defineKey];\n    r[defineValue] = defineKey;\n    return r;\n}, {});\n/**\n * The vLength contains the actual line length, it's needed for the creation of line caps by\n * detecting line ends. `vLength == vExtrusionCoord.x + lineWidth * 2`\n */\n/**\n * The vExtrusionStrength relies on the edges of the lines. Represents how far the current point was\n * extruded on the edges because of the current angle. Needed for preventing line caps artifacts on\n * sharp line edges. For example, on sharp edges, some vertices can be extruded much further than\n * the full line length.\n */\nconst tmpColor = new THREE.Color();\nconst vertexSource = `\n#define SEGMENT_OFFSET 0.1\n\nattribute vec3 extrusionCoord;\nattribute vec3 position;\nattribute vec4 bitangent;\nattribute vec3 tangent;\nattribute vec2 uv;\nattribute vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float lineWidth;\nuniform float outlineWidth;\nuniform vec2 drawRange;\n\n#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;\n#endif\n\nvarying vec3 vPosition;\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#ifdef USE_COLOR\nattribute vec3 color;\nvarying vec3 vColor;\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\n#include <fog_pars_vertex>\n\n#include <extrude_line_vert_func>\n\nvoid main() {\n    // Calculate the segment.\n    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;\n    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;\n\n    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.\n    float linePos = mix(segment.x, segment.y, segmentPos);\n    vec2 extrusionDir = sign(extrusionCoord.xy);\n    float extrusionFactor = extrusionDir.y * tan(bitangent.w / 2.0);\n\n    // Calculate the extruded vertex position (and scale the extrusion direction).\n    vec3 pos = extrudeLine(\n        position, linePos, lineWidth + outlineWidth, bitangent, tangent, extrusionDir);\n\n    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).\n    vRange = vec3(extrusionCoord.z, lineWidth, extrusionFactor);\n    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);\n\n    // Adjust the segment to fit the drawRange.\n    float capDist = (lineWidth + outlineWidth) / extrusionCoord.z;\n    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {\n        vCoords.zw += 1.0;\n    }\n    if (vCoords.z < drawRange.x) {\n        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);\n    }\n    if (vCoords.w > drawRange.y) {\n        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);\n    }\n\n    // Transform position.\n    #ifdef USE_DISPLACEMENTMAP\n    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\n    // Pass extruded position to fragment shader.\n    vPosition = pos;\n\n    #ifdef USE_COLOR\n    // Pass vertex color to fragment shader.\n    vColor = color;\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n\n    #include <fog_vertex>\n}`;\nconst fragmentSource = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuse;\nuniform vec3 outlineColor;\nuniform float opacity;\nuniform float lineWidth;\nuniform float outlineWidth;\nuniform vec2 tileSize;\nuniform vec2 drawRange;\n\n#ifdef USE_DASHED_LINE\nuniform float dashSize;\nuniform float gapSize;\nuniform vec3 dashColor;\n#endif\n\nvarying vec3 vPosition;\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\n#include <round_edges_and_add_caps>\n#include <tile_clip_func>\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\n#include <fog_pars_fragment>\n\nvoid main() {\n    float alpha = opacity;\n    vec3 outputDiffuse = diffuse;\n\n    #ifdef USE_TILE_CLIP\n    tileClip(vPosition.xy, tileSize);\n    #endif\n\n    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).\n    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);\n    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).\n    float distToEdge = distToCenter - (lineWidth + outlineWidth) / lineWidth;\n\n    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope\n    // of distToChange increases (i.e. the line is further away).\n    float width = fwidth(distToEdge);\n    alpha *= (1.0 - smoothstep(-width, width, distToEdge));\n\n    #ifdef USE_DASHED_LINE\n    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).\n    float d = dashSize / vRange.x;\n    float g = gapSize / vRange.x;\n    float distToDashOrigin = mod(vCoords.x, d + g) / d;\n\n    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the\n    // dashBlendFactor similarly on how we did it for the line opacity.\n    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);\n    float dashWidth = fwidth(distToDashEdge);\n    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);\n\n    #ifdef USE_DASH_COLOR\n    outputDiffuse = mix(diffuse, dashColor, dashBlendFactor);\n    #endif\n    #endif\n\n    #ifdef USE_OUTLINE\n    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and\n    // compute the outlineBlendFactor (used to mix line and outline colors).\n    float distToOutline = distToCenter - 1.0;\n    float outlineWidth = fwidth(distToOutline);\n    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);\n\n    // Mix the colors using the different computed factors.\n    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)\n    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);\n    outputDiffuse = mix(\n      mix(\n        mix(outlineColor, diffuse, colorBlendFactor),\n        outputDiffuse,\n        dashBlendFactor\n      ),\n      outlineColor,\n      outlineBlendFactor\n    );\n    #else\n    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);\n    #endif\n    #endif\n\n    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)\n    // Multiply the alpha by the dashBlendFactor.\n    #if defined(USE_OUTLINE)\n    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);\n    #else\n    alpha *= 1.0 - dashBlendFactor;\n    #endif\n    #endif\n\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( outputDiffuse * vColor, alpha );\n    #else\n    gl_FragColor = vec4( outputDiffuse, alpha );\n    #endif\n\n    #include <fog_fragment>\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n}`;\n/**\n * Material designed to render solid variable-width lines.\n */\nclass SolidLineMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Constructs a new `SolidLineMaterial`.\n     *\n     * @param params `SolidLineMaterial` parameters.\n     */\n    constructor(params) {\n        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);\n        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();\n        // Setup default defines.\n        const defines = {\n            CAPS_MODE: LinesChunks_1.LineCapsModes.CAPS_ROUND\n        };\n        // Prepare defines based on params passed in, before super class c-tor, this ensures\n        // proper set for shader compilation, without need to re-compile.\n        let fogParam = true;\n        let opacityParam = 1.0;\n        let displacementMap;\n        if (params !== undefined) {\n            fogParam = params.fog === true;\n            if (fogParam) {\n                Utils_1.setShaderDefine(defines, \"USE_FOG\", true);\n            }\n            opacityParam = params.opacity !== undefined ? params.opacity : opacityParam;\n            displacementMap = params.displacementMap;\n            if (displacementMap !== undefined) {\n                Utils_1.setShaderDefine(defines, \"USE_DISPLACEMENTMAP\", true);\n            }\n            const hasOutline = params.outlineWidth !== undefined && params.outlineWidth > 0;\n            if (hasOutline) {\n                Utils_1.setShaderDefine(defines, \"USE_OUTLINE\", true);\n            }\n        }\n        const shaderParams = {\n            name: \"SolidLineMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: THREE.UniformsUtils.merge([\n                {\n                    diffuse: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),\n                    dashColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),\n                    outlineColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),\n                    lineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),\n                    outlineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),\n                    opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),\n                    tileSize: new THREE.Uniform(new THREE.Vector2()),\n                    fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),\n                    fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),\n                    displacementMap: new THREE.Uniform(displacementMap !== undefined ? displacementMap : new THREE.Texture()),\n                    drawRange: new THREE.Uniform(new THREE.Vector2(SolidLineMaterial.DEFAULT_DRAW_RANGE_START, SolidLineMaterial.DEFAULT_DRAW_RANGE_END)),\n                    dashSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_DASH_SIZE),\n                    gapSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_GAP_SIZE)\n                },\n                // We need the fog uniforms available when we use `fog` setter as the internal\n                // recompilation cannot add or remove uniforms.\n                THREE.UniformsLib.fog\n            ]),\n            defines,\n            // No need to pass overridden `fog` and `opacity` params they will be set\n            // after super c-tor call.\n            fog: fogParam,\n            opacity: opacityParam\n        };\n        super(shaderParams);\n        // Required to satisfy compiler error if fields has no initializer or are not definitely\n        // assigned in the constructor, this also mimics ShaderMaterial set of defaults\n        // for overridden props.\n        this.m_fog = fogParam;\n        this.m_opacity = opacityParam;\n        Utils_1.enforceBlending(this);\n        this.extensions.derivatives = true;\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                tmpColor.set(params.color);\n                this.color = tmpColor;\n            }\n            if (params.outlineColor !== undefined) {\n                tmpColor.set(params.outlineColor);\n                this.outlineColor = tmpColor;\n            }\n            if (params.lineWidth !== undefined) {\n                this.lineWidth = params.lineWidth;\n            }\n            if (params.outlineWidth !== undefined) {\n                this.outlineWidth = params.outlineWidth;\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n            if (params.depthTest !== undefined) {\n                this.depthTest = params.depthTest;\n            }\n            if (params.depthWrite !== undefined) {\n                this.depthWrite = params.depthWrite;\n            }\n            if (params.fadeNear !== undefined) {\n                this.fadeNear = params.fadeNear;\n            }\n            if (params.fadeFar !== undefined) {\n                this.fadeFar = params.fadeFar;\n            }\n            if (params.displacementMap !== undefined) {\n                this.displacementMap = params.displacementMap;\n            }\n            if (params.caps !== undefined) {\n                this.caps = params.caps;\n            }\n            if (params.drawRangeStart !== undefined) {\n                this.drawRangeStart = params.drawRangeStart;\n            }\n            if (params.drawRangeEnd !== undefined) {\n                this.drawRangeEnd = params.drawRangeEnd;\n            }\n            if (params.dashColor !== undefined) {\n                tmpColor.set(params.dashColor);\n                this.dashColor = tmpColor;\n            }\n            if (params.dashSize !== undefined) {\n                this.dashSize = params.dashSize;\n            }\n            if (params.gapSize !== undefined) {\n                this.gapSize = params.gapSize;\n            }\n            if (params.fog !== undefined) {\n                this.fog = params.fog;\n            }\n        }\n        // ShaderMaterial overrides requires invalidation cause super c-tor may set this\n        // properties before related `defines` and `uniforms` were created.\n        this.invalidateFog();\n        this.invalidateOpacity();\n    }\n    /**\n     * Overrides THREE.Material.fog flag to add support for custom shader.\n     *\n     * @param enable Whether we want to enable the fog.\n     */\n    set fog(enable) {\n        this.m_fog = enable;\n        // Function may be called from THREE.js cause we override setter,\n        // in this case defines are not yet initalized and require late invalidation in\n        // SolidLineMaterial c-tor.\n        if (this.defines !== undefined) {\n            Utils_1.setShaderMaterialDefine(this, \"USE_FOG\", enable);\n        }\n    }\n    /**\n     * Checks if fog is enabled.\n     */\n    get fog() {\n        return this.m_fog && Utils_1.getShaderMaterialDefine(this, \"USE_FOG\") === true;\n    }\n    /**\n     * The method to call to recompile a material to enable/disable outline effect\n     *\n     * @param enable Whether we want to use outline.\n     */\n    set outline(enable) {\n        Utils_1.setShaderMaterialDefine(this, \"USE_OUTLINE\", enable);\n    }\n    /**\n     * Checks if outline is enabled.\n     */\n    get outline() {\n        return Utils_1.getShaderMaterialDefine(this, \"USE_OUTLINE\") === true;\n    }\n    /**\n     * Line opacity.\n     */\n    get opacity() {\n        return this.m_opacity;\n    }\n    set opacity(value) {\n        this.m_opacity = value;\n        // Setting opacity before uniform being created requires late invalidation,\n        // call to invalidateOpacity() is done at the end of c-tor.\n        if (this.uniforms !== undefined) {\n            this.uniforms.opacity.value = value;\n        }\n    }\n    /**\n     * Line color.\n     */\n    get color() {\n        return this.uniforms.diffuse.value;\n    }\n    set color(value) {\n        this.uniforms.diffuse.value.copy(value);\n    }\n    /**\n     * Outline color.\n     *\n     * @note The width of outline ([[outlineWidth]]) need to be also set to enable outlining.\n     */\n    get outlineColor() {\n        return this.uniforms.outlineColor.value;\n    }\n    set outlineColor(value) {\n        this.uniforms.outlineColor.value.copy(value);\n    }\n    /**\n     * Dash color.\n     *\n     * @note The property [[gapSize]] need to be set to enable dashed line.\n     */\n    get dashColor() {\n        return this.uniforms.dashColor.value;\n    }\n    set dashColor(value) {\n        this.uniforms.dashColor.value.copy(value);\n        Utils_1.setShaderMaterialDefine(this, \"USE_DASH_COLOR\", true);\n    }\n    /**\n     * Line width.\n     */\n    get lineWidth() {\n        return this.uniforms.lineWidth.value;\n    }\n    set lineWidth(value) {\n        this.uniforms.lineWidth.value = value;\n    }\n    /**\n     * Outline width.\n     */\n    get outlineWidth() {\n        return this.uniforms.outlineWidth.value;\n    }\n    set outlineWidth(value) {\n        this.uniforms.outlineWidth.value = value;\n        this.outline = value > 0.0;\n    }\n    /**\n     * Size of the dashed segments.\n     *\n     * @note Ths [[gapSize]] need to be also set to enable dashed line.\n     * @see gapSize.\n     */\n    get dashSize() {\n        return this.uniforms.dashSize.value;\n    }\n    set dashSize(value) {\n        this.uniforms.dashSize.value = value;\n    }\n    /**\n     * Size of the gaps between dashed segments.\n     *\n     * @note You may also need to set [[dashSize]].\n     * @see dashSize.\n     */\n    get gapSize() {\n        return this.uniforms.gapSize.value;\n    }\n    set gapSize(value) {\n        this.uniforms.gapSize.value = value;\n        Utils_1.setShaderMaterialDefine(this, \"USE_DASHED_LINE\", value > 0.0);\n    }\n    /**\n     * Caps mode.\n     */\n    get caps() {\n        let result = \"Round\";\n        const capsMode = Utils_1.getShaderMaterialDefine(this, \"CAPS_MODE\");\n        // Sanity check if material define is numerical and has direct mapping to LineCaps type.\n        if (typeof capsMode === \"number\" && DefinesLineCapsMapping.hasOwnProperty(capsMode)) {\n            result = DefinesLineCapsMapping[capsMode];\n        }\n        return result;\n    }\n    set caps(value) {\n        // Line caps mode may be set directly from theme, thus we need to check value\n        // correctness and if we provide string to define mapping.\n        if (LineCapsDefinesMapping.hasOwnProperty(value)) {\n            Utils_1.setShaderMaterialDefine(this, \"CAPS_MODE\", LineCapsDefinesMapping[value]);\n        }\n    }\n    get fadeNear() {\n        return this.uniforms.fadeNear.value;\n    }\n    set fadeNear(value) {\n        this.uniforms.fadeNear.value = value;\n    }\n    get fadeFar() {\n        return this.uniforms.fadeFar.value;\n    }\n    set fadeFar(value) {\n        this.uniforms.fadeFar.value = value;\n        Utils_1.setShaderMaterialDefine(this, \"USE_FADING\", value > 0.0);\n    }\n    get displacementMap() {\n        return this.uniforms.displacementMap.value;\n    }\n    set displacementMap(map) {\n        if (this.uniforms.displacementMap.value === map) {\n            return;\n        }\n        this.uniforms.displacementMap.value = map;\n        const useDisplacementMap = map !== undefined;\n        if (useDisplacementMap) {\n            this.uniforms.displacementMap.value.needsUpdate = true;\n        }\n        Utils_1.setShaderMaterialDefine(this, \"USE_DISPLACEMENTMAP\", useDisplacementMap);\n    }\n    get drawRangeStart() {\n        return this.uniforms.drawRange.value.x;\n    }\n    set drawRangeStart(value) {\n        this.uniforms.drawRange.value.x = value;\n    }\n    get drawRangeEnd() {\n        return this.uniforms.drawRange.value.y;\n    }\n    set drawRangeEnd(value) {\n        this.uniforms.drawRange.value.y = value;\n    }\n    set clipTileSize(tileSize) {\n        this.uniforms.tileSize.value.copy(tileSize);\n        const useTileClip = tileSize.x > 0 && tileSize.y > 0;\n        Utils_1.setShaderMaterialDefine(this, \"USE_TILE_CLIP\", useTileClip);\n    }\n    get clipTileSize() {\n        return this.uniforms.tileSize.value;\n    }\n    invalidateFog() {\n        if (this.m_fog !== Utils_1.getShaderMaterialDefine(this, \"USE_FOG\")) {\n            Utils_1.setShaderMaterialDefine(this, \"USE_FOG\", this.m_fog);\n        }\n    }\n    invalidateOpacity() {\n        if (this.m_opacity !== this.uniforms.opacity.value) {\n            this.uniforms.opacity.value = this.m_opacity;\n        }\n    }\n}\nexports.SolidLineMaterial = SolidLineMaterial;\nSolidLineMaterial.DEFAULT_COLOR = 0xff0000;\nSolidLineMaterial.DEFAULT_WIDTH = 1.0;\nSolidLineMaterial.DEFAULT_OUTLINE_WIDTH = 0.0;\nSolidLineMaterial.DEFAULT_OPACITY = 1.0;\nSolidLineMaterial.DEFAULT_DRAW_RANGE_START = 0.0;\nSolidLineMaterial.DEFAULT_DRAW_RANGE_END = 1.0;\nSolidLineMaterial.DEFAULT_DASH_SIZE = 1.0;\nSolidLineMaterial.DEFAULT_GAP_SIZE = 1.0;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/SolidLineMaterial.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/Utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/Utils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Values for boolean shader defines\n */\nexports.DEFINE_BOOL_TRUE = \"\";\nexports.DEFINE_BOOL_FALSE = undefined;\n/**\n * Insert shader includes after another shader include.\n *\n * @param shaderContent Original string.\n * @param shaderName String to append to.\n * @param insertedShaderName String to append after string `shaderA`.\n * @param addTab If `true`, a tab character will be inserted before `shaderB`.\n */\nfunction insertShaderInclude(shaderContent, shaderName, insertedShaderName, addTab) {\n    const tabChar = addTab === true ? \"\\t\" : \"\";\n    const result = shaderContent.replace(`#include <${shaderName}>`, `#include <${shaderName}>\n${tabChar}#include <${insertedShaderName}>`);\n    return result;\n}\nexports.insertShaderInclude = insertShaderInclude;\n/**\n * THREE.js is enabling blending only when transparent is `true` or when a blend mode\n * different than `NormalBlending` is set.\n * Since we don't want to set transparent to true and mess up the render order we set\n * `CustomBlending` with the same parameters as the `NormalBlending`.\n\n * @param material `Material` that should use blending\n * @note This function should not be used in frame update after material has been passed to WebGL.\n * In such cases use [[enableBlending]] instead.\n */\nfunction enforceBlending(material) {\n    if (material.transparent) {\n        // Nothing to do\n        return;\n    }\n    enableBlending(material);\n    material.forcedBlending = true;\n}\nexports.enforceBlending = enforceBlending;\n/**\n * Enable alpha blending using THREE.CustomBlending setup.\n *\n * Function enables blending using one of predefined modes, for both color and alpha components:\n * - Src: [[THREE.SrcAlphaFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]\n * - Src: [[THREE.OneFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]\n * The second blending equation is used when [[THREE.Material.premultipliedAlpha]] is enabled\n * for this material.\n * @note Blending mode change does not require material update.\n * @see THREE.Material.needsUpdate.\n * @param material The material or material parameters to modify.\n */\nfunction enableBlending(material) {\n    if (material.transparent || material.forcedBlending) {\n        // Nothing to do\n        return;\n    }\n    material.blending = THREE.CustomBlending;\n    if (material.premultipliedAlpha === true) {\n        material.blendSrc = THREE.OneFactor;\n        material.blendDst = THREE.OneMinusSrcAlphaFactor;\n        material.blendSrcAlpha = THREE.OneFactor;\n        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n    }\n    else {\n        material.blendSrc = THREE.SrcAlphaFactor;\n        material.blendDst = THREE.OneMinusSrcAlphaFactor;\n        material.blendSrcAlpha = THREE.OneFactor;\n        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n    }\n}\nexports.enableBlending = enableBlending;\n/**\n * Disable alpha blending using THREE.CustomBlending mode, switches to [[THREE.NormalBlending]].\n *\n * @note Blending mode change does not require material update.\n * @see THREE.Material.needsUpdate.\n * @see enableBlending.\n * @param material The material or material parameters to modify.\n */\nfunction disableBlending(material) {\n    if (material.transparent || material.forcedBlending) {\n        // Nothing to do\n        return;\n    }\n    material.blending = THREE.NormalBlending;\n}\nexports.disableBlending = disableBlending;\n/**\n * Setup material shader _define_ using two allowable semantics.\n *\n * Function accepts two types of values for shader preprocessor _define_:\n * - [[boolean]], simple [[true]] or [[false]] which causes _define_ to be set with empty string,\n * such defines may be handled in the shader using __#ifdef__ semantics:\n * ```\n * #ifdef SOME_DEFINE && !defined(OTHER_DEFINE)\n * // do something\n * #endif\n * ```\n *\n * - [[number]] which sets _define_ to explicit value. You may use it to enable/disable some\n * code or even set compile time constants affecting shaders math:\n * ```\n * #if SOME_DEFINE_SWITCH && OTHER_DEFINE_SWITCH == 0\n * gl_FragColor = vec4(1, 1, 1, DEFINE_ALPHA)\n * #endif\n * ```\n * @note Setting _define_ with `false` value is not the same as setting is with number value of `0`.\n *\n * @param material The [[THREE.ShaderMaterial]] which shader _define_ will be set.\n * @param key Name of shader _define_ as used in shader, i.e. `USE_FOG`, `COLOR_ALPHA`, etc.\n * @param value The value to be set as number or boolean specifying if preprocessor define\n * should be defined or not.\n */\nfunction setShaderMaterialDefine(material, key, value) {\n    harp_utils_1.assert(material.defines !== undefined, \"Do not use this function in ShaderMaterial derived c-tor.\");\n    const semanticValue = getShaderMaterialDefine(material, key);\n    const needsUpdate = value !== semanticValue;\n    // Nothing to change - early exit\n    if (!needsUpdate) {\n        return;\n    }\n    setShaderDefine(material.defines, key, value);\n    material.needsUpdate = needsUpdate;\n}\nexports.setShaderMaterialDefine = setShaderMaterialDefine;\n/**\n * Acquire value of [[THREE.ShaderMaterial]] GPU shader preprocessor define.\n *\n * The semantic used in entire engine assumes that preprocessor defines may have only binary\n * (defined / not defined) or numerical values, this ensures consistency in the shaders and\n * materials code.\n * @note If _define_ with [[key]] is _undefined_ function returns [[false]], if defined but\n * not numerical value it returns [[true]], otherwise returns number.\n * @see setShaderMaterialDefine.\n *\n * @param material The material which shader defines are accessed.\n * @param key The _define_ name (identifier).\n * @param fallbackValue The value returned when material `defines` are not initialized yet,\n * specified by default as [[false]], provide your own default if you expect numeric value.\n */\nfunction getShaderMaterialDefine(material, key, fallbackValue = false) {\n    if (material.defines === undefined) {\n        return fallbackValue;\n    }\n    return getShaderDefine(material.defines, key);\n}\nexports.getShaderMaterialDefine = getShaderMaterialDefine;\n/**\n * Sets new value of 'define' regardless of current value set.\n *\n * Update `defines` map with new key and value, if key is already occupied it overrides its value.\n * Helper function that may be used to setup [[THREE.ShaderMaterialParameters]] before\n * material is create (i.e. in c-tor).\n *\n * @param defines Shader `defines` stored in key-value map.\n * @param key The key used to identify _define_.\n * @param value The value to be stored.\n * @see setShaderMaterialDefine.\n */\nfunction setShaderDefine(defines, key, value) {\n    if (typeof value === \"number\") {\n        defines[key] = value;\n    }\n    else if (value === true) {\n        defines[key] = exports.DEFINE_BOOL_TRUE;\n    }\n    else {\n        // Sets to BOOL_FALSE === undefined\n        delete defines[key];\n    }\n}\nexports.setShaderDefine = setShaderDefine;\n/**\n * Acquire shader 'define' value from `defines` map.\n *\n * If there is no value under [[key]] specified, function returns false, otherwise result is\n * true or numeric value if there is a number stored.\n * @param defines The `defines` map.\n * @param key The identifier of the _define_.\n */\nfunction getShaderDefine(defines, key) {\n    const currentValue = defines[key];\n    const semanticValue = currentValue === exports.DEFINE_BOOL_FALSE\n        ? false\n        : currentValue === exports.DEFINE_BOOL_TRUE\n            ? true\n            : currentValue;\n    return semanticValue;\n}\nexports.getShaderDefine = getShaderDefine;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/Utils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-materials/lib/VignetteShader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@here/harp-materials/lib/VignetteShader.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * `VignetteShader`.\n */\nexports.VignetteShader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        offset: { value: 1.0 },\n        darkness: { value: 1.0 }\n    },\n    vertexShader: `\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }`,\n    fragmentShader: `\n        uniform float offset;\n        uniform float darkness;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 texel = texture2D( tDiffuse, vUv );\n            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\n            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n        }`\n};\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-materials/lib/VignetteShader.js?");

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/OmvDataFilter */ \"./node_modules/@here/harp-omv-datasource/lib/OmvDataFilter.js\"));\n__export(__webpack_require__(/*! ./lib/OmvDataSource */ \"./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js\"));\n__export(__webpack_require__(/*! ./lib/OmvDecoderDefs */ \"./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js\"));\n__export(__webpack_require__(/*! ./lib/OmvTile */ \"./node_modules/@here/harp-omv-datasource/lib/OmvTile.js\"));\n__export(__webpack_require__(/*! ./lib/OmvDebugLabelsTile */ \"./node_modules/@here/harp-omv-datasource/lib/OmvDebugLabelsTile.js\"));\n__export(__webpack_require__(/*! ./lib/OmvRestClient */ \"./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-omv-datasource/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDataFilter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDataFilter.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ \"./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js\");\n/**\n * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well\n * as an [[OmvFeatureModifier]].\n *\n */\nclass OmvFeatureFilterDescriptionBuilder {\n    /**\n     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as\n     * well as an [[OmvFeatureModifier]].\n     *\n     * @param processLayersDefault If `true`, all unspecified layers will be processed. If `false`,\n     * all unspecified layers will be ignored.\n     * @param processPointsDefault If `true`, all unspecified point features will be processed. If\n     * `false`, all unspecified point features will be ignored.\n     * @param processLinesDefault If `true`, all unspecified line features will be processed. If\n     * `false`, all unspecified line features will be ignored.\n     * @param processPolygonsDefault If `true`, all unspecified polygon features will be processed.\n     * If `false`, all unspecified polygon features will be ignored.\n     */\n    constructor(options) {\n        this.m_processLayersDefault = true;\n        this.m_processPointsDefault = true;\n        this.m_processLinesDefault = true;\n        this.m_processPolygonsDefault = true;\n        this.m_layersToProcess = new Array();\n        this.m_layersToIgnore = new Array();\n        this.m_pointsToProcess = new Array();\n        this.m_ignoredPoints = new Array();\n        this.m_linesToProcess = new Array();\n        this.m_linesToIgnore = new Array();\n        this.m_polygonsToProcess = new Array();\n        this.m_polygonsToIgnore = new Array();\n        this.m_kindsToProcess = [];\n        this.m_kindsToIgnore = [];\n        if (options) {\n            this.m_processLayersDefault =\n                options.processLayersDefault !== undefined ? options.processLayersDefault : true;\n            this.m_processPointsDefault =\n                options.processPointsDefault !== undefined ? options.processPointsDefault : true;\n            this.m_processLinesDefault =\n                options.processLinesDefault !== undefined ? options.processLinesDefault : true;\n            this.m_processPolygonsDefault =\n                options.processPolygonsDefault !== undefined\n                    ? options.processPolygonsDefault\n                    : true;\n        }\n    }\n    /**\n     * Add a layer that should be processed.\n     *\n     * @param layer Layer name to be matched.\n     * @param match Match condition.\n     */\n    processLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {\n        this.m_layersToProcess.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n    /**\n     * Add a layer that should be ignored.\n     *\n     * @param layer Layer name to be matched.\n     * @param match Match condition.\n     */\n    ignoreLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {\n        this.m_layersToIgnore.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n    /**\n     * Add a valid point feature.\n     *\n     * @param options Feature options.\n     */\n    processPoint(options) {\n        this.addItem(this.m_pointsToProcess, options);\n    }\n    /**\n     * Add valid point features.\n     *\n     * @param options Multi feature options.\n     */\n    processPoints(options) {\n        this.addItems(this.m_pointsToProcess, options);\n    }\n    /**\n     * Add a point feature that should be ignored.\n     *\n     * @param options Feature options.\n     */\n    ignorePoint(options) {\n        this.addItem(this.m_ignoredPoints, options);\n    }\n    /**\n     * Add point features that should be ignored.\n     *\n     * @param options Multi feature options.\n     */\n    ignorePoints(options) {\n        this.addItems(this.m_ignoredPoints, options);\n    }\n    /**\n     * Add a valid line feature.\n     *\n     * @param options Feature options.\n     */\n    processLine(options) {\n        this.addItem(this.m_linesToProcess, options);\n    }\n    /**\n     * Add valid line features.\n     *\n     * @param options Multi feature options.\n     */\n    processLines(options) {\n        this.addItems(this.m_linesToProcess, options);\n    }\n    /**\n     * Ignore a line feature.\n     *\n     * @param options Feature options.\n     */\n    ignoreLine(options) {\n        this.addItem(this.m_linesToIgnore, options);\n    }\n    /**\n     * Ignore line features.\n     *\n     * @param options Multi feature options.\n     */\n    ignoreLines(options) {\n        this.addItems(this.m_linesToIgnore, options);\n    }\n    /**\n     * Add a valid polygon feature.\n     *\n     * @param options Feature options.\n     */\n    processPolygon(options) {\n        this.addItem(this.m_polygonsToProcess, options);\n    }\n    /**\n     * Add valid polygon features.\n     *\n     * @param options Multi feature options.\n     */\n    processPolygons(options) {\n        this.addItems(this.m_polygonsToProcess, options);\n    }\n    /**\n     * Ignore a valid polygon feature.\n     *\n     * @param options Feature options.\n     */\n    ignorePolygon(options) {\n        this.addItem(this.m_polygonsToIgnore, options);\n    }\n    /**\n     * Ignore polygon features.\n     *\n     * @param options Multi feature options.\n     */\n    ignorePolygons(options) {\n        this.addItems(this.m_polygonsToIgnore, options);\n    }\n    /**\n     * Add all the specified strings as \"enabledKinds\".\n     *\n     * @param {string[]} enabledKinds List of kinds that should be generated.\n     */\n    processKinds(enabledKinds) {\n        this.m_kindsToProcess = this.m_kindsToProcess.concat(enabledKinds);\n    }\n    /**\n     * Add all the specified strings as \"disabledKinds\".\n     *\n     * @param {string[]} disabledKinds List of kinds that should _not_ be generated.\n     */\n    ignoreKinds(disabledKinds) {\n        this.m_kindsToIgnore = this.m_kindsToIgnore.concat(disabledKinds);\n    }\n    /**\n     * Create a filter description that can be passed as an option to the [[OmvDataSource]].\n     */\n    createDescription() {\n        return {\n            processLayersDefault: this.m_processLayersDefault,\n            processPointsDefault: this.m_processPointsDefault,\n            processLinesDefault: this.m_processLinesDefault,\n            processPolygonsDefault: this.m_processPolygonsDefault,\n            layersToProcess: this.m_layersToProcess,\n            layersToIgnore: this.m_layersToIgnore,\n            pointsToProcess: this.m_pointsToProcess,\n            pointsToIgnore: this.m_ignoredPoints,\n            linesToProcess: this.m_linesToProcess,\n            linesToIgnore: this.m_linesToIgnore,\n            polygonsToProcess: this.m_polygonsToProcess,\n            polygonsToIgnore: this.m_polygonsToIgnore,\n            kindsToProcess: this.m_kindsToProcess,\n            kindsToIgnore: this.m_kindsToIgnore\n        };\n    }\n    addItem(items, options) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n        const item = {\n            layerName: {\n                value: options.layer,\n                match: options.matchLayer === undefined\n                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match\n                    : options.matchLayer\n            },\n            geometryTypes: options.geomType !== undefined\n                ? Array.isArray(options.geomType)\n                    ? options.geomType\n                    : [options.geomType]\n                : undefined,\n            classes: [\n                {\n                    value: options.featureClass,\n                    match: options.matchClass === undefined\n                        ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match\n                        : options.matchClass\n                }\n            ],\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n        items.push(item);\n    }\n    addItems(items, options) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n        const item = {\n            layerName: {\n                value: options.layer,\n                match: options.matchLayer === undefined\n                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match\n                    : options.matchLayer\n            },\n            geometryTypes: options.geomTypes !== undefined\n                ? Array.isArray(options.geomTypes)\n                    ? options.geomTypes\n                    : [options.geomTypes]\n                : undefined,\n            classes: options.featureClasses,\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n        items.push(item);\n    }\n}\nexports.OmvFeatureFilterDescriptionBuilder = OmvFeatureFilterDescriptionBuilder;\n/**\n * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`\n * features before they are completely decoded.\n *\n * @hidden\n */\nclass OmvGenericFeatureFilter {\n    constructor(description) {\n        this.description = description;\n        if (this.description.kindsToProcess.length > 0) {\n            this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToProcess);\n        }\n        if (this.description.kindsToIgnore.length > 0) {\n            this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToIgnore);\n        }\n    }\n    static matchLayer(layer, layerItems, level) {\n        for (const layerItem of layerItems) {\n            if (level < layerItem.minLevel || level > layerItem.maxLevel) {\n                continue;\n            }\n            if (OmvDecoderDefs_1.OmvFilterString.matchString(layer, layerItem.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    wantsLayer(layer, level) {\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {\n            return true;\n        }\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {\n            return false;\n        }\n        return this.description.processLayersDefault;\n    }\n    wantsPointFeature(layer, geometryType, level) {\n        return this.wantsFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, geometryType, level, this.description.processPointsDefault);\n    }\n    wantsLineFeature(layer, geometryType, level) {\n        return this.wantsFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, geometryType, level, this.description.processLinesDefault);\n    }\n    wantsPolygonFeature(layer, geometryType, level) {\n        return this.wantsFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, geometryType, level, this.description.processPolygonsDefault);\n    }\n    wantsKind(kind) {\n        // undefined -> no way to filter\n        if (kind === undefined) {\n            return true;\n        }\n        return (!(this.disabledKinds !== undefined &&\n            this.disabledKinds.hasOrIntersects(kind)) ||\n            (this.enabledKinds !== undefined &&\n                this.enabledKinds.hasOrIntersects(kind)));\n    }\n    get hasKindFilter() {\n        return this.enabledKinds !== undefined || this.disabledKinds !== undefined;\n    }\n    wantsFeature(itemsToProcess, itemsToIgnore, layer, geometryType, level, defaultResult) {\n        for (const item of itemsToProcess) {\n            if (level < item.minLevel || level > item.maxLevel) {\n                continue;\n            }\n            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {\n                return true;\n            }\n        }\n        for (const item of itemsToIgnore) {\n            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {\n                return false;\n            }\n        }\n        return defaultResult;\n    }\n}\nexports.OmvGenericFeatureFilter = OmvGenericFeatureFilter;\n/**\n * An [[OmvFeatureFilter]] implementation that delegates all filter decision\n * returning `true` for any predicate if all delegates return `true`.\n */\nclass ComposedDataFilter {\n    constructor(filters) {\n        this.filters = filters;\n    }\n    get hasKindFilter() {\n        return this.filters.reduce((result, filter) => result && filter.hasKindFilter, true);\n    }\n    wantsLayer(layer, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsLayer(layer, level), true);\n    }\n    wantsPointFeature(layer, geometryType, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsPointFeature(layer, geometryType, level), true);\n    }\n    wantsLineFeature(layer, geometryType, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsLineFeature(layer, geometryType, level), true);\n    }\n    wantsPolygonFeature(layer, geometryType, level) {\n        return this.filters.reduce((result, filter) => result && filter.wantsPolygonFeature(layer, geometryType, level), true);\n    }\n    wantsKind(kind) {\n        return this.filters.reduce((result, filter) => result && filter.wantsKind(kind), true);\n    }\n}\nexports.ComposedDataFilter = ComposedDataFilter;\n/**\n * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter\n * `TileData` features before they are completely decoded.\n *\n * @hidden\n */\nclass OmvGenericFeatureModifier {\n    constructor(description) {\n        this.description = description;\n    }\n    static matchItems(layerName, featureClass, items) {\n        for (const item of items) {\n            if (item.classes !== undefined) {\n                if (!OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName)) {\n                    continue;\n                }\n                for (const matchClass of item.classes) {\n                    if (OmvDecoderDefs_1.OmvFilterString.matchString(featureClass, matchClass)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    static matchAttribute(layerName, env, items) {\n        for (const item of items) {\n            if (item.featureAttribute !== undefined) {\n                if (OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName) &&\n                    env.lookup(item.featureAttribute.key) === item.featureAttribute.value) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    doProcessPointFeature(layer, env) {\n        return this.doProcessFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, env, this.description.processPointsDefault);\n    }\n    doProcessLineFeature(layer, env) {\n        return this.doProcessFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, env, this.description.processLinesDefault);\n    }\n    doProcessPolygonFeature(layer, env) {\n        return this.doProcessFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, env, this.description.processPolygonsDefault);\n    }\n    doProcessFeature(itemsToProcess, itemsToIgnore, layer, env, defaultResult) {\n        if (layer === undefined || (itemsToProcess.length === 0 && itemsToIgnore.length === 0)) {\n            return defaultResult;\n        }\n        let featureClass;\n        const featureClassThing = env.lookup(\"class\");\n        if (featureClassThing !== undefined && featureClassThing !== null) {\n            featureClass = featureClassThing.toString();\n        }\n        if (featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)) {\n            return true;\n        }\n        if (featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)) {\n            return false;\n        }\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToProcess)) {\n            return true;\n        }\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToIgnore)) {\n            return false;\n        }\n        return defaultResult;\n    }\n}\nexports.OmvGenericFeatureModifier = OmvGenericFeatureModifier;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-omv-datasource/lib/OmvDataFilter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ \"./node_modules/@here/harp-mapview-decoder/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ \"./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js\");\nconst OmvRestClient_1 = __webpack_require__(/*! ./OmvRestClient */ \"./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js\");\nconst OmvTile_1 = __webpack_require__(/*! ./OmvTile */ \"./node_modules/@here/harp-omv-datasource/lib/OmvTile.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"OmvDataSource\");\n/**\n * A helper function to retrieve the [[DataProvider]] from the [[OmvDataSource]]s parameters.\n *\n * @param params The parameters passed into the OmvDataSource.\n */\nfunction getDataProvider(params) {\n    if (params.dataProvider) {\n        return params.dataProvider;\n    }\n    else if (params.baseUrl ||\n        params.url) {\n        return new OmvRestClient_1.OmvRestClient(params);\n    }\n    else {\n        throw new Error(\"OmvDataSource: missing url, baseUrl or dataProvider params\");\n    }\n}\nlet missingOmvDecoderServiceInfoEmitted = false;\nclass OmvDataSource extends harp_mapview_decoder_1.TileDataSource {\n    constructor(m_params) {\n        super(m_params.tileFactory || new harp_mapview_decoder_1.TileFactory(OmvTile_1.OmvTile), {\n            styleSetName: m_params.styleSetName || \"omv\",\n            name: m_params.name,\n            tilingScheme: harp_geoutils_1.webMercatorTilingScheme,\n            dataProvider: getDataProvider(m_params),\n            concurrentDecoderServiceName: OmvDecoderDefs_1.OMV_TILE_DECODER_SERVICE_TYPE,\n            decoder: m_params.decoder,\n            concurrentDecoderScriptUrl: m_params.concurrentDecoderScriptUrl,\n            copyrightInfo: m_params.copyrightInfo,\n            copyrightProvider: m_params.copyrightProvider,\n            minZoomLevel: harp_utils_1.getOptionValue(m_params.minZoomLevel, 1),\n            maxZoomLevel: harp_utils_1.getOptionValue(m_params.maxZoomLevel, 14),\n            storageLevelOffset: harp_utils_1.getOptionValue(m_params.storageLevelOffset, -1)\n        });\n        this.m_params = m_params;\n        this.cacheable = true;\n        this.addGroundPlane =\n            m_params.addGroundPlane === undefined || m_params.addGroundPlane === true;\n        this.m_decoderOptions = {\n            showMissingTechniques: this.m_params.showMissingTechniques === true,\n            filterDescription: this.m_params.filterDescr,\n            gatherFeatureAttributes: this.m_params.gatherFeatureAttributes === true,\n            createTileInfo: this.m_params.createTileInfo === true,\n            gatherRoadSegments: this.m_params.gatherRoadSegments === true,\n            featureModifierId: this.m_params.featureModifierId,\n            skipShortLabels: this.m_params.skipShortLabels,\n            storageLevelOffset: harp_utils_1.getOptionValue(m_params.storageLevelOffset, -1),\n            enableElevationOverlay: this.m_params.enableElevationOverlay === true\n        };\n        this.maxGeometryHeight = harp_utils_1.getOptionValue(m_params.maxGeometryHeight, harp_geoutils_1.EarthConstants.MAX_BUILDING_HEIGHT);\n    }\n    /** @override */\n    async connect() {\n        try {\n            await super.connect();\n        }\n        catch (error) {\n            if (harp_datasource_protocol_1.WorkerServiceProtocol.isUnknownServiceError(error) &&\n                !missingOmvDecoderServiceInfoEmitted) {\n                logger.info(\"Unable to create decoder service in worker. Use \" +\n                    \" 'OmvTileDecoderService.start();' in decoder script.\");\n                missingOmvDecoderServiceInfoEmitted = true;\n            }\n            throw error;\n        }\n        this.configureDecoder(undefined, undefined, undefined, this.m_decoderOptions);\n    }\n    /**\n     * Remove the current data filter.\n     * Will be applied to the decoder, which might be shared with other omv datasources.\n     */\n    removeDataFilter() {\n        this.configureDecoder(undefined, undefined, undefined, {\n            filterDescription: null\n        });\n    }\n    /**\n     * Set a new data filter. Can also be done during the creation of an [[OmvDataSource]].\n     * Will be applied to the decoder, which might be shared with other omv datasources.\n     *\n     * @param filterDescription Data filter description created with\n     * [[OmvFeatureFilterDescriptionBuilder]].\n     */\n    setDataFilter(filterDescription) {\n        this.m_decoderOptions.filterDescription =\n            filterDescription !== null ? filterDescription : undefined;\n        this.configureDecoder(undefined, undefined, undefined, {\n            filterDescription\n        });\n    }\n    /** @override */\n    shouldPreloadTiles() {\n        return true;\n    }\n    /**\n     * Check if a data source should be rendered or not depending on the zoom level.\n     *\n     * @param zoomLevel Zoom level.\n     * @param tileKey Level of the tile.\n     * @returns `true` if the data source should be rendered.\n     * @override\n     */\n    canGetTile(zoomLevel, tileKey) {\n        if (tileKey.level > this.maxZoomLevel) {\n            return false;\n        }\n        if (tileKey.level <= this.maxZoomLevel && zoomLevel >= this.maxZoomLevel) {\n            return true;\n        }\n        return super.canGetTile(zoomLevel, tileKey);\n    }\n    /** @override */\n    setLanguages(languages) {\n        if (languages !== undefined) {\n            this.configureDecoder(undefined, undefined, languages, undefined);\n        }\n    }\n    /** @override */\n    get storageLevelOffset() {\n        return super.storageLevelOffset;\n    }\n    /** @override */\n    set storageLevelOffset(levelOffset) {\n        super.storageLevelOffset = levelOffset;\n        this.m_decoderOptions.storageLevelOffset = this.storageLevelOffset;\n        this.configureDecoder(undefined, undefined, undefined, {\n            storageLevelOffset: this.storageLevelOffset\n        });\n    }\n    /** @override */\n    setEnableElevationOverlay(enable) {\n        if (this.m_decoderOptions.enableElevationOverlay !== enable) {\n            this.m_decoderOptions.enableElevationOverlay = enable;\n            this.configureDecoder(undefined, undefined, undefined, {\n                enableElevationOverlay: enable\n            });\n        }\n    }\n    configureDecoder(styleSet, definitions, languages, options) {\n        this.clearCache();\n        this.decoder.configure(styleSet, definitions, languages, options);\n        this.mapView.markTilesDirty(this);\n    }\n}\nexports.OmvDataSource = OmvDataSource;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-omv-datasource/lib/OmvDataSource.js?");

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDebugLabelsTile.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDebugLabelsTile.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ \"./node_modules/@here/harp-datasource-protocol/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst DebugContext_1 = __webpack_require__(/*! @here/harp-mapview/lib/DebugContext */ \"./node_modules/@here/harp-mapview/lib/DebugContext.js\");\nconst harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ \"./node_modules/@here/harp-text-canvas/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TileGeometryCreator_1 = __webpack_require__(/*! @here/harp-mapview/lib/geometry/TileGeometryCreator */ \"./node_modules/@here/harp-mapview/lib/geometry/TileGeometryCreator.js\");\nconst OmvTile_1 = __webpack_require__(/*! ./OmvTile */ \"./node_modules/@here/harp-omv-datasource/lib/OmvTile.js\");\nconst debugMaterial = new THREE.LineBasicMaterial({\n    color: 0x000000,\n    linewidth: 2,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\nconst debugCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\nconst debugCircleMaterialWF = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\ndebugCircleMaterialWF.wireframe = true;\nconst debugCircleMaterial2WF = new THREE.MeshBasicMaterial({\n    color: 0x8080ff,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\ndebugCircleMaterial2WF.wireframe = true;\nconst debugBlackCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0x000000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\nconst textRenderStyle = new harp_text_canvas_1.TextRenderStyle();\nconst textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle();\ntextRenderStyle.fontSize = {\n    unit: harp_text_canvas_1.FontUnit.Point,\n    size: 9,\n    backgroundSize: 0\n};\ntextRenderStyle.opacity = 0.75;\ntextRenderStyle.backgroundOpacity = 0.75;\nclass OmvDebugLabelsTile extends OmvTile_1.OmvTile {\n    constructor(dataSource, tileKey) {\n        super(dataSource, tileKey);\n    }\n    /** @override */\n    loadingFinished() {\n        this.addLabelDebugInfo();\n    }\n    /**\n     * Create [[TextElement]] objects from the given decoded [[Tile]] and list of materials.\n     */\n    addLabelDebugInfo() {\n        // activate in the browser with:\n        // window.__debugContext.setValue(\"DEBUG_TEXT_PATHS\", true)\n        const debugTextPaths = DebugContext_1.debugContext.getValue(\"DEBUG_TEXT_PATHS\");\n        const debugTextPathsFull = DebugContext_1.debugContext.getValue(\"DEBUG_TEXT_PATHS_FULL\");\n        if (!(debugTextPaths || debugTextPathsFull) || this.decodedTile === undefined) {\n            return;\n        }\n        const tileGeometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;\n        const decodedTile = this.decodedTile;\n        tileGeometryCreator.createTextElements(this, decodedTile);\n        const colorMap = new Map();\n        // allow limiting to specific names and/or index. There can be many paths with the same text\n        const textFilter = DebugContext_1.debugContext.getValue(\"DEBUG_TEXT_PATHS.FILTER.TEXT\");\n        const indexFilter = DebugContext_1.debugContext.getValue(\"DEBUG_TEXT_PATHS.FILTER.INDEX\");\n        const zoomLevel = this.mapView.zoomLevel;\n        if (decodedTile.textPathGeometries !== undefined) {\n            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(decodedTile.textPathGeometries, decodedTile);\n        }\n        if (this.preparedTextPaths !== undefined) {\n            const lineGeometry = new THREE.BufferGeometry();\n            const lineIndices = new Array();\n            const linePositions = new Array();\n            const redPointGeometry = new THREE.BufferGeometry();\n            const redPointIndices = new Array();\n            const redPointPositions = new Array();\n            const blackPointGeometry = new THREE.BufferGeometry();\n            const blackPointIndices = new Array();\n            const blackPointPositions = new Array();\n            let baseVertex = 0;\n            const pointScale = this.mapView.pixelToWorld;\n            const worldOffsetX = this.computeWorldOffsetX();\n            for (const textPath of this.preparedTextPaths) {\n                const technique = decodedTile.techniques[textPath.technique];\n                if (!harp_datasource_protocol_1.isTextTechnique(technique)) {\n                    continue;\n                }\n                if (technique.color !== undefined) {\n                    colorMap.set(textPath.technique, new THREE.Color(harp_datasource_protocol_1.getPropertyValue(technique.color, zoomLevel)));\n                }\n                baseVertex = linePositions.length / 3;\n                const text = textPath.text;\n                const elementIndex = this.preparedTextPaths.indexOf(textPath);\n                const createDebugInfo = (!textFilter || (text && text.indexOf(textFilter) >= 0)) &&\n                    (indexFilter === undefined || indexFilter === elementIndex);\n                if (createDebugInfo) {\n                    for (let i = 0; i < textPath.path.length; i += 3) {\n                        const pathIndex = i / 3;\n                        const x = textPath.path[i];\n                        const y = textPath.path[i + 1];\n                        // raise it a bit, so we get identify connectivity visually by tilting\n                        const z = textPath.path[i + 2] + i / 3;\n                        if (debugTextPaths) {\n                            linePositions.push(x, y, z);\n                        }\n                        const isRedPoint = i === 0;\n                        if (debugTextPathsFull || isRedPoint) {\n                            const pointSize = pointScale * (isRedPoint ? 6 : 4);\n                            const positions = isRedPoint ? redPointPositions : blackPointPositions;\n                            const indices = isRedPoint ? redPointIndices : blackPointIndices;\n                            positions.push(x, y - pointSize, z);\n                            positions.push(x + pointSize, y, z);\n                            positions.push(x, y + pointSize, z);\n                            positions.push(x - pointSize, y, z);\n                            const pointIndex = positions.length / 3;\n                            indices.push(pointIndex - 4);\n                            indices.push(pointIndex - 3);\n                            indices.push(pointIndex - 2);\n                            indices.push(pointIndex - 4);\n                            indices.push(pointIndex - 2);\n                            indices.push(pointIndex - 1);\n                            if (debugTextPathsFull) {\n                                // give point index a label\n                                const label = pathIndex % 5 === 0\n                                    ? text + \":\" + pathIndex\n                                    : Number(pathIndex).toString();\n                                const labelElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x + worldOffsetX, y, z), textRenderStyle, textLayoutStyle, harp_datasource_protocol_1.getPropertyValue(technique.priority || 0, zoomLevel), technique.xOffset || 0.0, technique.yOffset || 0.0);\n                                labelElement.minZoomLevel = technique.minZoomLevel;\n                                labelElement.mayOverlap = true;\n                                labelElement.reserveSpace = false;\n                                labelElement.alwaysOnTop = true;\n                                labelElement.ignoreDistance = true;\n                                this.addUserTextElement(labelElement);\n                            }\n                        }\n                    }\n                    // the lines of a path share a common geometry\n                    const N = textPath.path.length / 3;\n                    for (let i = 0; i < N; ++i) {\n                        if (i > 0) {\n                            lineIndices.push(baseVertex + i);\n                        }\n                        if (i + 1 < N) {\n                            lineIndices.push(baseVertex + i);\n                        }\n                    }\n                }\n            }\n            if (lineIndices.length > 0) {\n                lineGeometry.addGroup(0, lineIndices.length, 0);\n                lineGeometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(linePositions), 3));\n                lineGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(lineIndices), 1));\n                const lineMesh = new THREE.LineSegments(lineGeometry, debugMaterial);\n                lineMesh.renderOrder = 2000;\n                this.objects.push(lineMesh);\n            }\n            if (redPointIndices.length > 0) {\n                redPointGeometry.addGroup(0, redPointIndices.length, 0);\n                redPointGeometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(redPointPositions), 3));\n                redPointGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(redPointIndices), 1));\n                const redPointMesh = new THREE.Mesh(redPointGeometry, debugCircleMaterial);\n                redPointMesh.renderOrder = 3000;\n                this.objects.push(redPointMesh);\n            }\n            if (blackPointIndices.length > 0) {\n                blackPointGeometry.addGroup(0, blackPointIndices.length, 0);\n                blackPointGeometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(blackPointPositions), 3));\n                blackPointGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(blackPointIndices), 1));\n                const blackPointMesh = new THREE.Mesh(blackPointGeometry, debugBlackCircleMaterial);\n                blackPointMesh.renderOrder = 2500;\n                this.objects.push(blackPointMesh);\n            }\n        }\n    }\n}\nexports.OmvDebugLabelsTile = OmvDebugLabelsTile;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-omv-datasource/lib/OmvDebugLabelsTile.js?");

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.\n */\nvar FeatureModifierId;\n(function (FeatureModifierId) {\n    /**\n     * Identifier to use the OmvTomTomFeatureModifier in the OmvDecoder.\n     */\n    FeatureModifierId[FeatureModifierId[\"tomTom\"] = 0] = \"tomTom\";\n})(FeatureModifierId = exports.FeatureModifierId || (exports.FeatureModifierId = {}));\n/**\n * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.\n */\nvar OmvFilterString;\n(function (OmvFilterString) {\n    /**\n     * Match condition.\n     */\n    let StringMatch;\n    (function (StringMatch) {\n        /** Matches any. */\n        StringMatch[StringMatch[\"Any\"] = 0] = \"Any\";\n        /** Exact match. */\n        StringMatch[StringMatch[\"Match\"] = 1] = \"Match\";\n        /** Matches if a test string starts with a filter string. */\n        StringMatch[StringMatch[\"StartsWith\"] = 2] = \"StartsWith\";\n        /** Matches if a test string contains a filter string. */\n        StringMatch[StringMatch[\"Contains\"] = 3] = \"Contains\";\n        /** Matches if a test string ends with a filter string. */\n        StringMatch[StringMatch[\"EndsWith\"] = 4] = \"EndsWith\";\n    })(StringMatch = OmvFilterString.StringMatch || (OmvFilterString.StringMatch = {}));\n    /**\n     * Check for a string against a filter.\n     *\n     * @param str The string to check against a filter.\n     * @param filterString The filter containing the match condition.\n     * @returns `true` if the match condition is satisfied.\n     */\n    function matchString(str, filterString) {\n        switch (filterString.match) {\n            case OmvFilterString.StringMatch.Any:\n                return true;\n            case OmvFilterString.StringMatch.Match:\n                return str === filterString.value;\n            case OmvFilterString.StringMatch.StartsWith:\n                return filterString.value.startsWith(str);\n            case OmvFilterString.StringMatch.EndsWith:\n                return filterString.value.endsWith(str);\n            default:\n                return str.indexOf(filterString.value) >= 0;\n        }\n    }\n    OmvFilterString.matchString = matchString;\n})(OmvFilterString = exports.OmvFilterString || (exports.OmvFilterString = {}));\nvar OmvGeometryType;\n(function (OmvGeometryType) {\n    OmvGeometryType[OmvGeometryType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    OmvGeometryType[OmvGeometryType[\"POINT\"] = 1] = \"POINT\";\n    OmvGeometryType[OmvGeometryType[\"LINESTRING\"] = 2] = \"LINESTRING\";\n    OmvGeometryType[OmvGeometryType[\"POLYGON\"] = 3] = \"POLYGON\";\n})(OmvGeometryType = exports.OmvGeometryType || (exports.OmvGeometryType = {}));\n/**\n * Default OMV tile decoder service type.\n *\n * Used for requesting decoder services using [[WorkerServiceManager]].\n */\nexports.OMV_TILE_DECODER_SERVICE_TYPE = \"omv-tile-decoder\";\n/**\n * Default OMV tiler service type.\n *\n * Used for requesting tiler services using [[WorkerServiceManager]].\n */\nexports.OMV_TILER_SERVICE_TYPE = \"omv-tiler\";\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-omv-datasource/lib/OmvDecoderDefs.js?");

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\nconst harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ \"./node_modules/@here/harp-transfer-manager/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"OmvRestClient\");\n// tslint:disable:max-line-length\nvar APIFormat;\n(function (APIFormat) {\n    /**\n     * Use the REST API format of HERE Vector Tiles Server component version 1.\n     *\n     * Usage:\n     *\n     *     <OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>/omv\n     *\n     * If [[OmvRestClientParams.authenticationToken]] is provided, it will be added as HTTP header:\n     *\n     *     Authorization: Bearer $authenticationToken\n     *\n     * Format definition:\n     * `//http|s://<base-url>/{API version}/{layers}/{projection}/{z}/{x}/{y}/{format}`\n     *\n     * Default authentication method used: [[AuthenticationTypeBearer]].\n     */\n    APIFormat[APIFormat[\"HereV1\"] = 0] = \"HereV1\";\n    /**\n     * Use the REST API format of Mapbox Vector Tile API v4.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/v4/{map_id}/{z}/{x}/{y}{@2x}.{format}?[style]&access_token={access_token}`\n     *\n     * Sample URL:\n     * `http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=your-mapbox-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    APIFormat[APIFormat[\"MapboxV4\"] = 1] = \"MapboxV4\";\n    /**\n     * Use the REST API format of XYZ Vector Tile API in MVT format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.mvt?access_token=your-xyz-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    APIFormat[APIFormat[\"XYZMVT\"] = 2] = \"XYZMVT\";\n    /**\n     * Use the REST API format of XYZ Vector Tile API in JSON format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.json?access_token=your-xyz-api-key`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    APIFormat[APIFormat[\"XYZJson\"] = 3] = \"XYZJson\";\n    /**\n     * Use the REST API format of XYZ Vector Tile API in OMV format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/herebase.02/<zoom>/<X>/<Y>/omv?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/herebase.02/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/herebase.02/14/2649/6338/omv?access_token=your-xyz-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    APIFormat[APIFormat[\"XYZOMV\"] = 4] = \"XYZOMV\";\n    /**\n     * Use the REST API format of Tomtoms Vector Tile API v1.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.pbf?key=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `<http|https>://<baseURL>/map/<versionNumber>/tile/<layer>/<style>/<zoom>/<X>/<Y>.<format>?key=<apiKey>[&view=<view>][&language=<language>]`\n     *\n     * Sample URL:\n     * `http://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=<apiKey>`\n     *\n     * Default authentication method used: [[AuthenticationTypeTomTomV1]].\n     */\n    APIFormat[APIFormat[\"TomtomV1\"] = 5] = \"TomtomV1\";\n    /**\n     * Use the REST API format of XYZ Space Vector Tile API in OMV format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/hub/spaces/<space-id>/tile/web/<zoom>_<X>_<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/hub/spaces/{spaceId}/tile/web/{z}_{x}_{y}.mvt?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/hub/spaces/your-space-id/tile/web/{z}_{x}_{y}.mvt?access_token=your-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    APIFormat[APIFormat[\"XYZSpace\"] = 6] = \"XYZSpace\";\n})(APIFormat = exports.APIFormat || (exports.APIFormat = {}));\nvar AuthenticationMethod;\n(function (AuthenticationMethod) {\n    AuthenticationMethod[AuthenticationMethod[\"QueryString\"] = 0] = \"QueryString\";\n    AuthenticationMethod[AuthenticationMethod[\"AuthorizationHeader\"] = 1] = \"AuthorizationHeader\";\n})(AuthenticationMethod = exports.AuthenticationMethod || (exports.AuthenticationMethod = {}));\n/**\n * Authentication method, where token will be provided as HTTP Header:\n *\n *    Authorization: Bearer $authenticationToken\n */\nexports.AuthenticationTypeBearer = {\n    method: AuthenticationMethod.AuthorizationHeader,\n    name: \"Bearer\"\n};\n/**\n * TomTomV1 API compatible authorization method, where token will be provided as HTTP Header:\n *\n *    Authorization: Bearer $authenticationToken\n */\nexports.AuthenticationTypeTomTomV1 = {\n    method: AuthenticationMethod.QueryString,\n    name: \"key\"\n};\nexports.AuthenticationTypeAccessToken = {\n    method: AuthenticationMethod.QueryString,\n    name: \"access_token\"\n};\n/**\n * REST client supporting getting protobuf OMV Tile from REST-based servers.\n */\nclass OmvRestClient {\n    constructor(params) {\n        this.params = params;\n        this.downloadManager =\n            params.downloadManager === undefined\n                ? harp_transfer_manager_1.TransferManager.instance()\n                : params.downloadManager;\n        this.urlParams = params.urlParams === undefined ? {} : params.urlParams;\n    }\n    /** Overriding abstract method, in this case doing nothing. */\n    async connect() {\n        // not needed\n    }\n    /** Overriding abstract method, in this case always returning `true`. */\n    ready() {\n        return true;\n    }\n    /**\n     * Asynchronously fetches a tile from this restful server.\n     *\n     * **Note:** If the tile doesn't exist, a successful response with a `404` status code is\n     * returned.\n     *\n     * @example\n     * ```typescript\n     * const response = layer.getTile(tileKey);\n     * if (!response.ok) {\n     *     // a network error happened\n     *     console.error(\"Unable to download tile\", response.statusText);\n     *     return;\n     * }\n     * if (response.status === 404) {\n     *     // 404 -, no data exists at the given tile. Do nothing.\n     *     return;\n     * }\n     *\n     * // the response is ok and contains data, access it e.g. as arrayBuffer:\n     * const payload = await response.arrayBuffer();\n     * ```\n     *\n     * @param tileKey The tile key of the tile.\n     * @param tileRequestInit Optional request options to be passed to fetch when downloading a\n     * tile.\n     * @returns A `Promise` of the HTTP response that contains the payload of the requested tile.\n     */\n    async getTile(tileKey, abortSignal) {\n        const init = { signal: abortSignal };\n        let tileUrl = this.dataUrl(tileKey);\n        const authenticationCode = await this.getActualAuthenticationCode();\n        tileUrl = this.applyAuthCode(tileUrl, init, authenticationCode);\n        tileUrl = this.addQueryParams(tileUrl, this.urlParams);\n        if (this.params.apiFormat === APIFormat.XYZJson) {\n            return this.downloadManager.downloadJson(tileUrl, init);\n        }\n        return this.downloadManager.downloadArrayBuffer(tileUrl, init);\n    }\n    /**\n     * Get actual authentication code/token for this request according to configuration.\n     */\n    async getActualAuthenticationCode() {\n        if (typeof this.params.authenticationCode === \"string\") {\n            return this.params.authenticationCode;\n        }\n        else if (this.params.authenticationCode !== undefined) {\n            return this.params.authenticationCode();\n        }\n        else if (this.params.getBearerToken !== undefined) {\n            return this.params.getBearerToken();\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Get default authnentication method basing on apiFormat and other params.\n     */\n    getDefaultAuthMethod() {\n        if (this.params.getBearerToken !== undefined) {\n            return exports.AuthenticationTypeBearer;\n        }\n        switch (this.params.apiFormat) {\n            case APIFormat.HereV1:\n                return exports.AuthenticationTypeBearer;\n            case APIFormat.MapboxV4:\n            case APIFormat.XYZOMV:\n            case APIFormat.XYZMVT:\n            case APIFormat.XYZSpace:\n            case APIFormat.XYZJson:\n                return exports.AuthenticationTypeAccessToken;\n            case APIFormat.TomtomV1:\n                return exports.AuthenticationTypeTomTomV1;\n            default:\n                logger.warn(`#getDefaultAuthMethod: Not supported API format: ${this.params.apiFormat}`);\n                return undefined;\n        }\n    }\n    /**\n     * Apply athentication code/token using configured (or default) authentication method.\n     *\n     * @param url\n     * @param init request extra data\n     * @param authenticationCode authentication/token to be applied\n     * @return new url to be used\n     */\n    applyAuthCode(url, init, authenticationCode) {\n        if (authenticationCode === undefined) {\n            return url;\n        }\n        const authMethod = this.params.authenticationMethod || this.getDefaultAuthMethod();\n        if (authMethod === undefined) {\n            return url;\n        }\n        if (authMethod.method === AuthenticationMethod.AuthorizationHeader) {\n            if (init.headers === undefined) {\n                init.headers = new Headers();\n            }\n            const authType = authMethod.name || \"Bearer\";\n            init.headers.append(\"Authorization\", `${authType} ${authenticationCode}`);\n        }\n        else if (authMethod.method === AuthenticationMethod.QueryString) {\n            const attrName = authMethod.name || \"access_token\";\n            const authParams = {};\n            authParams[attrName] = authenticationCode;\n            url = this.addQueryParams(url, authParams);\n        }\n        return url;\n    }\n    /**\n     * Get actual tile URL depending on configured API format.\n     */\n    dataUrl(tileKey) {\n        if (this.params.url !== undefined) {\n            return this.params.url\n                .replace(\"{x}\", String(tileKey.column))\n                .replace(\"{y}\", String(tileKey.row))\n                .replace(\"{z}\", String(tileKey.level));\n        }\n        let path = [`/${tileKey.level}`, tileKey.column, tileKey.row].join(this.params.apiFormat === APIFormat.XYZSpace ? \"_\" : \"/\");\n        switch (this.params.apiFormat) {\n            case APIFormat.HereV1:\n            case APIFormat.XYZOMV:\n                path += \"/omv\";\n                break;\n            case APIFormat.MapboxV4:\n                path += \".mvt\";\n                break;\n            case APIFormat.XYZMVT:\n                path += \".mvt\";\n                break;\n            case APIFormat.XYZJson:\n                path += \".json\";\n                break;\n            case APIFormat.XYZSpace:\n                path += \".mvt\";\n                break;\n            case APIFormat.TomtomV1:\n                path += \".pbf\";\n                break;\n            default:\n                logger.warn(`Not supported API format: ${this.params.apiFormat}`);\n                break;\n        }\n        return this.params.baseUrl + path;\n    }\n    addQueryParams(url, queryParams) {\n        let queryString = \"\";\n        let concatinator = url.indexOf(\"?\") !== -1 ? \"&\" : \"?\";\n        Object.getOwnPropertyNames(queryParams).forEach(property => {\n            const prop = property;\n            queryString += concatinator + prop + \"=\" + queryParams[prop];\n            if (concatinator === \"?\") {\n                concatinator = \"&\";\n            }\n        });\n        return url + queryString;\n    }\n}\nexports.OmvRestClient = OmvRestClient;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-omv-datasource/lib/OmvRestClient.js?");

/***/ }),

/***/ "./node_modules/@here/harp-omv-datasource/lib/OmvTile.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-omv-datasource/lib/OmvTile.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nclass OmvTile extends harp_mapview_1.Tile {\n    constructor(dataSource, tileKey) {\n        super(dataSource, tileKey);\n    }\n}\nexports.OmvTile = OmvTile;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-omv-datasource/lib/OmvTile.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/rendering/FontCatalog */ \"./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js\"));\n__export(__webpack_require__(/*! ./lib/rendering/GlyphData */ \"./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js\"));\n__export(__webpack_require__(/*! ./lib/rendering/TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\"));\n__export(__webpack_require__(/*! ./lib/rendering/TextBufferObject */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js\"));\n__export(__webpack_require__(/*! ./lib/TextCanvas */ \"./node_modules/@here/harp-text-canvas/lib/TextCanvas.js\"));\n__export(__webpack_require__(/*! ./lib/utils/ContextualArabicConverter */ \"./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js\"));\n__export(__webpack_require__(/*! ./lib/utils/MaterialUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js\"));\n__export(__webpack_require__(/*! ./lib/utils/TypesettingUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js\"));\n__export(__webpack_require__(/*! ./lib/utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/TextCanvas.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/TextCanvas.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextBufferObject_1 = __webpack_require__(/*! ./rendering/TextBufferObject */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js\");\nconst TextGeometry_1 = __webpack_require__(/*! ./rendering/TextGeometry */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js\");\nconst TextStyle_1 = __webpack_require__(/*! ./rendering/TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\");\nconst LineTypesetter_1 = __webpack_require__(/*! ./typesetting/LineTypesetter */ \"./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js\");\nconst PathTypesetter_1 = __webpack_require__(/*! ./typesetting/PathTypesetter */ \"./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js\");\nconst MaterialUtils_1 = __webpack_require__(/*! ./utils/MaterialUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js\");\nconst tempTextPosition = new THREE.Vector3();\nconst tempTextBounds = {\n    array: [new THREE.Box2()],\n    offset: 0\n};\nlet tempVertexBuffer = new Float32Array();\n/**\n * Default's [[TextCanvas]] layer identifier.\n */\nexports.DEFAULT_TEXT_CANVAS_LAYER = 0;\n/**\n * three.js text rendering engine which can manage and render high-quality, transformable, stylable\n * and properly layout SDF and MSDF text.\n */\nclass TextCanvas {\n    /**\n     * Constructs a new `TextCanvas`.\n     *\n     * @param params `TextCanvas` construction parameters.\n     *\n     * @returns New `TextCanvas`.\n     */\n    constructor(params) {\n        this.m_renderer = params.renderer;\n        this.m_fontCatalog = params.fontCatalog;\n        this.minGlyphCount = params.minGlyphCount;\n        this.maxGlyphCount = params.maxGlyphCount;\n        if (params.material === undefined) {\n            this.m_ownsMaterial = true;\n            this.m_material = MaterialUtils_1.createSdfTextMaterial({ fontCatalog: params.fontCatalog });\n        }\n        else {\n            this.m_ownsMaterial = false;\n            this.m_material = params.material;\n        }\n        if (params.backgroundMaterial === undefined) {\n            this.m_ownsBgMaterial = true;\n            this.m_bgMaterial = MaterialUtils_1.createSdfTextMaterial({\n                fontCatalog: params.fontCatalog,\n                isBackground: true\n            });\n        }\n        else {\n            this.m_ownsBgMaterial = false;\n            this.m_bgMaterial = params.backgroundMaterial;\n        }\n        this.m_defaultLayer = {\n            id: exports.DEFAULT_TEXT_CANVAS_LAYER,\n            storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)\n        };\n        this.m_layers = [this.m_defaultLayer];\n        this.m_defaultTextRenderStyle = new TextStyle_1.TextRenderStyle();\n        this.m_currentTextRenderStyle = this.m_defaultTextRenderStyle;\n        this.m_defaultTextLayoutStyle = new TextStyle_1.TextLayoutStyle();\n        this.m_currentTextLayoutStyle = this.m_defaultTextLayoutStyle;\n        this.m_lineTypesetter = new LineTypesetter_1.LineTypesetter();\n        this.m_pathTypesetter = new PathTypesetter_1.PathTypesetter();\n    }\n    /**\n     * Currently active [[FontCatalog]].\n     */\n    get fontCatalog() {\n        return this.m_fontCatalog;\n    }\n    set fontCatalog(value) {\n        this.m_fontCatalog = value;\n        const material = this.m_material;\n        material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;\n        material.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);\n        material.defines.MSDF = this.m_fontCatalog.type === \"msdf\" ? 1.0 : 0.0;\n        const bgMaterial = this.m_bgMaterial;\n        bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;\n        bgMaterial.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);\n        bgMaterial.defines.MSDF = this.m_fontCatalog.type === \"msdf\" ? 1.0 : 0.0;\n    }\n    /**\n     * Currently active text rendering material.\n     */\n    get material() {\n        return this.m_material;\n    }\n    set material(value) {\n        if (this.m_ownsMaterial) {\n            this.m_material.dispose();\n            this.m_ownsMaterial = false;\n        }\n        this.m_material = value;\n        for (const layer of this.m_layers) {\n            layer.storage.mesh.material = this.m_material;\n        }\n    }\n    /**\n     * Currently active text background rendering material.\n     */\n    get backgroundMaterial() {\n        return this.m_bgMaterial;\n    }\n    set backgroundMaterial(value) {\n        if (this.m_ownsBgMaterial) {\n            this.m_bgMaterial.dispose();\n            this.m_ownsBgMaterial = false;\n        }\n        this.m_bgMaterial = value;\n        for (const layer of this.m_layers) {\n            layer.storage.backgroundMesh.material = this.m_bgMaterial;\n        }\n    }\n    /**\n     * Currently active text rendering style.\n     */\n    get textRenderStyle() {\n        return this.m_currentTextRenderStyle;\n    }\n    set textRenderStyle(style) {\n        this.m_currentTextRenderStyle = style;\n    }\n    /**\n     * Currently active text layout style.\n     */\n    get textLayoutStyle() {\n        return this.m_currentTextLayoutStyle;\n    }\n    set textLayoutStyle(style) {\n        this.m_currentTextLayoutStyle = style;\n    }\n    /**\n     * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).\n     */\n    clear() {\n        for (const layer of this.m_layers) {\n            layer.storage.clear();\n        }\n        this.m_currentTextRenderStyle = this.m_defaultTextRenderStyle;\n    }\n    /**\n     * Renders the content of this `TextCanvas`.\n     *\n     * @param camera Orthographic camera.\n     * @param target Optional render target.\n     * @param clear Optional render target clear operation.\n     */\n    render(camera, target, clear) {\n        this.m_fontCatalog.update(this.m_renderer);\n        let oldTarget = null;\n        if (target !== undefined) {\n            oldTarget = this.m_renderer.getRenderTarget();\n            this.m_renderer.setRenderTarget(target);\n        }\n        if (clear === true) {\n            this.m_renderer.clear(true);\n        }\n        for (const layer of this.m_layers) {\n            layer.storage.update();\n            this.m_renderer.clear(false, true);\n            this.m_renderer.render(layer.storage.scene, camera);\n        }\n        if (target !== undefined) {\n            this.m_renderer.setRenderTarget(oldTarget);\n        }\n    }\n    /**\n     * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the\n     * input `layerId`, it just returns this one instead.\n     *\n     * @param layerId Desired layer identifier.\n     *\n     * @returns Created [[TextCanvasLayer]].\n     */\n    addLayer(layerId) {\n        let result = this.getLayer(layerId);\n        if (result === undefined) {\n            result = {\n                id: layerId,\n                storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)\n            };\n            this.m_layers.push(result);\n            this.m_layers.sort((a, b) => {\n                return a.id - b.id;\n            });\n        }\n        return result;\n    }\n    /**\n     * Retrieves a specific `TextCanvas` rendering layer.\n     *\n     * @param layerId Desired layer identifier.\n     *\n     * @returns Selected [[TextCanvasLayer]].\n     */\n    getLayer(layerId) {\n        return this.m_layers.find(layer => layer.id === layerId);\n    }\n    /**\n     * Retrieves all `TextCanvas` rendering layers.\n     *\n     * @returns Array of [[TextCanvasLayer]]s.\n     */\n    getAllLayers() {\n        return this.m_layers;\n    }\n    /**\n     * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and\n     * [[TextLayoutStyle]] will influence the results of this function.\n     *\n     * @param text Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param outputBounds Output text bounding box.\n     * @param params Optional measurement parameters.\n     *\n     * @returns Result of the measurement. If `false`, some error occurred during execution and the\n     * input text couldn't be properly measured.\n     */\n    measureText(text, outputBounds, params) {\n        tempTextPosition.set(0, 0, 0);\n        let path;\n        let pathOverflow;\n        let upperCaseArray;\n        let outputCharacterBounds;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            outputCharacterBounds = params.outputCharacterBounds;\n            if (params.path !== undefined) {\n                const pathOrigin = params.path.getPoint(0);\n                if (pathOrigin === null) {\n                    return false;\n                }\n                tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0.0);\n            }\n            if (params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n        return this.placeText({\n            input: text,\n            layer: this.m_defaultLayer,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            bounds: outputBounds,\n            individualBounds: outputCharacterBounds,\n            letterCaseArray: upperCaseArray\n        });\n    }\n    /**\n     * Adds the input text to this `TextCanvas` in the specified screen position. The current\n     * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.\n     *\n     * @param text Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param position Screen position.\n     * @param params Optional addition parameters.\n     *\n     * @returns Result of the addition. If `false`, some error occurred during execution and the\n     * input text couldn't be properly added.\n     */\n    addText(text, position, params) {\n        tempTextPosition.copy(position);\n        let path;\n        let pathOverflow;\n        let upperCaseArray;\n        let targetLayer = this.m_defaultLayer;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            if (params.layer !== undefined) {\n                let tempLayer = this.getLayer(params.layer);\n                if (tempLayer === undefined) {\n                    tempLayer = this.addLayer(params.layer);\n                }\n                targetLayer = tempLayer;\n            }\n            if (params.path !== undefined) {\n                tempTextPosition.set(0, 0, tempTextPosition.z);\n            }\n            if (params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n        const prevDrawCount = targetLayer.storage.drawCount;\n        const result = this.placeText({\n            input: text,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            layer: targetLayer,\n            letterCaseArray: upperCaseArray\n        });\n        if (result && params !== undefined) {\n            if (params.updatePosition === true) {\n                position.copy(tempTextPosition);\n            }\n            if (params.pickingData !== undefined) {\n                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);\n            }\n        }\n        else if (!result) {\n            targetLayer.storage.m_drawCount = prevDrawCount;\n        }\n        return result;\n    }\n    /**\n     * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the\n     * result of performing the `addText` function for the input text in the screen origin.\n     *\n     * @param text Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param params Optional creation parameters.\n     *\n     * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be\n     * retrieved from the current [[FontCatalog]]).\n     */\n    createTextBufferObject(text, params) {\n        tempTextPosition.set(0, 0, 0);\n        let glyphArray;\n        let upperCaseArray;\n        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;\n        if (typeof text !== \"string\") {\n            glyphArray = text;\n            if (params !== undefined && params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n        else {\n            upperCaseArray = [];\n            glyphArray = this.m_fontCatalog.getGlyphs(text, this.m_currentTextRenderStyle, smallCapsEnabled ? upperCaseArray : undefined);\n            if (glyphArray === undefined) {\n                return undefined;\n            }\n        }\n        let path;\n        let pathOverflow;\n        let textBounds;\n        let characterBounds;\n        let renderStyle;\n        let layoutStyle;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            if (params.outputBounds === true) {\n                textBounds = new THREE.Box2();\n            }\n            if (params.outputCharacterBounds === true) {\n                characterBounds = [];\n            }\n            if (params.storeStyles === true) {\n                renderStyle = this.m_currentTextRenderStyle;\n                layoutStyle = this.m_currentTextLayoutStyle;\n            }\n        }\n        this.placeText({\n            input: text,\n            layer: this.m_defaultLayer,\n            computeTextBuffer: true,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            bounds: textBounds,\n            individualBounds: characterBounds,\n            letterCaseArray: upperCaseArray\n        });\n        return new TextBufferObject_1.TextBufferObject(glyphArray, new Float32Array(tempVertexBuffer), textBounds, characterBounds, renderStyle, layoutStyle);\n    }\n    /**\n     * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can\n     * be provided to override the attributes stored in the buffer.\n     *\n     * @param textBufferObject [[TextBufferObject]] to add.\n     * @param params Optional addition parameters.\n     *\n     * @returns Result of the addition. If `false`, some error occurred during execution and the\n     * input text couldn't be properly added.\n     */\n    addTextBufferObject(textBufferObject, params) {\n        let targetLayer = this.m_defaultLayer;\n        let position;\n        let scale;\n        let rotation;\n        let color;\n        let opacity;\n        let bgColor;\n        let bgOpacity;\n        if (params !== undefined) {\n            if (params.layer !== undefined) {\n                let tempLayer = this.getLayer(params.layer);\n                if (tempLayer === undefined) {\n                    tempLayer = this.addLayer(params.layer);\n                }\n                targetLayer = tempLayer;\n            }\n            position = params.position;\n            scale = params.scale;\n            rotation = params.rotation;\n            color = params.color;\n            opacity = params.opacity;\n            bgColor = params.backgroundColor;\n            bgOpacity = params.backgroundOpacity;\n        }\n        const prevDrawCount = targetLayer.storage.drawCount;\n        const result = targetLayer.storage.addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity);\n        if (result && params !== undefined) {\n            if (params.pickingData !== undefined) {\n                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);\n            }\n        }\n        else if (!result) {\n            targetLayer.storage.m_drawCount = prevDrawCount;\n        }\n        return result;\n    }\n    /**\n     * Executes the `pickCallback` for all previously stored picking data for text covering the\n     * specified screen position.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickCallback Callback to be called for every picked element.\n     */\n    pickText(position, callback) {\n        for (const layer of this.m_layers) {\n            layer.storage.pick(position, callback);\n        }\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.\n     *\n     * @param info The info object to increment with the values from this `TextCanvas`.\n     */\n    getMemoryUsage(info) {\n        this.m_fontCatalog.updateMemoryUsage(info);\n        for (const layer of this.m_layers) {\n            layer.storage.updateMemoryUsage(info);\n        }\n    }\n    // Places all glyphs for input text. Depending on parameters, it can store the resulting glyphs\n    // in the current [[TextGeometry]] (or into a separate buffer) or compute the bounding box for\n    // the input (as a whole or on a per-character basis).\n    placeText(params) {\n        if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines === 0) {\n            if (params.bounds !== undefined) {\n                params.bounds.min.set(0, 0);\n                params.bounds.max.set(0, 0);\n            }\n            if (params.individualBounds !== undefined) {\n                params.individualBounds.length = 0;\n            }\n            return true;\n        }\n        let glyphArray;\n        let smallCapsTransformations;\n        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;\n        if (typeof params.input !== \"string\") {\n            glyphArray = params.input;\n            if (params.letterCaseArray) {\n                smallCapsTransformations = params.letterCaseArray;\n            }\n        }\n        else {\n            smallCapsTransformations = [];\n            glyphArray = this.m_fontCatalog.getGlyphs(params.input, this.m_currentTextRenderStyle, smallCapsEnabled ? smallCapsTransformations : undefined);\n            if (glyphArray === undefined) {\n                return false;\n            }\n        }\n        let glyphBounds;\n        if (params.individualBounds !== undefined) {\n            tempTextBounds.array = params.individualBounds;\n            tempTextBounds.offset = 0;\n            glyphBounds = tempTextBounds;\n        }\n        if (params.bounds !== undefined) {\n            params.bounds.min.set(Infinity, Infinity);\n            params.bounds.max.set(-Infinity, -Infinity);\n        }\n        if (params.computeTextBuffer === true) {\n            tempVertexBuffer = new Float32Array(glyphArray.length * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT);\n        }\n        const isPath = params.textPath !== undefined;\n        const typesettingParams = {\n            glyphs: glyphArray,\n            fontCatalog: this.m_fontCatalog,\n            textRenderStyle: this.m_currentTextRenderStyle,\n            textLayoutStyle: this.m_currentTextLayoutStyle,\n            position: tempTextPosition,\n            geometry: params.layer.storage,\n            smallCapsArray: smallCapsEnabled ? smallCapsTransformations : undefined,\n            globalBounds: params.bounds,\n            individualBounds: glyphBounds,\n            vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : undefined\n        };\n        let result = true;\n        if (isPath) {\n            Object.assign(typesettingParams, {\n                path: params.textPath,\n                pathOverflow: params.textPathOverflow === true\n            });\n            result = this.m_pathTypesetter.arrangeGlyphs(typesettingParams);\n        }\n        else {\n            result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);\n        }\n        if (glyphBounds !== undefined) {\n            glyphBounds.array.length = glyphBounds.offset;\n        }\n        return result;\n    }\n}\nexports.TextCanvas = TextCanvas;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/TextCanvas.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GlyphData_1 = __webpack_require__(/*! ./GlyphData */ \"./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js\");\nconst GlyphTextureCache_1 = __webpack_require__(/*! ./GlyphTextureCache */ \"./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js\");\nconst TextStyle_1 = __webpack_require__(/*! ./TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\");\nconst ASSETS_PATH = \"_Assets/\";\nconst BOLD_ASSETS_PATH = \"_BoldAssets/\";\nconst ITALIC_ASSETS_PATH = \"_ItalicAssets/\";\nconst BOLD_ITALIC_ASSETS_PATH = \"_BoldItalicAssets/\";\nconst REPLACEMENT_PATH = \"_Assets/Extra/\";\n/**\n * Collection of font assets used to render glyphs when using a [[TextCanvas]].\n *\n * @summary A `FontCatalog` works as a stack of SDF bitmap fonts (using the BMFont format) designed\n * to cover the widest Unicode code point range possible. In order to manage all these assets\n * elegantly, the assets inside the `FontCatalog` are stored on a per-Unicode-Block basis, and\n * assets for a block are only loaded once a glyph belonging to that block is requested.\n *\n * Bitmap information coming from all different fonts is then stored in a unified WebGL GPU Texture\n * resource, which can be sampled to render all currently loaded glyphs.\n *\n */\nclass FontCatalog {\n    /**\n     * @hidden\n     * Creates a new FontCatalog.\n     *\n     * @param url FontCatalog's URL.\n     * @param name FontCatalog's name.\n     * @param type FontCatalog's type (sdf or msdf).\n     * @param size FontCatalog's glyph size (pixels).\n     * @param maxWidth FontCatalog's maximum glyph width (pixels).\n     * @param maxHeight FontCatalog's maximum glyph height (pixels).\n     * @param distanceRange Distance range used to generate the SDF bitmaps.\n     * @param fonts Array of supported fonts.\n     * @param unicodeBlocks Array of supported Unicode blocks.\n     * @param maxCodePointCount Maximum number of unique code points bitmaps this `FontCatalog`'s\n     * internal texture can store simultaneously.\n     * @param m_replacementGlyph [[GlyphData]] to be used whenever a Unicode code point is not\n     * supported by this `FontCatalog`.\n     *\n     * @returns New FontCatalog.\n     */\n    constructor(url, name, type, size, maxWidth, maxHeight, distanceRange, fonts, unicodeBlocks, maxCodePointCount, m_replacementGlyph) {\n        this.url = url;\n        this.name = name;\n        this.type = type;\n        this.size = size;\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this.distanceRange = distanceRange;\n        this.fonts = fonts;\n        this.unicodeBlocks = unicodeBlocks;\n        this.maxCodePointCount = maxCodePointCount;\n        this.m_replacementGlyph = m_replacementGlyph;\n        this.m_glyphTextureCache = new GlyphTextureCache_1.GlyphTextureCache(maxCodePointCount, this.maxWidth + 1, this.maxHeight + 1);\n        this.m_loadingJson = new Map();\n        this.m_loadingPages = new Map();\n        this.m_loadingGlyphs = new Map();\n        this.m_loadedJson = new Map();\n        this.m_loadedPages = new Map();\n        this.m_loadedGlyphs = new Map();\n    }\n    /**\n     * Loads a `FontCatalog`.\n     *\n     * @param url Asset url.\n     * @param maxCodePointCount Maximum number of unique code points bitmaps this `FontCatalog`'s\n     * internal texture can store simultaneously.\n     *\n     * @returns `FontCatalog` Promise.\n     */\n    static async load(path, maxCodePointCount) {\n        const url = new URL(path, window.location.href);\n        const fontCatalog = await FontCatalog.loadJSON(url.href);\n        const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);\n        const replacementJson = await FontCatalog.loadJSON(replacementDirUrl.href + \"Specials.json\");\n        const replacementTexture = await FontCatalog.loadTexture(replacementDirUrl.href + \"Specials.png\");\n        replacementTexture.wrapS = THREE.ClampToEdgeWrapping;\n        replacementTexture.wrapT = THREE.ClampToEdgeWrapping;\n        replacementTexture.minFilter = THREE.NearestFilter;\n        replacementTexture.needsUpdate = true;\n        const replacementFont = fontCatalog.fonts.find((font) => font.name === \"Extra\");\n        const replacementGlyph = new GlyphData_1.GlyphData(65533, \"Specials\", replacementJson.chars[0].width, replacementJson.chars[0].height, replacementJson.chars[0].xadvance, replacementJson.chars[0].xoffset, replacementJson.chars[0].yoffset, 0.0, 0.0, 1.0, 1.0, replacementTexture, replacementFont);\n        const fontCatalogInfo = new FontCatalog(url.href.substr(0, url.href.lastIndexOf(\"/\")), fontCatalog.name, fontCatalog.type, fontCatalog.size, fontCatalog.maxWidth, fontCatalog.maxHeight, fontCatalog.distanceRange, fontCatalog.fonts, fontCatalog.supportedBlocks, maxCodePointCount, replacementGlyph);\n        return fontCatalogInfo;\n    }\n    static async loadTexture(url) {\n        return new Promise(resolve => {\n            new THREE.TextureLoader().load(url, resolve);\n        });\n    }\n    static async loadJSON(url) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`${url} Status Text:  ${response.statusText}`);\n        }\n        const rawJSON = await response.text();\n        return JSON.parse(rawJSON);\n    }\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.fonts.length = 0;\n        this.unicodeBlocks.length = 0;\n        this.m_glyphTextureCache.dispose();\n        this.m_loadingJson.clear();\n        this.m_loadingPages.clear();\n        this.m_loadingGlyphs.clear();\n        this.m_loadedJson.clear();\n        this.m_loadedPages.clear();\n        this.m_loadedGlyphs.clear();\n    }\n    /**\n     * Removes all loaded (and loading) assets.\n     */\n    clear() {\n        this.m_glyphTextureCache.clear();\n        this.m_loadingJson.clear();\n        this.m_loadingPages.clear();\n        this.m_loadingGlyphs.clear();\n        this.m_loadedJson.clear();\n        this.m_loadedPages.clear();\n        this.m_loadedGlyphs.clear();\n    }\n    /**\n     * Updates the internal WebGLRenderTarget.\n     * The update will copy the newly introduced glyphs since the previous update.\n     *\n     * @param renderer WebGLRenderer.\n     */\n    update(renderer) {\n        this.m_glyphTextureCache.update(renderer);\n    }\n    /**\n     * Internal WebGL Texture.\n     */\n    get texture() {\n        return this.m_glyphTextureCache.texture;\n    }\n    /**\n     * Internal WebGL Texture size.\n     */\n    get textureSize() {\n        return this.m_glyphTextureCache.textureSize;\n    }\n    /**\n     * Current internal loading state.\n     */\n    get isLoading() {\n        return (this.m_loadingJson.size > 0 ||\n            this.m_loadingPages.size > 0 ||\n            this.m_loadingGlyphs.size > 0);\n    }\n    /**\n     * Loads the description file for a specific [[UnicodeBlock]]. This speeds up consequent calls\n     * to `FontCatalog`.loadCharset() that require glyphs from this block to be loaded.\n     *\n     * @param block Requested [[UnicodeBlock]].\n     * @param font [[Font]] to retrieve this Unicode block from.\n     * @param fontStyle [[FontStyle]] assets to load.\n     * @param loadPages If `true`, all pages in this Unicode block will also be loaded.\n     *\n     * @returns Loaded Unicode Block json.\n     */\n    async loadBlock(block, font, fontStyle, loadPages) {\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, \"_\")}.json`;\n        let json = this.m_loadedJson.get(jsonPath);\n        if (json === undefined) {\n            let jsonPromise = this.m_loadingJson.get(jsonPath);\n            if (jsonPromise === undefined) {\n                try {\n                    jsonPromise = FontCatalog.loadJSON(jsonPath);\n                    this.m_loadingJson.set(jsonPath, jsonPromise);\n                    json = await jsonPromise;\n                    this.m_loadingJson.delete(jsonPath);\n                    this.m_loadedJson.set(jsonPath, json);\n                }\n                catch (e) {\n                    // tslint:disable-next-line:no-console\n                    console.error(e);\n                    this.m_loadingJson.delete(jsonPath);\n                }\n            }\n            else {\n                json = await jsonPromise;\n            }\n        }\n        const pagePromises = [];\n        if (loadPages === true) {\n            for (const page of json.pages) {\n                pagePromises.push(this.loadPage(`${assetsPath}/${page}`));\n            }\n        }\n        await Promise.all(pagePromises);\n        return json;\n    }\n    /**\n     * Releases the description file for a specific [[UnicodeBlock]] (and all downloaded pages).\n     * Safe to call when no assets for this block have been loaded.\n     *\n     * @param block Requested [[UnicodeBlock]].\n     * @param font [[Font]] to remove this Unicode block from.\n     * @param fontStyle [[FontStyle]] assets to remove.\n     */\n    removeBlock(block, font, fontStyle) {\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, \"_\")}.json`;\n        const json = this.m_loadedJson.get(jsonPath);\n        if (json !== undefined) {\n            for (const page of json.pages) {\n                const pagePath = `${assetsPath}/${page}`;\n                this.m_loadingPages.delete(pagePath);\n                this.m_loadedPages.delete(pagePath);\n            }\n            this.m_loadingJson.delete(jsonPath);\n            this.m_loadedJson.delete(jsonPath);\n        }\n    }\n    /**\n     * Loads all the required glyphs needed to render the input text. Character repetition will not\n     * be considered, and only styled assets (with applied font selection, style and variants) will\n     * be loaded.\n     *\n     * @param input Input text.\n     * @param style Specific [[TextRenderStyle]] for which glyphs will be loaded.\n     *\n     * @returns Promise containing an array of all loaded [[GlyphData]] for the input text.\n     */\n    async loadCharset(input, style) {\n        const fontName = style.fontName;\n        const fontStyle = style.fontStyle;\n        const shouldTransform = style.fontVariant === TextStyle_1.FontVariant.AllCaps ||\n            style.fontVariant === TextStyle_1.FontVariant.SmallCaps;\n        const charset = (shouldTransform ? input.toUpperCase() : input).replace(/[\\s\\S](?=([\\s\\S]+))/g, (c, s) => {\n            return s.indexOf(c) + 1 ? \"\" : c;\n        });\n        const glyphPromises = [];\n        for (const char of charset) {\n            const codePoint = char.codePointAt(0);\n            const font = this.getFont(codePoint, fontName);\n            const fontHash = `${font.name}_${fontStyle}`;\n            const glyphHash = `${fontHash}_${codePoint}`;\n            let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);\n            if (fontGlyphMap === undefined) {\n                fontGlyphMap = new Map();\n                this.m_loadedGlyphs.set(fontHash, fontGlyphMap);\n            }\n            const glyph = fontGlyphMap.get(codePoint);\n            if (glyph === undefined) {\n                let glyphPromise = this.m_loadingGlyphs.get(glyphHash);\n                if (glyphPromise === undefined) {\n                    if (font.charset.indexOf(String.fromCodePoint(codePoint)) === -1) {\n                        const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);\n                        fontGlyphMap.set(codePoint, replacementGlyph);\n                        this.m_glyphTextureCache.add(glyphHash, replacementGlyph);\n                        continue;\n                    }\n                    let charUnicodeBlock;\n                    for (const block of this.unicodeBlocks) {\n                        if (codePoint >= block.min && codePoint <= block.max) {\n                            charUnicodeBlock = block;\n                            break;\n                        }\n                    }\n                    glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock, font);\n                    this.m_loadingGlyphs.set(glyphHash, glyphPromise);\n                    glyphPromise.then((loadedGlyph) => {\n                        this.m_loadingGlyphs.delete(glyphHash);\n                        fontGlyphMap.set(codePoint, loadedGlyph);\n                        this.m_glyphTextureCache.add(glyphHash, loadedGlyph);\n                    });\n                }\n                glyphPromises.push(glyphPromise);\n            }\n            else if (!this.m_glyphTextureCache.has(glyphHash)) {\n                glyphPromises.push(Promise.resolve(glyph));\n                this.m_glyphTextureCache.add(glyphHash, glyph);\n            }\n        }\n        return Promise.all(glyphPromises);\n    }\n    /**\n     * Retrieves the loaded [[GlyphData]] for a specific character.\n     * Returns `undefined` if the assets for this glyph haven't been loaded yet.\n     *\n     * @param codePoint Character's Unicode code point.\n     * @param font [[Font]] to get this glyph from.\n     * @param fontStyle Specific [[FontStyle]] to get glyphs for.\n     *\n     * @returns [[GlyphData]] for this code point.\n     */\n    getGlyph(codePoint, font, fontStyle) {\n        const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);\n        if (fontGlyphMap === undefined) {\n            return undefined;\n        }\n        return fontGlyphMap.get(codePoint);\n    }\n    /**\n     * Retrieves the loaded [[GlyphData]] for the specified text.\n     * Returns `undefined` if the assets for these glyphs haven't been loaded yet.\n     *\n     * @param input Input text.\n     * @param style Specific [[TextRenderStyle]] to get glyphs for.\n     * @param letterCaseArray Array containing the original letter case for the requested glyphs.\n     *\n     * @returns Array containing [[GlyphData]] for each character of the input text.\n     */\n    getGlyphs(input, style, letterCaseArray) {\n        const result = [];\n        const fontName = style.fontName;\n        const fontStyle = style.fontStyle;\n        const fontVariant = style.fontVariant;\n        const shouldTransform = fontVariant === TextStyle_1.FontVariant.AllCaps || fontVariant === TextStyle_1.FontVariant.SmallCaps;\n        for (const character of input) {\n            const transformedCharacter = shouldTransform ? character.toUpperCase() : character;\n            for (const char of transformedCharacter) {\n                const codePoint = char.codePointAt(0);\n                const font = this.getFont(codePoint, fontName);\n                const glyphData = this.getGlyph(codePoint, font, fontStyle);\n                if (glyphData !== undefined) {\n                    result.push(glyphData);\n                    if (letterCaseArray !== undefined) {\n                        letterCaseArray.push(char !== character);\n                    }\n                }\n                else {\n                    return undefined;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets the best matched font for a specific character.\n     *\n     * @param codePoint Character's Unicode code point.\n     * @param fontName Font name suggestion.\n     *\n     * @returns Best matched font.\n     */\n    getFont(codePoint, fontName) {\n        let selectedFontName = this.fonts[0].name;\n        for (const block of this.unicodeBlocks) {\n            if (codePoint >= block.min && codePoint <= block.max) {\n                selectedFontName =\n                    fontName !== undefined &&\n                        block.fonts.find(element => {\n                            return element === fontName;\n                        }) !== undefined\n                        ? fontName\n                        : block.fonts[0];\n                break;\n            }\n        }\n        return this.fonts.find(element => {\n            return element.name === selectedFontName;\n        });\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `FontCatalog`.\n     *\n     * @param info The info object to increment with the values from this `FontCatalog`.\n     */\n    updateMemoryUsage(info) {\n        let numBytes = 0;\n        for (const block of this.unicodeBlocks) {\n            numBytes += (block.max - block.min) * 2;\n        }\n        // Always stored in RGBA internally.\n        let textureBytes = this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;\n        for (const page in this.m_loadedPages.entries) {\n            if (this.m_loadedPages.get(page) !== undefined) {\n                const loadedPage = this.m_loadedPages.get(page);\n                if (loadedPage !== undefined) {\n                    textureBytes += loadedPage.image.width * loadedPage.image.height * 4;\n                }\n            }\n        }\n        info.heapSize += numBytes + textureBytes;\n        info.gpuSize += textureBytes;\n    }\n    createReplacementGlyph(codePoint, char, font) {\n        const replacementGlyph = this.m_replacementGlyph.clone();\n        replacementGlyph.codePoint = codePoint;\n        replacementGlyph.character = char;\n        replacementGlyph.font = font;\n        return replacementGlyph;\n    }\n    async loadAssets(codePoint, fontStyle, block, font) {\n        const json = await this.loadBlock(block, font, fontStyle);\n        if (json === undefined) {\n            return this.m_replacementGlyph;\n        }\n        const sourceGlyphData = json.chars.find(char => char.id === codePoint);\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const texturePath = `${assetsPath}/${json.pages[sourceGlyphData.page]}`;\n        const texture = await this.loadPage(texturePath);\n        const glyphData = new GlyphData_1.GlyphData(sourceGlyphData.id, block.name, sourceGlyphData.width, sourceGlyphData.height, sourceGlyphData.xadvance, sourceGlyphData.xoffset, sourceGlyphData.yoffset, sourceGlyphData.x / texture.image.width, 1.0 - (sourceGlyphData.y + sourceGlyphData.height) / texture.image.height, (sourceGlyphData.x + sourceGlyphData.width) / texture.image.width, 1.0 - sourceGlyphData.y / texture.image.height, texture, font);\n        return glyphData;\n    }\n    async loadPage(pagePath) {\n        let page = this.m_loadedPages.get(pagePath);\n        if (page === undefined) {\n            let pagePromise = this.m_loadingPages.get(pagePath);\n            if (pagePromise === undefined) {\n                pagePromise = FontCatalog.loadTexture(pagePath);\n                this.m_loadingPages.set(pagePath, pagePromise);\n                page = await pagePromise;\n                page.wrapS = THREE.ClampToEdgeWrapping;\n                page.wrapT = THREE.ClampToEdgeWrapping;\n                page.minFilter = THREE.NearestFilter;\n                page.needsUpdate = true;\n                if (this.m_loadingPages.delete(pagePath)) {\n                    this.m_loadedPages.set(pagePath, page);\n                }\n                this.m_loadingPages.delete(pagePath);\n            }\n            else {\n                page = await pagePromise;\n            }\n        }\n        return page;\n    }\n    getAssetsPath(fontStyle, font) {\n        let fontStylePath = ASSETS_PATH;\n        switch (fontStyle) {\n            case TextStyle_1.FontStyle.Bold:\n                if (font.bold !== undefined) {\n                    fontStylePath = BOLD_ASSETS_PATH;\n                }\n                break;\n            case TextStyle_1.FontStyle.Italic:\n                if (font.italic !== undefined) {\n                    fontStylePath = ITALIC_ASSETS_PATH;\n                }\n                break;\n            case TextStyle_1.FontStyle.BoldItalic:\n                if (font.boldItalic !== undefined) {\n                    fontStylePath = BOLD_ITALIC_ASSETS_PATH;\n                }\n                else if (font.italic !== undefined) {\n                    fontStylePath = ITALIC_ASSETS_PATH;\n                }\n                else if (font.bold !== undefined) {\n                    fontStylePath = BOLD_ASSETS_PATH;\n                }\n                break;\n        }\n        return `${this.url}/${this.name}${fontStylePath}${font.name}`;\n    }\n}\nexports.FontCatalog = FontCatalog;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/FontCatalog.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\");\n/**\n * Structure containing all the required information necessary to render a BMFont glyph using\n * [[TextCanvas]].\n */\nclass GlyphData {\n    /**\n     * Creates a new `GlyphData` object.\n     *\n     * @param codePoint Unicode code point.\n     * @param block Unicode block.\n     * @param width Glyph' width.\n     * @param height Glyph' height.\n     * @param advanceX Amount of pixel to move after placing this glyph.\n     * @param offsetX Horizontal offset from the glyph' origin.\n     * @param offsetY Vertical offset from the glyph' origin.\n     * @param u0 Glyph' left texture coordinate.\n     * @param v0 Glyph' bottom texture coordinate.\n     * @param u1 Glyph' right texture coordinate.\n     * @param v1 Glyph' top texture coordinate.\n     * @param texture Glyph' source texture atlas page.\n     * @param font Glyph' font.\n     *\n     * @returns New `GlyphData`.\n     */\n    constructor(codePoint, block, width, height, advanceX, offsetX, offsetY, u0, v0, u1, v1, texture, font) {\n        this.codePoint = codePoint;\n        this.block = block;\n        this.width = width;\n        this.height = height;\n        this.advanceX = advanceX;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.texture = texture;\n        this.font = font;\n        /**\n         * Array containing the positions for all corners of this glyph.\n         */\n        this.positions = [];\n        /**\n         * Array containing the source texture coordinates for all corners of this glyph.\n         * Used to sample the original texture atlas pages.\n         */\n        this.sourceTextureCoordinates = [];\n        /**\n         * Array containing the dynamic texture coordinates for all corners of this glyph.\n         * Used to sample the dynamic texture atlas page.\n         */\n        this.dynamicTextureCoordinates = [];\n        /**\n         * Source texture atlas' page copy index.\n         */\n        this.copyIndex = 0;\n        /**\n         * Flag indicating if glyph can be currently rendered.\n         */\n        this.isInCache = false;\n        this.character = String.fromCodePoint(codePoint);\n        this.direction = UnicodeUtils_1.UnicodeUtils.getDirection(codePoint, block);\n        const left = this.offsetX;\n        const right = left + this.width;\n        const top = font.metrics.lineHeight - this.offsetY;\n        const bottom = top - this.height;\n        this.positions.push(new THREE.Vector3(left, bottom, 1.0), new THREE.Vector3(right, bottom, 1.0), new THREE.Vector3(left, top, 1.0), new THREE.Vector3(right, top, 1.0));\n        this.sourceTextureCoordinates.push(new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1), new THREE.Vector2(u1, v1));\n        this.dynamicTextureCoordinates.push(new THREE.Vector2(0.0, 0.0), new THREE.Vector2(1.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 1.0));\n    }\n    /**\n     * Clone this `GlyphData`.\n     *\n     * @returns Cloned `GlyphData`.\n     */\n    clone() {\n        return new GlyphData(this.codePoint, this.block, this.width, this.height, this.advanceX, this.offsetX, this.offsetY, this.sourceTextureCoordinates[0].x, this.sourceTextureCoordinates[0].y, this.sourceTextureCoordinates[3].x, this.sourceTextureCoordinates[3].y, this.texture, this.font);\n    }\n}\nexports.GlyphData = GlyphData;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ \"./node_modules/@here/harp-lrucache/index.js\");\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst GlyphData_1 = __webpack_require__(/*! ./GlyphData */ \"./node_modules/@here/harp-text-canvas/lib/rendering/GlyphData.js\");\nconst TextMaterials_1 = __webpack_require__(/*! ./TextMaterials */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js\");\n/**\n * Maximum number of texture atlas pages we can copy from in a single go. This amount is determined\n * by the maximum number of texture units available on a pixel shader for all devices:\n * https://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS\n */\nconst MAX_NUM_COPY_PAGES = 8;\n/**\n * Maximum texture size supported. This amount is determined by the maximum texture size supported\n * for all devices:\n * https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE\n */\nconst MAX_TEXTURE_SIZE = 4096;\n/**\n * @hidden\n * Unified glyph SDF bitmap storage for all fonts in a [[FontCatalog]].\n * Implemented as an abstraction layer on top of an LRUCache and WebGLRenderTarget.\n */\nclass GlyphTextureCache {\n    /**\n     * Creates a `GlyphTextureCache` object.\n     *\n     * @param capacity Cache's maximum glyph capacity.\n     * @param entryWidth Maximum entry width.\n     * @param entryHeight Maximum entry height.\n     *\n     * @returns New `GlyphTextureCache`.\n     */\n    constructor(capacity, entryWidth, entryHeight) {\n        this.capacity = capacity;\n        this.entryWidth = entryWidth;\n        this.entryHeight = entryHeight;\n        const nRows = Math.floor(Math.sqrt(capacity));\n        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;\n        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;\n        this.m_textureSize = new THREE.Vector2(this.m_cacheWidth * entryWidth, this.m_cacheHeight * entryHeight);\n        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {\n            // tslint:disable-next-line:no-console\n            console.warn(\"GlyphTextureCache texture size (\" +\n                this.m_textureSize.x +\n                \", \" +\n                this.m_textureSize.y +\n                \") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (\" +\n                MAX_TEXTURE_SIZE +\n                \").\\n\" +\n                \"This could result in rendering errors on some devices.\\n\" +\n                \"Please consider reducing its capacity or input assets size.\");\n        }\n        this.m_entryCache = new harp_lrucache_1.LRUCache(capacity);\n        this.initCacheEntries();\n        this.m_scene = new THREE.Scene();\n        this.m_camera = new THREE.OrthographicCamera(0, this.m_textureSize.x, this.m_textureSize.y, 0);\n        this.m_camera.position.z = 1;\n        this.m_camera.updateMatrixWorld(false);\n        this.m_rt = new THREE.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {\n            wrapS: THREE.ClampToEdgeWrapping,\n            wrapT: THREE.ClampToEdgeWrapping,\n            depthBuffer: false,\n            stencilBuffer: false\n        });\n        this.m_copyTextureSet = new Set();\n        this.m_copyTransform = new THREE.Matrix3();\n        this.m_copyPositions = [];\n        this.m_copyPositions.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());\n        this.m_copyMaterial = new TextMaterials_1.GlyphCopyMaterial();\n        this.m_copyVertexBuffer = new THREE.InterleavedBuffer(new Float32Array(capacity * 20), 5);\n        this.m_copyVertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_copyPositionAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 3, 0);\n        this.m_copyUVAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 2, 3);\n        this.m_copyGeometry = new THREE.BufferGeometry();\n        this.m_copyGeometry.setAttribute(\"position\", this.m_copyPositionAttribute);\n        this.m_copyGeometry.setAttribute(\"uv\", this.m_copyUVAttribute);\n        const copyIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);\n        copyIndexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_copyGeometry.setIndex(copyIndexBuffer);\n        this.m_copyMesh = new THREE.Mesh(this.m_copyGeometry, this.m_copyMaterial);\n        this.m_copyMesh.frustumCulled = false;\n        this.m_copyGeometryDrawCount = 0;\n        this.m_clearMaterial = new TextMaterials_1.GlyphClearMaterial();\n        this.m_clearPositionAttribute = new THREE.BufferAttribute(new Float32Array(capacity * 8), 2);\n        this.m_clearPositionAttribute.setUsage(THREE.DynamicDrawUsage);\n        this.m_clearGeometry = new THREE.BufferGeometry();\n        this.m_clearGeometry.setAttribute(\"position\", this.m_clearPositionAttribute);\n        const clearIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);\n        clearIndexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_clearGeometry.setIndex(clearIndexBuffer);\n        this.m_clearMesh = new THREE.Mesh(this.m_clearGeometry, this.m_clearMaterial);\n        this.m_clearMesh.frustumCulled = false;\n        this.m_clearGeometryDrawCount = 0;\n        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);\n    }\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.m_entryCache.clear();\n        this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);\n        this.m_rt.dispose();\n        this.m_clearMaterial.dispose();\n        this.m_copyMaterial.dispose();\n        this.m_copyTextureSet.clear();\n        this.m_clearGeometry.dispose();\n        this.m_copyGeometry.dispose();\n    }\n    /**\n     * Internal WebGL Texture.\n     */\n    get texture() {\n        return this.m_rt.texture;\n    }\n    /**\n     * Internal WebGL Texture size.\n     */\n    get textureSize() {\n        return this.m_textureSize;\n    }\n    /**\n     * Add a new entry to the GlyphTextureCache. If the limit of entries is hit, the least requested\n     * entry will be replaced.\n     *\n     * @param hash Entry's hash.\n     * @param glyph Entry's glyph data.\n     */\n    add(hash, glyph) {\n        const entry = this.m_entryCache.get(hash);\n        if (entry !== undefined) {\n            return;\n        }\n        const oldestEntry = this.m_entryCache.oldest;\n        if (oldestEntry === null) {\n            throw new Error(\"GlyphTextureCache is uninitialized!\");\n        }\n        this.clearCacheEntry(oldestEntry.value);\n        this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);\n    }\n    /**\n     * Checks if an entry is in the cache.\n     *\n     * @param hash Entry's hash.\n     *\n     * @returns Test result.\n     */\n    has(hash) {\n        return this.m_entryCache.has(hash);\n    }\n    /**\n     * Retrieves an entry from the cache.\n     *\n     * @param hash Entry's hash.\n     *\n     * @returns Retrieval result.\n     */\n    get(hash) {\n        return this.m_entryCache.get(hash);\n    }\n    /**\n     * Clears the internal LRUCache.\n     */\n    clear() {\n        this.m_copyGeometryDrawCount = 0;\n        this.m_clearGeometryDrawCount = 0;\n        this.m_entryCache.clear();\n        this.m_copyTextureSet.clear();\n        this.initCacheEntries();\n    }\n    /**\n     * Updates the internal WebGLRenderTarget.\n     * The update will copy the newly introduced glyphs since the previous update.\n     *\n     * @param renderer WebGLRenderer.\n     */\n    update(renderer) {\n        let oldRenderTarget = null;\n        const willClearGeometry = this.m_clearGeometryDrawCount > 0;\n        const willCopyGeometry = this.m_copyGeometryDrawCount > 0;\n        if (willClearGeometry || willCopyGeometry) {\n            oldRenderTarget = renderer.getRenderTarget();\n            renderer.setRenderTarget(this.m_rt);\n        }\n        if (willClearGeometry) {\n            if (this.m_clearGeometry.index === null) {\n                throw new Error(\"GlyphTextureCache clear geometry index is uninitialized!\");\n            }\n            this.m_clearPositionAttribute.needsUpdate = true;\n            this.m_clearPositionAttribute.updateRange.offset = 0;\n            this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;\n            this.m_clearGeometry.index.needsUpdate = true;\n            this.m_clearGeometry.index.updateRange.offset = 0;\n            this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;\n            this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);\n            this.m_clearMesh.visible = true;\n            this.m_copyMesh.visible = false;\n            renderer.render(this.m_scene, this.m_camera);\n            this.m_clearGeometryDrawCount = 0;\n            this.m_clearMesh.visible = false;\n        }\n        if (willCopyGeometry) {\n            if (this.m_copyGeometry.index === null) {\n                throw new Error(\"GlyphTextureCache copy geometry index is uninitialized!\");\n            }\n            this.m_copyVertexBuffer.needsUpdate = true;\n            this.m_copyVertexBuffer.updateRange.offset = 0;\n            this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;\n            this.m_copyGeometry.index.needsUpdate = true;\n            this.m_copyGeometry.index.updateRange.offset = 0;\n            this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;\n            this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);\n            this.m_copyMesh.visible = true;\n            const srcPages = Array.from(this.m_copyTextureSet);\n            const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);\n            for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {\n                const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;\n                this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;\n                for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {\n                    const pageIndex = pageOffset + i;\n                    if (pageIndex < this.m_copyTextureSet.size) {\n                        this.m_copyMaterial.uniforms[\"page\" + i].value = srcPages[pageIndex];\n                    }\n                }\n                renderer.render(this.m_scene, this.m_camera);\n            }\n            this.m_copyTextureSet.clear();\n            this.m_copyGeometryDrawCount = 0;\n        }\n        if (willClearGeometry || willCopyGeometry) {\n            renderer.setRenderTarget(oldRenderTarget);\n        }\n    }\n    initCacheEntries() {\n        const dummyMetrics = {\n            size: 0,\n            distanceRange: 0,\n            base: 0,\n            lineHeight: 0,\n            lineGap: 0,\n            capHeight: 0,\n            xHeight: 0\n        };\n        const dummyFont = {\n            name: \"\",\n            metrics: dummyMetrics,\n            charset: \"\"\n        };\n        const dummyGlyphData = new GlyphData_1.GlyphData(0, \"\", 0, 0, 0, 0, 0, 0, 0, 0, 0, THREE.Texture.DEFAULT_IMAGE, dummyFont);\n        for (let i = 0; i < this.m_cacheHeight; i++) {\n            for (let j = 0; j < this.m_cacheWidth; j++) {\n                const dummyEntry = {\n                    glyphData: dummyGlyphData,\n                    location: new THREE.Vector2(j, i)\n                };\n                this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);\n            }\n        }\n    }\n    copyGlyphToCache(hash, glyph, cacheLocation) {\n        this.m_copyTextureSet.add(glyph.texture);\n        let copyTextureIndex = 0;\n        for (const value of this.m_copyTextureSet.values()) {\n            if (value === glyph.texture) {\n                break;\n            }\n            copyTextureIndex++;\n        }\n        glyph.copyIndex = copyTextureIndex;\n        this.m_copyTransform.set(1.0, 0.0, cacheLocation.x * this.entryWidth - glyph.offsetX, 0.0, 1.0, cacheLocation.y * this.entryHeight - glyph.positions[0].y, 0.0, 0.0, 0.0);\n        for (let i = 0; i < 4; ++i) {\n            this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);\n            this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);\n        }\n        if (this.m_copyGeometryDrawCount >= this.capacity) {\n            return;\n        }\n        const baseVertex = this.m_copyGeometryDrawCount * 4;\n        const baseIndex = this.m_copyGeometryDrawCount * 6;\n        for (let i = 0; i < 4; ++i) {\n            this.m_copyPositionAttribute.setXYZ(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y, glyph.copyIndex);\n            this.m_copyUVAttribute.setXY(baseVertex + i, glyph.sourceTextureCoordinates[i].x, glyph.sourceTextureCoordinates[i].y);\n        }\n        if (this.m_copyGeometry.index === null) {\n            throw new Error(\"GlyphTextureCache copy geometry index is uninitialized!\");\n        }\n        this.m_copyGeometry.index.setX(baseIndex, baseVertex);\n        this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);\n        this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);\n        this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);\n        this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);\n        this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);\n        ++this.m_copyGeometryDrawCount;\n        const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;\n        const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;\n        const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;\n        const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;\n        glyph.dynamicTextureCoordinates[0].set(u0, v0);\n        glyph.dynamicTextureCoordinates[1].set(u1, v0);\n        glyph.dynamicTextureCoordinates[2].set(u0, v1);\n        glyph.dynamicTextureCoordinates[3].set(u1, v1);\n        glyph.isInCache = true;\n        this.m_entryCache.set(hash, {\n            glyphData: glyph,\n            location: cacheLocation\n        });\n    }\n    clearCacheEntry(entry) {\n        entry.glyphData.isInCache = false;\n        this.m_copyPositions[0].set(entry.location.x * this.entryWidth, entry.location.y * this.entryHeight);\n        this.m_copyPositions[1].set((entry.location.x + 1) * this.entryWidth, entry.location.y * this.entryHeight);\n        this.m_copyPositions[2].set(entry.location.x * this.entryWidth, (entry.location.y + 1) * this.entryHeight);\n        this.m_copyPositions[3].set((entry.location.x + 1) * this.entryWidth, (entry.location.y + 1) * this.entryHeight);\n        if (this.m_clearGeometryDrawCount >= this.capacity) {\n            return;\n        }\n        const baseVertex = this.m_clearGeometryDrawCount * 4;\n        const baseIndex = this.m_clearGeometryDrawCount * 6;\n        for (let i = 0; i < 4; ++i) {\n            this.m_clearPositionAttribute.setXY(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y);\n        }\n        if (this.m_clearGeometry.index === null) {\n            throw new Error(\"GlyphTextureCache clear geometry index is uninitialized!\");\n        }\n        this.m_clearGeometry.index.setX(baseIndex, baseVertex);\n        this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);\n        this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);\n        this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);\n        this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);\n        this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);\n        ++this.m_clearGeometryDrawCount;\n    }\n}\nexports.GlyphTextureCache = GlyphTextureCache;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/GlyphTextureCache.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Object containing vertex buffer data generated by [[TextCanvas]].\n */\nclass TextBufferObject {\n    /**\n     * Constructs a new `TextBufferObject`.\n     *\n     * @param glyphs Input glyphs.\n     * @param buffer Buffer containing the data generated by [[TextCanvas]].\n     * @param bounds Optional text bounds.\n     * @param characterBounds Optional character bounds.\n     * @param textRenderStyle [[TextRenderStyle]] applied by [[TextCanvas]].\n     * @param textLayoutStyle [[TextLayoutStyle]] applied by [[TextCanvas]].\n     *\n     * @returns New `TextBufferObject`.\n     */\n    constructor(glyphs, buffer, bounds, characterBounds, textRenderStyle, textLayoutStyle) {\n        this.glyphs = glyphs;\n        this.buffer = buffer;\n        this.bounds = bounds;\n        this.characterBounds = characterBounds;\n        this.textRenderStyle = textRenderStyle;\n        this.textLayoutStyle = textLayoutStyle;\n    }\n}\nexports.TextBufferObject = TextBufferObject;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/TextBufferObject.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nconst THREE = __webpack_require__(/*! three */ \"three\");\nexports.MAX_CAPACITY = 65536;\nexports.VERTEX_BUFFER_STRIDE = 16;\nexports.INDEX_BUFFER_STRIDE = 1;\nexports.VERTICES_PER_QUAD = 4;\nexports.INDICES_PER_QUAD = 6;\nexports.QUAD_VERTEX_MEMORY_FOOTPRINT = exports.VERTICES_PER_QUAD * exports.VERTEX_BUFFER_STRIDE;\nexports.QUAD_INDEX_MEMORY_FOOTPRINT = exports.INDICES_PER_QUAD * exports.INDEX_BUFFER_STRIDE;\n/**\n * Number of bytes for float in an Float32Array.\n */\nconst NUM_BYTES_PER_FLOAT = 4;\n/**\n * Number of bytes for integer number in an UInt32Array.\n */\nconst NUM_BYTES_PER_INT32 = 4;\n/**\n * Procedural geometry that holds vertex attribute data for all glyphs in a [[TextCanvas]].\n */\nclass TextGeometry {\n    /**\n     * Creates a new `TextGeometry`.\n     *\n     * @param material Material used to render foreground glyphs.\n     * @param backgroundMaterial Material used to render background glyphs.\n     * @param initialSize Initial amount of glyphs that can be stored.\n     * @param capacity Maximum glyph capacity.\n     *\n     * @returns New `TextGeometry`.\n     */\n    constructor(scene, material, backgroundMaterial, initialSize, capacity) {\n        this.scene = scene;\n        this.capacity = Math.min(capacity, exports.MAX_CAPACITY);\n        this.m_currentCapacity = Math.min(initialSize, capacity);\n        this.m_drawCount = 0;\n        this.m_updateOffset = 0;\n        this.m_pickingCount = 0;\n        this.m_vertexBuffer = new THREE.InterleavedBuffer(new Float32Array(this.m_currentCapacity * exports.QUAD_VERTEX_MEMORY_FOOTPRINT), exports.VERTEX_BUFFER_STRIDE);\n        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);\n        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);\n        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);\n        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);\n        this.m_indexBuffer = new THREE.BufferAttribute(new Uint32Array(this.m_currentCapacity * exports.QUAD_INDEX_MEMORY_FOOTPRINT), exports.INDEX_BUFFER_STRIDE);\n        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_geometry = new THREE.BufferGeometry();\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"bgColor\", this.m_bgColorAttribute);\n        this.m_geometry.setIndex(this.m_indexBuffer);\n        this.m_pickingDataArray = new Array(this.m_currentCapacity);\n        this.m_mesh = new THREE.Mesh(this.m_geometry, material);\n        this.m_bgMesh = new THREE.Mesh(this.m_geometry, backgroundMaterial);\n        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;\n        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;\n        this.m_mesh.frustumCulled = false;\n        this.m_bgMesh.frustumCulled = false;\n        this.scene.add(this.m_bgMesh, this.m_mesh);\n    }\n    /**\n     * Count of currently drawn glyphs.\n     */\n    get drawCount() {\n        return this.m_drawCount;\n    }\n    /**\n     * Mesh used to render foreground glyphs.\n     */\n    get mesh() {\n        return this.m_mesh;\n    }\n    /**\n     * Mesh used to render background glyphs.\n     */\n    get backgroundMesh() {\n        return this.m_bgMesh;\n    }\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.scene.remove(this.m_bgMesh, this.m_mesh);\n        this.m_geometry.dispose();\n    }\n    /**\n     * Clear the geometry.\n     */\n    clear() {\n        this.m_drawCount = 0;\n        this.m_updateOffset = 0;\n        this.m_pickingCount = 0;\n    }\n    /**\n     * Update the GPU resources to reflect the latest additions to the geometry.\n     */\n    update() {\n        if (this.drawCount > this.m_updateOffset) {\n            this.m_vertexBuffer.needsUpdate = true;\n            this.m_vertexBuffer.updateRange.offset =\n                this.m_updateOffset * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;\n            this.m_vertexBuffer.updateRange.count =\n                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;\n            this.m_indexBuffer.needsUpdate = true;\n            this.m_indexBuffer.updateRange.offset =\n                this.m_updateOffset * exports.QUAD_INDEX_MEMORY_FOOTPRINT;\n            this.m_indexBuffer.updateRange.count =\n                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_INDEX_MEMORY_FOOTPRINT;\n        }\n        this.m_updateOffset = this.m_drawCount;\n        this.m_geometry.setDrawRange(0, this.m_drawCount * exports.INDICES_PER_QUAD);\n    }\n    /**\n     * Add a new glyph to the `TextGeometry`.\n     *\n     * @param glyphData [[GlyphData]] holding the glyph description.\n     * @param corners Transformed glyph corners.\n     * @param weight Foreground glyph sampling weight.\n     * @param bgWeight Foreground glyph sampling weight.\n     * @param mirrored If `true`, UVs will be horizontally mirrored (needed for RTL punctuation).\n     * @param style Currently set [[TextRenderStyle]].\n     *\n     * @returns Result of the addition.\n     */\n    add(glyphData, corners, weight, bgWeight, mirrored, style) {\n        if (this.m_drawCount >= this.capacity) {\n            return false;\n        }\n        else if (this.m_drawCount >= this.m_currentCapacity) {\n            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);\n            this.resizeBuffers(newSize);\n        }\n        const baseVertex = this.m_drawCount * exports.VERTICES_PER_QUAD;\n        const baseIndex = this.m_drawCount * exports.INDICES_PER_QUAD;\n        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {\n            this.m_positionAttribute.setXYZW(baseVertex + i, corners[i].x, corners[i].y, corners[i].z, (mirrored ? -1.0 : 1.0) * style.rotation);\n            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;\n            this.m_uvAttribute.setXYZW(baseVertex + i, glyphData.dynamicTextureCoordinates[mirroredUVIdx].x, glyphData.dynamicTextureCoordinates[mirroredUVIdx].y, weight, bgWeight);\n            this.m_colorAttribute.setXYZW(baseVertex + i, style.color.r, style.color.g, style.color.b, style.opacity);\n            this.m_bgColorAttribute.setXYZW(baseVertex + i, style.backgroundColor.r, style.backgroundColor.g, style.backgroundColor.b, style.backgroundOpacity);\n        }\n        this.m_indexBuffer.setX(baseIndex, baseVertex);\n        this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);\n        this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);\n        this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);\n        this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);\n        this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);\n        ++this.m_drawCount;\n        return true;\n    }\n    /**\n     * Add a new glyph to a text buffer.\n     *\n     * @param buffer Target buffer where glyph attributes will be stored.\n     * @param offset Offset of the target buffer.\n     * @param glyphData [[GlyphData]] holding the glyph description.\n     * @param corners Transformed glyph corners.\n     * @param weight Foreground glyph sampling weight.\n     * @param bgWeight Foreground glyph sampling weight.\n     * @param mirrored If `true`, UVs will be mirrored (needed for RTL punctuation).\n     * @param style Currently set [[TextRenderStyle]].\n     */\n    addToBuffer(buffer, offset, glyphData, corners, weight, bgWeight, mirrored, style) {\n        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {\n            const vertexOffset = offset + exports.VERTEX_BUFFER_STRIDE * i;\n            buffer[vertexOffset] = corners[i].x;\n            buffer[vertexOffset + 1] = corners[i].y;\n            buffer[vertexOffset + 2] = corners[i].z;\n            buffer[vertexOffset + 3] = (mirrored ? -1.0 : 1.0) * style.rotation;\n            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;\n            buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;\n            buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;\n            buffer[vertexOffset + 6] = weight;\n            buffer[vertexOffset + 7] = bgWeight;\n            buffer[vertexOffset + 8] = style.color.r;\n            buffer[vertexOffset + 9] = style.color.g;\n            buffer[vertexOffset + 10] = style.color.b;\n            buffer[vertexOffset + 11] = style.opacity;\n            buffer[vertexOffset + 12] = style.backgroundColor.r;\n            buffer[vertexOffset + 13] = style.backgroundColor.g;\n            buffer[vertexOffset + 14] = style.backgroundColor.b;\n            buffer[vertexOffset + 15] = style.backgroundOpacity;\n        }\n    }\n    /**\n     * Add a previously computed [[TextBufferObject]] to the `TextGeometry`. Extra parameters can\n     * be passed to override the passed attribute data.\n     *\n     * @param textBufferObject [[TextBufferObject]] containing computed glyphs.\n     * @param position Override position value.\n     * @param scale Override scale value.\n     * @param rotation Override rotation value.\n     * @param color Override color value.\n     * @param opacity Override opacity value.\n     * @param bgColor Override background color value.\n     * @param bgOpacity Override background opacity value.\n     *\n     * @returns Result of the addition.\n     */\n    addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity) {\n        if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {\n            return false;\n        }\n        else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {\n            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);\n            this.resizeBuffers(newSize);\n        }\n        const s = scale || 1.0;\n        const r = rotation || 0.0;\n        const cosR = Math.cos(r);\n        const sinR = Math.sin(r);\n        const offsetX = position !== undefined ? position.x : 0.0;\n        const offsetY = position !== undefined ? position.y : 0.0;\n        const offsetZ = position !== undefined ? position.z : 0.0;\n        const buffer = textBufferObject.buffer;\n        const rot = buffer[3];\n        const rotSign = rot < 0 ? -1.0 : 1.0;\n        const red = color !== undefined ? color.r : buffer[8];\n        const green = color !== undefined ? color.g : buffer[9];\n        const blue = color !== undefined ? color.b : buffer[10];\n        const alpha = opacity !== undefined ? opacity : buffer[11];\n        const bgRed = bgColor !== undefined ? bgColor.r : buffer[12];\n        const bgGreen = bgColor !== undefined ? bgColor.g : buffer[13];\n        const bgBlue = bgColor !== undefined ? bgColor.b : buffer[14];\n        const bgAlpha = bgOpacity !== undefined ? bgOpacity : buffer[15];\n        const targetOffset = this.m_drawCount * exports.VERTICES_PER_QUAD;\n        for (let i = 0; i < textBufferObject.glyphs.length; ++i) {\n            const srcOffset = i * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;\n            const glyph = textBufferObject.glyphs[i];\n            if (!glyph.isInCache) {\n                return false;\n            }\n            const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + exports.VERTEX_BUFFER_STRIDE + 4];\n            const w = buffer[srcOffset + 6];\n            const bw = buffer[srcOffset + 7];\n            for (let j = 0; j < exports.VERTICES_PER_QUAD; ++j) {\n                const x = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE];\n                const y = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 1];\n                this.m_positionAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, x * s * cosR + y * s * -sinR + offsetX, x * s * sinR + y * s * cosR + offsetY, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 2] + offsetZ, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 3] + rotSign * r);\n                const mirroredUVIdx = mirrored ? ((j + 1) % 2) + Math.floor(j / 2) * 2 : j;\n                this.m_uvAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, glyph.dynamicTextureCoordinates[mirroredUVIdx].x, glyph.dynamicTextureCoordinates[mirroredUVIdx].y, w, (bw - w) / s + w);\n                this.m_colorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, red, green, blue, alpha);\n                this.m_bgColorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, bgRed, bgGreen, bgBlue, bgAlpha);\n            }\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD);\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 1, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 2, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 3, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 4, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);\n            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 5, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 3);\n        }\n        this.m_drawCount += textBufferObject.glyphs.length;\n        return true;\n    }\n    /**\n     * Adds picking data for glyphs from the specified start until the last glyph added.\n     *\n     * @param startIdx First glyph index that this picking data is associated to.\n     * @param endIdx Last glyph index that this picking data is associated to.\n     * @param pickingData Picking data to be added.\n     */\n    addPickingData(startIdx, endIdx, pickingData) {\n        if (this.m_pickingCount >= this.m_currentCapacity) {\n            return false;\n        }\n        this.m_pickingDataArray[this.m_pickingCount] = {\n            start: Math.min(startIdx, this.capacity),\n            end: Math.min(endIdx, this.capacity),\n            data: pickingData\n        };\n        ++this.m_pickingCount;\n        return true;\n    }\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple glyphs\n     * are found, the order of the results is unspecified.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickCallback Callback to be called for every picked element.\n     */\n    pick(screenPosition, pickCallback) {\n        for (const pickingData of this.m_pickingDataArray) {\n            if (pickingData === undefined) {\n                return;\n            }\n            for (let i = pickingData.start; i < pickingData.end; ++i) {\n                const positionIndex = i * exports.VERTICES_PER_QUAD;\n                const minX = Math.min(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));\n                if (screenPosition.x < minX) {\n                    continue;\n                }\n                const maxX = Math.max(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));\n                if (screenPosition.x > maxX) {\n                    continue;\n                }\n                const minY = Math.min(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));\n                if (screenPosition.y < minY) {\n                    continue;\n                }\n                const maxY = Math.max(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));\n                if (screenPosition.y > maxY) {\n                    continue;\n                }\n                pickCallback(pickingData.data);\n                break;\n            }\n        }\n    }\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `TextGeometry`.\n     *\n     * @param info The info object to increment with the values from this `TextGeometry`.\n     */\n    updateMemoryUsage(info) {\n        const numBytes = this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT +\n            this.m_indexBuffer.count * NUM_BYTES_PER_INT32;\n        info.heapSize += numBytes;\n        info.gpuSize += numBytes;\n    }\n    resizeBuffers(size) {\n        this.m_currentCapacity = size;\n        const newVertexBuffer = new Float32Array(size * exports.QUAD_VERTEX_MEMORY_FOOTPRINT);\n        newVertexBuffer.set(this.m_vertexBuffer.array);\n        this.m_vertexBuffer = new THREE.InterleavedBuffer(newVertexBuffer, exports.VERTEX_BUFFER_STRIDE);\n        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);\n        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);\n        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);\n        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);\n        const newIndexBuffer = new Uint32Array(size * exports.QUAD_INDEX_MEMORY_FOOTPRINT);\n        newIndexBuffer.set(this.m_indexBuffer.array);\n        this.m_indexBuffer = new THREE.BufferAttribute(newIndexBuffer, exports.INDEX_BUFFER_STRIDE);\n        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_geometry.dispose();\n        this.m_geometry = new THREE.BufferGeometry();\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"bgColor\", this.m_bgColorAttribute);\n        this.m_geometry.setIndex(this.m_indexBuffer);\n        this.m_pickingDataArray.length = this.m_currentCapacity;\n        this.scene.remove(this.m_bgMesh, this.m_mesh);\n        this.m_mesh = new THREE.Mesh(this.m_geometry, this.m_mesh.material);\n        this.m_bgMesh = new THREE.Mesh(this.m_geometry, this.m_bgMesh.material);\n        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;\n        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;\n        this.m_mesh.frustumCulled = false;\n        this.m_bgMesh.frustumCulled = false;\n        this.scene.add(this.m_bgMesh, this.m_mesh);\n    }\n}\nexports.TextGeometry = TextGeometry;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst SdfShaderChunks = {\n    sdf_attributes: `\n        attribute vec4 position;\n        attribute vec4 uv;\n        attribute vec4 color;\n        attribute vec4 bgColor;\n        `,\n    sdf_varying: `\n        varying vec4 vColor;\n        varying float vWeight;\n        varying vec2 vUv;\n        varying float vRotation;\n        `,\n    sdf_varying_computation: `\n        #if BG_TEXT\n        vColor = bgColor;\n        vWeight = uv.w;\n        #else\n        vColor = color;\n        vWeight = uv.z;\n        #endif\n        vUv = vec2(uv.xy);\n        vRotation = position.w;\n        `,\n    sdf_frag_uniforms: `\n        uniform sampler2D sdfTexture;\n        uniform vec4 sdfParams;\n        `,\n    sdf_sampling_functions: `\n        float median(float r, float g, float b) {\n            return max(min(r, g), min(max(r, g), b));\n        }\n\n        float getDistance(vec2 uvOffset) {\n            vec3 sample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;\n            #if MSDF\n            return median(sample.r, sample.g, sample.b);\n            #else\n            return sample.r;\n            #endif\n        }\n\n        float getOpacity(vec2 uvOffset, float weight) {\n            vec2 uv = vUv + uvOffset;\n            vec2 rotatedUVs = abs(vec2(\n                cos(vRotation) * uv.x - sin(vRotation) * uv.y,\n                sin(vRotation) * uv.x + cos(vRotation) * uv.y));\n\n            float dx = dFdx(rotatedUVs.x) * sdfParams.x;\n            float dy = dFdy(rotatedUVs.y) * sdfParams.y;\n            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );\n\n            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;\n            return clamp(dist * toPixels + 0.5, 0.0, 1.0);\n        }\n        `\n};\nObject.assign(THREE.ShaderChunk, SdfShaderChunks);\nconst clearVertexSource = `\n    attribute vec2 position;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }`;\nconst clearFragmentSource = `\n    precision highp float;\n    precision highp int;\n\n    void main() {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }`;\nconst copyVertexSource = `\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vUv;\n\n    void main() {\n        vUv = vec3(uv.xy, position.z);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }`;\nconst copyFragmentSource = `\n    precision highp float;\n    precision highp int;\n\n    uniform float pageOffset;\n    uniform sampler2D page0;\n    uniform sampler2D page1;\n    uniform sampler2D page2;\n    uniform sampler2D page3;\n    uniform sampler2D page4;\n    uniform sampler2D page5;\n    uniform sampler2D page6;\n    uniform sampler2D page7;\n\n    varying vec3 vUv;\n\n    void main() {\n        vec4 sample = vec4(0.0);\n        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;\n        else if (vUv.z < pageOffset + 1.0) sample = texture2D(page0, vUv.xy);\n        else if (vUv.z < pageOffset + 2.0) sample = texture2D(page1, vUv.xy);\n        else if (vUv.z < pageOffset + 3.0) sample = texture2D(page2, vUv.xy);\n        else if (vUv.z < pageOffset + 4.0) sample = texture2D(page3, vUv.xy);\n        else if (vUv.z < pageOffset + 5.0) sample = texture2D(page4, vUv.xy);\n        else if (vUv.z < pageOffset + 6.0) sample = texture2D(page5, vUv.xy);\n        else if (vUv.z < pageOffset + 7.0) sample = texture2D(page6, vUv.xy);\n        else sample = texture2D(page7, vUv.xy);\n\n        gl_FragColor = sample;\n    }`;\nconst sdfTextVertexSource = `\n    #include <sdf_attributes>\n    #include <sdf_varying>\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        #include <sdf_varying_computation>\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n    }`;\nconst sdfTextFragmentSource = `\n    precision highp float;\n    precision highp int;\n\n    #include <sdf_varying>\n    #include <sdf_frag_uniforms>\n    #include <sdf_sampling_functions>\n\n    void main() {\n        vec4 color = vColor;\n        color.a *= getOpacity(vec2(0.0), vWeight);\n        if (color.a < 0.05) {\n            discard;\n        }\n        gl_FragColor = color;\n    }`;\n/**\n * @hidden\n * Material used for clearing glyphs from a [[GlyphTextureCache]].\n */\nclass GlyphClearMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Creates a new `GlyphClearMaterial`.\n     *\n     * @returns New `GlyphClearMaterial`.\n     */\n    constructor() {\n        const shaderParams = {\n            name: \"GlyphClearMaterial\",\n            vertexShader: clearVertexSource,\n            fragmentShader: clearFragmentSource,\n            uniforms: {},\n            depthTest: false,\n            depthWrite: false\n        };\n        super(shaderParams);\n    }\n}\nexports.GlyphClearMaterial = GlyphClearMaterial;\n/**\n * @hidden\n * Material used for copying glyphs into a [[GlyphTextureCache]].\n */\nclass GlyphCopyMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Creates a new `GlyphCopyMaterial`.\n     *\n     * @returns New `GlyphCopyMaterial`.\n     */\n    constructor() {\n        const shaderParams = {\n            name: \"GlyphCopyMaterial\",\n            vertexShader: copyVertexSource,\n            fragmentShader: copyFragmentSource,\n            uniforms: {\n                pageOffset: new THREE.Uniform(0.0),\n                page0: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page1: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page2: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page3: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page4: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page5: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page6: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page7: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE)\n            },\n            depthTest: false,\n            depthWrite: false\n        };\n        super(shaderParams);\n    }\n}\nexports.GlyphCopyMaterial = GlyphCopyMaterial;\n/**\n * @hidden\n * Material designed to render transformable, high quality SDF text.\n */\nclass SdfTextMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Creates a new `SdfTextMaterial`.\n     *\n     * @param params Material parameters.\n     *\n     * @returns New `SdfTextMaterial`.\n     */\n    constructor(params) {\n        const shaderParams = {\n            name: \"SdfTextMaterial\",\n            vertexShader: params.vertexSource !== undefined ? params.vertexSource : sdfTextVertexSource,\n            fragmentShader: params.fragmentSource !== undefined ? params.fragmentSource : sdfTextFragmentSource,\n            uniforms: {\n                sdfTexture: new THREE.Uniform(params.texture),\n                sdfParams: new THREE.Uniform(new THREE.Vector4(params.textureSize.x, params.textureSize.y, params.size, params.distanceRange))\n            },\n            defines: {\n                MSDF: params.isMsdf ? 1.0 : 0.0,\n                BG_TEXT: params.isBackground ? 1.0 : 0.0\n            },\n            depthTest: true,\n            depthWrite: true,\n            side: THREE.DoubleSide,\n            transparent: true\n        };\n        super(shaderParams);\n        this.extensions.derivatives = true;\n    }\n}\nexports.SdfTextMaterial = SdfTextMaterial;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\n/**\n * Unit of measurement used to specify a font's size.\n */\nvar FontUnit;\n(function (FontUnit) {\n    FontUnit[FontUnit[\"Em\"] = 0] = \"Em\";\n    FontUnit[FontUnit[\"Pixel\"] = 1] = \"Pixel\";\n    FontUnit[FontUnit[\"Point\"] = 2] = \"Point\";\n    FontUnit[FontUnit[\"Percent\"] = 3] = \"Percent\";\n})(FontUnit = exports.FontUnit || (exports.FontUnit = {}));\n/**\n * Style to be used when rendering glyphs.\n */\nvar FontStyle;\n(function (FontStyle) {\n    FontStyle[FontStyle[\"Regular\"] = 0] = \"Regular\";\n    FontStyle[FontStyle[\"Bold\"] = 1] = \"Bold\";\n    FontStyle[FontStyle[\"Italic\"] = 2] = \"Italic\";\n    FontStyle[FontStyle[\"BoldItalic\"] = 3] = \"BoldItalic\";\n})(FontStyle = exports.FontStyle || (exports.FontStyle = {}));\n/**\n * Variant to be used when rendering.\n */\nvar FontVariant;\n(function (FontVariant) {\n    FontVariant[FontVariant[\"Regular\"] = 0] = \"Regular\";\n    FontVariant[FontVariant[\"AllCaps\"] = 1] = \"AllCaps\";\n    FontVariant[FontVariant[\"SmallCaps\"] = 2] = \"SmallCaps\";\n})(FontVariant = exports.FontVariant || (exports.FontVariant = {}));\n/**\n * Vertical alignment to be used when placing text.\n */\nvar VerticalAlignment;\n(function (VerticalAlignment) {\n    VerticalAlignment[VerticalAlignment[\"Above\"] = 0] = \"Above\";\n    VerticalAlignment[VerticalAlignment[\"Center\"] = -0.5] = \"Center\";\n    VerticalAlignment[VerticalAlignment[\"Below\"] = -1] = \"Below\";\n})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));\n/**\n * Horizontal alignment to be used when placing text.\n */\nvar HorizontalAlignment;\n(function (HorizontalAlignment) {\n    HorizontalAlignment[HorizontalAlignment[\"Left\"] = 0] = \"Left\";\n    HorizontalAlignment[HorizontalAlignment[\"Center\"] = -0.5] = \"Center\";\n    HorizontalAlignment[HorizontalAlignment[\"Right\"] = -1] = \"Right\";\n})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));\n/**\n * Text wrapping rule used when `lineWidth` is reached.\n */\nvar WrappingMode;\n(function (WrappingMode) {\n    WrappingMode[WrappingMode[\"None\"] = 0] = \"None\";\n    WrappingMode[WrappingMode[\"Character\"] = 1] = \"Character\";\n    WrappingMode[WrappingMode[\"Word\"] = 2] = \"Word\";\n})(WrappingMode = exports.WrappingMode || (exports.WrappingMode = {}));\n/**\n * Namespace containing default values for all members of [[TextRenderParameters]] and\n * [[TextLayoutParameters]].\n */\nvar DefaultTextStyle;\n(function (DefaultTextStyle) {\n    DefaultTextStyle.DEFAULT_FONT_NAME = \"\";\n    DefaultTextStyle.DEFAULT_FONT_SIZE = {\n        unit: Object.freeze(FontUnit.Pixel),\n        size: Object.freeze(16.0),\n        backgroundSize: Object.freeze(0.0)\n    };\n    DefaultTextStyle.DEFAULT_FONT_STYLE = FontStyle.Regular;\n    DefaultTextStyle.DEFAULT_FONT_VARIANT = FontVariant.Regular;\n    DefaultTextStyle.DEFAULT_ROTATION = 0.0;\n    DefaultTextStyle.DEFAULT_COLOR = new THREE.Color(0x000000);\n    DefaultTextStyle.DEFAULT_OPACITY = 1.0;\n    DefaultTextStyle.DEFAULT_BACKGROUND_COLOR = new THREE.Color(0x000000);\n    DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY = 0.0;\n    DefaultTextStyle.DEFAULT_TRACKING = 0.0;\n    DefaultTextStyle.DEFAULT_LEADING = 0.0;\n    DefaultTextStyle.DEFAULT_MAX_LINES = Infinity;\n    DefaultTextStyle.DEFAULT_LINE_WIDTH = Infinity;\n    DefaultTextStyle.DEFAULT_CANVAS_ROTATION = 0.0;\n    DefaultTextStyle.DEFAULT_LINE_ROTATION = 0.0;\n    DefaultTextStyle.DEFAULT_WRAPPING_MODE = WrappingMode.Word;\n    DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT = VerticalAlignment.Above;\n    DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT = HorizontalAlignment.Left;\n})(DefaultTextStyle = exports.DefaultTextStyle || (exports.DefaultTextStyle = {}));\n/**\n * [[TextCanvas]] text rendering style.\n */\nclass TextRenderStyle {\n    /**\n     * Creates a new `TextRenderStyle`.\n     *\n     * @param params Input [[TextRenderParameters]].\n     *\n     * @returns New `TextRenderStyle`.\n     */\n    constructor(params = {}) {\n        this.m_params = {\n            fontName: params.fontName !== undefined\n                ? params.fontName\n                : DefaultTextStyle.DEFAULT_FONT_NAME,\n            fontSize: params.fontSize !== undefined\n                ? params.fontSize\n                : {\n                    unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,\n                    size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,\n                    backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize\n                },\n            fontStyle: params.fontStyle !== undefined\n                ? params.fontStyle\n                : DefaultTextStyle.DEFAULT_FONT_STYLE,\n            fontVariant: params.fontVariant !== undefined\n                ? params.fontVariant\n                : DefaultTextStyle.DEFAULT_FONT_VARIANT,\n            rotation: params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,\n            color: params.color !== undefined\n                ? params.color\n                : new THREE.Color(DefaultTextStyle.DEFAULT_COLOR),\n            opacity: params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,\n            backgroundColor: params.backgroundColor !== undefined\n                ? params.backgroundColor\n                : new THREE.Color(DefaultTextStyle.DEFAULT_BACKGROUND_COLOR),\n            backgroundOpacity: params.backgroundOpacity !== undefined\n                ? params.backgroundOpacity\n                : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY\n        };\n    }\n    /**\n     * Current [[TextRenderParameters]] for this style.\n     */\n    get params() {\n        return this.m_params;\n    }\n    set params(value) {\n        this.m_params = Object.assign(Object.assign({}, this.m_params), value);\n    }\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    get fontName() {\n        return this.m_params.fontName;\n    }\n    set fontName(value) {\n        this.m_params.fontName = value;\n    }\n    /**\n     * Collection of unit and sizes to apply for the currently active [[Font]].\n     */\n    get fontSize() {\n        return this.m_params.fontSize;\n    }\n    set fontSize(value) {\n        this.m_params.fontSize = value;\n    }\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    get fontStyle() {\n        return this.m_params.fontStyle;\n    }\n    set fontStyle(value) {\n        this.m_params.fontStyle = value;\n    }\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    get fontVariant() {\n        return this.m_params.fontVariant;\n    }\n    set fontVariant(value) {\n        this.m_params.fontVariant = value;\n    }\n    /**\n     * Glyph local rotation (radians).\n     */\n    get rotation() {\n        return this.m_params.rotation;\n    }\n    set rotation(value) {\n        this.m_params.rotation = value;\n    }\n    /**\n     * Glyph color.\n     */\n    get color() {\n        return this.m_params.color;\n    }\n    set color(value) {\n        this.m_params.color = value;\n    }\n    /**\n     * Glyph background color.\n     */\n    get backgroundColor() {\n        return this.m_params.backgroundColor;\n    }\n    set backgroundColor(value) {\n        this.m_params.backgroundColor = value;\n    }\n    /**\n     * Glyph opacity.\n     */\n    get opacity() {\n        return this.m_params.opacity;\n    }\n    set opacity(value) {\n        this.m_params.opacity = value;\n    }\n    /**\n     * Glyph background opacity.\n     */\n    get backgroundOpacity() {\n        return this.m_params.backgroundOpacity;\n    }\n    set backgroundOpacity(value) {\n        this.m_params.backgroundOpacity = value;\n    }\n    /**\n     * Clone this `TextRenderStyle`.\n     *\n     * @param params Input [[TextRenderParameters]].\n     *\n     * @returns Cloned `TextRenderStyle`.\n     */\n    clone(params = {}) {\n        return new TextRenderStyle(Object.assign(Object.assign({}, this.m_params), params));\n    }\n}\nexports.TextRenderStyle = TextRenderStyle;\n/**\n * [[TextCanvas]] text rendering style.\n */\nclass TextLayoutStyle {\n    /**\n     * Creates a new `TextLayoutStyle`.\n     *\n     * @param params Input [[TextLayoutParameters]].\n     *\n     * @returns New `TextLayoutStyle`.\n     */\n    constructor(params = {}) {\n        this.m_params = {\n            tracking: params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,\n            leading: params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,\n            maxLines: params.maxLines !== undefined\n                ? params.maxLines\n                : DefaultTextStyle.DEFAULT_MAX_LINES,\n            lineWidth: params.lineWidth !== undefined\n                ? params.lineWidth\n                : DefaultTextStyle.DEFAULT_LINE_WIDTH,\n            canvasRotation: params.canvasRotation !== undefined\n                ? params.canvasRotation\n                : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,\n            lineRotation: params.lineRotation !== undefined\n                ? params.lineRotation\n                : DefaultTextStyle.DEFAULT_LINE_ROTATION,\n            wrappingMode: params.wrappingMode !== undefined\n                ? params.wrappingMode\n                : DefaultTextStyle.DEFAULT_WRAPPING_MODE,\n            verticalAlignment: params.verticalAlignment !== undefined\n                ? params.verticalAlignment\n                : DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT,\n            horizontalAlignment: params.horizontalAlignment !== undefined\n                ? params.horizontalAlignment\n                : DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT\n        };\n    }\n    /**\n     * Current [[TextLayoutParameters]] for this style.\n     */\n    get params() {\n        return this.m_params;\n    }\n    set params(value) {\n        this.m_params = Object.assign(Object.assign({}, this.m_params), value);\n    }\n    /**\n     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].\n     */\n    get tracking() {\n        return this.m_params.tracking;\n    }\n    set tracking(value) {\n        this.m_params.tracking = value;\n    }\n    /**\n     * Inter-line spacing (pixels). Scaled by [[FontSize]].\n     */\n    get leading() {\n        return this.m_params.leading;\n    }\n    set leading(value) {\n        this.m_params.leading = value;\n    }\n    /**\n     * Maximum number of lines to be considered when using [[TextCanvas]].\n     */\n    get maxLines() {\n        return this.m_params.maxLines;\n    }\n    set maxLines(value) {\n        this.m_params.maxLines = value;\n    }\n    /**\n     * Maximum line width (pixels).\n     */\n    get lineWidth() {\n        return this.m_params.lineWidth;\n    }\n    set lineWidth(value) {\n        this.m_params.lineWidth = value;\n    }\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    get canvasRotation() {\n        return this.m_params.canvasRotation;\n    }\n    set canvasRotation(value) {\n        this.m_params.canvasRotation = value;\n    }\n    /**\n     * Line typesetting rotation (radians).\n     */\n    get lineRotation() {\n        return this.m_params.lineRotation;\n    }\n    set lineRotation(value) {\n        this.m_params.lineRotation = value;\n    }\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    get wrappingMode() {\n        return this.m_params.wrappingMode;\n    }\n    set wrappingMode(value) {\n        this.m_params.wrappingMode = value;\n    }\n    /**\n     * Text position regarding the baseline.\n     */\n    get verticalAlignment() {\n        return this.m_params.verticalAlignment;\n    }\n    set verticalAlignment(value) {\n        this.m_params.verticalAlignment = value;\n    }\n    /**\n     * Text position inside a line.\n     */\n    get horizontalAlignment() {\n        return this.m_params.horizontalAlignment;\n    }\n    set horizontalAlignment(value) {\n        this.m_params.horizontalAlignment = value;\n    }\n    /**\n     * Clone this `TextLayoutStyle`.\n     *\n     * @param params Input [[TextLayoutParameters]].\n     *\n     * @returns Cloned `TextLayoutStyle`.\n     */\n    clone(params = {}) {\n        return new TextLayoutStyle(Object.assign(Object.assign({}, this.m_params), params));\n    }\n}\nexports.TextLayoutStyle = TextLayoutStyle;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js\");\nconst TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\");\nconst TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js\");\nconst UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\");\n/**\n * @hidden\n * [[Typesetter]] implementation that handles multi-line complex layout text.\n */\nclass LineTypesetter {\n    /**\n     * Creates a `LineTypesetter` object.\n     *\n     * @returns New `LineTypesetter`.\n     */\n    constructor() {\n        this.m_tempTransform = new THREE.Matrix3();\n        this.m_tempCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;\n        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;\n        this.m_tempPixelSize = 1.0;\n        this.m_tempPixelBgSize = 1.0;\n        this.m_tempScale = 1.0;\n        this.m_tempSmallCaps = false;\n    }\n    /**\n     * Arranges the specified glyphs using this `LineTypesetter`. Text will be placed into multiple\n     * bidirectional lines, that will be generated taking into account [[textLayoutStyle]] features,\n     * such as:\n     * - Maximum line width.\n     * - Word and character wrapping.\n     * - Maximum number of lines.\n     * - Vertical and horizontal alignment.\n     * - Leading (spacing between lines).\n     *\n     * @param params Typesetting parameters.\n     *\n     * @returns If `false`, some error occurred during execution and the output should be dismissed.\n     */\n    arrangeGlyphs(params) {\n        // Initializes common typesetting parameters (used across all functions in this class).\n        this.m_currentParams = params;\n        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);\n        this.m_tempRunDirection = this.m_tempLineDirection;\n        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);\n        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;\n        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);\n        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;\n        this.m_currentParams.position.y +=\n            this.m_currentParams.textLayoutStyle.verticalAlignment *\n                this.m_currentParams.glyphs[0].font.metrics.capHeight *\n                this.m_tempScale;\n        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&\n            this.m_currentParams.vertexBuffer === undefined;\n        // Compute line origin and height.\n        const origin = this.m_currentParams.position.x;\n        const lineHeight = this.m_currentParams.glyphs[0].font.metrics.lineHeight +\n            this.m_currentParams.textLayoutStyle.leading;\n        // Initialize line-breaking and wrapping variables.\n        let lineStartIdx = 0;\n        let glyphWrapIdx = 0;\n        let wordWrapIdx = 0;\n        let lineStartX = 0;\n        let lineCurrX = 0;\n        let glyphWrapX = 0;\n        let wordWrapX = 0;\n        let lineCount = 0;\n        let isBidirectionalLine = false;\n        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {\n            if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {\n                break;\n            }\n            const glyphData = this.m_currentParams.glyphs[i];\n            if (!glyphData.isInCache && !isOnlyMeasured) {\n                return false;\n            }\n            const isNewLine = UnicodeUtils_1.UnicodeUtils.isNewLine(glyphData.codePoint);\n            const isWhiteSpace = UnicodeUtils_1.UnicodeUtils.isWhiteSpace(glyphData.codePoint);\n            // Check if this line should be treated as bidirectional.\n            if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {\n                isBidirectionalLine = true;\n            }\n            // Advance the line's current X offset (only for printable characters).\n            if (UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                lineCurrX +=\n                    (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *\n                        this.m_tempScale *\n                        (this.m_tempSmallCaps\n                            ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)\n                            : 1.0);\n            }\n            // If this is the first character in a line, update the line's X offset values (needed\n            // to properly center and wrap).\n            if (i === lineStartIdx) {\n                lineStartX = lineCurrX;\n                glyphWrapX = lineCurrX;\n                wordWrapX = lineCurrX;\n            }\n            // Check if should break the current line.\n            if (isNewLine ||\n                (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Character &&\n                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth) ||\n                (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&\n                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth &&\n                    wordWrapX !== lineStartX)) {\n                // Perform wrapping.\n                if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None) {\n                    let wrapPointIdx = glyphWrapIdx;\n                    let wrapPointX = glyphWrapX;\n                    // Only wrap words when more than a single word fits into the current line.\n                    if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&\n                        wordWrapX !== lineStartX) {\n                        wrapPointIdx = wordWrapIdx;\n                        wrapPointX = wordWrapX;\n                    }\n                    lineCurrX = wrapPointX;\n                    i = Math.min(isNewLine ? (lineStartIdx === i ? wrapPointIdx : i) : wrapPointIdx, this.m_currentParams.glyphs.length - 1);\n                }\n                // Calculate the correct starting position for the line base on alignment, and place\n                // all glyphs in it.\n                const lineAlignment = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine\n                    ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment\n                    : this.m_currentParams.textLayoutStyle.horizontalAlignment;\n                this.m_currentParams.position.x =\n                    this.m_currentParams.position.x + lineCurrX * lineAlignment;\n                if (!this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)) {\n                    return false;\n                }\n                // Update the line position.\n                this.m_currentParams.position.y -= lineHeight * this.m_tempScale;\n                this.m_currentParams.position.x = origin;\n                // Find the beginning of a new line (removing trailing white spaces).\n                while (i !== lineStartIdx &&\n                    i + 1 < this.m_currentParams.glyphs.length &&\n                    UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)) {\n                    ++i;\n                }\n                lineStartIdx = i + 1;\n                if (lineStartIdx === this.m_currentParams.glyphs.length) {\n                    break;\n                }\n                // Only reset the line's direction when a new line character is found (to keep\n                // correct bidirectional behaviour when a bidirectional run is placed between\n                // multiple lines).\n                if (isNewLine) {\n                    this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, lineStartIdx);\n                    this.m_tempRunDirection = this.m_tempLineDirection;\n                }\n                // Reset the line placement parameters.\n                lineStartX = 0;\n                lineCurrX = 0;\n                glyphWrapIdx = lineStartIdx;\n                glyphWrapX = 0;\n                wordWrapIdx = lineStartIdx;\n                wordWrapX = 0;\n                isBidirectionalLine = false;\n                lineCount++;\n            }\n            // If not, should if we should record any new wrapping points.\n            else if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None &&\n                !isWhiteSpace) {\n                // Update the per-glyph wrapping point.\n                glyphWrapIdx = i;\n                glyphWrapX = lineCurrX;\n                // Update the word wrapping point (only if mode is correctly set and we are\n                // currently placed at the end of a word).\n                if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&\n                    i + 1 < this.m_currentParams.glyphs.length &&\n                    (UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) ||\n                        UnicodeUtils_1.UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))) {\n                    wordWrapIdx = i;\n                    wordWrapX = lineCurrX;\n                }\n            }\n        }\n        // If we still haven't placed all characters, place a final line.\n        if (lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 &&\n            lineStartIdx <= this.m_currentParams.glyphs.length - 1) {\n            const offset = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine\n                ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment\n                : this.m_currentParams.textLayoutStyle.horizontalAlignment;\n            this.m_currentParams.position.setX(this.m_currentParams.position.x + lineCurrX * offset);\n            if (!this.placeLine(lineStartIdx, this.m_currentParams.glyphs.length - 1, this.m_tempLineDirection, isBidirectionalLine)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Place characters alongside a line. Text direction is taken into account, and text is broken\n    // into directional runs.\n    placeLine(startIdx, endIdx, direction, isBidirectional) {\n        // If the line is not bidirectional, place it as a single directional run.\n        if (!isBidirectional) {\n            return this.placeRun(startIdx, endIdx, direction);\n        }\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams.glyphs;\n        const smallCapsArray = this.m_currentParams.smallCapsArray;\n        const textRenderStyle = this.m_currentParams.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams.textLayoutStyle;\n        const position = this.m_currentParams.position;\n        // Initialize line placement parameters.\n        const isRTL = direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;\n        const origin = position.x;\n        let offset = 0;\n        let runStart = startIdx;\n        for (let i = startIdx; i <= endIdx; ++i) {\n            const glyphData = glyphDataArray[i];\n            // If the current glyph changes the line direction, place the current run.\n            if (glyphData.direction === -this.m_tempRunDirection) {\n                if (isRTL) {\n                    position.x = origin + offset;\n                }\n                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                    return false;\n                }\n                if (!isRTL) {\n                    position.x = origin + offset;\n                }\n                runStart = i;\n                this.m_tempRunDirection *= -1.0;\n            }\n            // If the current glyph has neutral direction (i.e. white space) and we're in the middle\n            // of a run with direction opposite to the line's main direction, check for the closest\n            // strong direction in the run.\n            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&\n                this.m_tempRunDirection === -direction) {\n                let neutralIdx = i;\n                while (neutralIdx + 1 < glyphDataArray.length &&\n                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {\n                    ++neutralIdx;\n                }\n                // If the closest strong direction in the run is not the current run's direction,\n                // place the current run.\n                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {\n                    if (isRTL) {\n                        position.x = origin + offset;\n                    }\n                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                        return false;\n                    }\n                    if (!isRTL) {\n                        position.x = origin + offset;\n                    }\n                    runStart = i;\n                    this.m_tempRunDirection *= -1.0;\n                }\n            }\n            // Advance the offset position in the line.\n            offset +=\n                (glyphData.advanceX + textLayoutStyle.tracking) *\n                    this.m_tempScale *\n                    (this.m_tempSmallCaps\n                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(glyphDataArray, smallCapsArray, i, textRenderStyle.fontVariant)\n                        : 1.0) *\n                    direction;\n        }\n        // If we still haven't placed all characters in the line, place a final run.\n        if (runStart <= endIdx) {\n            if (isRTL) {\n                position.x = origin + offset;\n            }\n            if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {\n                return false;\n            }\n            if (!isRTL) {\n                position.x = origin + offset;\n            }\n        }\n        return true;\n    }\n    // Place a directional run of index inside a line.\n    placeRun(startIdx, endIdx, direction) {\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams.glyphs;\n        const smallCapsArray = this.m_currentParams.smallCapsArray;\n        const fontCatalog = this.m_currentParams.fontCatalog;\n        const textRenderStyle = this.m_currentParams.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams.textLayoutStyle;\n        const position = this.m_currentParams.position;\n        const geometry = this.m_currentParams.geometry;\n        const globalBounds = this.m_currentParams.globalBounds;\n        const individualBounds = this.m_currentParams.individualBounds;\n        const vertexBuffer = this.m_currentParams.vertexBuffer;\n        // Move through the glyph array following the run's direction (as the order of the glyphs in\n        // memory might not match the order on glyphs on scree).\n        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;\n        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;\n        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {\n            // Only process printable characters.\n            const glyphData = glyphDataArray[i];\n            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n            // When placing a RTL run, we need to check for weak runs (numerical runs of characters\n            // that don't change the overall run direction, but should always be displayed as LTR\n            // text).\n            if (startIdx !== endIdx &&\n                i !== 0 &&\n                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&\n                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {\n                let weakRunStart = i;\n                let weakGlyph = glyphDataArray[weakRunStart - 1];\n                while (weakRunStart !== startIdx &&\n                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||\n                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&\n                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {\n                    --weakRunStart;\n                    weakGlyph = glyphDataArray[weakRunStart - 1];\n                }\n                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);\n                i = weakRunStart;\n                continue;\n            }\n            // Compute various rendering parameters for this glyph.\n            const glyphFont = glyphData.font;\n            const glyphFontMetrics = glyphFont.metrics;\n            const fontStyle = textRenderStyle.fontStyle;\n            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||\n                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&\n                    glyphFont.bold === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||\n                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&\n                    glyphFont.italic === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isSmallCaps = this.m_tempSmallCaps\n                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps\n                : false;\n            const smallCapsScale = isSmallCaps\n                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight\n                : 1.0;\n            const glyphScale = this.m_tempScale * smallCapsScale;\n            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *\n                (fontCatalog.size / fontCatalog.distanceRange);\n            const bgWeight = (0.5 * this.m_tempPixelBgSize) /\n                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));\n            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&\n                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;\n            const verticalOffset = glyphFontMetrics.lineHeight -\n                glyphFontMetrics.base -\n                glyphFontMetrics.distanceRange * 0.5;\n            // Compute the glyphs transformation matrix and apply to all corners of a glyph.\n            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, position, glyphScale, textLayoutStyle.canvasRotation, textRenderStyle.rotation);\n            for (let j = 0; j < 4; ++j) {\n                const glyphVertexPosition = glyphData.positions[j];\n                const horizontalOffset = isItalicEmulated && j > 1\n                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size\n                    : 0.0;\n                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);\n                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);\n            }\n            // Depending on the typesetting options, add the computed glyph to the TextGeometry or\n            // update the text bounds.\n            if (globalBounds === undefined && vertexBuffer === undefined) {\n                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {\n                    return false;\n                }\n            }\n            else {\n                if (globalBounds !== undefined) {\n                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);\n                }\n                if (vertexBuffer !== undefined) {\n                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);\n                }\n            }\n            // Advance the current position and proceed to next glyph in the run.\n            position.set(position.x +\n                (glyphData.advanceX + textLayoutStyle.tracking) *\n                    glyphScale *\n                    Math.cos(textLayoutStyle.lineRotation), position.y +\n                (glyphData.advanceX + textLayoutStyle.tracking) *\n                    glyphScale *\n                    Math.sin(textLayoutStyle.lineRotation), position.z);\n        }\n        return true;\n    }\n}\nexports.LineTypesetter = LineTypesetter;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/typesetting/LineTypesetter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextGeometry.js\");\nconst TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\");\nconst TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js\");\nconst UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\");\n/**\n * @hidden\n * [[Typesetter]] implementation that arranges glyphs alongside a specified path.\n */\nclass PathTypesetter {\n    /**\n     * Creates a `PathTypesetter` object.\n     *\n     * @returns New `PathTypesetter`.\n     */\n    constructor() {\n        this.m_tempTransform = new THREE.Matrix3();\n        this.m_tempCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;\n        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;\n        this.m_tempPixelSize = 1.0;\n        this.m_tempPixelBgSize = 1.0;\n        this.m_tempScale = 1.0;\n        this.m_tempSmallCaps = false;\n        this.m_tempPathPosition = new THREE.Vector3();\n        this.m_tempPathLength = 0.0;\n        this.m_tempPathOffset = 0.0;\n    }\n    /**\n     * Arranges the specified glyphs using this `PathTypesetter`. Text will be placed into a single\n     * bidirectional line that follows the specified path. Characters will be orientated and placed\n     * alongside this path following [[TextLayout]]'s [[VerticalAlignment]] and\n     * [[HorizontalAlignment]].\n     *\n     * @param params Typesetting parameters.\n     *\n     * @returns If `false`, some error occurred during execution and the output should be dismissed.\n     */\n    arrangeGlyphs(params) {\n        // Initializes common typesetting parameters (used across all functions in this class).\n        this.m_currentParams = params;\n        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);\n        this.m_tempRunDirection = this.m_tempLineDirection;\n        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);\n        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;\n        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);\n        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;\n        this.m_tempPathLength = this.m_currentParams.path.getLength();\n        this.m_tempPathOffset = 0.0;\n        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&\n            this.m_currentParams.vertexBuffer === undefined;\n        // To be able to properly set the horizontal alignment on a path, we need to first retrieve\n        // how much of the path the input text covers, so we can calculate the correct initial\n        // offset.\n        let isBidirectional = false;\n        let pathWidth = 0.0;\n        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {\n            const glyphData = this.m_currentParams.glyphs[i];\n            if (!glyphData.isInCache && !isOnlyMeasured) {\n                return false;\n            }\n            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n            if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {\n                isBidirectional = true;\n            }\n            pathWidth +=\n                (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *\n                    this.m_tempScale *\n                    (this.m_tempSmallCaps\n                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)\n                        : 1.0);\n        }\n        this.m_tempPathOffset = Math.min(Math.max(-this.m_currentParams.textLayoutStyle.horizontalAlignment +\n            (this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth) /\n                this.m_tempPathLength, 0), 1);\n        // Place the input text as a single path line.\n        return this.placeLine(this.m_tempLineDirection, isBidirectional);\n    }\n    // Place characters alongside a path line. Text direction is taken into account, and text is\n    // broken into directional runs.\n    placeLine(direction, isBidirectional) {\n        // If the line is not bidirectional, place it as a single directional run.\n        if (!isBidirectional) {\n            return this.placeRun(0, this.m_currentParams.glyphs.length - 1, direction);\n        }\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams.glyphs;\n        // Initialize line placement parameters.\n        let runStart = 0;\n        for (let i = runStart; i < glyphDataArray.length; ++i) {\n            const glyphData = glyphDataArray[i];\n            // If the current glyph changes the line direction, place the current run.\n            if (glyphData.direction === -this.m_tempRunDirection) {\n                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                    return false;\n                }\n                runStart = i;\n                this.m_tempRunDirection *= -1.0;\n            }\n            // If the current glyph has neutral direction (i.e. white space) and we're in the middle\n            // of a run with direction opposite to the line's main direction, check for the closest\n            // strong direction in the run.\n            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&\n                this.m_tempRunDirection === -direction) {\n                let neutralIdx = i;\n                while (neutralIdx + 1 < glyphDataArray.length &&\n                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {\n                    ++neutralIdx;\n                }\n                // If the closest strong direction in the run is not the current run's direction,\n                // place the current run.\n                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {\n                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                        return false;\n                    }\n                    runStart = i;\n                    this.m_tempRunDirection *= -1.0;\n                }\n            }\n        }\n        // If we still haven't placed all characters in the line, place a final run.\n        if (runStart < glyphDataArray.length) {\n            if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Place a directional run of index inside a path line.\n    placeRun(startIdx, endIdx, direction) {\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams.glyphs;\n        const smallCapsArray = this.m_currentParams.smallCapsArray;\n        const fontCatalog = this.m_currentParams.fontCatalog;\n        const textRenderStyle = this.m_currentParams.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams.textLayoutStyle;\n        const position = this.m_currentParams.position;\n        const geometry = this.m_currentParams.geometry;\n        const globalBounds = this.m_currentParams.globalBounds;\n        const individualBounds = this.m_currentParams.individualBounds;\n        const vertexBuffer = this.m_currentParams.vertexBuffer;\n        const path = this.m_currentParams.path;\n        const defaultGlyphRotation = textRenderStyle.rotation;\n        const normalDisplacement = textLayoutStyle.verticalAlignment *\n            glyphDataArray[0].font.metrics.capHeight *\n            this.m_tempScale;\n        // Move through the glyph array following the run's direction (as the order of the glyphs in\n        // memory might not match the order on glyphs on scree).\n        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;\n        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;\n        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {\n            // Only process printable characters.\n            const glyphData = glyphDataArray[i];\n            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n            // When placing a RTL run, we need to check for weak runs (numerical runs of characters\n            // that don't change the overall run direction, but should always be displayed as LTR\n            // text).\n            if (startIdx !== endIdx &&\n                i !== 0 &&\n                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&\n                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {\n                let weakRunStart = i;\n                let weakGlyph = glyphDataArray[weakRunStart - 1];\n                while (weakRunStart !== startIdx &&\n                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||\n                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&\n                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {\n                    --weakRunStart;\n                    weakGlyph = glyphDataArray[weakRunStart - 1];\n                }\n                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);\n                i = weakRunStart;\n                continue;\n            }\n            // Compute various rendering parameters for this glyph.\n            const glyphFont = glyphData.font;\n            const glyphFontMetrics = glyphFont.metrics;\n            const fontStyle = textRenderStyle.fontStyle;\n            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||\n                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&\n                    glyphFont.bold === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||\n                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&\n                    glyphFont.italic === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isSmallCaps = this.m_tempSmallCaps\n                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps\n                : false;\n            const smallCapsScale = isSmallCaps\n                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight\n                : 1.0;\n            const glyphScale = this.m_tempScale * smallCapsScale;\n            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *\n                (fontCatalog.size / fontCatalog.distanceRange);\n            const bgWeight = (0.5 * this.m_tempPixelBgSize) /\n                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));\n            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&\n                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;\n            const verticalOffset = glyphFontMetrics.lineHeight -\n                glyphFontMetrics.base -\n                glyphFontMetrics.distanceRange * 0.5;\n            // Update the current interpolated path position and angle.\n            const textPoint = path.getPoint(this.m_tempPathOffset);\n            if (textPoint === null) {\n                return this.m_currentParams.pathOverflow;\n            }\n            const tangent = path.getTangent(this.m_tempPathOffset);\n            const normal = new THREE.Vector2(-tangent.y, tangent.x).multiplyScalar(normalDisplacement);\n            const angle = Math.atan2(tangent.y, tangent.x);\n            this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);\n            textRenderStyle.rotation = defaultGlyphRotation + angle;\n            // Compute the glyphs transformation matrix and apply to all corners of a glyph.\n            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, this.m_tempPathPosition, glyphScale, 0.0, textRenderStyle.rotation);\n            for (let j = 0; j < 4; ++j) {\n                const glyphVertexPosition = glyphData.positions[j];\n                const horizontalOffset = isItalicEmulated && j > 1\n                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size\n                    : 0.0;\n                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);\n                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);\n                this.m_tempCorners[j].x -= position.x;\n                this.m_tempCorners[j].y -= position.y;\n            }\n            // Depending on the typesetting options, add the computed glyph to the TextGeometry or\n            // update the text bounds.\n            if (globalBounds === undefined && vertexBuffer === undefined) {\n                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {\n                    return false;\n                }\n            }\n            else {\n                if (globalBounds !== undefined) {\n                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);\n                }\n                if (vertexBuffer !== undefined) {\n                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);\n                }\n            }\n            // Restore the original glyph rotation.\n            textRenderStyle.rotation = defaultGlyphRotation;\n            // Advance the current position and proceed to next glyph in the run.\n            this.m_tempPathOffset +=\n                ((glyphData.advanceX + textLayoutStyle.tracking) * glyphScale) /\n                    this.m_tempPathLength;\n        }\n        return true;\n    }\n}\nexports.PathTypesetter = PathTypesetter;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/typesetting/PathTypesetter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ContextualForm;\n(function (ContextualForm) {\n    ContextualForm[ContextualForm[\"Initial\"] = 0] = \"Initial\";\n    ContextualForm[ContextualForm[\"Medial\"] = 1] = \"Medial\";\n    ContextualForm[ContextualForm[\"Final\"] = 2] = \"Final\";\n})(ContextualForm || (ContextualForm = {}));\nvar CombinedForm;\n(function (CombinedForm) {\n    CombinedForm[CombinedForm[\"Isolated\"] = 0] = \"Isolated\";\n    CombinedForm[CombinedForm[\"Connected\"] = 1] = \"Connected\";\n})(CombinedForm || (CombinedForm = {}));\n/**\n * Converter between arabic isolated forms (in Unicode Block 'Arabic') and their contextual forms\n * (in Unicode Block 'Arabic Presentation Forms-B').\n */\nclass ContextualArabicConverter {\n    constructor() {\n        this.m_singleCharactersMap = new Map();\n        this.m_combinedCharactersMap = new Map();\n        // Single characters.\n        this.m_singleCharactersMap.set(0x0621, [undefined, undefined, undefined]); // HAMZA\n        this.m_singleCharactersMap.set(0x0622, [undefined, undefined, 0xfe82]); // ALEF_MADDA\n        this.m_singleCharactersMap.set(0x0623, [undefined, undefined, 0xfe84]); // ALEF_HAMZA_ABOVE\n        this.m_singleCharactersMap.set(0x0624, [undefined, undefined, 0xfe86]); // WAW_HAMZA\n        this.m_singleCharactersMap.set(0x0625, [undefined, undefined, 0xfe88]); // ALEF_HAMZA_BELOW\n        this.m_singleCharactersMap.set(0x0626, [0xfe8b, 0xfe8c, 0xfe8a]); // YEH_HAMZA\n        this.m_singleCharactersMap.set(0x0627, [undefined, undefined, 0xfe8e]); // ALEF\n        this.m_singleCharactersMap.set(0x0628, [0xfe91, 0xfe92, 0xfe90]); // BEH\n        this.m_singleCharactersMap.set(0x0629, [undefined, undefined, 0xfe94]); // TEH_MARBUTA\n        this.m_singleCharactersMap.set(0x062a, [0xfe97, 0xfe98, 0xfe96]); // TEH\n        this.m_singleCharactersMap.set(0x062b, [0xfe9b, 0xfe9c, 0xfe9a]); // THEH\n        this.m_singleCharactersMap.set(0x062c, [0xfe9f, 0xfea0, 0xfe9e]); // JEEM\n        this.m_singleCharactersMap.set(0x062d, [0xfea3, 0xfea4, 0xfea2]); // HAH\n        this.m_singleCharactersMap.set(0x062e, [0xfea7, 0xfea8, 0xfea6]); // KHAH\n        this.m_singleCharactersMap.set(0x062f, [undefined, undefined, 0xfeaa]); // DAL\n        this.m_singleCharactersMap.set(0x0630, [undefined, undefined, 0xfeac]); // THAL\n        this.m_singleCharactersMap.set(0x0631, [undefined, undefined, 0xfeae]); // REH\n        this.m_singleCharactersMap.set(0x0632, [undefined, undefined, 0xfeb0]); // ZAIN\n        this.m_singleCharactersMap.set(0x0633, [0xfeb3, 0xfeb4, 0xfeb2]); // SEEN\n        this.m_singleCharactersMap.set(0x0634, [0xfeb7, 0xfeb8, 0xfeb6]); // SHEEN\n        this.m_singleCharactersMap.set(0x0635, [0xfebb, 0xfebc, 0xfeba]); // SAD\n        this.m_singleCharactersMap.set(0x0636, [0xfebf, 0xfec0, 0xfebe]); // DAD\n        this.m_singleCharactersMap.set(0x0637, [0xfec3, 0xfec4, 0xfec2]); // TAH\n        this.m_singleCharactersMap.set(0x0638, [0xfec7, 0xfec8, 0xfec6]); // ZAH\n        this.m_singleCharactersMap.set(0x0639, [0xfecb, 0xfecc, 0xfeca]); // AIN\n        this.m_singleCharactersMap.set(0x063a, [0xfecf, 0xfed0, 0xfece]); // GHAIN\n        this.m_singleCharactersMap.set(0x0640, [0x0640, 0x0640, 0x0640]); // TATWEEL\n        this.m_singleCharactersMap.set(0x0641, [0xfed3, 0xfed4, 0xfed2]); // FEH\n        this.m_singleCharactersMap.set(0x0642, [0xfed7, 0xfed8, 0xfed6]); // QAF\n        this.m_singleCharactersMap.set(0x0643, [0xfedb, 0xfedc, 0xfeda]); // KAF\n        this.m_singleCharactersMap.set(0x0644, [0xfedf, 0xfee0, 0xfede]); // LAM\n        this.m_singleCharactersMap.set(0x0645, [0xfee3, 0xfee4, 0xfee2]); // MEEM\n        this.m_singleCharactersMap.set(0x0646, [0xfee7, 0xfee8, 0xfee6]); // NOON\n        this.m_singleCharactersMap.set(0x0647, [0xfeeb, 0xfeec, 0xfeea]); // HEH\n        this.m_singleCharactersMap.set(0x0648, [undefined, undefined, 0xfeee]); // WAW\n        this.m_singleCharactersMap.set(0x0649, [undefined, undefined, 0xfef0]); // ALEF_MAKSURA\n        this.m_singleCharactersMap.set(0x064a, [0xfef3, 0xfef4, 0xfef2]); // YEH\n        this.m_singleCharactersMap.set(0x067e, [0xfb58, 0xfb59, 0xfb57]); // PEH\n        this.m_singleCharactersMap.set(0x06cc, [0xfbfe, 0xfbff, 0xfbfd]); // Farsi Yeh\n        this.m_singleCharactersMap.set(0x0686, [0xfb7c, 0xfb7d, 0xfb7b]); // Tcheh\n        this.m_singleCharactersMap.set(0x06a9, [0xfb90, 0xfb91, 0xfb8f]); // Keheh\n        this.m_singleCharactersMap.set(0x06af, [0xfb94, 0xfb95, 0xfb93]); // Gaf\n        this.m_singleCharactersMap.set(0x0698, [undefined, undefined, 0xfb8b]); // Jeh\n        // Combined characters.\n        this.m_combinedCharactersMap.set(0x0644, new Map());\n        // LAM_ALEF_MADDA\n        this.m_combinedCharactersMap.get(0x0644).set(0x0622, [0xfef5, 0xfef6]);\n        // LAM_ALEF_HAMZA_ABOVE\n        this.m_combinedCharactersMap.get(0x0644).set(0x0623, [0xfef7, 0xfef8]);\n        // LAM_ALEF_HAMZA_BELOW\n        this.m_combinedCharactersMap.get(0x0644).set(0x0625, [0xfef9, 0xfefa]);\n        // LAM_ALEF\n        this.m_combinedCharactersMap.get(0x0644).set(0x0627, [0xfefb, 0xfefc]);\n        // Neutral characters.\n        this.m_neutralCharacters = [\n            0x0610,\n            0x0612,\n            0x0613,\n            0x0614,\n            0x0615,\n            0x064b,\n            0x064c,\n            0x064d,\n            0x064e,\n            0x064f,\n            0x0650,\n            0x0651,\n            0x0652,\n            0x0653,\n            0x0654,\n            0x0655,\n            0x0656,\n            0x0657,\n            0x0658,\n            0x0670,\n            0x06d6,\n            0x06d7,\n            0x06d8,\n            0x06d9,\n            0x06da,\n            0x06db,\n            0x06dc,\n            0x06df,\n            0x06e0,\n            0x06e1,\n            0x06e2,\n            0x06e3,\n            0x06e4,\n            0x06e7,\n            0x06e8,\n            0x06ea,\n            0x06eb,\n            0x06ec,\n            0x06ed // ARABIC SMALL LOW MEEM\n        ];\n    }\n    static get instance() {\n        if (this.m_instance === undefined) {\n            this.m_instance = new ContextualArabicConverter();\n        }\n        return this.m_instance;\n    }\n    /**\n     * Converts isolated arabic characters into their contextual form.\n     *\n     * @param input String with isolated arabic characters.\n     */\n    convert(input) {\n        let output = \"\";\n        for (let i = 0; i < input.length; ++i) {\n            const currentCodePoint = input.charCodeAt(i);\n            // Only process arabic characters in the map.\n            if (this.isArabicCharacter(currentCodePoint)) {\n                // Find the first previous non-neutral character.\n                let prevIndex = i - 1;\n                for (; prevIndex >= 0; --prevIndex) {\n                    if (!this.isNeutral(input.charCodeAt(prevIndex))) {\n                        break;\n                    }\n                }\n                // Check if the previous character has ligatures with following characters.\n                let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : undefined;\n                if (prevCodePoint !== undefined) {\n                    const prevMap = this.getCharacterMap(prevCodePoint);\n                    if (prevMap === undefined ||\n                        (prevMap[ContextualForm.Initial] === undefined &&\n                            prevMap[ContextualForm.Medial] === undefined)) {\n                        prevCodePoint = undefined;\n                    }\n                }\n                // Find the first next non-neutral character.\n                let nextIndex = i + 1;\n                for (; nextIndex < input.length; ++nextIndex) {\n                    if (!this.isNeutral(input.charCodeAt(nextIndex))) {\n                        break;\n                    }\n                }\n                // Check if the next character has ligatures with previous characters.\n                let nextCodePoint = nextIndex < input.length ? input.charCodeAt(nextIndex) : undefined;\n                if (nextCodePoint !== undefined) {\n                    const nextMap = this.getCharacterMap(nextCodePoint);\n                    if (nextMap === undefined ||\n                        (nextMap[ContextualForm.Medial] === undefined &&\n                            nextMap[ContextualForm.Final] === undefined)) {\n                        nextCodePoint = undefined;\n                    }\n                }\n                // Check for Lam Alef combinated forms.\n                if (currentCodePoint === 0x0644 &&\n                    nextCodePoint !== undefined &&\n                    (nextCodePoint === 0x0622 ||\n                        nextCodePoint === 0x0623 ||\n                        nextCodePoint === 0x0625 ||\n                        nextCodePoint === 0x0627)) {\n                    const combinedMap = this.getCombinedCharacterMap(currentCodePoint, nextCodePoint);\n                    if (prevCodePoint !== undefined) {\n                        output += String.fromCharCode(combinedMap[CombinedForm.Connected]);\n                    }\n                    else {\n                        output += String.fromCharCode(combinedMap[CombinedForm.Isolated]);\n                    }\n                    // Skip the next character and continue.\n                    ++i;\n                    continue;\n                }\n                // Check for single character contextual forms.\n                const map = this.getCharacterMap(currentCodePoint);\n                // Intermediate.\n                if (prevCodePoint !== undefined &&\n                    nextCodePoint !== undefined &&\n                    map[ContextualForm.Medial] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Medial]);\n                }\n                // Final.\n                else if (prevCodePoint !== undefined && map[ContextualForm.Final] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Final]);\n                }\n                // Initial.\n                else if (nextCodePoint !== undefined && map[ContextualForm.Initial] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Initial]);\n                }\n                // Isolated.\n                else {\n                    output += String.fromCharCode(currentCodePoint);\n                }\n            }\n            else {\n                output += String.fromCharCode(currentCodePoint);\n            }\n        }\n        return output;\n    }\n    isArabicCharacter(codePoint) {\n        return this.m_singleCharactersMap.has(codePoint);\n    }\n    getCharacterMap(codePoint) {\n        return this.m_singleCharactersMap.get(codePoint);\n    }\n    getCombinedCharacterMap(codePoint, nextCodePoint) {\n        const map = this.m_combinedCharactersMap.get(codePoint);\n        if (map !== undefined) {\n            return map.get(nextCodePoint);\n        }\n        return undefined;\n    }\n    isNeutral(codePoint) {\n        for (const character of this.m_neutralCharacters) {\n            if (character === codePoint) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.ContextualArabicConverter = ContextualArabicConverter;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/utils/ContextualArabicConverter.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js":
/*!************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TextMaterials_1 = __webpack_require__(/*! ../rendering/TextMaterials */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextMaterials.js\");\n/**\n * Helper function designed to create [[SdfTextMaterials]] that can be rendered using\n * [[TextCanvas]].\n *\n * @param params Material parameters.\n *\n * @returns New `SdfTextMaterial`.\n */\nfunction createSdfTextMaterial(params) {\n    return new TextMaterials_1.SdfTextMaterial({\n        texture: params.fontCatalog.texture,\n        textureSize: params.fontCatalog.textureSize,\n        size: params.fontCatalog.size,\n        distanceRange: params.fontCatalog.distanceRange,\n        isMsdf: params.fontCatalog.type === \"msdf\",\n        isBackground: params.isBackground === true,\n        vertexSource: params.vertexSource,\n        fragmentSource: params.fragmentSource\n    });\n}\nexports.createSdfTextMaterial = createSdfTextMaterial;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/utils/MaterialUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ \"./node_modules/@here/harp-text-canvas/lib/rendering/TextStyle.js\");\nconst UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ \"./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js\");\n/**\n * Collection of different constants and utility functions used by [[Typesetter]]s.\n */\nvar TypesettingUtils;\n(function (TypesettingUtils) {\n    /**\n     * Ratio between EMs and Pixels.\n     */\n    TypesettingUtils.EM_TO_PX = 16.0;\n    /**\n     * Ratio between Points and Pixels.\n     */\n    TypesettingUtils.PT_TO_PX = 1.25;\n    /**\n     * Angle used when emulating italic fonts (oblique).\n     */\n    TypesettingUtils.OBLIQUE_ANGLE = 0.174533;\n    /**\n     * Horizontal offset used when emulating italic fonts (oblique).\n     */\n    TypesettingUtils.OBLIQUE_OFFSET = Math.tan(TypesettingUtils.OBLIQUE_ANGLE);\n    /**\n     * Convert between any size specified in any [[FontUnit]] to pixels.\n     *\n     * @param size Font size (specified in `unit`).\n     * @param unit Size unit.\n     * @param originalSize Original size (pixels)\n     *\n     * @returns Pixel size.\n     */\n    function getPixelSize(size, unit, originalSize) {\n        let result = size;\n        switch (unit) {\n            case TextStyle_1.FontUnit.Em:\n                result *= TypesettingUtils.EM_TO_PX;\n                break;\n            case TextStyle_1.FontUnit.Point:\n                result *= TypesettingUtils.PT_TO_PX;\n                break;\n            case TextStyle_1.FontUnit.Percent:\n                result *= (1.0 / 100) * originalSize;\n                break;\n        }\n        return result;\n    }\n    TypesettingUtils.getPixelSize = getPixelSize;\n    /**\n     * Gets the scale applied to a certain character when using the [[FontVariant]].`SmallCaps`.\n     *\n     * @param glyphs Array containing [[TransformedGlyphData]].\n     * @param index Index to `glyphDataArray`.\n     * @param fontVariant Currently active [[FontVariant]].\n     *\n     * @returns Glyph `SmallCaps` scale.\n     */\n    function getSmallCapsScale(glyphs, smallCapsTransformations, index, fontVariant) {\n        const isSmallCaps = smallCapsTransformations[index] && fontVariant === TextStyle_1.FontVariant.SmallCaps;\n        return isSmallCaps\n            ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight\n            : 1.0;\n    }\n    TypesettingUtils.getSmallCapsScale = getSmallCapsScale;\n    /**\n     * Returns the first strong direction (LTR or RTL) found for a given array of [[GlyphData]].\n     *\n     * @param glyphs Array containing [[GlyphData]].\n     * @param offset `glyphDataArray` offset.\n     *\n     * @returns Strong direction.\n     */\n    function getDirection(glyphs, offset) {\n        let result = UnicodeUtils_1.UnicodeUtils.Direction.LTR;\n        let index = offset;\n        while (glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.LTR &&\n            glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.RTL &&\n            index < glyphs.length - 1) {\n            ++index;\n        }\n        if (Math.abs(glyphs[index].direction) === 1.0) {\n            result = glyphs[index].direction;\n        }\n        return result;\n    }\n    TypesettingUtils.getDirection = getDirection;\n    /**\n     * Computes the transformation matrix for a glyph.\n     *\n     * @param transform Matrix used to store the results.\n     * @param position Glyph' position.\n     * @param scale Glyph' scale.\n     * @param rotation [[TextCanvas]] rotation.\n     * @param localRotation Glyph' local rotation.\n     */\n    function computeGlyphTransform(transform, position, scale, rotation, localRotation) {\n        const cosAngle = Math.cos(rotation);\n        const sinAngle = Math.sin(rotation);\n        const localCosAngle = Math.cos(localRotation);\n        const localSinAngle = Math.sin(localRotation);\n        transform.set(scale * localCosAngle, scale * -localSinAngle, cosAngle * position.x - sinAngle * position.y, scale * localSinAngle, scale * localCosAngle, sinAngle * position.x + cosAngle * position.y, 0, 0, 1.0);\n    }\n    TypesettingUtils.computeGlyphTransform = computeGlyphTransform;\n    /**\n     * Updates the supplied bounds with the computed screen-space corners for a given glyph.\n     *\n     * @param corners Glyph' corners.\n     * @param globalBounds Global text bounds.\n     * @param individualBounds Individual per-character bounds.\n     */\n    function updateBounds(corners, globalBounds, individualBounds) {\n        const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n        const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n        if (individualBounds !== undefined) {\n            if (individualBounds.array[individualBounds.offset] !== undefined) {\n                individualBounds.array[individualBounds.offset].min.set(minX, minY);\n                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);\n            }\n            else {\n                individualBounds.array.push(new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY)));\n            }\n            ++individualBounds.offset;\n        }\n        globalBounds.min.set(Math.min(globalBounds.min.x, minX), Math.min(globalBounds.min.y, minY));\n        globalBounds.max.set(Math.max(globalBounds.max.x, maxX), Math.max(globalBounds.max.y, maxY));\n    }\n    TypesettingUtils.updateBounds = updateBounds;\n})(TypesettingUtils = exports.TypesettingUtils || (exports.TypesettingUtils = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/utils/TypesettingUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Namespace containing useful information when dealing with Unicode's code points.\n */\nvar UnicodeUtils;\n(function (UnicodeUtils) {\n    /**\n     * Range of Unicode code points considered as white space.\n     * https://en.wikipedia.org/wiki/Whitespace_character\n     */\n    UnicodeUtils.whiteSpaceRanges = [\n        [0x0009, 0x0009],\n        [0x0020, 0x0020],\n        [0x1680, 0x1680],\n        [0x2000, 0x2006],\n        [0x2008, 0x200a],\n        [0x205f, 0x3000],\n        [0x180e, 0x180e],\n        [0x200b, 0x200d]\n    ];\n    /**\n     * Checks if a character should be considered as a white space.\n     *\n     * @param codePoint Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    function isWhiteSpace(codePoint) {\n        for (const range of UnicodeUtils.whiteSpaceRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    UnicodeUtils.isWhiteSpace = isWhiteSpace;\n    /**\n     * Range of Unicode code points considered as `NewLine`.\n     * https://en.wikipedia.org/wiki/Newline#Unicode\n     */\n    UnicodeUtils.newLineRanges = [\n        [0x000a, 0x000d],\n        [0x0085, 0x0085],\n        [0x2028, 0x2029]\n    ];\n    /**\n     * Checks if a character should be considered as a new line.\n     *\n     * @param codePoint Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    function isNewLine(codePoint) {\n        for (const range of UnicodeUtils.newLineRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    UnicodeUtils.isNewLine = isNewLine;\n    /**\n     * Range of Unicode code points considered as non-printable.\n     * https://en.wikipedia.org/wiki/Unicode_control_characters\n     */\n    UnicodeUtils.nonPrintableRanges = [\n        [0x0000, 0x001f],\n        [0x007f, 0x009f]\n    ];\n    /**\n     * Checks if a character's can be printed (rendered).\n     *\n     * @param codePoint Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    function isPrintable(codePoint) {\n        for (const range of UnicodeUtils.nonPrintableRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    UnicodeUtils.isPrintable = isPrintable;\n    /**\n     * Unicode code point direction.\n     */\n    let Direction;\n    (function (Direction) {\n        Direction[Direction[\"Neutral\"] = 0] = \"Neutral\";\n        Direction[Direction[\"Weak\"] = 0.5] = \"Weak\";\n        Direction[Direction[\"LTR\"] = 1] = \"LTR\";\n        Direction[Direction[\"RTL\"] = -1] = \"RTL\";\n    })(Direction = UnicodeUtils.Direction || (UnicodeUtils.Direction = {}));\n    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).\n    /**\n     * Unicode Blocks which have inherent RTL direction.\n     * These blocks correspond to the scripts described here:\n     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts\n     */\n    UnicodeUtils.rtlBlocks = [\n        \"Hebrew\",\n        \"Alphabetic Presentation Forms\",\n        \"Arabic\",\n        \"Arabic Supplement\",\n        \"Arabic Extended-A\",\n        \"Arabic Presentation Forms-A\",\n        \"Arabic Presentation Forms-B\",\n        \"Arabic Mathematical Alphabetic Symbols\",\n        \"Indic Siyaq Numbers\",\n        \"Rumi Numeral Symbols\",\n        \"Syriac\",\n        \"Syriac Supplement\",\n        \"Samaritan\",\n        \"Mandaic\",\n        \"Thaana\",\n        \"Mende Kikakui\",\n        \"NKo\",\n        \"Adlam\",\n        \"Hanifi Rohingya\"\n    ];\n    /**\n     * ASCII punctuation is considered to have neutral direction:\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     */\n    UnicodeUtils.neutralBidirectionalRanges = [\n        [0x0020, 0x002f],\n        [0x003a, 0x0040],\n        [0x005b, 0x0060],\n        [0x007b, 0x007e]\n    ];\n    /**\n     * Latin and arabic numerals are considered to have weak directionality:\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block\n     */\n    UnicodeUtils.weakBidirectionalRanges = [\n        [0x0030, 0x0039],\n        [0x0660, 0x0669],\n        [0x06f0, 0x06f9]\n    ];\n    /**\n     * Returns the Unicode's character direction.\n     *\n     * @param codePoint Character's Unicode code point.\n     * @param block Character's Unicode block.\n     *\n     * @returns Character's direction.\n     */\n    function getDirection(codePoint, block) {\n        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).\n        for (const weakRange of UnicodeUtils.weakBidirectionalRanges) {\n            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {\n                return Direction.Weak;\n            }\n        }\n        for (const neutralRange of UnicodeUtils.neutralBidirectionalRanges) {\n            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {\n                return Direction.Neutral;\n            }\n        }\n        // Check for RTL/LTR.\n        const rtl = UnicodeUtils.rtlBlocks.find(element => {\n            return element === block;\n        });\n        if (rtl !== undefined) {\n            return Direction.RTL;\n        }\n        else {\n            return Direction.LTR;\n        }\n    }\n    UnicodeUtils.getDirection = getDirection;\n    /**\n     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering\n     * a RTL string to preserve their intrinsic meaning.\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     */\n    UnicodeUtils.rtlMirroredCodePoints = [\n        0x0028,\n        0x0029,\n        0x003c,\n        0x003e,\n        0x005b,\n        0x005d,\n        0x007b,\n        0x007d\n    ];\n    /**\n     * Checks if a character should be mirrored on an RTL run.\n     *\n     * @param codePoint Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    function isRtlMirrored(codePoint) {\n        return (UnicodeUtils.rtlMirroredCodePoints.find(element => {\n            return element === codePoint;\n        }) !== undefined);\n    }\n    UnicodeUtils.isRtlMirrored = isRtlMirrored;\n})(UnicodeUtils = exports.UnicodeUtils || (exports.UnicodeUtils = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-text-canvas/lib/utils/UnicodeUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-transfer-manager/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-transfer-manager/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./src/TransferManager */ \"./node_modules/@here/harp-transfer-manager/src/TransferManager.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-transfer-manager/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-transfer-manager/src/TransferManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@here/harp-transfer-manager/src/TransferManager.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module\n *\n * This module provides classes to ease downloading URLs. In particular, following redirects,\n * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.\n */\n__webpack_require__(/*! @here/harp-fetch */ \"./node_modules/@here/harp-fetch/index.web.js\");\n/** @internal\n * DeferredPromise takes an executor function for executing it later, when [[exec]] is called.\n * This class allows wrapping other promises or long running functions for later execution.\n */\nclass DeferredPromise {\n    constructor(executor) {\n        this.executor = executor;\n        this.doExec = false;\n        this.promise = new Promise((resolve, reject) => {\n            this.resolveFunc = resolve;\n            this.rejectFunc = reject;\n            if (this.doExec) {\n                this.execInnerPromise(this.resolveFunc, this.rejectFunc);\n            }\n        });\n    }\n    /**\n     * When `exec` is called the deferred executor function is executed.\n     */\n    exec() {\n        if (this.resolveFunc === undefined || this.rejectFunc === undefined) {\n            // deferred promise not yet initialized - handle it in callback above\n            this.doExec = true;\n            return;\n        }\n        this.execInnerPromise(this.resolveFunc, this.rejectFunc);\n    }\n    execInnerPromise(resolveFunc, rejectFunc) {\n        this.executor()\n            .then(result => resolveFunc(result))\n            .catch(err => rejectFunc(err));\n    }\n}\n/**\n * `TransferManager` for downloading URLs.\n *\n * Features:\n *\n * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded\n *   once.\n * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that\n *   would otherwise stall the browser.\n * * Retries the downloads with an increasing timeout on HTTP 503 replies.\n *\n * The static method [[instance]] can be used to get a default constructed instance.\n */\nclass TransferManager {\n    /**\n     * Constructs a new [[TransferManager]].\n     *\n     * @param fetchFunction The default fetch function to use.\n     * @param maxRetries The maximum amount to try to re-fetch a resource.\n     */\n    constructor(fetchFunction = fetch, maxRetries = 5) {\n        this.fetchFunction = fetchFunction;\n        this.maxRetries = maxRetries;\n        this.activeDownloadCount = 0;\n        this.downloadQueue = new Array();\n        this.activeDownloads = new Map();\n    }\n    /**\n     * Returns a default instance of [[TransferManager]].\n     */\n    static instance() {\n        return TransferManager.defaultInstance;\n    }\n    static async fetchRepeatedly(fetchFunction, retryCount, maxRetries, url, init) {\n        try {\n            const response = await fetchFunction(url, init);\n            if (response.status !== 503 || retryCount > maxRetries) {\n                return response;\n            }\n        }\n        catch (err) {\n            if (err.hasOwnProperty(\"isCancelled\") ||\n                (err.hasOwnProperty(\"name\") && err.name === \"AbortError\") ||\n                retryCount > maxRetries) {\n                throw err;\n            }\n        }\n        return TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() => TransferManager.fetchRepeatedly(fetchFunction, maxRetries, retryCount + 1, url, init));\n    }\n    static waitFor(milliseconds) {\n        return new Promise(resolve => setTimeout(resolve, milliseconds));\n    }\n    /**\n     * Downloads a JSON object. Merges downloads if requested multiple times.\n     *\n     * Note: This method merges multiple downloads of the same resource to\n     * only one request. The init parameter is ignored if the download is merged.\n     * Call [[download]] instead to download the resource without merging.\n     *\n     * @param url The URL to download\n     * @param init Optional extra parameters for the download.\n     */\n    downloadJson(url, init) {\n        return this.downloadAs(response => response.json(), url, init);\n    }\n    /**\n     * Downloads a binary object. Merges downloads if requested multiple times.\n     *\n     * Note: This method merges multiple downloads of the same resource to\n     * only one request. The init parameter is ignored if the download is merged.\n     * Call [[download]] instead to download the resource without merging.\n     *\n     * @param url The URL to download\n     * @param init Optional extra parameters for the download\n     */\n    downloadArrayBuffer(url, init) {\n        return this.download(url, init).then(response => response.arrayBuffer());\n    }\n    /**\n     * Downloads a URL and returns the response.\n     *\n     * Does not merge multiple requests to the same URL.\n     *\n     * @param url The URL to download.\n     * @param init Optional extra parameters for the download.\n     */\n    download(url, init) {\n        if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {\n            const deferred = new DeferredPromise(() => this.doDownload(url, init));\n            this.downloadQueue.push(deferred);\n            return deferred.promise;\n        }\n        return this.doDownload(url, init);\n    }\n    doDownload(url, init) {\n        ++this.activeDownloadCount;\n        return TransferManager.fetchRepeatedly(this.fetchFunction, 0, this.maxRetries, url, init)\n            .then(response => {\n            this.onDownloadDone();\n            return response;\n        })\n            .catch(err => {\n            this.onDownloadDone();\n            throw err;\n        });\n    }\n    onDownloadDone() {\n        --this.activeDownloadCount;\n        this.execDeferredDownload();\n    }\n    execDeferredDownload() {\n        const future = this.downloadQueue.pop();\n        if (future === undefined) {\n            return;\n        }\n        future.exec();\n    }\n    downloadAs(converter, url, init) {\n        const cacheKey = url;\n        const pendingFetch = this.activeDownloads.get(cacheKey);\n        if (pendingFetch !== undefined) {\n            return Promise.resolve(pendingFetch);\n        }\n        const newFetch = this.download(url, init)\n            .then(response => {\n            this.activeDownloads.delete(cacheKey);\n            if (response.ok) {\n                return converter(response);\n            }\n            throw new Error(JSON.stringify(response));\n        })\n            .catch(err => {\n            this.activeDownloads.delete(cacheKey);\n            throw err;\n        });\n        this.activeDownloads.set(cacheKey, newFetch);\n        return newFetch;\n    }\n}\nexports.TransferManager = TransferManager;\n/**\n * The timeout in milliseconds to wait between retries. This timeout is multiplied with the\n * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and\n * so on.\n */\nTransferManager.retryTimeout = 500;\n/**\n * The amount of maximum parallel downloads to allow.\n */\nTransferManager.maxParallelDownloads = 16;\nTransferManager.defaultInstance = new TransferManager();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-transfer-manager/src/TransferManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/index-common.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-utils/index-common.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./lib/GroupedPriorityList */ \"./node_modules/@here/harp-utils/lib/GroupedPriorityList.js\"));\n__export(__webpack_require__(/*! ./lib/Logger */ \"./node_modules/@here/harp-utils/lib/Logger/index.js\"));\n__export(__webpack_require__(/*! ./lib/Math2D */ \"./node_modules/@here/harp-utils/lib/Math2D.js\"));\n__export(__webpack_require__(/*! ./lib/MathUtils */ \"./node_modules/@here/harp-utils/lib/MathUtils.js\"));\n__export(__webpack_require__(/*! ./lib/Mixins */ \"./node_modules/@here/harp-utils/lib/Mixins.js\"));\n__export(__webpack_require__(/*! ./lib/assert */ \"./node_modules/@here/harp-utils/lib/assert.js\"));\n__export(__webpack_require__(/*! ./lib/ContextLogger */ \"./node_modules/@here/harp-utils/lib/ContextLogger.js\"));\n__export(__webpack_require__(/*! ./lib/PerformanceTimer */ \"./node_modules/@here/harp-utils/lib/PerformanceTimer.js\"));\n__export(__webpack_require__(/*! ./lib/ObjectUtils */ \"./node_modules/@here/harp-utils/lib/ObjectUtils.js\"));\n__export(__webpack_require__(/*! ./lib/OptionsUtils */ \"./node_modules/@here/harp-utils/lib/OptionsUtils.js\"));\n__export(__webpack_require__(/*! ./lib/UriResolver */ \"./node_modules/@here/harp-utils/lib/UriResolver.js\"));\n__export(__webpack_require__(/*! ./lib/UrlUtils */ \"./node_modules/@here/harp-utils/lib/UrlUtils.js\"));\n__export(__webpack_require__(/*! ./lib/Functions */ \"./node_modules/@here/harp-utils/lib/Functions.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/index-common.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/index.web.js":
/*!****************************************************!*\
  !*** ./node_modules/@here/harp-utils/index.web.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./index-common */ \"./node_modules/@here/harp-utils/index-common.js\"));\n__export(__webpack_require__(/*! ./lib/UrlPlatformUtils.web */ \"./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/index.web.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/ContextLogger.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/ContextLogger.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Context-aware logger that decorates log message with stack-based prefix, emits `headerMessage`\n * before first actual log message.\n */\nclass ContextLogger {\n    /**\n     * Construct a context-aware logger that logs to `m_logger`.\n     */\n    constructor(m_logger, headerMessage) {\n        this.m_logger = m_logger;\n        this.headerMessage = headerMessage;\n        this.context = [];\n        this.m_headerLogged = false;\n        // They, are public member functions it's just tslint who doesn't understand this.\n        // tslint:disable:member-ordering\n        this.warn = this.createLogMethod(\"warn\");\n        this.info = this.createLogMethod(\"info\");\n        this.error = this.createLogMethod(\"error\");\n    }\n    /**\n     * Push \"attribute-like\" context.\n     *\n     * Following log messages will be prefixed with `name` or `.name` depending on current context.\n     */\n    pushAttr(name) {\n        this.context.push(`${this.context.length > 0 ? \".\" : \"\"}${name}`);\n    }\n    /**\n     * Push \"index-like\" context.\n     *\n     * Following log messages will be prefixed with `[index]`.\n     */\n    pushIndex(index) {\n        this.context.push(`[${index}]`);\n    }\n    pop() {\n        this.context.pop();\n    }\n    // tslint:enable:member-ordering\n    createLogMethod(severity) {\n        return (message, ...rest) => {\n            if (!this.m_headerLogged) {\n                this.m_logger.info(this.headerMessage);\n                this.m_headerLogged = true;\n            }\n            this.m_logger[severity](`${this.context.join(\"\")}: ${message}`, ...rest);\n        };\n    }\n}\nexports.ContextLogger = ContextLogger;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/ContextLogger.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Functions.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Functions.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Chains two functions for further assigning as one wrapped callback function\n */\nfunction chainCallbacks(f1, f2) {\n    return function (...args) {\n        if (f1) {\n            f1.apply(this, args);\n        }\n        return f2.apply(this, args);\n    };\n}\nexports.chainCallbacks = chainCallbacks;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Functions.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/GroupedPriorityList.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/GroupedPriorityList.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The `PriorityListGroup` contains a list of [[PriorityListElement]]s that all have the same\n * (integer) priority.\n */\nclass PriorityListGroup {\n    constructor(priority, elements = new Array()) {\n        this.priority = priority;\n        this.elements = elements;\n    }\n    /**\n     * Create and return a deep copy of the `PriorityListGroup<T>`.\n     *\n     * @returns A clone of the `PriorityListGroup<T>`.\n     */\n    clone() {\n        return new PriorityListGroup(this.priority, this.elements.slice());\n    }\n}\nexports.PriorityListGroup = PriorityListGroup;\n/**\n * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items\n * in priority groups.\n */\nclass GroupedPriorityList {\n    constructor() {\n        this.groups = new Map();\n    }\n    /**\n     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.\n     *\n     * @param element Element to be added.\n     */\n    add(element) {\n        this.getGroup(element.priority).elements.push(element);\n    }\n    /**\n     * Remove an element from the `GroupedPriorityList`.\n     *\n     * Note: It is required that the priority is the same as it was when the element has been added.\n     * Otherwise, the removal will fail.\n     *\n     * @param element Element to be removed.\n     * @returns `True` if the element was removed, `false` otherwise.\n     */\n    remove(element) {\n        const group = this.getGroup(element.priority);\n        if (group !== undefined) {\n            const foundIndex = group.elements.indexOf(element);\n            if (foundIndex >= 0) {\n                group.elements.splice(foundIndex, 1);\n                if (group.elements.length === 0) {\n                    const normalizedPriority = Math.floor(element.priority);\n                    this.groups.delete(normalizedPriority);\n                    if (this.m_sortedGroups) {\n                        this.m_sortedGroups = [];\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Remove all internal [[PriorityListGroup]]s.\n     */\n    clear() {\n        this.groups.clear();\n        if (this.m_sortedGroups) {\n            this.m_sortedGroups = [];\n        }\n    }\n    /**\n     * Merge another [[GroupedPriorityList]] into this one.\n     *\n     * @param other Other group to merge.\n     */\n    merge(other) {\n        for (const otherGroup of other.groups) {\n            const group = this.findGroup(otherGroup[1].priority);\n            if (group === undefined) {\n                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());\n                if (this.m_sortedGroups) {\n                    this.m_sortedGroups = [];\n                }\n                continue;\n            }\n            group.elements = group.elements.concat(otherGroup[1].elements);\n        }\n        return this;\n    }\n    /**\n     * Return a sorted list of [[PriorityListGroup]]s.\n     */\n    get sortedGroups() {\n        if (this.m_sortedGroups && this.m_sortedGroups.length > 0) {\n            return this.m_sortedGroups;\n        }\n        if (!this.m_sortedGroups) {\n            this.m_sortedGroups = [];\n        }\n        for (const priorityList of this.groups) {\n            this.m_sortedGroups.push(priorityList[1]);\n        }\n        this.m_sortedGroups.sort((a, b) => {\n            return b.priority - a.priority;\n        });\n        return this.m_sortedGroups;\n    }\n    /**\n     * Apply function to all elements in this `GroupedPriorityList`.\n     *\n     * @param {(element: T) => void} fun Function to apply.\n     */\n    forEach(fun) {\n        for (const group of this.groups) {\n            group[1].elements.forEach(fun);\n        }\n    }\n    /**\n     * Count the number of elements in this `GroupedPriorityList`.\n     */\n    count() {\n        let n = 0;\n        for (const group of this.groups) {\n            n += group[1].elements.length;\n        }\n        return n;\n    }\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority The priority to retrieve all elements from.\n     */\n    findGroup(priority) {\n        const normalizedPriority = Math.floor(priority);\n        const group = this.groups.get(normalizedPriority);\n        return group;\n    }\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority The priority to retrieve all elements from.\n     */\n    getGroup(priority) {\n        let group = this.findGroup(priority);\n        if (group === undefined) {\n            const normalizedPriority = Math.floor(priority);\n            group = new PriorityListGroup(normalizedPriority);\n            this.groups.set(normalizedPriority, group);\n            if (this.m_sortedGroups) {\n                this.m_sortedGroups = [];\n            }\n        }\n        return group;\n    }\n}\nexports.GroupedPriorityList = GroupedPriorityList;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/GroupedPriorityList.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js":
/*!********************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class for the default console channel.\n */\nclass ConsoleChannel {\n    error(message, ...optionalParams) {\n        // tslint:disable-next-line:no-console\n        console.error(message, ...optionalParams);\n    }\n    debug(message, ...optionalParams) {\n        // tslint:disable-next-line:no-console\n        console.debug(message, ...optionalParams);\n    }\n    info(message, ...optionalParams) {\n        // tslint:disable-next-line:no-console\n        console.info(message, ...optionalParams);\n    }\n    log(message, ...optionalParams) {\n        // tslint:disable-next-line:no-console\n        console.log(message, ...optionalParams);\n    }\n    trace(message, ...optionalParams) {\n        // tslint:disable-next-line:no-console\n        console.trace(message, ...optionalParams);\n    }\n    warn(message, ...optionalParams) {\n        // tslint:disable-next-line:no-console\n        console.warn(message, ...optionalParams);\n    }\n}\nexports.ConsoleChannel = ConsoleChannel;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/ILogger.js":
/*!*************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/ILogger.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Enum log levels\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Log\"] = 2] = \"Log\";\n    LogLevel[LogLevel[\"Info\"] = 3] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 4] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 5] = \"Error\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n/**\n * Logger options to configure logger\n */\nclass LoggerOptions {\n}\nexports.LoggerOptions = LoggerOptions;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/ILogger.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/Logger.js":
/*!************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/Logger.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ILogger_1 = __webpack_require__(/*! ./ILogger */ \"./node_modules/@here/harp-utils/lib/Logger/ILogger.js\");\n/**\n * Logger class.\n */\nclass Logger {\n    constructor(name, m_channel, options) {\n        this.name = name;\n        this.m_channel = m_channel;\n        this.enabled = true;\n        this.level = ILogger_1.LogLevel.Trace;\n        if (options !== undefined) {\n            this.update(options);\n        }\n    }\n    error(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Error) {\n            this.m_channel.error(this.prefix, message, ...optionalParams);\n        }\n    }\n    debug(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Debug) {\n            this.m_channel.debug(this.prefix, message, ...optionalParams);\n        }\n    }\n    info(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Info) {\n            this.m_channel.info(this.prefix, message, ...optionalParams);\n        }\n    }\n    log(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Log) {\n            this.m_channel.log(this.prefix, message, ...optionalParams);\n        }\n    }\n    trace(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Trace) {\n            this.m_channel.trace(this.prefix, message, ...optionalParams);\n        }\n    }\n    warn(message, ...optionalParams) {\n        if (this.enabled && this.level <= ILogger_1.LogLevel.Warn) {\n            this.m_channel.warn(this.prefix, message, ...optionalParams);\n        }\n    }\n    update(options) {\n        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;\n        this.level = options.level === undefined ? this.level : options.level;\n    }\n    get prefix() {\n        return this.name + \":\";\n    }\n}\nexports.Logger = Logger;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/Logger.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LoggerManagerImpl_1 = __webpack_require__(/*! ./LoggerManagerImpl */ \"./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js\");\n/**\n * The LoggerManager class implements a singleton object that handles logging.\n *\n * Example:\n *\n * ```typescript\n *\n * const logger = LoggerManager.instance.create(\"MyFontLoaderClass\");\n * if (missingFonts.length > 0) {\n *     logger.error(\"These fonts can not be loaded: \", missingFonts);\n * } else {\n *     logger.log(\"All fonts have been loaded.\");\n * }\n * ```\n */\nclass LoggerManager {\n    static get instance() {\n        return this.m_instance || (this.m_instance = new LoggerManagerImpl_1.LoggerManagerImpl());\n    }\n}\nexports.LoggerManager = LoggerManager;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ConsoleChannel_1 = __webpack_require__(/*! ./ConsoleChannel */ \"./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js\");\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/@here/harp-utils/lib/Logger/Logger.js\");\nconst WorkerChannel_1 = __webpack_require__(/*! ./WorkerChannel */ \"./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js\");\n/**\n * LoggerManagerImpl is the class for the singleton instance of the logger manager.\n * It handles channels and loggers.\n */\nclass LoggerManagerImpl {\n    constructor() {\n        this.m_loggers = [];\n        this.channel =\n            typeof self === \"undefined\" || typeof self.document !== \"undefined\"\n                ? new ConsoleChannel_1.ConsoleChannel()\n                : new WorkerChannel_1.WorkerChannel();\n    }\n    getLoggerNames() {\n        return this.m_loggers.map(logger => logger.name);\n    }\n    getLogger(name) {\n        return this.m_loggers.find(logger => logger.name === name);\n    }\n    create(loggerName, options = {}) {\n        if (this.m_levelSetForAll !== undefined &&\n            (options.level === undefined || options.level < this.m_levelSetForAll)) {\n            options.level = this.m_levelSetForAll;\n        }\n        const logger = new Logger_1.Logger(loggerName, this.channel, options);\n        this.m_loggers.push(logger);\n        return logger;\n    }\n    dispose(logger) {\n        const found = this.m_loggers.indexOf(logger);\n        if (found < 0) {\n            throw new Error(`Cannot unregister \"${logger}\" : no such logger registered.`);\n        }\n        this.m_loggers.splice(found, 1);\n    }\n    updateAll(options) {\n        for (const logger of this.m_loggers) {\n            logger.update(options);\n        }\n    }\n    update(loggerName, config) {\n        for (const logger of this.m_loggers) {\n            if (logger.name === loggerName) {\n                logger.update(config);\n            }\n        }\n    }\n    enableAll(enabled) {\n        for (const logger of this.m_loggers) {\n            logger.enabled = enabled;\n        }\n    }\n    enable(loggerName, value) {\n        this.update(loggerName, { enabled: value });\n    }\n    setLogLevelForAll(level) {\n        this.m_levelSetForAll = level;\n        for (const logger of this.m_loggers) {\n            logger.level = level;\n        }\n    }\n    setLogLevel(loggerName, level) {\n        this.update(loggerName, { level });\n    }\n    setChannel(channel) {\n        this.channel = channel;\n    }\n}\nexports.LoggerManagerImpl = LoggerManagerImpl;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/LoggerManagerImpl.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class allowing mixing several channels.\n */\nclass MultiChannel {\n    constructor(...channels) {\n        this.channels = [];\n        this.channels = channels;\n    }\n    error(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.error(message, ...optionalParams);\n        }\n    }\n    debug(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.debug(message, ...optionalParams);\n        }\n    }\n    info(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.info(message, ...optionalParams);\n        }\n    }\n    log(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.log(message, ...optionalParams);\n        }\n    }\n    trace(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.trace(message, ...optionalParams);\n        }\n    }\n    warn(message, ...optionalParams) {\n        for (const channel of this.channels) {\n            channel.warn(message, ...optionalParams);\n        }\n    }\n}\nexports.MultiChannel = MultiChannel;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ILogger_1 = __webpack_require__(/*! ./ILogger */ \"./node_modules/@here/harp-utils/lib/Logger/ILogger.js\");\nexports.WORKERCHANNEL_MSG_TYPE = \"worker-channel-message\";\n/**\n * The class for the worker channel.\n */\nclass WorkerChannel {\n    error(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Error\n        };\n        self.postMessage(workerMessage);\n    }\n    debug(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Debug\n        };\n        self.postMessage(workerMessage);\n    }\n    info(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Info\n        };\n        self.postMessage(workerMessage);\n    }\n    log(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Log\n        };\n        self.postMessage(workerMessage);\n    }\n    trace(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Trace\n        };\n        self.postMessage(workerMessage);\n    }\n    warn(message, ...optionalParams) {\n        const workerMessage = {\n            message: [message, ...optionalParams],\n            type: exports.WORKERCHANNEL_MSG_TYPE,\n            level: ILogger_1.LogLevel.Warn\n        };\n        self.postMessage(workerMessage);\n    }\n}\nexports.WorkerChannel = WorkerChannel;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Logger/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Logger/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./ConsoleChannel */ \"./node_modules/@here/harp-utils/lib/Logger/ConsoleChannel.js\"));\n__export(__webpack_require__(/*! ./ILogger */ \"./node_modules/@here/harp-utils/lib/Logger/ILogger.js\"));\n__export(__webpack_require__(/*! ./Logger */ \"./node_modules/@here/harp-utils/lib/Logger/Logger.js\"));\n__export(__webpack_require__(/*! ./LoggerManager */ \"./node_modules/@here/harp-utils/lib/Logger/LoggerManager.js\"));\n__export(__webpack_require__(/*! ./MultiChannel */ \"./node_modules/@here/harp-utils/lib/Logger/MultiChannel.js\"));\n__export(__webpack_require__(/*! ./WorkerChannel */ \"./node_modules/@here/harp-utils/lib/Logger/WorkerChannel.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Logger/index.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Math2D.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Math2D.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Math2D;\n(function (Math2D) {\n    /**\n     * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n     * objects with two numbers each). Should be faster.\n     */\n    class Box {\n        /**\n         * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n         * objects with two numbers each). Should be faster.\n         *\n         * @param x New X value.\n         * @param y New y value.\n         * @param w New w value.\n         * @param h New h value.\n         */\n        constructor(x = 0, y = 0, w = 0, h = 0) {\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n        }\n        /**\n         * Set new values to all properties of the box.\n         *\n         * @param x New X value.\n         * @param y New y value.\n         * @param w New w value.\n         * @param h New h value.\n         */\n        set(x, y, w, h) {\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n        }\n        /**\n         * Test box for inclusion of point.\n         *\n         * @param x X coordinate of point.\n         * @param y Y coordinate of point.\n         */\n        contains(x, y) {\n            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;\n        }\n        /**\n         * Test box for inclusion of another box.\n         *\n         * @param other Box 2 to test for inclusion.\n         */\n        containsBox(other) {\n            const xmax = other.x + other.w;\n            const ymax = other.y + other.h;\n            return (this.contains(other.x, other.y) &&\n                this.contains(xmax, other.y) &&\n                this.contains(other.x, ymax) &&\n                this.contains(xmax, ymax));\n        }\n        /**\n         * Test two boxes for intersection.\n         *\n         * @param other Box 2 to test for intersection.\n         */\n        intersects(other) {\n            return (this.x <= other.x + other.w &&\n                this.x + this.w >= other.x &&\n                this.y <= other.y + other.h &&\n                this.y + this.h >= other.y);\n        }\n    }\n    Math2D.Box = Box;\n    /**\n     * Compute squared distance between two 2D points `a` and `b`.\n     *\n     * @param ax Point a.x\n     * @param ay Point a.y\n     * @param bx Point b.x\n     * @param by Point b.y\n     * @returns Squared distance between the two points\n     */\n    function distSquared(ax, ay, bx, by) {\n        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);\n    }\n    Math2D.distSquared = distSquared;\n    /**\n     * Computes the squared length of a line.\n     *\n     * @param line An array of that forms a line via [x,y,z,x,y,z,...] tuples.\n     */\n    function computeSquaredLineLength(line) {\n        let squaredLineLength = 0;\n        const length = line.length - 4;\n        for (let i = 0; i < length; i += 3) {\n            const xDiff = line[i + 3] - line[i];\n            const yDiff = line[i + 4] - line[i + 1];\n            squaredLineLength += xDiff * xDiff + yDiff * yDiff;\n        }\n        return squaredLineLength;\n    }\n    Math2D.computeSquaredLineLength = computeSquaredLineLength;\n    /**\n     * Compute squared distance between a 2D point and a 2D line segment.\n     *\n     * @param px Test point X\n     * @param py Test point y\n     * @param l0x Line segment start X\n     * @param l0y Line segment start Y\n     * @param l1x Line segment end X\n     * @param l1y Line segment end Y\n     * @returns Squared distance between point and line segment\n     */\n    function distToSegmentSquared(px, py, l0x, l0y, l1x, l1y) {\n        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);\n        if (lineLengthSuared === 0) {\n            return distSquared(px, py, l0x, l0y);\n        }\n        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;\n        t = Math.max(0, Math.min(1, t));\n        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));\n    }\n    Math2D.distToSegmentSquared = distToSegmentSquared;\n})(Math2D = exports.Math2D || (exports.Math2D = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Math2D.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/MathUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/MathUtils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MathUtils;\n(function (MathUtils) {\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value The value to be clamped.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     *\n     * @returns Clamped value.\n     */\n    function clamp(value, min, max) {\n        return value < min ? min : value > max ? max : value;\n    }\n    MathUtils.clamp = clamp;\n    /**\n     * Returns a linear interpolation between the values of edge0 and edge1 based on the factor.\n     *\n     * Given two known points the linear interpolant between these points may be presented as\n     * straight line. This means that for given factor change the resulting change of return\n     * value is always const.\n     * @see https://en.wikipedia.org/wiki/Linear_interpolation\n     *\n     * @param edge0\n     * @param edge1\n     * @param factor Interpolation factor that ranges between: 0 <= x <= 1.\n     */\n    function lerp(edge0, edge1, factor) {\n        return edge0 * (1 - factor) + edge1 * factor;\n    }\n    MathUtils.lerp = lerp;\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0\n     * @param edge1\n     * @param x\n     */\n    function smoothStep(edge0, edge1, x) {\n        // Scale, bias and saturate x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * (3 - 2 * x);\n    }\n    MathUtils.smoothStep = smoothStep;\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     *\n     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and\n     * `x = 1`:\n     *\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0\n     * @param edge1\n     * @param x\n     */\n    function smootherStep(edge0, edge1, x) {\n        // Scale, and clamp x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * x * (x * (x * 6 - 15) + 10);\n    }\n    MathUtils.smootherStep = smootherStep;\n    /**\n     * Maps a number from one range to another.\n     *\n     * @param val The incoming value to be converted.\n     * @param inMin Lower bound of the value's current range.\n     * @param inMax Upper bound of the value's current range.\n     * @param outMin Lower bound of the value's target range.\n     * @param outMax Upper bound of the value's target range.\n     */\n    function map(val, inMin, inMax, outMin, outMax) {\n        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n    }\n    MathUtils.map = map;\n    /**\n     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a First number.\n     * @param b Second number.\n     */\n    function min2(a, b) {\n        let result;\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.min(result, b);\n        }\n        return result;\n    }\n    MathUtils.min2 = min2;\n    /**\n     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a First number.\n     * @param b Second number.\n     */\n    function max2(a, b) {\n        let result;\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.max(result, b);\n        }\n        return result;\n    }\n    MathUtils.max2 = max2;\n    /**\n     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be\n     * undefined, in which case their value is ignored.\n     *\n     * @param value Value to check.\n     * @param lowerBound The lower bound to check the value against.\n     * @param upperBound The upper bound to check the value against.\n     *\n     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`\n     *          otherwise.\n     */\n    function isClamped(value, lowerBound, upperBound) {\n        if (lowerBound !== undefined && value < lowerBound) {\n            return false;\n        }\n        if (upperBound !== undefined && value > upperBound) {\n            return false;\n        }\n        return true;\n    }\n    MathUtils.isClamped = isClamped;\n    /**\n     * Smoothly interpolates between two values using cubic formula\n     *\n     * @param startValue\n     * @param endValue\n     * @param time\n     * @returns Result of the interpolation within the range of `[startValue, endValue]`\n     */\n    function easeInOutCubic(startValue, endValue, time) {\n        const timeValue = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n        return startValue + (endValue - startValue) * timeValue;\n    }\n    MathUtils.easeInOutCubic = easeInOutCubic;\n})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/MathUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/Mixins.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/Mixins.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Copy methods and properties from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor Class to mix methods and properties into.\n * @param baseCtors Class to take all methods and properties from.\n */\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\nexports.applyMixins = applyMixins;\n/**\n * Copy methods from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor Class to mix methods into.\n * @param baseCtors Class to take all methods from.\n */\nfunction applyMixinsWithoutProperties(derivedCtor, baseCtors) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);\n            if (descriptor !== undefined &&\n                descriptor.get === undefined &&\n                name !== \"constructor\") {\n                derivedCtor.prototype[name] = baseCtor.prototype[name];\n            }\n        });\n    });\n}\nexports.applyMixinsWithoutProperties = applyMixinsWithoutProperties;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/Mixins.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/ObjectUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/ObjectUtils.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Deep clone of object.\n *\n * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,\n * object), `Date` and `RegExp`s and cycles.\n *\n * Throws error if enounters object with `prototype` assuming that in general class instances\n * cannot be reliably cloned by generic algorithm.\n */\nfunction cloneDeep(obj) {\n    const cache = new Map();\n    function cloneInternal(src) {\n        if (src === null) {\n            return null;\n        }\n        else if (typeof src === \"object\") {\n            const cached = cache.get(src);\n            if (cached !== undefined) {\n                return cached;\n            }\n            if (Array.isArray(src)) {\n                const result = [];\n                cache.set(src, result);\n                result.length = src.length;\n                for (let i = 0; i < result.length; ++i) {\n                    result[i] = cloneInternal(src[i]);\n                }\n                return result;\n            }\n            else if (src instanceof Date) {\n                const result = new Date(src.getTime());\n                cache.set(src, result);\n                return result;\n            }\n            else if (src instanceof RegExp) {\n                const result = new RegExp(src.source, src.flags);\n                cache.set(src, result);\n                return result;\n            }\n            else if (src.constructor !== Object) {\n                throw new Error(\"cloneDeep doesn't support objects with custom prototypes\");\n            }\n            else {\n                const result = {};\n                cache.set(src, result);\n                for (const key in src) {\n                    if (src.hasOwnProperty(key)) {\n                        result[key] = cloneInternal(src[key]);\n                    }\n                }\n                return result;\n            }\n        }\n        else {\n            // string, number, boolean, undefined and functions are returned as is\n            return src;\n        }\n    }\n    const r = cloneInternal(obj);\n    cache.clear();\n    return r;\n}\nexports.cloneDeep = cloneDeep;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/ObjectUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/OptionsUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/OptionsUtils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getOptionValue(...values) {\n    for (const candidate of values) {\n        if (candidate !== undefined && candidate !== null) {\n            return candidate;\n        }\n    }\n    return undefined;\n}\nexports.getOptionValue = getOptionValue;\n/**\n * Merge options into existing parameters object.\n *\n * Convenience helper with _similar_ semantics as:\n *\n *     const finalParams1 = { ...defaults, ... options };\n *     const finalParams2 = Object.assign({}, defaults, options);\n *\n * This function doesn't copy _extra_ properties of `options` that doesn't exist in `defaults`.\n * `defaults` is used as _parameters_ template.\n *\n * This doc uses following notion of `option` and `parameter` terms:\n * * `parameter` is a variable, or 'almost constant' of procedure/function/algorith/object\n *    * `parameter` usually have sensible and usually used default\n *    * `parameter` is always defined (no `undefined`, `null` or `?` in type)\n *    * `parameter` can be overriden by specyfying `option` with same name\n * * `option` means value that may be passed optionally, overrides `parameter` value with same name\n *\n * Usage:\n *\n *     interface FooParams {\n *         useTextures: boolean;\n *         opacity: number;\n *     }\n *\n *     const FOO_DEFAULTS: FooParams = {\n *         useTextures: true,\n *         opacity: 0.8\n *     };\n *\n *     type FooOptions = Partial<FooParams>;\n *\n *     function doSomething(options: FooOptions) {\n *         const params = mergeWithOptions(FOO_DEFAULTS, options);\n *             // typeof params === FooParams\n *             // params.opacity = 0.5\n *             // params.useTextures = true\n *             // params.someOtherOptionFromOtherApi is not defined\n *     }\n *     const opt = {opacity: 0.5, someOtherOptionFromOtherApi: 'aaa'};\n *     doSomething(opt);\n *\n * Rationale:\n *   * both `Object.assign` and spread operator copy extra options\n *   * `Object.assign` & `spread operator` may copy `undefined` and `null`s if they really exist\n *     in options object\n *\n * @param parameters parmeters template object holding all expected parameters\n * @param options options object\n * @returns new object with `parameters` overriden by values from `options`\n */\nfunction mergeWithOptions(parameters, options) {\n    // NOTE: `as object` needed due to TypeScript bug:\n    //       https://github.com/Microsoft/TypeScript/issues/14409\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    const result = Object.assign({}, parameters);\n    if (options === undefined || options === null) {\n        return result;\n    }\n    for (const prop in parameters) {\n        if (parameters.hasOwnProperty(prop)) {\n            const optionValue = options[prop];\n            if (optionValue !== undefined && optionValue !== null) {\n                result[prop] = optionValue;\n            }\n        }\n    }\n    return result;\n}\nexports.mergeWithOptions = mergeWithOptions;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/OptionsUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/PerformanceTimer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/PerformanceTimer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* tslint:disable:max-line-length */\n/**\n * See:\n * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now\n */\n/* tslint:ensable:max-line-length */\nclass PerformanceTimer {\n    /**\n     * Returns timestamp in milliseconds since page load.\n     *\n     * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,\n     * otherwise it is in milliseconds. Timespans are computed by taking the difference between two\n     * samples.\n     *\n     * Example:\n     * ```typescript\n     * const now = PerformanceTimer.now();\n     * // call some expensive function for which you want to check the duration.\n     * const end = PerformanceTimer.now();\n     * const elapsedTime = end - now;\n     * ```\n     */\n    static now() {\n        return PerformanceTimer.nowFunc();\n    }\n    static getNowFunc() {\n        if (typeof performance !== \"undefined\" && typeof performance.now !== \"undefined\") {\n            return () => performance.now();\n        }\n        // fall back to Date.getTime()\n        return () => {\n            return new Date().getTime();\n        };\n    }\n}\nexports.PerformanceTimer = PerformanceTimer;\n// tslint:disable-next-line:no-unused-variable\nPerformanceTimer.instance = new PerformanceTimer();\nPerformanceTimer.nowFunc = PerformanceTimer.getNowFunc();\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/PerformanceTimer.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UriResolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UriResolver.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ \"./node_modules/@here/harp-utils/lib/UrlUtils.js\");\n/**\n * Basic, import-map like [[UriResolver]].\n *\n * Resolves `uris` basing on exact or prefix match of `key` from `definitions`.\n *\n * In definitions, `key` is matched against input uri with following strategy:\n *  - `key` without trailing `/` -> `key` and input `uri` must be identical\n *  - `key` with trailing `/`, -> `key` is treated as \"package prefix\", so `uri` must start with\n *    `key`\n *\n * Example:\n * ```\n * {\n *     \"local://poiMasterList\": \"/assets/poiMasterList.json\"\n *        // will match only 'local://poiMasterList' and resolve `/assets/poiMasterList.json`\n *     \"local://icons/\": \"/assets/icons/\"\n *        // will match only 'local://icons/ANYPATH' (and similar) and resolve to\n *        // `/assets/icons/ANYPATH\n * }\n * ```\n * Inspired by [`WICG` import maps proposal](https://github.com/WICG/import-maps#the-import-map).\n */\nclass PrefixMapUriResolver {\n    constructor(definitions) {\n        this.definitions = definitions;\n    }\n    resolveUri(uri) {\n        return Object.keys(this.definitions).reduce((r, key) => {\n            if (key.endsWith(\"/\") && r.startsWith(key)) {\n                const newPrefix = this.definitions[key];\n                return newPrefix + r.substr(key.length);\n            }\n            else if (r === key) {\n                return this.definitions[key];\n            }\n            return r;\n        }, uri);\n    }\n}\nexports.PrefixMapUriResolver = PrefixMapUriResolver;\n/**\n * [UriResolver] that resolve relative `uri`s against to parent resource `uri`.\n */\nclass RelativeUriResolver {\n    constructor(parentUri) {\n        this.parentUri = parentUri;\n    }\n    resolveUri(uri) {\n        return UrlUtils_1.resolveReferenceUri(this.parentUri, uri);\n    }\n}\nexports.RelativeUriResolver = RelativeUriResolver;\n/**\n * Compose URI resolvers.\n *\n * Creates new [[UriResolver]] that applies resolvers in orders or arguments.\n *\n * Example:\n *\n *     const themeUrl = ...; // url of parent object\n *     const childUrlResolver = composeUrlResolvers(\n *           new RelativeUriResolver(themeUrl),\n *           defaultUrlResolver\n *     );\n */\nfunction composeUriResolvers(...resolvers) {\n    return {\n        resolveUri(originalUrl) {\n            return resolvers.reduce((url, resolver) => {\n                if (resolver !== undefined) {\n                    return resolver.resolveUri(url);\n                }\n                else {\n                    return url;\n                }\n            }, originalUrl);\n        }\n    };\n}\nexports.composeUriResolvers = composeUriResolvers;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/UriResolver.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ \"./node_modules/@here/harp-utils/lib/UrlUtils.js\");\n/**\n * Get base URL for from where relative URLs will be loaded.\n *\n * * In browser, it resolves to `baseUrl(location.href)` i.e document's base URL\n * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n *\n * * In node, it resolves to `file://${process.cwd()}`.\n */\nfunction getAppBaseUrl() {\n    return UrlUtils_1.baseUrl(window.location.href);\n}\nexports.getAppBaseUrl = getAppBaseUrl;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/UrlPlatformUtils.web.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/UrlUtils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/UrlUtils.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Resolve URI of referenced object w.r.t parent URI.\n *\n * Resolves `childUri` as it would be loaded from location specified by `parentUri`.\n *\n * If `childUri` is absolute, then it is returned unchanged.\n * If `childUri` is origin-absolute path, then only origin path is taken from `parentUri`.\n *\n * See [[baseUri]] for reference how base URL of `parentUri` is determined.\n *\n * Examples:\n *\n *     // normal case, child is sibling\n *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent is \"folder\", so child is just located in this folder\n *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent looks like leaf, so last component is stripped\n *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png\n *\n *     // origin-absolute URL, takes only origin from parent\n *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json\n *\n * @param parentUri URI of parent resource\n * @param childUri URI of child as referenced from parent resource\n * @return `childUrl` as if anchored in location of `parentUrl`\n */\nfunction resolveReferenceUri(parentUri, childUri) {\n    if (absoluteUrlWithOriginRe.test(childUri)) {\n        return childUri;\n    }\n    else if (childUri.startsWith(\"/\")) {\n        const origin = getUrlOrigin(parentUri);\n        return origin + childUri;\n    }\n    else {\n        if (childUri.startsWith(\"./\")) {\n            childUri = childUri.substr(2);\n        }\n        const parentBaseUrl = baseUrl(parentUri);\n        return parentBaseUrl + childUri;\n    }\n}\nexports.resolveReferenceUri = resolveReferenceUri;\nconst absoluteUrlWithOriginRe = new RegExp(\"^(?:[a-z]+:)?//\", \"i\");\n/**\n * Returns base URL of given resource URL.\n *\n * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if\n * `url` ends with name component it is treated as \"leaf\", so last path component is removed.\n *\n * Standalone files (without any folder structure) are considered relative to `./`.\n *\n * Examples:\n * ```\n *     https://foo.com/themes/a.json -> https://foo.com/themes/\n *     https://foo.com/themes/ -> https://foo.com/themes/\n *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf\n *     themes/day.json -> themes/\n *     themes -> ./\n * ```\n */\nfunction baseUrl(url) {\n    if (url === undefined) {\n        return \"./\";\n    }\n    let idx = url.indexOf(\"#\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.indexOf(\"?\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.lastIndexOf(\"/\");\n    if (idx === -1) {\n        return \"./\";\n    }\n    else {\n        return url.substring(0, idx + 1);\n    }\n}\nexports.baseUrl = baseUrl;\n/**\n * Get `origin` part of URL.\n *\n * @example\n *    https://example.com/foo -> https://example.com\n *    //example.com:8080/ -> //example.com:8080\n *    file:///etc/hosts ->\n *\n * @param url input URL\n * @return origin of given URL\n */\nfunction getUrlOrigin(url) {\n    if (url === undefined) {\n        return \"\";\n    }\n    const parsed = getUrlHostAndProtocol(url);\n    if (parsed.protocol === \"file:\") {\n        return \"file://\";\n    }\n    else if (parsed.host && parsed.protocol) {\n        return parsed.protocol + \"//\" + parsed.host;\n    }\n    else if (parsed.host) {\n        return \"//\" + parsed.host;\n    }\n    else if (parsed.protocol) {\n        return parsed.protocol + \"//\";\n    }\n    else {\n        return \"\";\n    }\n}\nexports.getUrlOrigin = getUrlOrigin;\n/**\n * Parse `host` and `protocol` part from URL.\n */\nfunction getUrlHostAndProtocol(url) {\n    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\\/\\/([^\\/]*)/, \"i\");\n    const match = url.match(urlOriginRe);\n    if (!match) {\n        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);\n    }\n    return {\n        protocol: match[1],\n        host: match[2]\n    };\n}\nexports.getUrlHostAndProtocol = getUrlHostAndProtocol;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/UrlUtils.js?");

/***/ }),

/***/ "./node_modules/@here/harp-utils/lib/assert.js":
/*!*****************************************************!*\
  !*** ./node_modules/@here/harp-utils/lib/assert.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = \"development\" === \"production\";\n//TODO: Make assertHandler configurable\n/**\n * Implementation of assert as a development help\n *\n * Note - this is deliberately a global function so that minimizers remove the\n * entire call when building for production.\n *\n * @hidden\n * @param condition Condition to match, if false, throws an Error(message)\n * @param message Optional message, defaults to \"ASSERTION failed\"\n */\nfunction assert(condition, message) {\n    if (!isProduction) {\n        if (!condition) {\n            throw new Error(message !== undefined ? message : \"ASSERTION failed\");\n        }\n    }\n}\nexports.assert = assert;\nfunction assertExists(element, message) {\n    if (!isProduction) {\n        if (element === undefined || element === null) {\n            throw new Error(message !== undefined ? message : \"ASSERTION failed: Element is undefined or null\");\n        }\n    }\n    return element;\n}\nexports.assertExists = assertExists;\n\n\n//# sourceURL=webpack:///./node_modules/@here/harp-utils/lib/assert.js?");

/***/ }),

/***/ "./node_modules/@tweenjs/tween.js/src/Tween.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tweenjs/tween.js/src/Tween.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\n\n\nvar _Group = function () {\n\tthis._tweens = {};\n\tthis._tweensAddedDuringUpdate = {};\n};\n\n_Group.prototype = {\n\tgetAll: function () {\n\n\t\treturn Object.keys(this._tweens).map(function (tweenId) {\n\t\t\treturn this._tweens[tweenId];\n\t\t}.bind(this));\n\n\t},\n\n\tremoveAll: function () {\n\n\t\tthis._tweens = {};\n\n\t},\n\n\tadd: function (tween) {\n\n\t\tthis._tweens[tween.getId()] = tween;\n\t\tthis._tweensAddedDuringUpdate[tween.getId()] = tween;\n\n\t},\n\n\tremove: function (tween) {\n\n\t\tdelete this._tweens[tween.getId()];\n\t\tdelete this._tweensAddedDuringUpdate[tween.getId()];\n\n\t},\n\n\tupdate: function (time, preserve) {\n\n\t\tvar tweenIds = Object.keys(this._tweens);\n\n\t\tif (tweenIds.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttime = time !== undefined ? time : TWEEN.now();\n\n\t\t// Tweens are updated in \"batches\". If you add a new tween during an update, then the\n\t\t// new tween will be updated in the next batch.\n\t\t// If you remove a tween during an update, it may or may not be updated. However,\n\t\t// if the removed tween was added during the current batch, then it will not be updated.\n\t\twhile (tweenIds.length > 0) {\n\t\t\tthis._tweensAddedDuringUpdate = {};\n\n\t\t\tfor (var i = 0; i < tweenIds.length; i++) {\n\n\t\t\t\tvar tween = this._tweens[tweenIds[i]];\n\n\t\t\t\tif (tween && tween.update(time) === false) {\n\t\t\t\t\ttween._isPlaying = false;\n\n\t\t\t\t\tif (!preserve) {\n\t\t\t\t\t\tdelete this._tweens[tweenIds[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttweenIds = Object.keys(this._tweensAddedDuringUpdate);\n\t\t}\n\n\t\treturn true;\n\n\t}\n};\n\nvar TWEEN = new _Group();\n\nTWEEN.Group = _Group;\nTWEEN._nextId = 0;\nTWEEN.nextId = function () {\n\treturn TWEEN._nextId++;\n};\n\n\n// Include a performance.now polyfill.\n// In node.js, use process.hrtime.\nif (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {\n\tTWEEN.now = function () {\n\t\tvar time = process.hrtime();\n\n\t\t// Convert [seconds, nanoseconds] to milliseconds.\n\t\treturn time[0] * 1000 + time[1] / 1000000;\n\t};\n}\n// In a browser, use self.performance.now if it is available.\nelse if (typeof (self) !== 'undefined' &&\n         self.performance !== undefined &&\n\t\t self.performance.now !== undefined) {\n\t// This must be bound, because directly assigning this function\n\t// leads to an invocation exception in Chrome.\n\tTWEEN.now = self.performance.now.bind(self.performance);\n}\n// Use Date.now if it is available.\nelse if (Date.now !== undefined) {\n\tTWEEN.now = Date.now;\n}\n// Otherwise, use 'new Date().getTime()'.\nelse {\n\tTWEEN.now = function () {\n\t\treturn new Date().getTime();\n\t};\n}\n\n\nTWEEN.Tween = function (object, group) {\n\tthis._object = object;\n\tthis._valuesStart = {};\n\tthis._valuesEnd = {};\n\tthis._valuesStartRepeat = {};\n\tthis._duration = 1000;\n\tthis._repeat = 0;\n\tthis._repeatDelayTime = undefined;\n\tthis._yoyo = false;\n\tthis._isPlaying = false;\n\tthis._reversed = false;\n\tthis._delayTime = 0;\n\tthis._startTime = null;\n\tthis._easingFunction = TWEEN.Easing.Linear.None;\n\tthis._interpolationFunction = TWEEN.Interpolation.Linear;\n\tthis._chainedTweens = [];\n\tthis._onStartCallback = null;\n\tthis._onStartCallbackFired = false;\n\tthis._onUpdateCallback = null;\n\tthis._onRepeatCallback = null;\n\tthis._onCompleteCallback = null;\n\tthis._onStopCallback = null;\n\tthis._group = group || TWEEN;\n\tthis._id = TWEEN.nextId();\n\n};\n\nTWEEN.Tween.prototype = {\n\tgetId: function () {\n\t\treturn this._id;\n\t},\n\n\tisPlaying: function () {\n\t\treturn this._isPlaying;\n\t},\n\n\tto: function (properties, duration) {\n\n\t\tthis._valuesEnd = Object.create(properties);\n\n\t\tif (duration !== undefined) {\n\t\t\tthis._duration = duration;\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tduration: function duration(d) {\n\t\tthis._duration = d;\n\t\treturn this;\n\t},\n\n\tstart: function (time) {\n\n\t\tthis._group.add(this);\n\n\t\tthis._isPlaying = true;\n\n\t\tthis._onStartCallbackFired = false;\n\n\t\tthis._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();\n\t\tthis._startTime += this._delayTime;\n\n\t\tfor (var property in this._valuesEnd) {\n\n\t\t\t// Check if an Array was provided as property value\n\t\t\tif (this._valuesEnd[property] instanceof Array) {\n\n\t\t\t\tif (this._valuesEnd[property].length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Create a local copy of the Array with the start value at the front\n\t\t\t\tthis._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);\n\n\t\t\t}\n\n\t\t\t// If `to()` specifies a property that doesn't exist in the source object,\n\t\t\t// we should not set that property in the object\n\t\t\tif (this._object[property] === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Save the starting value.\n\t\t\tthis._valuesStart[property] = this._object[property];\n\n\t\t\tif ((this._valuesStart[property] instanceof Array) === false) {\n\t\t\t\tthis._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n\t\t\t}\n\n\t\t\tthis._valuesStartRepeat[property] = this._valuesStart[property] || 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif (!this._isPlaying) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._group.remove(this);\n\t\tthis._isPlaying = false;\n\n\t\tif (this._onStopCallback !== null) {\n\t\t\tthis._onStopCallback(this._object);\n\t\t}\n\n\t\tthis.stopChainedTweens();\n\t\treturn this;\n\n\t},\n\n\tend: function () {\n\n\t\tthis.update(Infinity);\n\t\treturn this;\n\n\t},\n\n\tstopChainedTweens: function () {\n\n\t\tfor (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\tthis._chainedTweens[i].stop();\n\t\t}\n\n\t},\n\n\tgroup: function (group) {\n\t\tthis._group = group;\n\t\treturn this;\n\t},\n\n\tdelay: function (amount) {\n\n\t\tthis._delayTime = amount;\n\t\treturn this;\n\n\t},\n\n\trepeat: function (times) {\n\n\t\tthis._repeat = times;\n\t\treturn this;\n\n\t},\n\n\trepeatDelay: function (amount) {\n\n\t\tthis._repeatDelayTime = amount;\n\t\treturn this;\n\n\t},\n\n\tyoyo: function (yoyo) {\n\n\t\tthis._yoyo = yoyo;\n\t\treturn this;\n\n\t},\n\n\teasing: function (easingFunction) {\n\n\t\tthis._easingFunction = easingFunction;\n\t\treturn this;\n\n\t},\n\n\tinterpolation: function (interpolationFunction) {\n\n\t\tthis._interpolationFunction = interpolationFunction;\n\t\treturn this;\n\n\t},\n\n\tchain: function () {\n\n\t\tthis._chainedTweens = arguments;\n\t\treturn this;\n\n\t},\n\n\tonStart: function (callback) {\n\n\t\tthis._onStartCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonUpdate: function (callback) {\n\n\t\tthis._onUpdateCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonRepeat: function onRepeat(callback) {\n\n\t\tthis._onRepeatCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonComplete: function (callback) {\n\n\t\tthis._onCompleteCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonStop: function (callback) {\n\n\t\tthis._onStopCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tupdate: function (time) {\n\n\t\tvar property;\n\t\tvar elapsed;\n\t\tvar value;\n\n\t\tif (time < this._startTime) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this._onStartCallbackFired === false) {\n\n\t\t\tif (this._onStartCallback !== null) {\n\t\t\t\tthis._onStartCallback(this._object);\n\t\t\t}\n\n\t\t\tthis._onStartCallbackFired = true;\n\t\t}\n\n\t\telapsed = (time - this._startTime) / this._duration;\n\t\telapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;\n\n\t\tvalue = this._easingFunction(elapsed);\n\n\t\tfor (property in this._valuesEnd) {\n\n\t\t\t// Don't update properties that do not exist in the source object\n\t\t\tif (this._valuesStart[property] === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar start = this._valuesStart[property] || 0;\n\t\t\tvar end = this._valuesEnd[property];\n\n\t\t\tif (end instanceof Array) {\n\n\t\t\t\tthis._object[property] = this._interpolationFunction(end, value);\n\n\t\t\t} else {\n\n\t\t\t\t// Parses relative end values with start as base (e.g.: +10, -3)\n\t\t\t\tif (typeof (end) === 'string') {\n\n\t\t\t\t\tif (end.charAt(0) === '+' || end.charAt(0) === '-') {\n\t\t\t\t\t\tend = start + parseFloat(end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tend = parseFloat(end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Protect against non numeric properties.\n\t\t\t\tif (typeof (end) === 'number') {\n\t\t\t\t\tthis._object[property] = start + (end - start) * value;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (this._onUpdateCallback !== null) {\n\t\t\tthis._onUpdateCallback(this._object, elapsed);\n\t\t}\n\n\t\tif (elapsed === 1) {\n\n\t\t\tif (this._repeat > 0) {\n\n\t\t\t\tif (isFinite(this._repeat)) {\n\t\t\t\t\tthis._repeat--;\n\t\t\t\t}\n\n\t\t\t\t// Reassign starting values, restart by making startTime = now\n\t\t\t\tfor (property in this._valuesStartRepeat) {\n\n\t\t\t\t\tif (typeof (this._valuesEnd[property]) === 'string') {\n\t\t\t\t\t\tthis._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._yoyo) {\n\t\t\t\t\t\tvar tmp = this._valuesStartRepeat[property];\n\n\t\t\t\t\t\tthis._valuesStartRepeat[property] = this._valuesEnd[property];\n\t\t\t\t\t\tthis._valuesEnd[property] = tmp;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._valuesStart[property] = this._valuesStartRepeat[property];\n\n\t\t\t\t}\n\n\t\t\t\tif (this._yoyo) {\n\t\t\t\t\tthis._reversed = !this._reversed;\n\t\t\t\t}\n\n\t\t\t\tif (this._repeatDelayTime !== undefined) {\n\t\t\t\t\tthis._startTime = time + this._repeatDelayTime;\n\t\t\t\t} else {\n\t\t\t\t\tthis._startTime = time + this._delayTime;\n\t\t\t\t}\n\n\t\t\t\tif (this._onRepeatCallback !== null) {\n\t\t\t\t\tthis._onRepeatCallback(this._object);\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\tif (this._onCompleteCallback !== null) {\n\n\t\t\t\t\tthis._onCompleteCallback(this._object);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\t\t\t// Make the chained tweens start exactly at the time they should,\n\t\t\t\t\t// even if the `update()` method was called way past the duration of the tween\n\t\t\t\t\tthis._chainedTweens[i].start(this._startTime + this._duration);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n};\n\n\nTWEEN.Easing = {\n\n\tLinear: {\n\n\t\tNone: function (k) {\n\n\t\t\treturn k;\n\n\t\t}\n\n\t},\n\n\tQuadratic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn k * (2 - k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * (--k * (k - 2) - 1);\n\n\t\t}\n\n\t},\n\n\tCubic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn --k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tQuartic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn 1 - (--k * k * k * k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * ((k -= 2) * k * k * k - 2);\n\n\t\t}\n\n\t},\n\n\tQuintic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn --k * k * k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tSinusoidal: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - Math.cos(k * Math.PI / 2);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn Math.sin(k * Math.PI / 2);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\treturn 0.5 * (1 - Math.cos(Math.PI * k));\n\n\t\t}\n\n\t},\n\n\tExponential: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k === 0 ? 0 : Math.pow(1024, k - 1);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * Math.pow(1024, k - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);\n\n\t\t}\n\n\t},\n\n\tCircular: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - Math.sqrt(1 - k * k);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn Math.sqrt(1 - (--k * k));\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn - 0.5 * (Math.sqrt(1 - k * k) - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\n\t\t}\n\n\t},\n\n\tElastic: {\n\n\t\tIn: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tk *= 2;\n\n\t\t\tif (k < 1) {\n\t\t\t\treturn -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\t\t\t}\n\n\t\t\treturn 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n\n\t\t}\n\n\t},\n\n\tBack: {\n\n\t\tIn: function (k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn k * k * ((s + 1) * k - s);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn --k * k * ((s + 1) * k + s) + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tvar s = 1.70158 * 1.525;\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * (k * k * ((s + 1) * k - s));\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\n\t\t}\n\n\t},\n\n\tBounce: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - TWEEN.Easing.Bounce.Out(1 - k);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tif (k < (1 / 2.75)) {\n\t\t\t\treturn 7.5625 * k * k;\n\t\t\t} else if (k < (2 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t\t\t} else if (k < (2.5 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t\t\t} else {\n\t\t\t\treturn 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t\t\t}\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k < 0.5) {\n\t\t\t\treturn TWEEN.Easing.Bounce.In(k * 2) * 0.5;\n\t\t\t}\n\n\t\t\treturn TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n\n\t\t}\n\n\t}\n\n};\n\nTWEEN.Interpolation = {\n\n\tLinear: function (v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.Linear;\n\n\t\tif (k < 0) {\n\t\t\treturn fn(v[0], v[1], f);\n\t\t}\n\n\t\tif (k > 1) {\n\t\t\treturn fn(v[m], v[m - 1], m - f);\n\t\t}\n\n\t\treturn fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n\n\t},\n\n\tBezier: function (v, k) {\n\n\t\tvar b = 0;\n\t\tvar n = v.length - 1;\n\t\tvar pw = Math.pow;\n\t\tvar bn = TWEEN.Interpolation.Utils.Bernstein;\n\n\t\tfor (var i = 0; i <= n; i++) {\n\t\t\tb += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n\t\t}\n\n\t\treturn b;\n\n\t},\n\n\tCatmullRom: function (v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.CatmullRom;\n\n\t\tif (v[0] === v[m]) {\n\n\t\t\tif (k < 0) {\n\t\t\t\ti = Math.floor(f = m * (1 + k));\n\t\t\t}\n\n\t\t\treturn fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n\n\t\t} else {\n\n\t\t\tif (k < 0) {\n\t\t\t\treturn v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n\t\t\t}\n\n\t\t\tif (k > 1) {\n\t\t\t\treturn v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n\t\t\t}\n\n\t\t\treturn fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n\n\t\t}\n\n\t},\n\n\tUtils: {\n\n\t\tLinear: function (p0, p1, t) {\n\n\t\t\treturn (p1 - p0) * t + p0;\n\n\t\t},\n\n\t\tBernstein: function (n, i) {\n\n\t\t\tvar fc = TWEEN.Interpolation.Utils.Factorial;\n\n\t\t\treturn fc(n) / fc(i) / fc(n - i);\n\n\t\t},\n\n\t\tFactorial: (function () {\n\n\t\t\tvar a = [1];\n\n\t\t\treturn function (n) {\n\n\t\t\t\tvar s = 1;\n\n\t\t\t\tif (a[n]) {\n\t\t\t\t\treturn a[n];\n\t\t\t\t}\n\n\t\t\t\tfor (var i = n; i > 1; i--) {\n\t\t\t\t\ts *= i;\n\t\t\t\t}\n\n\t\t\t\ta[n] = s;\n\t\t\t\treturn s;\n\n\t\t\t};\n\n\t\t})(),\n\n\t\tCatmullRom: function (p0, p1, p2, p3, t) {\n\n\t\t\tvar v0 = (p2 - p0) * 0.5;\n\t\t\tvar v1 = (p3 - p1) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\n\t\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t}\n\n};\n\n// UMD (Universal Module Definition)\n(function (root) {\n\n\tif (true) {\n\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn TWEEN;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\t} else {}\n\n})(this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/@tweenjs/tween.js/src/Tween.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/rbush/rbush.min.js":
/*!*****************************************!*\
  !*** ./node_modules/rbush/rbush.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(t,i){ true?module.exports=i():undefined}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n\n\n//# sourceURL=webpack:///./node_modules/rbush/rbush.min.js?");

/***/ }),

/***/ "./src/TerrainRGBDataSource.ts":
/*!*************************************!*\
  !*** ./src/TerrainRGBDataSource.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst THREE = __webpack_require__(/*! three */ \"three\");\nconst SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ \"./node_modules/@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.js\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ \"./node_modules/@here/harp-utils/index.web.js\");\nconst logger = harp_utils_1.LoggerManager.instance.create(\"RGBTerrainDataSource\");\nlogger.warn(THREE.REVISION);\nconst textureLoader = new THREE.TextureLoader();\ntextureLoader.crossOrigin = \"\"; // empty assignment required to support CORS\nclass TerrainRGBDataSource extends harp_mapview_1.DataSource {\n    /**\n     * Constructs a new `WebTileDataSource`.\n     *\n     * @param m_accessKey The Mapbox access key.\n     */\n    constructor(m_accessKey) {\n        super(\"terraintile\", undefined, 1, 20);\n        this.m_accessKey = m_accessKey;\n        this.cacheable = true;\n        this.storageLevelOffset = -1;\n    }\n    /** @override */\n    shouldPreloadTiles() {\n        return true;\n    }\n    /** @override */\n    getTilingScheme() {\n        return harp_geoutils_1.webMercatorTilingScheme;\n    }\n    /** @override */\n    getTile(tileKey) {\n        const tile = new harp_mapview_1.Tile(this, tileKey);\n        const url = `https://api.mapbox.com/v4/mapbox.terrain-rgb/` +\n            `${tileKey.level}/${tileKey.column}/${tileKey.row}@2x.pngraw?access_token=` +\n            `${this.m_accessKey}`;\n        /*\n        return new Promise((resolve, reject) => {\n            getPixels(url, (error, pixels) => {\n                if (error) {\n                    reject(error);\n                }\n                console.log(pixels.shape.slice());\n                return resolve(new Float32Array(pixels.shape.slice()));\n            });\n        });\n        */\n        const color = new THREE.Color();\n        Promise.resolve(this.loadTexture(url))\n            .then(texture => {\n            texture.minFilter = THREE.LinearFilter;\n            texture.magFilter = THREE.LinearFilter;\n            texture.generateMipmaps = false;\n            const size = texture.image.width;\n            const shouldSubdivide = this.projection.type === harp_geoutils_1.ProjectionType.Spherical;\n            const sourceProjection = this.getTilingScheme().projection;\n            const tmpV = new THREE.Vector3();\n            tile.boundingBox.getSize(tmpV);\n            tile.addOwnedTexture(texture);\n            const terrain = this.createTerrain(tmpV.x, tmpV.y, size, texture, tile.center);\n            if (shouldSubdivide) {\n                const modifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier((10 / 180) * Math.PI, sourceProjection);\n                modifier.modify(terrain.geometry);\n            }\n            const water = this.createWater(tmpV.x, tmpV.y, tile.center);\n            tile.objects.push(terrain);\n            //tile.objects.push(water);\n            tile.invalidateResourceInfo();\n            this.requestUpdate();\n        })\n            .catch(error => {\n            logger.error(`failed to load RGBTerrain tile ${tileKey.mortonCode()}: ${error}`);\n        });\n        return tile;\n    }\n    createTerrain(width, height, size, heightMap, planeCenter) {\n        const maxRes = 100;\n        const maxZoomLevel = 13;\n        const z = Math.floor(this.mapView.zoomLevel);\n        const res = maxRes; //z <= maxZoomLevel ? maxRes : maxRes / (2 * (z - maxZoomLevel));\n        const geometry = new THREE.PlaneBufferGeometry(width, height, res, res);\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = canvas.height = size;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(heightMap.image, 0, 0, size, size);\n        const imgData = ctx.getImageData(0, 0, size + 1, size).data;\n        for (let row = 0; row < res; row++) {\n            const rowOnImage = Math.floor((row / res) * size);\n            for (let column = 0; column < res; column++) {\n                const columnOnImage = Math.floor((column / res) * size);\n                const indexOnImage = (rowOnImage * size + columnOnImage) * 4;\n                const R = imgData[indexOnImage];\n                const G = imgData[indexOnImage + 1];\n                const B = imgData[indexOnImage + 2];\n                const height = -10000 + (R * 256 * 256 + G * 256 + B) * 0.1;\n                const index = row * res + column;\n                geometry.attributes.position.setZ(index, height);\n            }\n        }\n        geometry.computeVertexNormals();\n        const material = new THREE.MeshLambertMaterial({\n            color: 0xc0b3aa,\n        });\n        const plane = new THREE.Mesh(geometry, material);\n        plane.position.copy(planeCenter);\n        return plane;\n    }\n    createWater(width, height, planeCenter) {\n        const geometry = new THREE.PlaneBufferGeometry(width, height, 1, 1);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0x80a9c1,\n        });\n        const plane = new THREE.Mesh(geometry, material);\n        plane.position.copy(planeCenter);\n        return plane;\n    }\n    loadTexture(url) {\n        return new Promise((resolve, reject) => {\n            textureLoader.load(url, texture => resolve(texture), undefined, // The \"onProgress\" event's callback.\n            () => reject(new Error(\"failed to load texture\")));\n        });\n    }\n}\nexports.TerrainRGBDataSource = TerrainRGBDataSource;\n\n\n//# sourceURL=webpack:///./src/TerrainRGBDataSource.ts?");

/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst harp_omv_datasource_1 = __webpack_require__(/*! @here/harp-omv-datasource */ \"./node_modules/@here/harp-omv-datasource/index.js\");\nconst harp_map_controls_1 = __webpack_require__(/*! @here/harp-map-controls */ \"./node_modules/@here/harp-map-controls/index.js\");\nconst harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ \"./node_modules/@here/harp-mapview/index.js\");\nconst TerrainRGBDataSource_1 = __webpack_require__(/*! ./TerrainRGBDataSource */ \"./src/TerrainRGBDataSource.ts\");\nconst harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ \"./node_modules/@here/harp-geoutils/index.js\");\nconst map = new harp_mapview_1.MapView({\n    canvas: document.getElementsByTagName(\"canvas\")[0],\n    theme: \"./harpbox.json\",\n    enableNativeWebglAntialias: false,\n    tileCacheSize: 50,\n});\nwindow.addEventListener(\"resize\", () => {\n    map.resize(window.innerWidth, window.innerHeight);\n});\nharp_mapview_1.CopyrightElementHandler.install(\"copyrightNotice\", map);\nharp_mapview_1.CopyrightElementHandler.install(\"copyrightNotice\")\n    .attach(map)\n    .setDefaults([\n    {\n        id: \"openstreetmap.org\",\n        label: \"OpenStreetMap contributors\",\n        link: \"https://www.openstreetmap.org/copyright\",\n    },\n]);\nconst omvDataSource = new harp_omv_datasource_1.OmvDataSource({\n    concurrentDecoderScriptUrl: \"dist/harp-worker.bundle.js\",\n    baseUrl: \"https://xyz.api.here.com/tiles/osmbase/512/all\",\n    apiFormat: harp_omv_datasource_1.APIFormat.XYZMVT,\n    styleSetName: \"tilezen\",\n    maxZoomLevel: 17,\n    authenticationCode: \"AGln99HORnqL1kfIQtsQl70\",\n});\nmap.addDataSource(omvDataSource).then(() => {\n    omvDataSource.setLanguages([\"en\"]);\n});\nconst mapboxAccessKey = \"pk.eyJ1IjoiZHVtYmxlZG9yZTk5IiwiYSI6ImNqc29meGFjeTBrYTk0M255eHZueWtydHMifQ.CJEbodjhMFYCdm8nmCsMhg\";\nconst terrain = new TerrainRGBDataSource_1.TerrainRGBDataSource(mapboxAccessKey);\nmap.addDataSource(terrain);\nconst controls = new harp_map_controls_1.MapControls(map);\ncontrols.maxTiltAngle = 50;\nconst ui = new harp_map_controls_1.MapControlsUI(controls, {\n    zoomLevel: \"input\",\n});\nmap.canvas.parentElement.appendChild(ui.domElement);\nmap.lookAt(new harp_geoutils_1.GeoCoordinates(12.03, -61.75), 9000, 0);\n\n\n//# sourceURL=webpack:///./src/app.ts?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = THREE;\n\n//# sourceURL=webpack:///external_%22THREE%22?");

/***/ })

/******/ });